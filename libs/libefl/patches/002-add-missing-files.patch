diff -Naur a/src/lib/ecore/Ecore.eo.hh b/src/lib/ecore/Ecore.eo.hh
--- a/src/lib/ecore/Ecore.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/Ecore.eo.hh	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,14 @@
+#ifndef EFL_CXX_ECORE_HH
+#define EFL_CXX_ECORE_HH
+
+#ifdef EFL_BETA_API_SUPPORT
+#include <ecore_poller.eo.hh>
+#include <ecore_job.eo.hh>
+#include <ecore_idler.eo.hh>
+#include <ecore_idle_exiter.eo.hh>
+#include <ecore_animator.eo.hh>
+#include <ecore_parent.eo.hh>
+#endif
+
+#endif
+
diff -Naur a/src/lib/ecore/ecore_animator.eo.c b/src/lib/ecore/ecore_animator.eo.c
--- a/src/lib/ecore/ecore_animator.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_animator.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,39 @@
+
+void _ecore_animator_timeline_constructor(Eo *obj, Ecore_Animator_Data *pd, double runtime, Ecore_Timeline_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_animator_timeline_constructor, EO_FUNC_CALL(runtime, func, data), double runtime, Ecore_Timeline_Cb func, const void *data);
+
+void _ecore_animator_constructor(Eo *obj, Ecore_Animator_Data *pd, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_animator_constructor, EO_FUNC_CALL(func, data), Ecore_Task_Cb func, const void *data);
+
+void _ecore_animator_eo_base_destructor(Eo *obj, Ecore_Animator_Data *pd);
+
+
+void _ecore_animator_eo_base_event_freeze(Eo *obj, Ecore_Animator_Data *pd);
+
+
+void _ecore_animator_eo_base_event_thaw(Eo *obj, Ecore_Animator_Data *pd);
+
+
+static Eo_Op_Description _ecore_animator_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_animator_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_event_freeze, _ecore_animator_eo_base_event_freeze),
+     EO_OP_FUNC_OVERRIDE(eo_event_thaw, _ecore_animator_eo_base_event_thaw),
+     EO_OP_FUNC(ecore_animator_timeline_constructor, _ecore_animator_timeline_constructor, "Constructor."),
+     EO_OP_FUNC(ecore_animator_constructor, _ecore_animator_constructor, "Constructor."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_animator_class_desc = {
+     EO_VERSION,
+     "Ecore_Animator",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_animator_op_desc),
+     NULL,
+     sizeof(Ecore_Animator_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_animator_class_get, &_ecore_animator_class_desc, EO_BASE_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_animator.eo.h b/src/lib/ecore/ecore_animator.eo.h
--- a/src/lib/ecore/ecore_animator.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_animator.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,44 @@
+#ifndef _ECORE_ANIMATOR_EO_H_
+#define _ECORE_ANIMATOR_EO_H_
+
+#ifndef _ECORE_ANIMATOR_EO_CLASS_TYPE
+#define _ECORE_ANIMATOR_EO_CLASS_TYPE
+
+typedef Eo Ecore_Animator;
+
+#endif
+
+#ifndef _ECORE_ANIMATOR_EO_TYPES
+#define _ECORE_ANIMATOR_EO_TYPES
+
+
+#endif
+#define ECORE_ANIMATOR_CLASS ecore_animator_class_get()
+
+const Eo_Class *ecore_animator_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Constructor.
+ * 
+ *
+ * @param[in] runtime No description supplied.
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_animator_timeline_constructor(double runtime, Ecore_Timeline_Cb func, const void *data);
+
+/**
+ *
+ * Constructor.
+ * 
+ *
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_animator_constructor(Ecore_Task_Cb func, const void *data);
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_animator.eo.hh b/src/lib/ecore/ecore_animator.eo.hh
--- a/src/lib/ecore/ecore_animator.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_animator.eo.hh	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,233 @@
+#ifndef EFL_GENERATED_ECORE_ANIMATOR_HH
+#define EFL_GENERATED_ECORE_ANIMATOR_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_animator.eo.h"
+}
+
+#include <Ecore.h>
+
+namespace ecore {
+
+struct animator
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit animator(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit animator(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Constructor.
+   ///
+   /// @param runtime 
+   /// @param func 
+   /// @param data 
+   ///
+   template <typename F>
+   animator(double runtime_, F && func_, efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : animator(_c0(runtime_, std::forward<F>(func_), _p))
+   {}
+
+   /// @brief Constructor.
+   ///
+   /// @param func 
+   /// @param data 
+   ///
+   template <typename F>
+   animator(F && func_, efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : animator(_c1(std::forward<F>(func_), _p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   animator(animator const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~animator() {}
+
+   /// @brief freeze events of object.
+   /// Prevents event callbacks from being called for the object.
+   ///
+   void event_freeze() const
+   {
+      eo_do(_eo_ptr(), ::eo_event_freeze());
+   }
+
+   /// @brief thaw events of object.
+   /// Lets event callbacks be called for the object.
+   ///
+   void event_thaw() const
+   {
+      eo_do(_eo_ptr(), ::eo_event_thaw());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_ANIMATOR_CLASS);
+   }
+
+private:
+   template <typename F>
+   static Eo* _c0(double runtime_, F && func_, efl::eo::parent_type _p)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+function_type* _tmp_f = new F(std::forward<F>(func_));
+      return eo_add_ref(ECORE_ANIMATOR_CLASS, _p._eo_raw, ecore_animator_timeline_constructor(runtime_, efl::eolian::get_callback<Ecore_Timeline_Cb, function_type>(), _tmp_f));
+   }
+
+   template <typename F>
+   static Eo* _c1(F && func_, efl::eo::parent_type _p)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+function_type* _tmp_f = new F(std::forward<F>(func_));
+      return eo_add_ref(ECORE_ANIMATOR_CLASS, _p._eo_raw, ecore_animator_constructor(efl::eolian::get_callback<Ecore_Task_Cb, function_type>(), _tmp_f));
+   }
+
+};
+} 
+
+template <typename T>
+void ecore_animator_event_freeze_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->event_freeze();
+}
+
+template <typename T>
+void ecore_animator_event_thaw_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->event_thaw();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ecore::animator >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void event_freeze()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_event_freeze());
+      }
+
+      virtual void event_thaw()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_event_thaw());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ecore::animator >
+{
+   static const int value = 2;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<ecore::animator>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::ecore_animator_event_freeze_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_event_freeze);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::ecore_animator_event_thaw_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::eo_event_thaw);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ecore::animator >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::animator, ::std::tuple<double, Ecore_Timeline_Cb, const void *> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::ecore_animator_timeline_constructor(::efl::eolian::to_c(args.get<0>()), ::efl::eolian::to_c(args.get<1>()), ::efl::eolian::to_c(args.get<2>())));
+}
+
+inline void
+call_constructor(tag< ecore::animator >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::animator, ::std::tuple<Ecore_Task_Cb, const void *> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::ecore_animator_constructor(::efl::eolian::to_c(args.get<0>()), ::efl::eolian::to_c(args.get<1>())));
+}
+
+inline void
+call_constructor(tag< ecore::animator >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::animator, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ecore::animator>
+{
+   template <typename U>
+   struct type
+   {
+      operator ecore::animator() const
+      {
+         return ecore::animator(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void event_freeze()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_event_freeze());
+      }
+
+      void event_thaw()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_event_thaw());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<ecore::animator>)
+{
+   return (ECORE_ANIMATOR_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_ANIMATOR_HH
+
diff -Naur a/src/lib/ecore/ecore_animator.eo.legacy.h b/src/lib/ecore/ecore_animator.eo.legacy.h
--- a/src/lib/ecore/ecore_animator.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_animator.eo.legacy.h	2014-11-27 00:57:33.447046332 +0200
@@ -0,0 +1,17 @@
+#ifndef _ECORE_ANIMATOR_EO_LEGACY_H_
+#define _ECORE_ANIMATOR_EO_LEGACY_H_
+
+#ifndef _ECORE_ANIMATOR_EO_CLASS_TYPE
+#define _ECORE_ANIMATOR_EO_CLASS_TYPE
+
+typedef Eo Ecore_Animator;
+
+#endif
+
+#ifndef _ECORE_ANIMATOR_EO_TYPES
+#define _ECORE_ANIMATOR_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/ecore/ecore_exe.eo.c b/src/lib/ecore/ecore_exe.eo.c
--- a/src/lib/ecore/ecore_exe.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_exe.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,49 @@
+EOAPI const Eo_Event_Description _ECORE_EXE_EVENT_DATA_GET =
+   EO_EVENT_DESCRIPTION("data,get", "");
+EOAPI const Eo_Event_Description _ECORE_EXE_EVENT_DATA_ERROR =
+   EO_EVENT_DESCRIPTION("data,error", "");
+
+void _ecore_exe_command_set(Eo *obj, Ecore_Exe_Data *pd, const char *exe_cmd, Ecore_Exe_Flags flags);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_obj_exe_command_set, EO_FUNC_CALL(exe_cmd, flags), const char *exe_cmd, Ecore_Exe_Flags flags);
+
+void _ecore_exe_command_get(Eo *obj, Ecore_Exe_Data *pd, const char **exe_cmd, Ecore_Exe_Flags *flags);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_obj_exe_command_get, EO_FUNC_CALL(exe_cmd, flags), const char **exe_cmd, Ecore_Exe_Flags *flags);
+
+void _ecore_exe_eo_base_destructor(Eo *obj, Ecore_Exe_Data *pd);
+
+
+Eo * _ecore_exe_eo_base_finalize(Eo *obj, Ecore_Exe_Data *pd);
+
+
+void _ecore_exe_efl_control_suspend_set(Eo *obj, Ecore_Exe_Data *pd, Eina_Bool suspend);
+
+
+static Eo_Op_Description _ecore_exe_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_exe_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_finalize, _ecore_exe_eo_base_finalize),
+     EO_OP_FUNC_OVERRIDE(efl_control_suspend_set, _ecore_exe_efl_control_suspend_set),
+     EO_OP_FUNC(ecore_obj_exe_command_set, _ecore_exe_command_set, ""),
+     EO_OP_FUNC(ecore_obj_exe_command_get, _ecore_exe_command_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Event_Description *_ecore_exe_event_desc[] = {
+     ECORE_EXE_EVENT_DATA_GET,
+     ECORE_EXE_EVENT_DATA_ERROR,
+     NULL
+};
+
+static const Eo_Class_Description _ecore_exe_class_desc = {
+     EO_VERSION,
+     "Ecore_Exe",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_exe_op_desc),
+     _ecore_exe_event_desc,
+     sizeof(Ecore_Exe_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_exe_class_get, &_ecore_exe_class_desc, EO_BASE_CLASS, EFL_CONTROL_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_exe.eo.h b/src/lib/ecore/ecore_exe.eo.h
--- a/src/lib/ecore/ecore_exe.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_exe.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,55 @@
+#ifndef _ECORE_EXE_EO_H_
+#define _ECORE_EXE_EO_H_
+
+#ifndef _ECORE_EXE_EO_CLASS_TYPE
+#define _ECORE_EXE_EO_CLASS_TYPE
+
+typedef Eo Ecore_Exe;
+
+#endif
+
+#ifndef _ECORE_EXE_EO_TYPES
+#define _ECORE_EXE_EO_TYPES
+
+
+#endif
+#define ECORE_EXE_CLASS ecore_exe_class_get()
+
+const Eo_Class *ecore_exe_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Control the command that's executed. FIXME: May need a split/rename.
+ * 
+ *
+ * @param[in] exe_cmd The command to execute.
+ * @param[in] flags The execution flags.
+ *
+ */
+EOAPI void  ecore_obj_exe_command_set(const char *exe_cmd, Ecore_Exe_Flags flags);
+
+/**
+ *
+ * Control the command that's executed. FIXME: May need a split/rename.
+ * 
+ *
+ * @param[out] exe_cmd The command to execute.
+ * @param[out] flags The execution flags.
+ *
+ */
+EOAPI void  ecore_obj_exe_command_get(const char **exe_cmd, Ecore_Exe_Flags *flags);
+
+EOAPI extern const Eo_Event_Description _ECORE_EXE_EVENT_DATA_GET;
+EOAPI extern const Eo_Event_Description _ECORE_EXE_EVENT_DATA_ERROR;
+
+/**
+ * No description
+ */
+#define ECORE_EXE_EVENT_DATA_GET (&(_ECORE_EXE_EVENT_DATA_GET))
+
+/**
+ * No description
+ */
+#define ECORE_EXE_EVENT_DATA_ERROR (&(_ECORE_EXE_EVENT_DATA_ERROR))
+
+#endif
diff -Naur a/src/lib/ecore/ecore_exe.eo.legacy.h b/src/lib/ecore/ecore_exe.eo.legacy.h
--- a/src/lib/ecore/ecore_exe.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_exe.eo.legacy.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,17 @@
+#ifndef _ECORE_EXE_EO_LEGACY_H_
+#define _ECORE_EXE_EO_LEGACY_H_
+
+#ifndef _ECORE_EXE_EO_CLASS_TYPE
+#define _ECORE_EXE_EO_CLASS_TYPE
+
+typedef Eo Ecore_Exe;
+
+#endif
+
+#ifndef _ECORE_EXE_EO_TYPES
+#define _ECORE_EXE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/ecore/ecore_idle_enterer.eo.c b/src/lib/ecore/ecore_idle_enterer.eo.c
--- a/src/lib/ecore/ecore_idle_enterer.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idle_enterer.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,31 @@
+
+void _ecore_idle_enterer_before_constructor(Eo *obj, Ecore_Idle_Enterer_Data *pd, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_idle_enterer_before_constructor, EO_FUNC_CALL(func, data), Ecore_Task_Cb func, const void *data);
+
+void _ecore_idle_enterer_after_constructor(Eo *obj, Ecore_Idle_Enterer_Data *pd, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_idle_enterer_after_constructor, EO_FUNC_CALL(func, data), Ecore_Task_Cb func, const void *data);
+
+void _ecore_idle_enterer_eo_base_destructor(Eo *obj, Ecore_Idle_Enterer_Data *pd);
+
+
+static Eo_Op_Description _ecore_idle_enterer_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_idle_enterer_eo_base_destructor),
+     EO_OP_FUNC(ecore_idle_enterer_before_constructor, _ecore_idle_enterer_before_constructor, "Contructor. Will insert the handler at the beginning of the list."),
+     EO_OP_FUNC(ecore_idle_enterer_after_constructor, _ecore_idle_enterer_after_constructor, "Contructor. Will insert the handler at the end of the list."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_idle_enterer_class_desc = {
+     EO_VERSION,
+     "Ecore_Idle_Enterer",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_idle_enterer_op_desc),
+     NULL,
+     sizeof(Ecore_Idle_Enterer_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_idle_enterer_class_get, &_ecore_idle_enterer_class_desc, EO_BASE_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_idle_enterer.eo.h b/src/lib/ecore/ecore_idle_enterer.eo.h
--- a/src/lib/ecore/ecore_idle_enterer.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idle_enterer.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,43 @@
+#ifndef _ECORE_IDLE_ENTERER_EO_H_
+#define _ECORE_IDLE_ENTERER_EO_H_
+
+#ifndef _ECORE_IDLE_ENTERER_EO_CLASS_TYPE
+#define _ECORE_IDLE_ENTERER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Idle_Enterer;
+
+#endif
+
+#ifndef _ECORE_IDLE_ENTERER_EO_TYPES
+#define _ECORE_IDLE_ENTERER_EO_TYPES
+
+
+#endif
+#define ECORE_IDLE_ENTERER_CLASS ecore_idle_enterer_class_get()
+
+const Eo_Class *ecore_idle_enterer_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Contructor. Will insert the handler at the beginning of the list.
+ * 
+ *
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_idle_enterer_before_constructor(Ecore_Task_Cb func, const void *data);
+
+/**
+ *
+ * Contructor. Will insert the handler at the end of the list.
+ * 
+ *
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_idle_enterer_after_constructor(Ecore_Task_Cb func, const void *data);
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_idle_enterer.eo.legacy.h b/src/lib/ecore/ecore_idle_enterer.eo.legacy.h
--- a/src/lib/ecore/ecore_idle_enterer.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idle_enterer.eo.legacy.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,17 @@
+#ifndef _ECORE_IDLE_ENTERER_EO_LEGACY_H_
+#define _ECORE_IDLE_ENTERER_EO_LEGACY_H_
+
+#ifndef _ECORE_IDLE_ENTERER_EO_CLASS_TYPE
+#define _ECORE_IDLE_ENTERER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Idle_Enterer;
+
+#endif
+
+#ifndef _ECORE_IDLE_ENTERER_EO_TYPES
+#define _ECORE_IDLE_ENTERER_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/ecore/ecore_idle_exiter.eo.c b/src/lib/ecore/ecore_idle_exiter.eo.c
--- a/src/lib/ecore/ecore_idle_exiter.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idle_exiter.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,26 @@
+
+void _ecore_idle_exiter_constructor(Eo *obj, Ecore_Idle_Exiter_Data *pd, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_idle_exiter_constructor, EO_FUNC_CALL(func, data), Ecore_Task_Cb func, const void *data);
+
+void _ecore_idle_exiter_eo_base_destructor(Eo *obj, Ecore_Idle_Exiter_Data *pd);
+
+
+static Eo_Op_Description _ecore_idle_exiter_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_idle_exiter_eo_base_destructor),
+     EO_OP_FUNC(ecore_idle_exiter_constructor, _ecore_idle_exiter_constructor, "Constructor."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_idle_exiter_class_desc = {
+     EO_VERSION,
+     "Ecore_Idle_Exiter",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_idle_exiter_op_desc),
+     NULL,
+     sizeof(Ecore_Idle_Exiter_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_idle_exiter_class_get, &_ecore_idle_exiter_class_desc, EO_BASE_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_idle_exiter.eo.h b/src/lib/ecore/ecore_idle_exiter.eo.h
--- a/src/lib/ecore/ecore_idle_exiter.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idle_exiter.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,32 @@
+#ifndef _ECORE_IDLE_EXITER_EO_H_
+#define _ECORE_IDLE_EXITER_EO_H_
+
+#ifndef _ECORE_IDLE_EXITER_EO_CLASS_TYPE
+#define _ECORE_IDLE_EXITER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Idle_Exiter;
+
+#endif
+
+#ifndef _ECORE_IDLE_EXITER_EO_TYPES
+#define _ECORE_IDLE_EXITER_EO_TYPES
+
+
+#endif
+#define ECORE_IDLE_EXITER_CLASS ecore_idle_exiter_class_get()
+
+const Eo_Class *ecore_idle_exiter_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Constructor.
+ * 
+ *
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_idle_exiter_constructor(Ecore_Task_Cb func, const void *data);
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_idle_exiter.eo.hh b/src/lib/ecore/ecore_idle_exiter.eo.hh
--- a/src/lib/ecore/ecore_idle_exiter.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idle_exiter.eo.hh	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,141 @@
+#ifndef EFL_GENERATED_ECORE_IDLE_EXITER_HH
+#define EFL_GENERATED_ECORE_IDLE_EXITER_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_idle_exiter.eo.h"
+}
+
+#include <Ecore.h>
+
+namespace ecore { namespace idle {
+
+struct exiter
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit exiter(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit exiter(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Constructor.
+   ///
+   /// @param func 
+   /// @param data 
+   ///
+   template <typename F>
+   exiter(F && func_, efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : exiter(_c0(std::forward<F>(func_), _p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   exiter(exiter const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~exiter() {}
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_IDLE_EXITER_CLASS);
+   }
+
+private:
+   template <typename F>
+   static Eo* _c0(F && func_, efl::eo::parent_type _p)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+function_type* _tmp_f = new F(std::forward<F>(func_));
+      return eo_add_ref(ECORE_IDLE_EXITER_CLASS, _p._eo_raw, ecore_idle_exiter_constructor(efl::eolian::get_callback<Ecore_Task_Cb, function_type>(), _tmp_f));
+   }
+
+};
+} } 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ecore::idle::exiter >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ecore::idle::exiter >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<ecore::idle::exiter>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< ecore::idle::exiter >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::idle::exiter, ::std::tuple<Ecore_Task_Cb, const void *> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::ecore_idle_exiter_constructor(::efl::eolian::to_c(args.get<0>()), ::efl::eolian::to_c(args.get<1>())));
+}
+
+inline void
+call_constructor(tag< ecore::idle::exiter >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::idle::exiter, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ecore::idle::exiter>
+{
+   template <typename U>
+   struct type
+   {
+      operator ecore::idle::exiter() const
+      {
+         return ecore::idle::exiter(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<ecore::idle::exiter>)
+{
+   return (ECORE_IDLE_EXITER_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_IDLE_EXITER_HH
+
diff -Naur a/src/lib/ecore/ecore_idle_exiter.eo.legacy.h b/src/lib/ecore/ecore_idle_exiter.eo.legacy.h
--- a/src/lib/ecore/ecore_idle_exiter.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idle_exiter.eo.legacy.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,17 @@
+#ifndef _ECORE_IDLE_EXITER_EO_LEGACY_H_
+#define _ECORE_IDLE_EXITER_EO_LEGACY_H_
+
+#ifndef _ECORE_IDLE_EXITER_EO_CLASS_TYPE
+#define _ECORE_IDLE_EXITER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Idle_Exiter;
+
+#endif
+
+#ifndef _ECORE_IDLE_EXITER_EO_TYPES
+#define _ECORE_IDLE_EXITER_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/ecore/ecore_idler.eo.c b/src/lib/ecore/ecore_idler.eo.c
--- a/src/lib/ecore/ecore_idler.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idler.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,26 @@
+
+void _ecore_idler_constructor(Eo *obj, Ecore_Idler_Data *pd, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_idler_constructor, EO_FUNC_CALL(func, data), Ecore_Task_Cb func, const void *data);
+
+void _ecore_idler_eo_base_destructor(Eo *obj, Ecore_Idler_Data *pd);
+
+
+static Eo_Op_Description _ecore_idler_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_idler_eo_base_destructor),
+     EO_OP_FUNC(ecore_idler_constructor, _ecore_idler_constructor, "Constructor."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_idler_class_desc = {
+     EO_VERSION,
+     "Ecore_Idler",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_idler_op_desc),
+     NULL,
+     sizeof(Ecore_Idler_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_idler_class_get, &_ecore_idler_class_desc, EO_BASE_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_idler.eo.h b/src/lib/ecore/ecore_idler.eo.h
--- a/src/lib/ecore/ecore_idler.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idler.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,32 @@
+#ifndef _ECORE_IDLER_EO_H_
+#define _ECORE_IDLER_EO_H_
+
+#ifndef _ECORE_IDLER_EO_CLASS_TYPE
+#define _ECORE_IDLER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Idler;
+
+#endif
+
+#ifndef _ECORE_IDLER_EO_TYPES
+#define _ECORE_IDLER_EO_TYPES
+
+
+#endif
+#define ECORE_IDLER_CLASS ecore_idler_class_get()
+
+const Eo_Class *ecore_idler_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Constructor.
+ * 
+ *
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_idler_constructor(Ecore_Task_Cb func, const void *data);
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_idler.eo.hh b/src/lib/ecore/ecore_idler.eo.hh
--- a/src/lib/ecore/ecore_idler.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idler.eo.hh	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,141 @@
+#ifndef EFL_GENERATED_ECORE_IDLER_HH
+#define EFL_GENERATED_ECORE_IDLER_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_idler.eo.h"
+}
+
+#include <Ecore.h>
+
+namespace ecore {
+
+struct idler
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit idler(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit idler(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Constructor.
+   ///
+   /// @param func 
+   /// @param data 
+   ///
+   template <typename F>
+   idler(F && func_, efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : idler(_c0(std::forward<F>(func_), _p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   idler(idler const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~idler() {}
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_IDLER_CLASS);
+   }
+
+private:
+   template <typename F>
+   static Eo* _c0(F && func_, efl::eo::parent_type _p)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+function_type* _tmp_f = new F(std::forward<F>(func_));
+      return eo_add_ref(ECORE_IDLER_CLASS, _p._eo_raw, ecore_idler_constructor(efl::eolian::get_callback<Ecore_Task_Cb, function_type>(), _tmp_f));
+   }
+
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ecore::idler >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ecore::idler >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<ecore::idler>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< ecore::idler >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::idler, ::std::tuple<Ecore_Task_Cb, const void *> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::ecore_idler_constructor(::efl::eolian::to_c(args.get<0>()), ::efl::eolian::to_c(args.get<1>())));
+}
+
+inline void
+call_constructor(tag< ecore::idler >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::idler, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ecore::idler>
+{
+   template <typename U>
+   struct type
+   {
+      operator ecore::idler() const
+      {
+         return ecore::idler(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<ecore::idler>)
+{
+   return (ECORE_IDLER_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_IDLER_HH
+
diff -Naur a/src/lib/ecore/ecore_idler.eo.legacy.h b/src/lib/ecore/ecore_idler.eo.legacy.h
--- a/src/lib/ecore/ecore_idler.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_idler.eo.legacy.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,17 @@
+#ifndef _ECORE_IDLER_EO_LEGACY_H_
+#define _ECORE_IDLER_EO_LEGACY_H_
+
+#ifndef _ECORE_IDLER_EO_CLASS_TYPE
+#define _ECORE_IDLER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Idler;
+
+#endif
+
+#ifndef _ECORE_IDLER_EO_TYPES
+#define _ECORE_IDLER_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/ecore/ecore_job.eo.c b/src/lib/ecore/ecore_job.eo.c
--- a/src/lib/ecore/ecore_job.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_job.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,26 @@
+
+void _ecore_job_constructor(Eo *obj, Ecore_Job_Data *pd, Ecore_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_job_constructor, EO_FUNC_CALL(func, data), Ecore_Cb func, const void *data);
+
+void _ecore_job_eo_base_destructor(Eo *obj, Ecore_Job_Data *pd);
+
+
+static Eo_Op_Description _ecore_job_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_job_eo_base_destructor),
+     EO_OP_FUNC(ecore_job_constructor, _ecore_job_constructor, "Constructor."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_job_class_desc = {
+     EO_VERSION,
+     "Ecore_Job",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_job_op_desc),
+     NULL,
+     sizeof(Ecore_Job_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_job_class_get, &_ecore_job_class_desc, EO_BASE_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_job.eo.h b/src/lib/ecore/ecore_job.eo.h
--- a/src/lib/ecore/ecore_job.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_job.eo.h	2014-11-27 00:57:33.447046332 +0200
@@ -0,0 +1,32 @@
+#ifndef _ECORE_JOB_EO_H_
+#define _ECORE_JOB_EO_H_
+
+#ifndef _ECORE_JOB_EO_CLASS_TYPE
+#define _ECORE_JOB_EO_CLASS_TYPE
+
+typedef Eo Ecore_Job;
+
+#endif
+
+#ifndef _ECORE_JOB_EO_TYPES
+#define _ECORE_JOB_EO_TYPES
+
+
+#endif
+#define ECORE_JOB_CLASS ecore_job_class_get()
+
+const Eo_Class *ecore_job_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Constructor.
+ * 
+ *
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_job_constructor(Ecore_Cb func, const void *data);
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_job.eo.hh b/src/lib/ecore/ecore_job.eo.hh
--- a/src/lib/ecore/ecore_job.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_job.eo.hh	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,141 @@
+#ifndef EFL_GENERATED_ECORE_JOB_HH
+#define EFL_GENERATED_ECORE_JOB_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_job.eo.h"
+}
+
+#include <Ecore.h>
+
+namespace ecore {
+
+struct job
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit job(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit job(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Constructor.
+   ///
+   /// @param func 
+   /// @param data 
+   ///
+   template <typename F>
+   job(F && func_, efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : job(_c0(std::forward<F>(func_), _p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   job(job const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~job() {}
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_JOB_CLASS);
+   }
+
+private:
+   template <typename F>
+   static Eo* _c0(F && func_, efl::eo::parent_type _p)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+function_type* _tmp_f = new F(std::forward<F>(func_));
+      return eo_add_ref(ECORE_JOB_CLASS, _p._eo_raw, ecore_job_constructor(efl::eolian::get_callback<Ecore_Cb, function_type>(), _tmp_f));
+   }
+
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ecore::job >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ecore::job >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<ecore::job>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< ecore::job >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::job, ::std::tuple<Ecore_Cb, const void *> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::ecore_job_constructor(::efl::eolian::to_c(args.get<0>()), ::efl::eolian::to_c(args.get<1>())));
+}
+
+inline void
+call_constructor(tag< ecore::job >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::job, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ecore::job>
+{
+   template <typename U>
+   struct type
+   {
+      operator ecore::job() const
+      {
+         return ecore::job(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<ecore::job>)
+{
+   return (ECORE_JOB_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_JOB_HH
+
diff -Naur a/src/lib/ecore/ecore_job.eo.legacy.h b/src/lib/ecore/ecore_job.eo.legacy.h
--- a/src/lib/ecore/ecore_job.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_job.eo.legacy.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,17 @@
+#ifndef _ECORE_JOB_EO_LEGACY_H_
+#define _ECORE_JOB_EO_LEGACY_H_
+
+#ifndef _ECORE_JOB_EO_CLASS_TYPE
+#define _ECORE_JOB_EO_CLASS_TYPE
+
+typedef Eo Ecore_Job;
+
+#endif
+
+#ifndef _ECORE_JOB_EO_TYPES
+#define _ECORE_JOB_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/ecore/ecore_mainloop.eo.c b/src/lib/ecore/ecore_mainloop.eo.c
--- a/src/lib/ecore/ecore_mainloop.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_mainloop.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,65 @@
+EOAPI const Eo_Event_Description _ECORE_MAINLOOP_EVENT_IDLE_ENTER =
+   EO_EVENT_DESCRIPTION("idle,enter", "");
+EOAPI const Eo_Event_Description _ECORE_MAINLOOP_EVENT_IDLE_EXIT =
+   EO_EVENT_DESCRIPTION("idle,exit", "");
+EOAPI const Eo_Event_Description _ECORE_MAINLOOP_EVENT_IDLE =
+   EO_EVENT_DESCRIPTION("idle", "");
+
+void _ecore_mainloop_select_func_set(Eo *obj, void *pd, Ecore_Select_Function select_func);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_mainloop_select_func_set, EO_FUNC_CALL(select_func), Ecore_Select_Function select_func);
+
+Ecore_Select_Function _ecore_mainloop_select_func_get(Eo *obj, void *pd);
+
+EOAPI EO_FUNC_BODY(ecore_mainloop_select_func_get, Ecore_Select_Function, 0);
+
+void _ecore_mainloop_iterate(Eo *obj, void *pd);
+
+EOAPI EO_VOID_FUNC_BODY(ecore_mainloop_iterate);
+
+int _ecore_mainloop_iterate_may_block(Eo *obj, void *pd, int may_block);
+
+EOAPI EO_FUNC_BODYV(ecore_mainloop_iterate_may_block, int, 0, EO_FUNC_CALL(may_block), int may_block);
+
+void _ecore_mainloop_begin(Eo *obj, void *pd);
+
+EOAPI EO_VOID_FUNC_BODY(ecore_mainloop_begin);
+
+void _ecore_mainloop_quit(Eo *obj, void *pd);
+
+EOAPI EO_VOID_FUNC_BODY(ecore_mainloop_quit);
+
+Eina_Bool _ecore_mainloop_animator_ticked(Eo *obj, void *pd);
+
+EOAPI EO_FUNC_BODY(ecore_mainloop_animator_ticked, Eina_Bool, 0);
+
+static Eo_Op_Description _ecore_mainloop_op_desc[] = {
+     EO_OP_FUNC(ecore_mainloop_select_func_set, _ecore_mainloop_select_func_set, ""),
+     EO_OP_FUNC(ecore_mainloop_select_func_get, _ecore_mainloop_select_func_get, ""),
+     EO_OP_FUNC(ecore_mainloop_iterate, _ecore_mainloop_iterate, ""),
+     EO_OP_FUNC(ecore_mainloop_iterate_may_block, _ecore_mainloop_iterate_may_block, ""),
+     EO_OP_FUNC(ecore_mainloop_begin, _ecore_mainloop_begin, ""),
+     EO_OP_FUNC(ecore_mainloop_quit, _ecore_mainloop_quit, ""),
+     EO_OP_FUNC(ecore_mainloop_animator_ticked, _ecore_mainloop_animator_ticked, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Event_Description *_ecore_mainloop_event_desc[] = {
+     ECORE_MAINLOOP_EVENT_IDLE_ENTER,
+     ECORE_MAINLOOP_EVENT_IDLE_EXIT,
+     ECORE_MAINLOOP_EVENT_IDLE,
+     NULL
+};
+
+static const Eo_Class_Description _ecore_mainloop_class_desc = {
+     EO_VERSION,
+     "Ecore_Mainloop",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_mainloop_op_desc),
+     _ecore_mainloop_event_desc,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_mainloop_class_get, &_ecore_mainloop_class_desc, EO_BASE_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_mainloop.eo.h b/src/lib/ecore/ecore_mainloop.eo.h
--- a/src/lib/ecore/ecore_mainloop.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_mainloop.eo.h	2014-11-27 00:57:33.447046332 +0200
@@ -0,0 +1,97 @@
+#ifndef _ECORE_MAINLOOP_EO_H_
+#define _ECORE_MAINLOOP_EO_H_
+
+#ifndef _ECORE_MAINLOOP_EO_CLASS_TYPE
+#define _ECORE_MAINLOOP_EO_CLASS_TYPE
+
+typedef Eo Ecore_Mainloop;
+
+#endif
+
+#ifndef _ECORE_MAINLOOP_EO_TYPES
+#define _ECORE_MAINLOOP_EO_TYPES
+
+
+#endif
+#define ECORE_MAINLOOP_CLASS ecore_mainloop_class_get()
+
+const Eo_Class *ecore_mainloop_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] select_func No description supplied.
+ *
+ */
+EOAPI void  ecore_mainloop_select_func_set(Ecore_Select_Function select_func);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Ecore_Select_Function  ecore_mainloop_select_func_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI void  ecore_mainloop_iterate(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] may_block No description supplied.
+ *
+ */
+EOAPI int  ecore_mainloop_iterate_may_block(int may_block);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI void  ecore_mainloop_begin(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI void  ecore_mainloop_quit(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  ecore_mainloop_animator_ticked(void);
+
+EOAPI extern const Eo_Event_Description _ECORE_MAINLOOP_EVENT_IDLE_ENTER;
+EOAPI extern const Eo_Event_Description _ECORE_MAINLOOP_EVENT_IDLE_EXIT;
+EOAPI extern const Eo_Event_Description _ECORE_MAINLOOP_EVENT_IDLE;
+
+/**
+ * No description
+ */
+#define ECORE_MAINLOOP_EVENT_IDLE_ENTER (&(_ECORE_MAINLOOP_EVENT_IDLE_ENTER))
+
+/**
+ * No description
+ */
+#define ECORE_MAINLOOP_EVENT_IDLE_EXIT (&(_ECORE_MAINLOOP_EVENT_IDLE_EXIT))
+
+/**
+ * No description
+ */
+#define ECORE_MAINLOOP_EVENT_IDLE (&(_ECORE_MAINLOOP_EVENT_IDLE))
+
+#endif
diff -Naur a/src/lib/ecore/ecore_parent.eo.c b/src/lib/ecore/ecore_parent.eo.c
--- a/src/lib/ecore/ecore_parent.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_parent.eo.c	2014-11-27 00:57:33.447046332 +0200
@@ -0,0 +1,13 @@
+
+static const Eo_Class_Description _ecore_parent_class_desc = {
+     EO_VERSION,
+     "Ecore_Parent",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_parent_class_get, &_ecore_parent_class_desc, EO_BASE_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore/ecore_parent.eo.h b/src/lib/ecore/ecore_parent.eo.h
--- a/src/lib/ecore/ecore_parent.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_parent.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,21 @@
+#ifndef _ECORE_PARENT_EO_H_
+#define _ECORE_PARENT_EO_H_
+
+#ifndef _ECORE_PARENT_EO_CLASS_TYPE
+#define _ECORE_PARENT_EO_CLASS_TYPE
+
+typedef Eo Ecore_Parent;
+
+#endif
+
+#ifndef _ECORE_PARENT_EO_TYPES
+#define _ECORE_PARENT_EO_TYPES
+
+
+#endif
+#define ECORE_PARENT_CLASS ecore_parent_class_get()
+
+const Eo_Class *ecore_parent_class_get(void) EINA_CONST;
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_parent.eo.hh b/src/lib/ecore/ecore_parent.eo.hh
--- a/src/lib/ecore/ecore_parent.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_parent.eo.hh	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,113 @@
+#ifndef EFL_GENERATED_ECORE_PARENT_HH
+#define EFL_GENERATED_ECORE_PARENT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_parent.eo.h"
+}
+
+
+namespace ecore {
+
+struct parent
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit parent(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit parent(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   parent(parent const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~parent() {}
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_PARENT_CLASS);
+   }
+
+private:
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ecore::parent >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ecore::parent >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<ecore::parent>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< ecore::parent >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::parent, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ecore::parent>
+{
+   template <typename U>
+   struct type
+   {
+      operator ecore::parent() const
+      {
+         return ecore::parent(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<ecore::parent>)
+{
+   return (ECORE_PARENT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_PARENT_HH
+
diff -Naur a/src/lib/ecore/ecore_poller.eo.c b/src/lib/ecore/ecore_poller.eo.c
--- a/src/lib/ecore/ecore_poller.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_poller.eo.c	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,47 @@
+
+Eina_Bool _ecore_poller_interval_set(Eo *obj, Ecore_Poller_Data *pd, int interval);
+
+EOAPI EO_FUNC_BODYV(ecore_poller_interval_set, Eina_Bool, 0, EO_FUNC_CALL(interval), int interval);
+
+int _ecore_poller_interval_get(Eo *obj, Ecore_Poller_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_poller_interval_get, int, 0);
+
+void _ecore_poller_constructor(Eo *obj, Ecore_Poller_Data *pd, Ecore_Poller_Type type, int interval, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_poller_constructor, EO_FUNC_CALL(type, interval, func, data), Ecore_Poller_Type type, int interval, Ecore_Task_Cb func, const void *data);
+
+void _ecore_poller_eo_base_destructor(Eo *obj, Ecore_Poller_Data *pd);
+
+
+static Eo_Op_Description _ecore_poller_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_poller_eo_base_destructor),
+     EO_OP_FUNC(ecore_poller_interval_set, _ecore_poller_interval_set, "@brief Changes the polling interval rate of @p poller."),
+     EO_OP_FUNC(ecore_poller_interval_get, _ecore_poller_interval_get, "@brief Gets the polling interval rate of @p poller."),
+     EO_OP_FUNC(ecore_poller_constructor, _ecore_poller_constructor, "Constructor with parameters for Ecore Poller."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_poller_class_desc = {
+     EO_VERSION,
+     "Ecore_Poller",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_poller_op_desc),
+     NULL,
+     sizeof(Ecore_Poller_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_poller_class_get, &_ecore_poller_class_desc, EO_BASE_CLASS, NULL);
+EAPI Eina_Bool
+ecore_poller_poller_interval_set(Ecore_Poller *obj, int interval)
+{
+   return eo_do((Ecore_Poller *)obj, ecore_poller_interval_set(interval));
+}
+
+EAPI int
+ecore_poller_poller_interval_get(const Ecore_Poller *obj)
+{
+   return eo_do((Ecore_Poller *)obj, ecore_poller_interval_get());
+}
diff -Naur a/src/lib/ecore/ecore_poller.eo.h b/src/lib/ecore/ecore_poller.eo.h
--- a/src/lib/ecore/ecore_poller.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_poller.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,58 @@
+#ifndef _ECORE_POLLER_EO_H_
+#define _ECORE_POLLER_EO_H_
+
+#ifndef _ECORE_POLLER_EO_CLASS_TYPE
+#define _ECORE_POLLER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Poller;
+
+#endif
+
+#ifndef _ECORE_POLLER_EO_TYPES
+#define _ECORE_POLLER_EO_TYPES
+
+
+#endif
+#define ECORE_POLLER_CLASS ecore_poller_class_get()
+
+const Eo_Class *ecore_poller_class_get(void) EINA_CONST;
+
+/**
+ *
+ * @brief Changes the polling interval rate of @p poller.
+ * @return Returns true on success, false on failure.
+ *
+ * This allows the changing of a poller's polling interval. It is useful when
+ * you want to alter a poll rate without deleting and re-creating a poller.
+ *
+ * @param[in] interval The tick interval to set; must be a power of 2 and <= 32768.
+ *
+ */
+EOAPI Eina_Bool  ecore_poller_interval_set(int interval);
+
+/**
+ *
+ * @brief Gets the polling interval rate of @p poller.
+ * @return Returns the interval, in ticks, that @p poller polls at.
+ *
+ * This returns a poller's polling interval, or 0 on error.
+ *
+ *
+ */
+EOAPI int  ecore_poller_interval_get(void);
+
+/**
+ *
+ * Constructor with parameters for Ecore Poller.
+ * 
+ *
+ * @param[in] type No description supplied.
+ * @param[in] interval No description supplied.
+ * @param[in] func No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  ecore_poller_constructor(Ecore_Poller_Type type, int interval, Ecore_Task_Cb func, const void *data);
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_poller.eo.hh b/src/lib/ecore/ecore_poller.eo.hh
--- a/src/lib/ecore/ecore_poller.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_poller.eo.hh	2014-11-27 00:57:33.447046332 +0200
@@ -0,0 +1,228 @@
+#ifndef EFL_GENERATED_ECORE_POLLER_HH
+#define EFL_GENERATED_ECORE_POLLER_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_poller.eo.h"
+}
+
+#include <Ecore.h>
+
+namespace ecore {
+
+struct poller
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit poller(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit poller(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Constructor with parameters for Ecore Poller.
+   ///
+   /// @param type 
+   /// @param interval 
+   /// @param func 
+   /// @param data 
+   ///
+   template <typename F>
+   poller(Ecore_Poller_Type type_, int interval_, F && func_, efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : poller(_c0(type_, interval_, std::forward<F>(func_), _p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   poller(poller const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~poller() {}
+
+   /// @brief @brief Gets the polling interval rate of @p poller.
+   /// @return Returns the interval, in ticks, that @p poller polls at.
+   ///
+   /// This returns a poller's polling interval, or 0 on error.
+   ///
+   /// @param interval The tick interval to set; must be a power of 2 and <= 32768.
+   ///
+   int interval_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_poller_interval_get());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Changes the polling interval rate of @p poller.
+   /// @return Returns true on success, false on failure.
+   ///
+   /// This allows the changing of a poller's polling interval. It is useful when
+   /// you want to alter a poll rate without deleting and re-creating a poller.
+   ///
+   /// @param interval The tick interval to set; must be a power of 2 and <= 32768.
+   ///
+   bool interval_set(int interval_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_poller_interval_set(interval_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_POLLER_CLASS);
+   }
+
+private:
+   template <typename F>
+   static Eo* _c0(Ecore_Poller_Type type_, int interval_, F && func_, efl::eo::parent_type _p)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+function_type* _tmp_f = new F(std::forward<F>(func_));
+      return eo_add_ref(ECORE_POLLER_CLASS, _p._eo_raw, ecore_poller_constructor(type_, interval_, efl::eolian::get_callback<Ecore_Task_Cb, function_type>(), _tmp_f));
+   }
+
+};
+} 
+
+template <typename T>
+int ecore_poller_interval_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->interval_get();
+}
+
+template <typename T>
+bool ecore_poller_interval_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int interval_)
+{
+   return static_cast<T*>(self->this_)->interval_set(interval_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ecore::poller >
+{
+   template <typename T>
+   struct type
+   {
+      virtual int interval_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_poller_interval_get());
+            return _tmp_ret;
+      }
+
+      virtual bool interval_set(int interval_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_poller_interval_set(interval_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ecore::poller >
+{
+   static const int value = 2;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<ecore::poller>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::ecore_poller_interval_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::ecore_poller_interval_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::ecore_poller_interval_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::ecore_poller_interval_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ecore::poller >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::poller, ::std::tuple<Ecore_Poller_Type, int, Ecore_Task_Cb, const void *> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::ecore_poller_constructor(::efl::eolian::to_c(args.get<0>()), ::efl::eolian::to_c(args.get<1>()), ::efl::eolian::to_c(args.get<2>()), ::efl::eolian::to_c(args.get<3>())));
+}
+
+inline void
+call_constructor(tag< ecore::poller >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<ecore::poller, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ecore::poller>
+{
+   template <typename U>
+   struct type
+   {
+      operator ecore::poller() const
+      {
+         return ecore::poller(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      int interval_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_poller_interval_get());
+            return _tmp_ret;
+      }
+
+      bool interval_set(int interval_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_poller_interval_set(interval_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<ecore::poller>)
+{
+   return (ECORE_POLLER_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_POLLER_HH
+
diff -Naur a/src/lib/ecore/ecore_poller.eo.legacy.h b/src/lib/ecore/ecore_poller.eo.legacy.h
--- a/src/lib/ecore/ecore_poller.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_poller.eo.legacy.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,39 @@
+#ifndef _ECORE_POLLER_EO_LEGACY_H_
+#define _ECORE_POLLER_EO_LEGACY_H_
+
+#ifndef _ECORE_POLLER_EO_CLASS_TYPE
+#define _ECORE_POLLER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Poller;
+
+#endif
+
+#ifndef _ECORE_POLLER_EO_TYPES
+#define _ECORE_POLLER_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * @brief Changes the polling interval rate of @p poller.
+ * @return Returns true on success, false on failure.
+ *
+ * This allows the changing of a poller's polling interval. It is useful when
+ * you want to alter a poll rate without deleting and re-creating a poller.
+ *
+ * @param[in] interval The tick interval to set; must be a power of 2 and <= 32768.
+ */
+EAPI Eina_Bool ecore_poller_poller_interval_set(Ecore_Poller *obj, int interval);
+
+/**
+ *
+ * @brief Gets the polling interval rate of @p poller.
+ * @return Returns the interval, in ticks, that @p poller polls at.
+ *
+ * This returns a poller's polling interval, or 0 on error.
+ *
+ */
+EAPI int ecore_poller_poller_interval_get(const Ecore_Poller *obj);
+
+#endif
diff -Naur a/src/lib/ecore/ecore_timer.eo.c b/src/lib/ecore/ecore_timer.eo.c
--- a/src/lib/ecore/ecore_timer.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_timer.eo.c	2014-11-27 00:57:33.447046332 +0200
@@ -0,0 +1,97 @@
+
+void _ecore_timer_interval_set(Eo *obj, Ecore_Timer_Data *pd, double in);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_obj_timer_interval_set, EO_FUNC_CALL(in), double in);
+
+double _ecore_timer_interval_get(Eo *obj, Ecore_Timer_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_obj_timer_interval_get, double, 0);
+
+double _ecore_timer_pending_get(Eo *obj, Ecore_Timer_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_obj_timer_pending_get, double, 0);
+
+void _ecore_timer_loop_constructor(Eo *obj, Ecore_Timer_Data *pd, double in, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_obj_timer_loop_constructor, EO_FUNC_CALL(in, func, data), double in, Ecore_Task_Cb func, const void *data);
+
+void _ecore_timer_constructor(Eo *obj, Ecore_Timer_Data *pd, double in, Ecore_Task_Cb func, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_obj_timer_constructor, EO_FUNC_CALL(in, func, data), double in, Ecore_Task_Cb func, const void *data);
+
+void _ecore_timer_reset(Eo *obj, Ecore_Timer_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(ecore_obj_timer_reset);
+
+void _ecore_timer_delay(Eo *obj, Ecore_Timer_Data *pd, double add);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_obj_timer_delay, EO_FUNC_CALL(add), double add);
+
+void _ecore_timer_eo_base_destructor(Eo *obj, Ecore_Timer_Data *pd);
+
+
+void _ecore_timer_eo_base_event_freeze(Eo *obj, Ecore_Timer_Data *pd);
+
+
+int _ecore_timer_eo_base_event_freeze_count_get(Eo *obj, Ecore_Timer_Data *pd);
+
+
+void _ecore_timer_eo_base_event_thaw(Eo *obj, Ecore_Timer_Data *pd);
+
+
+static Eo_Op_Description _ecore_timer_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_timer_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_event_freeze, _ecore_timer_eo_base_event_freeze),
+     EO_OP_FUNC_OVERRIDE(eo_event_freeze_count_get, _ecore_timer_eo_base_event_freeze_count_get),
+     EO_OP_FUNC_OVERRIDE(eo_event_thaw, _ecore_timer_eo_base_event_thaw),
+     EO_OP_FUNC(ecore_obj_timer_interval_set, _ecore_timer_interval_set, "Change the interval the timer ticks off. If set during"),
+     EO_OP_FUNC(ecore_obj_timer_interval_get, _ecore_timer_interval_get, "Get the interval the timer ticks on."),
+     EO_OP_FUNC(ecore_obj_timer_pending_get, _ecore_timer_pending_get, "Get the pending time regarding a timer."),
+     EO_OP_FUNC(ecore_obj_timer_loop_constructor, _ecore_timer_loop_constructor, "Create a timer to call in a given time from now"),
+     EO_OP_FUNC(ecore_obj_timer_constructor, _ecore_timer_constructor, "Create a timer to call in a given time from when the mainloop woke up from sleep"),
+     EO_OP_FUNC(ecore_obj_timer_reset, _ecore_timer_reset, "Reset a timer to its full interval. This effectively makes"),
+     EO_OP_FUNC(ecore_obj_timer_delay, _ecore_timer_delay, "Add some delay for the next occurrence of a timer."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_timer_class_desc = {
+     EO_VERSION,
+     "Ecore_Timer",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_timer_op_desc),
+     NULL,
+     sizeof(Ecore_Timer_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_timer_class_get, &_ecore_timer_class_desc, EO_BASE_CLASS, NULL);
+EAPI void
+ecore_timer_interval_set(Ecore_Timer *obj, double in)
+{
+   eo_do((Ecore_Timer *)obj, ecore_obj_timer_interval_set(in));
+}
+
+EAPI double
+ecore_timer_interval_get(const Ecore_Timer *obj)
+{
+   return eo_do((Ecore_Timer *)obj, ecore_obj_timer_interval_get());
+}
+
+EAPI double
+ecore_timer_pending_get(const Ecore_Timer *obj)
+{
+   return eo_do((Ecore_Timer *)obj, ecore_obj_timer_pending_get());
+}
+
+EAPI void
+ecore_timer_reset(Ecore_Timer *obj)
+{
+   eo_do((Ecore_Timer *)obj, ecore_obj_timer_reset());
+}
+
+EAPI void
+ecore_timer_delay(Ecore_Timer *obj, double add)
+{
+   eo_do((Ecore_Timer *)obj, ecore_obj_timer_delay(add));
+}
diff -Naur a/src/lib/ecore/ecore_timer.eo.h b/src/lib/ecore/ecore_timer.eo.h
--- a/src/lib/ecore/ecore_timer.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_timer.eo.h	2014-11-27 00:57:33.450379688 +0200
@@ -0,0 +1,105 @@
+#ifndef _ECORE_TIMER_EO_H_
+#define _ECORE_TIMER_EO_H_
+
+#ifndef _ECORE_TIMER_EO_CLASS_TYPE
+#define _ECORE_TIMER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Timer;
+
+#endif
+
+#ifndef _ECORE_TIMER_EO_TYPES
+#define _ECORE_TIMER_EO_TYPES
+
+
+#endif
+/**
+ * Timers are objects that will call a given callback at some point
+ * *  in the future. They may also optionall repeat themselves if the
+ * *  timer callback returns true. If it does not they will be
+ * *  automatically deleted and never called again. Timers require the
+ * *  ecore mainloop to be running and functioning properly. They do not
+ * *  guarantee exact timing, but try to work on a "best effort basis.
+ */
+#define ECORE_TIMER_CLASS ecore_timer_class_get()
+
+const Eo_Class *ecore_timer_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Change the interval the timer ticks off. If set during
+ * * a timer call, this will affect the next interval.
+ *
+ * @param[in] in The new interval in seconds
+ *
+ */
+EOAPI void  ecore_obj_timer_interval_set(double in);
+
+/**
+ *
+ * Get the interval the timer ticks on.
+ *
+ *
+ */
+EOAPI double  ecore_obj_timer_interval_get(void);
+
+/**
+ *
+ * Get the pending time regarding a timer.
+ *
+ *
+ */
+EOAPI double  ecore_obj_timer_pending_get(void);
+
+/**
+ *
+ * Create a timer to call in a given time from now
+ * 
+ *
+ * @param[in] in The time, in seconds, from now when to go off
+ * @param[in] func The callback function to call when the timer goes off
+ * @param[in] data A pointer to pass to the callback function as its data pointer
+ *
+ */
+EOAPI void  ecore_obj_timer_loop_constructor(double in, Ecore_Task_Cb func, const void *data);
+
+/**
+ *
+ * Create a timer to call in a given time from when the mainloop woke up from sleep
+ * 
+ *
+ * @param[in] in The time, in seconds, from when the main loop woke up, to go off
+ * @param[in] func The callback function to call when the timer goes off
+ * @param[in] data A pointer to pass to the callback function as its data pointer
+ *
+ */
+EOAPI void  ecore_obj_timer_constructor(double in, Ecore_Task_Cb func, const void *data);
+
+/**
+ *
+ * Reset a timer to its full interval. This effectively makes
+ * *  the timer start ticking off from zero now.
+ * *  @note This is equivalent to (but faster than)
+ * * @code
+ * * ecore_timer_delay(timer, ecore_timer_interval_get(timer) - ecore_timer_pending_get(timer));
+ * * @endcode
+ * * @since 1.2
+ * 
+ *
+ *
+ */
+EOAPI void  ecore_obj_timer_reset(void);
+
+/**
+ *
+ * Add some delay for the next occurrence of a timer.
+ * * This doesn't affect the interval of a timer.
+ * 
+ *
+ * @param[in] add The amount of time to delay the timer by in seconds
+ *
+ */
+EOAPI void  ecore_obj_timer_delay(double add);
+
+
+#endif
diff -Naur a/src/lib/ecore/ecore_timer.eo.legacy.h b/src/lib/ecore/ecore_timer.eo.legacy.h
--- a/src/lib/ecore/ecore_timer.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore/ecore_timer.eo.legacy.h	2014-11-27 00:57:33.447046332 +0200
@@ -0,0 +1,72 @@
+#ifndef _ECORE_TIMER_EO_LEGACY_H_
+#define _ECORE_TIMER_EO_LEGACY_H_
+
+#ifndef _ECORE_TIMER_EO_CLASS_TYPE
+#define _ECORE_TIMER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Timer;
+
+#endif
+
+#ifndef _ECORE_TIMER_EO_TYPES
+#define _ECORE_TIMER_EO_TYPES
+
+
+#endif
+/**
+ * Timers are objects that will call a given callback at some point
+ * *  in the future. They may also optionall repeat themselves if the
+ * *  timer callback returns true. If it does not they will be
+ * *  automatically deleted and never called again. Timers require the
+ * *  ecore mainloop to be running and functioning properly. They do not
+ * *  guarantee exact timing, but try to work on a "best effort basis.
+ */
+
+/**
+ *
+ * Change the interval the timer ticks off. If set during
+ * * a timer call, this will affect the next interval.
+ *
+ * @param[in] in The new interval in seconds
+ */
+EAPI void ecore_timer_interval_set(Ecore_Timer *obj, double in);
+
+/**
+ *
+ * Get the interval the timer ticks on.
+ *
+ */
+EAPI double ecore_timer_interval_get(const Ecore_Timer *obj);
+
+/**
+ *
+ * Get the pending time regarding a timer.
+ *
+ */
+EAPI double ecore_timer_pending_get(const Ecore_Timer *obj);
+
+/**
+ *
+ * Reset a timer to its full interval. This effectively makes
+ * *  the timer start ticking off from zero now.
+ * *  @note This is equivalent to (but faster than)
+ * * @code
+ * * ecore_timer_delay(timer, ecore_timer_interval_get(timer) - ecore_timer_pending_get(timer));
+ * * @endcode
+ * * @since 1.2
+ * 
+ *
+ */
+EAPI void ecore_timer_reset(Ecore_Timer *obj);
+
+/**
+ *
+ * Add some delay for the next occurrence of a timer.
+ * * This doesn't affect the interval of a timer.
+ * 
+ *
+ * @param[in] add The amount of time to delay the timer by in seconds
+ */
+EAPI void ecore_timer_delay(Ecore_Timer *obj, double add);
+
+#endif
diff -Naur a/src/lib/ecore_audio/Ecore_Audio.hh b/src/lib/ecore_audio/Ecore_Audio.hh
--- a/src/lib/ecore_audio/Ecore_Audio.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/Ecore_Audio.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,15 @@
+#ifndef EFL_CXX_ECORE_AUDIO_HH
+#define EFL_CXX_ECORE_AUDIO_HH
+
+#ifdef EFL_BETA_API_SUPPORT
+#include <ecore_audio.eo.hh>
+#include <ecore_audio_in.eo.hh>
+#include <ecore_audio_out.eo.hh>
+#include <ecore_audio_in_sndfile.eo.hh>
+#include <ecore_audio_out_sndfile.eo.hh>
+#include <ecore_audio_out_pulse.eo.hh>
+#include <ecore_audio_in_tone.eo.hh>
+#endif
+
+#endif
+
diff -Naur a/src/lib/ecore_audio/ecore_audio.eo.hh b/src/lib/ecore_audio/ecore_audio.eo.hh
--- a/src/lib/ecore_audio/ecore_audio.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/ecore_audio.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,532 @@
+#ifndef EFL_GENERATED_ECORE_AUDIO_HH
+#define EFL_GENERATED_ECORE_AUDIO_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_audio.eo.h"
+}
+
+#include <string>
+
+struct ecore_audio
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit ecore_audio(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit ecore_audio(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   ecore_audio(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : ecore_audio(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   ecore_audio(ecore_audio const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~ecore_audio() {}
+
+   /// @brief Get the source of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param source 
+   ///
+   std::string source_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the source of the object
+   ///
+   /// What sources are supported depends on the actual object. For example,
+   /// the libsndfile class accepts WAV, OGG, FLAC files as source.
+   ///
+   /// @since 1.8
+   ///
+   /// @param source 
+   ///
+   bool source_set(std::string source_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the format of the object
+   ///
+   /// After setting the source if the format was ECORE_AUDIO_FORMAT_AUTO this
+   /// function will now return the actual format.
+   ///
+   /// @since 1.8
+   ///
+   /// @param format 
+   ///
+   Ecore_Audio_Format format_get() const
+   {
+      Ecore_Audio_Format _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the format of the object
+   ///
+   /// What formats are supported depends on the actual object. Default is
+   /// ECORE_AUDIO_FORMAT_AUTO
+   ///
+   /// @since 1.8
+   ///
+   /// @param format 
+   ///
+   bool format_set(Ecore_Audio_Format format_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_set(format_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the name of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param name 
+   ///
+   std::string name_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_name_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the name of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param name 
+   ///
+   void name_set(std::string name_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_name_set(efl::eolian::to_c(name_)));
+   }
+
+   /// @brief Get the pause state of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param paused 
+   ///
+   bool paused_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_paused_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the pause state of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param paused 
+   ///
+   void paused_set(bool paused_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_paused_set(efl::eolian::to_c(paused_)));
+   }
+
+   /// @brief Get the volume of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param volume 
+   ///
+   double volume_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_volume_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the volume of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param volume 
+   ///
+   void volume_set(double volume_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_volume_set(volume_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_AUDIO_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(ECORE_AUDIO_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+std::string _ecore_audio_source_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_get();
+}
+
+template <typename T>
+bool _ecore_audio_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * source_)
+{
+   return static_cast<T*>(self->this_)->source_set(efl::eolian::to_cxx<std::string>(source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Ecore_Audio_Format _ecore_audio_format_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->format_get();
+}
+
+template <typename T>
+bool _ecore_audio_format_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Ecore_Audio_Format format_)
+{
+   return static_cast<T*>(self->this_)->format_set(format_);
+}
+
+template <typename T>
+std::string _ecore_audio_name_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->name_get();
+}
+
+template <typename T>
+void _ecore_audio_name_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_)
+{
+   static_cast<T*>(self->this_)->name_set(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool _ecore_audio_paused_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->paused_get();
+}
+
+template <typename T>
+void _ecore_audio_paused_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool paused_)
+{
+   static_cast<T*>(self->this_)->paused_set(efl::eolian::to_cxx<bool>(paused_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+double _ecore_audio_volume_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->volume_get();
+}
+
+template <typename T>
+void _ecore_audio_volume_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double volume_)
+{
+   static_cast<T*>(self->this_)->volume_set(volume_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::ecore_audio >
+{
+   template <typename T>
+   struct type
+   {
+      virtual std::string source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool source_set(std::string source_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Ecore_Audio_Format format_get()
+      {
+         Ecore_Audio_Format _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_format_get());
+            return _tmp_ret;
+      }
+
+      virtual bool format_set(Ecore_Audio_Format format_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_format_set(format_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual std::string name_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_name_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void name_set(std::string name_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_name_set(efl::eolian::to_c(name_)));
+      }
+
+      virtual bool paused_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_paused_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void paused_set(bool paused_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_paused_set(efl::eolian::to_c(paused_)));
+      }
+
+      virtual double volume_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_volume_get());
+            return _tmp_ret;
+      }
+
+      virtual void volume_set(double volume_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_volume_set(volume_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::ecore_audio >
+{
+   static const int value = 10;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::ecore_audio>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_ecore_audio_source_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_source_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_ecore_audio_source_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_source_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_ecore_audio_format_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_format_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_ecore_audio_format_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_format_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_ecore_audio_name_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_name_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_ecore_audio_name_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_name_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_ecore_audio_paused_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_paused_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_ecore_audio_paused_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_paused_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_ecore_audio_volume_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_volume_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_ecore_audio_volume_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_volume_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::ecore_audio >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::ecore_audio >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::ecore_audio>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::ecore_audio() const
+      {
+         return ::ecore_audio(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      std::string source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool source_set(std::string source_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Ecore_Audio_Format format_get()
+      {
+         Ecore_Audio_Format _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_get());
+            return _tmp_ret;
+      }
+
+      bool format_set(Ecore_Audio_Format format_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_set(format_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      std::string name_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_name_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void name_set(std::string name_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_name_set(efl::eolian::to_c(name_)));
+      }
+
+      bool paused_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_paused_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void paused_set(bool paused_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_paused_set(efl::eolian::to_c(paused_)));
+      }
+
+      double volume_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_volume_get());
+            return _tmp_ret;
+      }
+
+      void volume_set(double volume_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_volume_set(volume_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::ecore_audio>)
+{
+   return (ECORE_AUDIO_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_AUDIO_HH
+
diff -Naur a/src/lib/ecore_audio/ecore_audio_in.eo.hh b/src/lib/ecore_audio/ecore_audio_in.eo.hh
--- a/src/lib/ecore_audio/ecore_audio_in.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/ecore_audio_in.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,941 @@
+#ifndef EFL_GENERATED_ECORE_AUDIO_IN_HH
+#define EFL_GENERATED_ECORE_AUDIO_IN_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_audio_in.eo.h"
+}
+
+#include "ecore_audio.eo.hh"
+
+struct ecore_audio_in
+      : ecore_audio
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit ecore_audio_in(Eo* eo)
+      : ecore_audio(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit ecore_audio_in(std::nullptr_t)
+      : ecore_audio(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   ecore_audio_in(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : ecore_audio_in(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   ecore_audio_in(ecore_audio_in const& other)
+      : ecore_audio(eo_ref(other._eo_ptr()))
+   {}
+
+   ~ecore_audio_in() {}
+
+   /// @brief Set the virtual IO functions
+   ///
+   /// @since 1.8
+   ///
+   /// @param vio 
+   /// @param data 
+   /// @param free_func 
+   ///
+   void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+   }
+
+   /// @brief Get the the preloaded state of the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param preloaded 
+   ///
+   bool preloaded_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_preloaded_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the preloaded state of the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param preloaded 
+   ///
+   void preloaded_set(bool preloaded_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_in_preloaded_set(efl::eolian::to_c(preloaded_)));
+   }
+
+   /// @brief Set the length of the input
+   ///
+   /// This function is only implemented by some classes
+   /// (i.e. ECORE_AUDIO_OBJ_IN_TONE_CLASS)
+   ///
+   /// @since 1.8
+   ///
+   /// @param length 
+   ///
+   void length_set(double length_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_in_length_set(length_));
+   }
+
+   /// @brief Get the playback speed of the input.
+   ///
+   /// @since 1.8
+   ///
+   /// @param speed 
+   ///
+   double speed_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_speed_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the playback speed of the input.
+   ///
+   /// @since 1.8
+   ///
+   /// @param speed 
+   ///
+   void speed_set(double speed_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_in_speed_set(speed_));
+   }
+
+   /// @brief Get the he sample-rate of the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param samplerate 
+   ///
+   int samplerate_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_samplerate_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the sample-rate of the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param samplerate 
+   ///
+   void samplerate_set(int samplerate_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_in_samplerate_set(samplerate_));
+   }
+
+   /// @brief Get the amount of channels the input has
+   ///
+   /// @since 1.8
+   ///
+   /// @param channels 
+   ///
+   int channels_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_channels_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the amount of channels the input has
+   ///
+   /// @since 1.8
+   ///
+   /// @param channels 
+   ///
+   void channels_set(int channels_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_in_channels_set(channels_));
+   }
+
+   /// @brief Get the looped state of the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param looped 
+   ///
+   bool looped_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_looped_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the looped state of the input
+   ///
+   /// If the input is looped and reaches the end it will start from the
+   /// beginning again. At the same time the event @ref ECORE_AUDIO_EV_IN_LOOPED
+   /// will be emitted
+   ///
+   /// @since 1.8
+   ///
+   /// @param looped 
+   ///
+   void looped_set(bool looped_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_in_looped_set(efl::eolian::to_c(looped_)));
+   }
+
+   /// @brief Get the length of the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param length 
+   ///
+   double length_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_length_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the output that this input is attached to
+   ///
+   /// @since 1.8
+   ///
+   /// @param output 
+   ///
+   efl::eo::base output_get() const
+   {
+      Eo * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_output_get());
+      return efl::eolian::to_cxx<efl::eo::base>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the remaining time of the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param remaining 
+   ///
+   double remaining_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_remaining_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Read from the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param buf 
+   /// @param len 
+   ///
+   ssize_t read(void * buf_, size_t len_) const
+   {
+      ssize_t _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read(buf_, len_));
+      return _tmp_ret;
+   }
+
+   /// @brief Internal read function
+   ///
+   /// @since 1.8
+   ///
+   /// @param buf 
+   /// @param len 
+   ///
+   ssize_t read_internal(void * buf_, size_t len_) const
+   {
+      ssize_t _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+      return _tmp_ret;
+   }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_in_looped_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_IN_EVENT_IN_LOOPED, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>,
+         ECORE_AUDIO_IN_EVENT_IN_LOOPED );
+   }
+
+   template <typename T>
+   void
+   callback_in_looped_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_IN_EVENT_IN_LOOPED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_in_stopped_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_IN_EVENT_IN_STOPPED, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>,
+         ECORE_AUDIO_IN_EVENT_IN_STOPPED );
+   }
+
+   template <typename T>
+   void
+   callback_in_stopped_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_IN_EVENT_IN_STOPPED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_in_samplerate_changed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_IN_EVENT_IN_SAMPLERATE_CHANGED, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>,
+         ECORE_AUDIO_IN_EVENT_IN_SAMPLERATE_CHANGED );
+   }
+
+   template <typename T>
+   void
+   callback_in_samplerate_changed_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_IN_EVENT_IN_SAMPLERATE_CHANGED, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_AUDIO_IN_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(ECORE_AUDIO_IN_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _ecore_audio_in_vio_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+{
+   static_cast<T*>(self->this_)->vio_set(vio_, data_, free_func_);
+}
+
+template <typename T>
+bool _ecore_audio_in_preloaded_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->preloaded_get();
+}
+
+template <typename T>
+void _ecore_audio_in_preloaded_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool preloaded_)
+{
+   static_cast<T*>(self->this_)->preloaded_set(efl::eolian::to_cxx<bool>(preloaded_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void _ecore_audio_in_length_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double length_)
+{
+   static_cast<T*>(self->this_)->length_set(length_);
+}
+
+template <typename T>
+double _ecore_audio_in_speed_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->speed_get();
+}
+
+template <typename T>
+void _ecore_audio_in_speed_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double speed_)
+{
+   static_cast<T*>(self->this_)->speed_set(speed_);
+}
+
+template <typename T>
+int _ecore_audio_in_samplerate_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->samplerate_get();
+}
+
+template <typename T>
+void _ecore_audio_in_samplerate_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int samplerate_)
+{
+   static_cast<T*>(self->this_)->samplerate_set(samplerate_);
+}
+
+template <typename T>
+int _ecore_audio_in_channels_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->channels_get();
+}
+
+template <typename T>
+void _ecore_audio_in_channels_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int channels_)
+{
+   static_cast<T*>(self->this_)->channels_set(channels_);
+}
+
+template <typename T>
+bool _ecore_audio_in_looped_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->looped_get();
+}
+
+template <typename T>
+void _ecore_audio_in_looped_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool looped_)
+{
+   static_cast<T*>(self->this_)->looped_set(efl::eolian::to_cxx<bool>(looped_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+double _ecore_audio_in_length_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->length_get();
+}
+
+template <typename T>
+efl::eo::base _ecore_audio_in_output_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->output_get();
+}
+
+template <typename T>
+double _ecore_audio_in_remaining_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->remaining_get();
+}
+
+template <typename T>
+ssize_t _ecore_audio_in_read_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * buf_, size_t len_)
+{
+   return static_cast<T*>(self->this_)->read(buf_, len_);
+}
+
+template <typename T>
+ssize_t _ecore_audio_in_read_internal_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * buf_, size_t len_)
+{
+   return static_cast<T*>(self->this_)->read_internal(buf_, len_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::ecore_audio_in >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+      }
+
+      virtual bool preloaded_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_preloaded_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void preloaded_set(bool preloaded_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_in_preloaded_set(efl::eolian::to_c(preloaded_)));
+      }
+
+      virtual void length_set(double length_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_in_length_set(length_));
+      }
+
+      virtual double speed_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_speed_get());
+            return _tmp_ret;
+      }
+
+      virtual void speed_set(double speed_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_in_speed_set(speed_));
+      }
+
+      virtual int samplerate_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_samplerate_get());
+            return _tmp_ret;
+      }
+
+      virtual void samplerate_set(int samplerate_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_in_samplerate_set(samplerate_));
+      }
+
+      virtual int channels_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_channels_get());
+            return _tmp_ret;
+      }
+
+      virtual void channels_set(int channels_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_in_channels_set(channels_));
+      }
+
+      virtual bool looped_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_looped_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void looped_set(bool looped_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_in_looped_set(efl::eolian::to_c(looped_)));
+      }
+
+      virtual double length_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_length_get());
+            return _tmp_ret;
+      }
+
+      virtual efl::eo::base output_get()
+      {
+         Eo * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_output_get());
+            return efl::eolian::to_cxx<efl::eo::base>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual double remaining_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_remaining_get());
+            return _tmp_ret;
+      }
+
+      virtual ssize_t read(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_read(buf_, len_));
+            return _tmp_ret;
+      }
+
+      virtual ssize_t read_internal(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+            return _tmp_ret;
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::ecore_audio_in >
+{
+   static const int value = 17;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::ecore_audio_in>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_ecore_audio_in_vio_set_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_vio_set);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_ecore_audio_in_preloaded_get_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_preloaded_get);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_ecore_audio_in_preloaded_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_preloaded_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_ecore_audio_in_length_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_length_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_ecore_audio_in_speed_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_speed_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_ecore_audio_in_speed_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_speed_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_ecore_audio_in_samplerate_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_samplerate_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_ecore_audio_in_samplerate_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_samplerate_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_ecore_audio_in_channels_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_channels_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_ecore_audio_in_channels_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_channels_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::_ecore_audio_in_looped_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_looped_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::_ecore_audio_in_looped_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_looped_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::_ecore_audio_in_length_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_length_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::_ecore_audio_in_output_get_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_output_get);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::_ecore_audio_in_remaining_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_remaining_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::_ecore_audio_in_read_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_read);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::_ecore_audio_in_read_internal_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_read_internal);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::ecore_audio_in >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_in, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::ecore_audio_in >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_in, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::ecore_audio_in>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::ecore_audio_in() const
+      {
+         return ::ecore_audio_in(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+      }
+
+      bool preloaded_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_preloaded_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void preloaded_set(bool preloaded_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_in_preloaded_set(efl::eolian::to_c(preloaded_)));
+      }
+
+      void length_set(double length_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_in_length_set(length_));
+      }
+
+      double speed_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_speed_get());
+            return _tmp_ret;
+      }
+
+      void speed_set(double speed_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_in_speed_set(speed_));
+      }
+
+      int samplerate_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_samplerate_get());
+            return _tmp_ret;
+      }
+
+      void samplerate_set(int samplerate_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_in_samplerate_set(samplerate_));
+      }
+
+      int channels_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_channels_get());
+            return _tmp_ret;
+      }
+
+      void channels_set(int channels_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_in_channels_set(channels_));
+      }
+
+      bool looped_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_looped_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void looped_set(bool looped_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_in_looped_set(efl::eolian::to_c(looped_)));
+      }
+
+      double length_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_length_get());
+            return _tmp_ret;
+      }
+
+      efl::eo::base output_get()
+      {
+         Eo * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_output_get());
+            return efl::eolian::to_cxx<efl::eo::base>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      double remaining_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_remaining_get());
+            return _tmp_ret;
+      }
+
+      ssize_t read(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read(buf_, len_));
+            return _tmp_ret;
+      }
+
+      ssize_t read_internal(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+            return _tmp_ret;
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_in_looped_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_IN_EVENT_IN_LOOPED, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>,
+         ECORE_AUDIO_IN_EVENT_IN_LOOPED );
+   }
+
+   template <typename T>
+   void
+   callback_in_looped_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_IN_EVENT_IN_LOOPED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_in_stopped_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_IN_EVENT_IN_STOPPED, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>,
+         ECORE_AUDIO_IN_EVENT_IN_STOPPED );
+   }
+
+   template <typename T>
+   void
+   callback_in_stopped_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_IN_EVENT_IN_STOPPED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_in_samplerate_changed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_IN_EVENT_IN_SAMPLERATE_CHANGED, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_in, function_type>,
+         ECORE_AUDIO_IN_EVENT_IN_SAMPLERATE_CHANGED );
+   }
+
+   template <typename T>
+   void
+   callback_in_samplerate_changed_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_IN_EVENT_IN_SAMPLERATE_CHANGED, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::ecore_audio_in>)
+{
+   return (ECORE_AUDIO_IN_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_AUDIO_IN_HH
+
diff -Naur a/src/lib/ecore_audio/ecore_audio_in_sndfile.eo.hh b/src/lib/ecore_audio/ecore_audio_in_sndfile.eo.hh
--- a/src/lib/ecore_audio/ecore_audio_in_sndfile.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/ecore_audio_in_sndfile.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,426 @@
+#ifndef EFL_GENERATED_ECORE_AUDIO_IN_SNDFILE_HH
+#define EFL_GENERATED_ECORE_AUDIO_IN_SNDFILE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_audio_in_sndfile.eo.h"
+}
+
+#include "ecore_audio_in.eo.hh"
+#include <string>
+
+struct ecore_audio_in_sndfile
+      : ecore_audio_in
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit ecore_audio_in_sndfile(Eo* eo)
+      : ecore_audio_in(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit ecore_audio_in_sndfile(std::nullptr_t)
+      : ecore_audio_in(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   ecore_audio_in_sndfile(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : ecore_audio_in_sndfile(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   ecore_audio_in_sndfile(ecore_audio_in_sndfile const& other)
+      : ecore_audio_in(eo_ref(other._eo_ptr()))
+   {}
+
+   ~ecore_audio_in_sndfile() {}
+
+   /// @brief Set the source of the object
+   ///
+   /// What sources are supported depends on the actual object. For example,
+   /// the libsndfile class accepts WAV, OGG, FLAC files as source.
+   ///
+   /// @since 1.8
+   ///
+   /// @param source 
+   ///
+   bool source_set(std::string source_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the source of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param source 
+   ///
+   std::string source_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the format of the object
+   ///
+   /// What formats are supported depends on the actual object. Default is
+   /// ECORE_AUDIO_FORMAT_AUTO
+   ///
+   /// @since 1.8
+   ///
+   /// @param format 
+   ///
+   bool format_set(Ecore_Audio_Format format_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_set(format_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the format of the object
+   ///
+   /// After setting the source if the format was ECORE_AUDIO_FORMAT_AUTO this
+   /// function will now return the actual format.
+   ///
+   /// @since 1.8
+   ///
+   /// @param format 
+   ///
+   Ecore_Audio_Format format_get() const
+   {
+      Ecore_Audio_Format _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the virtual IO functions
+   ///
+   /// @since 1.8
+   ///
+   /// @param vio 
+   /// @param data 
+   /// @param free_func 
+   ///
+   void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+   }
+
+   /// @brief Seek within the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param offs 
+   /// @param mode 
+   ///
+   double seek(double offs_, int mode_) const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_seek(offs_, mode_));
+      return _tmp_ret;
+   }
+
+   /// @brief Internal read function
+   ///
+   /// @since 1.8
+   ///
+   /// @param buf 
+   /// @param len 
+   ///
+   ssize_t read_internal(void * buf_, size_t len_) const
+   {
+      ssize_t _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+      return _tmp_ret;
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_AUDIO_IN_SNDFILE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(ECORE_AUDIO_IN_SNDFILE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+bool _ecore_audio_in_sndfile_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * source_)
+{
+   return static_cast<T*>(self->this_)->source_set(efl::eolian::to_cxx<std::string>(source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string _ecore_audio_in_sndfile_source_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_get();
+}
+
+template <typename T>
+bool _ecore_audio_in_sndfile_format_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Ecore_Audio_Format format_)
+{
+   return static_cast<T*>(self->this_)->format_set(format_);
+}
+
+template <typename T>
+Ecore_Audio_Format _ecore_audio_in_sndfile_format_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->format_get();
+}
+
+template <typename T>
+void _ecore_audio_in_sndfile_vio_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+{
+   static_cast<T*>(self->this_)->vio_set(vio_, data_, free_func_);
+}
+
+template <typename T>
+double _ecore_audio_in_sndfile_seek_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double offs_, int mode_)
+{
+   return static_cast<T*>(self->this_)->seek(offs_, mode_);
+}
+
+template <typename T>
+ssize_t _ecore_audio_in_sndfile_read_internal_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * buf_, size_t len_)
+{
+   return static_cast<T*>(self->this_)->read_internal(buf_, len_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::ecore_audio_in_sndfile >
+{
+   template <typename T>
+   struct type
+   {
+      virtual bool source_set(std::string source_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual std::string source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool format_set(Ecore_Audio_Format format_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_format_set(format_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Ecore_Audio_Format format_get()
+      {
+         Ecore_Audio_Format _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_format_get());
+            return _tmp_ret;
+      }
+
+      virtual void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+      }
+
+      virtual double seek(double offs_, int mode_)
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_seek(offs_, mode_));
+            return _tmp_ret;
+      }
+
+      virtual ssize_t read_internal(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+            return _tmp_ret;
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::ecore_audio_in_sndfile >
+{
+   static const int value = 7;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::ecore_audio_in_sndfile>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_ecore_audio_in_sndfile_source_set_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_source_set);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_ecore_audio_in_sndfile_source_get_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_source_get);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_ecore_audio_in_sndfile_format_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_format_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_ecore_audio_in_sndfile_format_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_format_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_ecore_audio_in_sndfile_vio_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_vio_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_ecore_audio_in_sndfile_seek_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_seek);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_ecore_audio_in_sndfile_read_internal_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_read_internal);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::ecore_audio_in_sndfile >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_in_sndfile, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::ecore_audio_in_sndfile >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_in_sndfile, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::ecore_audio_in_sndfile>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::ecore_audio_in_sndfile() const
+      {
+         return ::ecore_audio_in_sndfile(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      bool source_set(std::string source_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      std::string source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool format_set(Ecore_Audio_Format format_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_set(format_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Ecore_Audio_Format format_get()
+      {
+         Ecore_Audio_Format _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_get());
+            return _tmp_ret;
+      }
+
+      void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+      }
+
+      double seek(double offs_, int mode_)
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_seek(offs_, mode_));
+            return _tmp_ret;
+      }
+
+      ssize_t read_internal(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+            return _tmp_ret;
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::ecore_audio_in_sndfile>)
+{
+   return (ECORE_AUDIO_IN_SNDFILE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_AUDIO_IN_SNDFILE_HH
+
diff -Naur a/src/lib/ecore_audio/ecore_audio_in_tone.eo.hh b/src/lib/ecore_audio/ecore_audio_in_tone.eo.hh
--- a/src/lib/ecore_audio/ecore_audio_in_tone.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/ecore_audio_in_tone.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,328 @@
+#ifndef EFL_GENERATED_ECORE_AUDIO_IN_TONE_HH
+#define EFL_GENERATED_ECORE_AUDIO_IN_TONE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_audio_in_tone.eo.h"
+}
+
+#include "ecore_audio_in.eo.hh"
+#include <string>
+
+struct ecore_audio_in_tone
+      : ecore_audio_in
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit ecore_audio_in_tone(Eo* eo)
+      : ecore_audio_in(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit ecore_audio_in_tone(std::nullptr_t)
+      : ecore_audio_in(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   ecore_audio_in_tone(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : ecore_audio_in_tone(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   ecore_audio_in_tone(ecore_audio_in_tone const& other)
+      : ecore_audio_in(eo_ref(other._eo_ptr()))
+   {}
+
+   ~ecore_audio_in_tone() {}
+
+   /// @brief Set generic data to object.
+   ///
+   /// @param key the key associated with the data
+   /// @param data the data to set
+   /// @param free_func the func to free data with (NULL means
+   ///
+   void key_data_set(std::string key_, const void * data_, eo_key_data_free_func free_func_) const
+   {
+      eo_do(_eo_ptr(), ::eo_key_data_set(efl::eolian::to_c(key_), data_, free_func_));
+   }
+
+   /// @brief Get generic data from object.
+   ///
+   /// @param key the key associated with the data
+   ///
+   void * key_data_get(std::string key_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::eo_key_data_get(efl::eolian::to_c(key_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Set the length of the input
+   ///
+   /// This function is only implemented by some classes
+   /// (i.e. ECORE_AUDIO_OBJ_IN_TONE_CLASS)
+   ///
+   /// @since 1.8
+   ///
+   /// @param length 
+   ///
+   void length_set(double length_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_in_length_set(length_));
+   }
+
+   /// @brief Seek within the input
+   ///
+   /// @since 1.8
+   ///
+   /// @param offs 
+   /// @param mode 
+   ///
+   double seek(double offs_, int mode_) const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_seek(offs_, mode_));
+      return _tmp_ret;
+   }
+
+   /// @brief Internal read function
+   ///
+   /// @since 1.8
+   ///
+   /// @param buf 
+   /// @param len 
+   ///
+   ssize_t read_internal(void * buf_, size_t len_) const
+   {
+      ssize_t _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+      return _tmp_ret;
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_AUDIO_IN_TONE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(ECORE_AUDIO_IN_TONE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _ecore_audio_in_tone_key_data_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * key_, const void * data_, eo_key_data_free_func free_func_)
+{
+   static_cast<T*>(self->this_)->key_data_set(efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()), data_, free_func_);
+}
+
+template <typename T>
+void * _ecore_audio_in_tone_key_data_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * key_)
+{
+   return static_cast<T*>(self->this_)->key_data_get(efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void _ecore_audio_in_tone_length_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double length_)
+{
+   static_cast<T*>(self->this_)->length_set(length_);
+}
+
+template <typename T>
+double _ecore_audio_in_tone_seek_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double offs_, int mode_)
+{
+   return static_cast<T*>(self->this_)->seek(offs_, mode_);
+}
+
+template <typename T>
+ssize_t _ecore_audio_in_tone_read_internal_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * buf_, size_t len_)
+{
+   return static_cast<T*>(self->this_)->read_internal(buf_, len_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::ecore_audio_in_tone >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void key_data_set(std::string key_, const void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_key_data_set(efl::eolian::to_c(key_), data_, free_func_));
+      }
+
+      virtual void * key_data_get(std::string key_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::eo_key_data_get(efl::eolian::to_c(key_)));
+            return _tmp_ret;
+      }
+
+      virtual void length_set(double length_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_in_length_set(length_));
+      }
+
+      virtual double seek(double offs_, int mode_)
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_seek(offs_, mode_));
+            return _tmp_ret;
+      }
+
+      virtual ssize_t read_internal(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+            return _tmp_ret;
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::ecore_audio_in_tone >
+{
+   static const int value = 5;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::ecore_audio_in_tone>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_ecore_audio_in_tone_key_data_set_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_key_data_set);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_ecore_audio_in_tone_key_data_get_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::eo_key_data_get);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_ecore_audio_in_tone_length_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_length_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_ecore_audio_in_tone_seek_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_seek);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_ecore_audio_in_tone_read_internal_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_in_read_internal);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::ecore_audio_in_tone >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_in_tone, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::ecore_audio_in_tone >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_in_tone, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::ecore_audio_in_tone>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::ecore_audio_in_tone() const
+      {
+         return ::ecore_audio_in_tone(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void key_data_set(std::string key_, const void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_key_data_set(efl::eolian::to_c(key_), data_, free_func_));
+      }
+
+      void * key_data_get(std::string key_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::eo_key_data_get(efl::eolian::to_c(key_)));
+            return _tmp_ret;
+      }
+
+      void length_set(double length_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_in_length_set(length_));
+      }
+
+      double seek(double offs_, int mode_)
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_seek(offs_, mode_));
+            return _tmp_ret;
+      }
+
+      ssize_t read_internal(void * buf_, size_t len_)
+      {
+         ssize_t _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_in_read_internal(buf_, len_));
+            return _tmp_ret;
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::ecore_audio_in_tone>)
+{
+   return (ECORE_AUDIO_IN_TONE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_AUDIO_IN_TONE_HH
+
diff -Naur a/src/lib/ecore_audio/ecore_audio_out.eo.hh b/src/lib/ecore_audio/ecore_audio_out.eo.hh
--- a/src/lib/ecore_audio/ecore_audio_out.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/ecore_audio_out.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,290 @@
+#ifndef EFL_GENERATED_ECORE_AUDIO_OUT_HH
+#define EFL_GENERATED_ECORE_AUDIO_OUT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_audio_out.eo.h"
+}
+
+#include "ecore_audio.eo.hh"
+#include <eo_base.hh>
+
+struct ecore_audio_out
+      : ecore_audio
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit ecore_audio_out(Eo* eo)
+      : ecore_audio(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit ecore_audio_out(std::nullptr_t)
+      : ecore_audio(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   ecore_audio_out(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : ecore_audio_out(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   ecore_audio_out(ecore_audio_out const& other)
+      : ecore_audio(eo_ref(other._eo_ptr()))
+   {}
+
+   ~ecore_audio_out() {}
+
+   /// @brief Set the virtual IO functions
+   ///
+   /// @since 1.8
+   ///
+   /// @param vio 
+   /// @param data 
+   /// @param free_func 
+   ///
+   void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+   }
+
+   /// @brief Attach an input to an output
+   ///
+   /// @since 1.8
+   ///
+   /// @param input 
+   ///
+   bool input_attach(efl::eo::base input_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Detach an input from an output
+   ///
+   /// @since 1.8
+   ///
+   /// @param input 
+   ///
+   bool input_detach(efl::eo::base input_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_detach(efl::eolian::to_c(input_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Returns the list of all attached inputs
+   ///
+   /// @since 1.8
+   ///
+   efl::eina::range_list< efl::eo::base > inputs_get() const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_inputs_get());
+      return efl::eolian::to_cxx<efl::eina::range_list< efl::eo::base >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_AUDIO_OUT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(ECORE_AUDIO_OUT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _ecore_audio_out_vio_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+{
+   static_cast<T*>(self->this_)->vio_set(vio_, data_, free_func_);
+}
+
+template <typename T>
+bool _ecore_audio_out_input_attach_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo * input_)
+{
+   return static_cast<T*>(self->this_)->input_attach(efl::eolian::to_cxx<efl::eo::base>(input_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool _ecore_audio_out_input_detach_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo * input_)
+{
+   return static_cast<T*>(self->this_)->input_detach(efl::eolian::to_cxx<efl::eo::base>(input_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+efl::eina::range_list< efl::eo::base > _ecore_audio_out_inputs_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->inputs_get();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::ecore_audio_out >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+      }
+
+      virtual bool input_attach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool input_detach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_out_input_detach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual efl::eina::range_list< efl::eo::base > inputs_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_out_inputs_get());
+            return efl::eolian::to_cxx<efl::eina::range_list< efl::eo::base >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::ecore_audio_out >
+{
+   static const int value = 4;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::ecore_audio_out>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_ecore_audio_out_vio_set_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_vio_set);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_ecore_audio_out_input_attach_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_out_input_attach);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_ecore_audio_out_input_detach_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_out_input_detach);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_ecore_audio_out_inputs_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_out_inputs_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::ecore_audio_out >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_out, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::ecore_audio_out >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_out, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::ecore_audio_out>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::ecore_audio_out() const
+      {
+         return ::ecore_audio_out(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void vio_set(Ecore_Audio_Vio * vio_, void * data_, eo_key_data_free_func free_func_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_vio_set(vio_, data_, free_func_));
+      }
+
+      bool input_attach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool input_detach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_detach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      efl::eina::range_list< efl::eo::base > inputs_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_inputs_get());
+            return efl::eolian::to_cxx<efl::eina::range_list< efl::eo::base >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::ecore_audio_out>)
+{
+   return (ECORE_AUDIO_OUT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_AUDIO_OUT_HH
+
diff -Naur a/src/lib/ecore_audio/ecore_audio_out_pulse.eo.hh b/src/lib/ecore_audio/ecore_audio_out_pulse.eo.hh
--- a/src/lib/ecore_audio/ecore_audio_out_pulse.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/ecore_audio_out_pulse.eo.hh	2014-11-27 00:57:33.520380796 +0200
@@ -0,0 +1,345 @@
+#ifndef EFL_GENERATED_ECORE_AUDIO_OUT_PULSE_HH
+#define EFL_GENERATED_ECORE_AUDIO_OUT_PULSE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_audio_out_pulse.eo.h"
+}
+
+#include "ecore_audio_out.eo.hh"
+#include <eo_base.hh>
+
+struct ecore_audio_out_pulse
+      : ecore_audio_out
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit ecore_audio_out_pulse(Eo* eo)
+      : ecore_audio_out(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit ecore_audio_out_pulse(std::nullptr_t)
+      : ecore_audio_out(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   ecore_audio_out_pulse(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : ecore_audio_out_pulse(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   ecore_audio_out_pulse(ecore_audio_out_pulse const& other)
+      : ecore_audio_out(eo_ref(other._eo_ptr()))
+   {}
+
+   ~ecore_audio_out_pulse() {}
+
+   /// @brief Set the volume of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param volume 
+   ///
+   void volume_set(double volume_) const
+   {
+      eo_do(_eo_ptr(), ::ecore_audio_obj_volume_set(volume_));
+   }
+
+   /// @brief Attach an input to an output
+   ///
+   /// @since 1.8
+   ///
+   /// @param input 
+   ///
+   bool input_attach(efl::eo::base input_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Detach an input from an output
+   ///
+   /// @since 1.8
+   ///
+   /// @param input 
+   ///
+   bool input_detach(efl::eo::base input_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_detach(efl::eolian::to_c(input_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_context_ready_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_READY, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>,
+         ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_READY );
+   }
+
+   template <typename T>
+   void
+   callback_context_ready_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_READY, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_context_fail_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_FAIL, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>,
+         ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_FAIL );
+   }
+
+   template <typename T>
+   void
+   callback_context_fail_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_FAIL, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_AUDIO_OUT_PULSE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(ECORE_AUDIO_OUT_PULSE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _ecore_audio_out_pulse_volume_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double volume_)
+{
+   static_cast<T*>(self->this_)->volume_set(volume_);
+}
+
+template <typename T>
+bool _ecore_audio_out_pulse_input_attach_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo * input_)
+{
+   return static_cast<T*>(self->this_)->input_attach(efl::eolian::to_cxx<efl::eo::base>(input_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool _ecore_audio_out_pulse_input_detach_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo * input_)
+{
+   return static_cast<T*>(self->this_)->input_detach(efl::eolian::to_cxx<efl::eo::base>(input_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::ecore_audio_out_pulse >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void volume_set(double volume_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::ecore_audio_obj_volume_set(volume_));
+      }
+
+      virtual bool input_attach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool input_detach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_out_input_detach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::ecore_audio_out_pulse >
+{
+   static const int value = 3;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::ecore_audio_out_pulse>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_ecore_audio_out_pulse_volume_set_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_volume_set);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_ecore_audio_out_pulse_input_attach_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_out_input_attach);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_ecore_audio_out_pulse_input_detach_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_out_input_detach);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::ecore_audio_out_pulse >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_out_pulse, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::ecore_audio_out_pulse >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_out_pulse, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::ecore_audio_out_pulse>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::ecore_audio_out_pulse() const
+      {
+         return ::ecore_audio_out_pulse(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void volume_set(double volume_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::ecore_audio_obj_volume_set(volume_));
+      }
+
+      bool input_attach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool input_detach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_detach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_context_ready_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_READY, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>,
+         ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_READY );
+   }
+
+   template <typename T>
+   void
+   callback_context_ready_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_READY, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_context_fail_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_FAIL, priority_,
+            &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<::ecore_audio_out_pulse, function_type>,
+         ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_FAIL );
+   }
+
+   template <typename T>
+   void
+   callback_context_fail_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (ECORE_AUDIO_OUT_PULSE_EVENT_CONTEXT_FAIL, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::ecore_audio_out_pulse>)
+{
+   return (ECORE_AUDIO_OUT_PULSE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_AUDIO_OUT_PULSE_HH
+
diff -Naur a/src/lib/ecore_audio/ecore_audio_out_sndfile.eo.hh b/src/lib/ecore_audio/ecore_audio_out_sndfile.eo.hh
--- a/src/lib/ecore_audio/ecore_audio_out_sndfile.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_audio/ecore_audio_out_sndfile.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,347 @@
+#ifndef EFL_GENERATED_ECORE_AUDIO_OUT_SNDFILE_HH
+#define EFL_GENERATED_ECORE_AUDIO_OUT_SNDFILE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "ecore_audio_out_sndfile.eo.h"
+}
+
+#include "ecore_audio_out.eo.hh"
+#include <eo_base.hh>
+#include <string>
+
+struct ecore_audio_out_sndfile
+      : ecore_audio_out
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit ecore_audio_out_sndfile(Eo* eo)
+      : ecore_audio_out(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit ecore_audio_out_sndfile(std::nullptr_t)
+      : ecore_audio_out(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   ecore_audio_out_sndfile(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : ecore_audio_out_sndfile(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   ecore_audio_out_sndfile(ecore_audio_out_sndfile const& other)
+      : ecore_audio_out(eo_ref(other._eo_ptr()))
+   {}
+
+   ~ecore_audio_out_sndfile() {}
+
+   /// @brief Get the source of the object
+   ///
+   /// @since 1.8
+   ///
+   /// @param source 
+   ///
+   std::string source_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the source of the object
+   ///
+   /// What sources are supported depends on the actual object. For example,
+   /// the libsndfile class accepts WAV, OGG, FLAC files as source.
+   ///
+   /// @since 1.8
+   ///
+   /// @param source 
+   ///
+   bool source_set(std::string source_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the format of the object
+   ///
+   /// After setting the source if the format was ECORE_AUDIO_FORMAT_AUTO this
+   /// function will now return the actual format.
+   ///
+   /// @since 1.8
+   ///
+   /// @param format 
+   ///
+   Ecore_Audio_Format format_get() const
+   {
+      Ecore_Audio_Format _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the format of the object
+   ///
+   /// What formats are supported depends on the actual object. Default is
+   /// ECORE_AUDIO_FORMAT_AUTO
+   ///
+   /// @since 1.8
+   ///
+   /// @param format 
+   ///
+   bool format_set(Ecore_Audio_Format format_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_set(format_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Attach an input to an output
+   ///
+   /// @since 1.8
+   ///
+   /// @param input 
+   ///
+   bool input_attach(efl::eo::base input_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(ECORE_AUDIO_OUT_SNDFILE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(ECORE_AUDIO_OUT_SNDFILE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+std::string _ecore_audio_out_sndfile_source_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_get();
+}
+
+template <typename T>
+bool _ecore_audio_out_sndfile_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * source_)
+{
+   return static_cast<T*>(self->this_)->source_set(efl::eolian::to_cxx<std::string>(source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Ecore_Audio_Format _ecore_audio_out_sndfile_format_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->format_get();
+}
+
+template <typename T>
+bool _ecore_audio_out_sndfile_format_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Ecore_Audio_Format format_)
+{
+   return static_cast<T*>(self->this_)->format_set(format_);
+}
+
+template <typename T>
+bool _ecore_audio_out_sndfile_input_attach_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo * input_)
+{
+   return static_cast<T*>(self->this_)->input_attach(efl::eolian::to_cxx<efl::eo::base>(input_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::ecore_audio_out_sndfile >
+{
+   template <typename T>
+   struct type
+   {
+      virtual std::string source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool source_set(std::string source_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Ecore_Audio_Format format_get()
+      {
+         Ecore_Audio_Format _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_format_get());
+            return _tmp_ret;
+      }
+
+      virtual bool format_set(Ecore_Audio_Format format_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_format_set(format_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool input_attach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::ecore_audio_out_sndfile >
+{
+   static const int value = 5;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::ecore_audio_out_sndfile>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_ecore_audio_out_sndfile_source_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_source_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_ecore_audio_out_sndfile_source_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_source_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_ecore_audio_out_sndfile_format_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_format_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_ecore_audio_out_sndfile_format_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_format_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_ecore_audio_out_sndfile_input_attach_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::ecore_audio_obj_out_input_attach);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::ecore_audio_out_sndfile >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_out_sndfile, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::ecore_audio_out_sndfile >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::ecore_audio_out_sndfile, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::ecore_audio_out_sndfile>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::ecore_audio_out_sndfile() const
+      {
+         return ::ecore_audio_out_sndfile(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      std::string source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool source_set(std::string source_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_source_set(efl::eolian::to_c(source_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Ecore_Audio_Format format_get()
+      {
+         Ecore_Audio_Format _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_get());
+            return _tmp_ret;
+      }
+
+      bool format_set(Ecore_Audio_Format format_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_format_set(format_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool input_attach(efl::eo::base input_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::ecore_audio_obj_out_input_attach(efl::eolian::to_c(input_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::ecore_audio_out_sndfile>)
+{
+   return (ECORE_AUDIO_OUT_SNDFILE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_ECORE_AUDIO_OUT_SNDFILE_HH
+
diff -Naur a/src/lib/ecore_con/ecore_con_base.eo.c b/src/lib/ecore_con/ecore_con_base.eo.c
--- a/src/lib/ecore_con/ecore_con_base.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_base.eo.c	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,60 @@
+EOAPI const Eo_Event_Description _ECORE_CON_BASE_EVENT_DATA_RECEIVED =
+   EO_EVENT_DESCRIPTION("data,received", "");
+EOAPI const Eo_Event_Description _ECORE_CON_BASE_EVENT_CONNECTION_UPGRADED =
+   EO_EVENT_DESCRIPTION("connection,upgraded", "");
+EOAPI const Eo_Event_Description _ECORE_CON_BASE_EVENT_CONNECTION_ERROR =
+   EO_EVENT_DESCRIPTION("connection,error", "");
+EOAPI EO_FUNC_BODY(ecore_con_obj_ip_get, const char *, 0);
+EOAPI EO_FUNC_BODY(ecore_con_obj_uptime_get, double, 0);
+EOAPI EO_VOID_FUNC_BODYV(ecore_con_obj_port_set, EO_FUNC_CALL(port), int port);
+EOAPI EO_FUNC_BODY(ecore_con_obj_port_get, int, 0);
+EOAPI EO_FUNC_BODY(ecore_con_obj_fd_get, int, 0);
+EOAPI EO_FUNC_BODY(ecore_con_obj_connected_get, Eina_Bool, 0);
+EOAPI EO_VOID_FUNC_BODYV(ecore_con_obj_timeout_set, EO_FUNC_CALL(timeout), double timeout);
+EOAPI EO_FUNC_BODY(ecore_con_obj_timeout_get, double, 0);
+EOAPI EO_VOID_FUNC_BODY(ecore_con_obj_flush);
+EOAPI EO_FUNC_BODYV(ecore_con_obj_send, int, 0, EO_FUNC_CALL(data, size), const void *data, int size);
+
+Eina_Bool _ecore_con_base_lookup(Eo *obj, void *pd, const char *name, Ecore_Con_Dns_Cb done_cb, const void *data);
+
+EOAPI EO_FUNC_BODYV(ecore_con_obj_lookup, Eina_Bool, 0, EO_FUNC_CALL(name, done_cb, data), const char *name, Ecore_Con_Dns_Cb done_cb, const void *data);
+
+static Eo_Op_Description _ecore_con_base_op_desc[] = {
+     EO_OP_FUNC(ecore_con_obj_ip_get, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_uptime_get, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_port_set, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_port_get, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_fd_get, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_connected_get, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_timeout_set, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_timeout_get, NULL, ""),
+     EO_OP_FUNC(ecore_con_obj_flush, NULL, "* Flushes all pending data to the given server."),
+     EO_OP_FUNC(ecore_con_obj_send, NULL, ""),
+     EO_OP_CLASS_FUNC(ecore_con_obj_lookup, _ecore_con_base_lookup, "* Do an asynchronous DNS lookup."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Event_Description *_ecore_con_base_event_desc[] = {
+     ECORE_CON_BASE_EVENT_DATA_RECEIVED,
+     ECORE_CON_BASE_EVENT_CONNECTION_UPGRADED,
+     ECORE_CON_BASE_EVENT_CONNECTION_ERROR,
+     NULL
+};
+
+static const Eo_Class_Description _ecore_con_base_class_desc = {
+     EO_VERSION,
+     "Ecore_Con_Base",
+     EO_CLASS_TYPE_REGULAR_NO_INSTANT,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_con_base_op_desc),
+     _ecore_con_base_event_desc,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_con_base_class_get, &_ecore_con_base_class_desc, EO_BASE_CLASS, NULL);
+EAPI Eina_Bool
+ecore_con_lookup(const char *name, Ecore_Con_Dns_Cb done_cb, const void *data)
+{
+   return eo_do(ECORE_CON_BASE_CLASS, ecore_con_obj_lookup(name, done_cb, data));
+}
diff -Naur a/src/lib/ecore_con/ecore_con_base.eo.h b/src/lib/ecore_con/ecore_con_base.eo.h
--- a/src/lib/ecore_con/ecore_con_base.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_base.eo.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,195 @@
+#ifndef _ECORE_CON_BASE_EO_H_
+#define _ECORE_CON_BASE_EO_H_
+
+#ifndef _ECORE_CON_BASE_EO_CLASS_TYPE
+#define _ECORE_CON_BASE_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Base;
+
+#endif
+
+#ifndef _ECORE_CON_BASE_EO_TYPES
+#define _ECORE_CON_BASE_EO_TYPES
+
+typedef struct {
+  void *data; /** The data thet got sent. */
+  int size; /** The length of the data sent. */
+} Ecore_Con_Event_Data_Received;
+
+typedef void (*Ecore_Con_Dns_Cb)(const char *, const char *, struct sockaddr *, int, void *);
+
+
+#endif
+#define ECORE_CON_BASE_CLASS ecore_con_base_class_get()
+
+const Eo_Class *ecore_con_base_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI const char * ecore_con_obj_ip_get(void);
+
+/**
+ *
+ * * @brief Check how long the object has been connected
+ * *
+ * * This function is used to find out how long a client has been connected for.
+ * 
+ *
+ *
+ */
+EOAPI double  ecore_con_obj_uptime_get(void);
+
+/**
+ *
+ * * @brief Return the port that the obj is connected to
+ * *
+ * 
+ *
+ * @param[in] port The The port that obj is connected to, or -1 on error.
+ *
+ */
+EOAPI void  ecore_con_obj_port_set(int port);
+
+/**
+ *
+ * * @brief Return the port that the obj is connected to
+ * *
+ * 
+ *
+ *
+ */
+EOAPI int  ecore_con_obj_port_get(void);
+
+/**
+ *
+ * * Get the fd that the server is connected to
+ * *
+ * * This function returns the fd which is used by the underlying server connection.
+ * * It should not be tampered with unless you REALLY know what you are doing.
+ * * @note This function is only valid for servers created with ecore_con_server_connect()
+ * * @warning Seriously. Don't use this unless you know what you are doing.
+ * * @since 1.1
+ * 
+ *
+ *
+ */
+EOAPI int  ecore_con_obj_fd_get(void);
+
+/**
+ *
+ * * Returns whether the client is still connected
+ * 
+ *
+ *
+ */
+EOAPI Eina_Bool  ecore_con_obj_connected_get(void);
+
+/**
+ *
+ * * Control the default time after which an inactive client will be disconnected
+ * *
+ * * This function is used by the server to set the default idle timeout on
+ * * clients. If the any of the clients becomes idle for a time higher than this
+ * * value, it will be disconnected. A value of < 1 disables the idle timeout.
+ * *
+ * * This timeout is not affected by the one set by
+ * * ecore_con_client_timeout_set(). A client will be disconnected whenever the
+ * * client or the server timeout is reached. That means, the lower timeout value
+ * * will be used for that client if ecore_con_client_timeout_set() is used on it.
+ * 
+ *
+ * @param[in] timeout The timeout, in seconds, to disconnect after.
+ *
+ */
+EOAPI void  ecore_con_obj_timeout_set(double timeout);
+
+/**
+ *
+ * * Control the default time after which an inactive client will be disconnected
+ * *
+ * * This function is used by the server to set the default idle timeout on
+ * * clients. If the any of the clients becomes idle for a time higher than this
+ * * value, it will be disconnected. A value of < 1 disables the idle timeout.
+ * *
+ * * This timeout is not affected by the one set by
+ * * ecore_con_client_timeout_set(). A client will be disconnected whenever the
+ * * client or the server timeout is reached. That means, the lower timeout value
+ * * will be used for that client if ecore_con_client_timeout_set() is used on it.
+ * 
+ *
+ *
+ */
+EOAPI double  ecore_con_obj_timeout_get(void);
+
+/**
+ *
+ * * Flushes all pending data to the given server.
+ * *
+ * * This function will block until all data is sent to the server.
+ * 
+ *
+ *
+ */
+EOAPI void  ecore_con_obj_flush(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] data The given data
+ * @param[in] size Length of the data, in bytes.
+ *
+ */
+EOAPI int  ecore_con_obj_send(const void *data, int size);
+
+/**
+ *
+ * * Do an asynchronous DNS lookup.
+ * *
+ * * @param name IP address or server name to translate.
+ * * @param done_cb Callback to notify when done.
+ * * @param data User data to be given to done_cb.
+ * * @return @c EINA_TRUE if the request did not fail to be set up, @c EINA_FALSE
+ * * if it failed.
+ * *
+ * * This function performs a DNS lookup on the hostname specified by @p name,
+ * * then calls @p done_cb with the result and the @p data given as parameter.
+ * * The result will be given to the @p done_cb as follows:
+ * * @li @c canonname - the canonical name of the address
+ * * @li @c ip - the resolved ip address
+ * * @li @c addr - a pointer to the socket address
+ * * @li @c addrlen - the length of the socket address, in bytes
+ * * @li @c data - the data pointer given as parameter to ecore_con_lookup()
+ * 
+ *
+ * @param[in] name Hostname to lookup.
+ * @param[in] done_cb The callback to be called wehn lookup is done.
+ * @param[in] data User data for the callback.
+ *
+ */
+EOAPI Eina_Bool  ecore_con_obj_lookup(const char *name, Ecore_Con_Dns_Cb done_cb, const void *data);
+
+EOAPI extern const Eo_Event_Description _ECORE_CON_BASE_EVENT_DATA_RECEIVED;
+EOAPI extern const Eo_Event_Description _ECORE_CON_BASE_EVENT_CONNECTION_UPGRADED;
+EOAPI extern const Eo_Event_Description _ECORE_CON_BASE_EVENT_CONNECTION_ERROR;
+
+/**
+ * No description
+ */
+#define ECORE_CON_BASE_EVENT_DATA_RECEIVED (&(_ECORE_CON_BASE_EVENT_DATA_RECEIVED))
+
+/**
+ * No description
+ */
+#define ECORE_CON_BASE_EVENT_CONNECTION_UPGRADED (&(_ECORE_CON_BASE_EVENT_CONNECTION_UPGRADED))
+
+/**
+ * No description
+ */
+#define ECORE_CON_BASE_EVENT_CONNECTION_ERROR (&(_ECORE_CON_BASE_EVENT_CONNECTION_ERROR))
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_base.eo.legacy.h b/src/lib/ecore_con/ecore_con_base.eo.legacy.h
--- a/src/lib/ecore_con/ecore_con_base.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_base.eo.legacy.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,50 @@
+#ifndef _ECORE_CON_BASE_EO_LEGACY_H_
+#define _ECORE_CON_BASE_EO_LEGACY_H_
+
+#ifndef _ECORE_CON_BASE_EO_CLASS_TYPE
+#define _ECORE_CON_BASE_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Base;
+
+#endif
+
+#ifndef _ECORE_CON_BASE_EO_TYPES
+#define _ECORE_CON_BASE_EO_TYPES
+
+typedef struct {
+  void *data; /** The data thet got sent. */
+  int size; /** The length of the data sent. */
+} Ecore_Con_Event_Data_Received;
+
+typedef void (*Ecore_Con_Dns_Cb)(const char *, const char *, struct sockaddr *, int, void *);
+
+
+#endif
+
+/**
+ *
+ * * Do an asynchronous DNS lookup.
+ * *
+ * * @param name IP address or server name to translate.
+ * * @param done_cb Callback to notify when done.
+ * * @param data User data to be given to done_cb.
+ * * @return @c EINA_TRUE if the request did not fail to be set up, @c EINA_FALSE
+ * * if it failed.
+ * *
+ * * This function performs a DNS lookup on the hostname specified by @p name,
+ * * then calls @p done_cb with the result and the @p data given as parameter.
+ * * The result will be given to the @p done_cb as follows:
+ * * @li @c canonname - the canonical name of the address
+ * * @li @c ip - the resolved ip address
+ * * @li @c addr - a pointer to the socket address
+ * * @li @c addrlen - the length of the socket address, in bytes
+ * * @li @c data - the data pointer given as parameter to ecore_con_lookup()
+ * 
+ *
+ * @param[in] name Hostname to lookup.
+ * @param[in] done_cb The callback to be called wehn lookup is done.
+ * @param[in] data User data for the callback.
+ */
+EAPI Eina_Bool ecore_con_lookup(const char *name, Ecore_Con_Dns_Cb done_cb, const void *data) EINA_ARG_NONNULL(2);
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_client.eo.c b/src/lib/ecore_con/ecore_con_client.eo.c
--- a/src/lib/ecore_con/ecore_con_client.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_client.eo.c	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,67 @@
+
+Ecore_Con_Server * _ecore_con_client_server_get(Eo *obj, Ecore_Con_Client_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_con_client_obj_server_get, Ecore_Con_Server *, 0);
+
+void _ecore_con_client_eo_base_destructor(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+const char * _ecore_con_client_ecore_con_base_ip_get(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+double _ecore_con_client_ecore_con_base_uptime_get(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+int _ecore_con_client_ecore_con_base_port_get(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+int _ecore_con_client_ecore_con_base_fd_get(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+Eina_Bool _ecore_con_client_ecore_con_base_connected_get(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+void _ecore_con_client_ecore_con_base_timeout_set(Eo *obj, Ecore_Con_Client_Data *pd, double timeout);
+
+
+double _ecore_con_client_ecore_con_base_timeout_get(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+void _ecore_con_client_ecore_con_base_flush(Eo *obj, Ecore_Con_Client_Data *pd);
+
+
+int _ecore_con_client_ecore_con_base_send(Eo *obj, Ecore_Con_Client_Data *pd, const void *data, int size);
+
+
+static Eo_Op_Description _ecore_con_client_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_con_client_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_ip_get, _ecore_con_client_ecore_con_base_ip_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_uptime_get, _ecore_con_client_ecore_con_base_uptime_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_port_get, _ecore_con_client_ecore_con_base_port_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_fd_get, _ecore_con_client_ecore_con_base_fd_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_connected_get, _ecore_con_client_ecore_con_base_connected_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_timeout_set, _ecore_con_client_ecore_con_base_timeout_set),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_timeout_get, _ecore_con_client_ecore_con_base_timeout_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_flush, _ecore_con_client_ecore_con_base_flush),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_send, _ecore_con_client_ecore_con_base_send),
+     EO_OP_FUNC(ecore_con_client_obj_server_get, _ecore_con_client_server_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_con_client_class_desc = {
+     EO_VERSION,
+     "Ecore_Con_Client",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_con_client_op_desc),
+     NULL,
+     sizeof(Ecore_Con_Client_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_con_client_class_get, &_ecore_con_client_class_desc, ECORE_CON_BASE_CLASS, NULL);
+EAPI Ecore_Con_Server *
+ecore_con_client_server_get(const Ecore_Con_Client *obj)
+{
+   return eo_do((Ecore_Con_Client *)obj, ecore_con_client_obj_server_get());
+}
diff -Naur a/src/lib/ecore_con/ecore_con_client.eo.h b/src/lib/ecore_con/ecore_con_client.eo.h
--- a/src/lib/ecore_con/ecore_con_client.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_client.eo.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,32 @@
+#ifndef _ECORE_CON_CLIENT_EO_H_
+#define _ECORE_CON_CLIENT_EO_H_
+
+#ifndef _ECORE_CON_CLIENT_EO_CLASS_TYPE
+#define _ECORE_CON_CLIENT_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Client;
+
+#endif
+
+#ifndef _ECORE_CON_CLIENT_EO_TYPES
+#define _ECORE_CON_CLIENT_EO_TYPES
+
+
+#endif
+#define ECORE_CON_CLIENT_CLASS ecore_con_client_class_get()
+
+const Eo_Class *ecore_con_client_class_get(void) EINA_CONST;
+
+/**
+ *
+ * * Controls the server representing the socket the client has
+ * * connected to.
+ * *
+ * 
+ *
+ *
+ */
+EOAPI Ecore_Con_Server * ecore_con_client_obj_server_get(void);
+
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_client.eo.legacy.h b/src/lib/ecore_con/ecore_con_client.eo.legacy.h
--- a/src/lib/ecore_con/ecore_con_client.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_client.eo.legacy.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,27 @@
+#ifndef _ECORE_CON_CLIENT_EO_LEGACY_H_
+#define _ECORE_CON_CLIENT_EO_LEGACY_H_
+
+#ifndef _ECORE_CON_CLIENT_EO_CLASS_TYPE
+#define _ECORE_CON_CLIENT_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Client;
+
+#endif
+
+#ifndef _ECORE_CON_CLIENT_EO_TYPES
+#define _ECORE_CON_CLIENT_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * * Controls the server representing the socket the client has
+ * * connected to.
+ * *
+ * 
+ *
+ */
+EAPI Ecore_Con_Server *ecore_con_client_server_get(const Ecore_Con_Client *obj);
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_connector.eo.c b/src/lib/ecore_con/ecore_con_connector.eo.c
--- a/src/lib/ecore_con/ecore_con_connector.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_connector.eo.c	2014-11-27 00:57:33.427045986 +0200
@@ -0,0 +1,21 @@
+
+Eo * _ecore_con_connector_eo_base_finalize(Eo *obj, void *pd);
+
+
+static Eo_Op_Description _ecore_con_connector_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_finalize, _ecore_con_connector_eo_base_finalize),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_con_connector_class_desc = {
+     EO_VERSION,
+     "Ecore_Con_Connector",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_con_connector_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_con_connector_class_get, &_ecore_con_connector_class_desc, ECORE_CON_SERVER_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/ecore_con/ecore_con_connector.eo.h b/src/lib/ecore_con/ecore_con_connector.eo.h
--- a/src/lib/ecore_con/ecore_con_connector.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_connector.eo.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,21 @@
+#ifndef _ECORE_CON_CONNECTOR_EO_H_
+#define _ECORE_CON_CONNECTOR_EO_H_
+
+#ifndef _ECORE_CON_CONNECTOR_EO_CLASS_TYPE
+#define _ECORE_CON_CONNECTOR_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Connector;
+
+#endif
+
+#ifndef _ECORE_CON_CONNECTOR_EO_TYPES
+#define _ECORE_CON_CONNECTOR_EO_TYPES
+
+
+#endif
+#define ECORE_CON_CONNECTOR_CLASS ecore_con_connector_class_get()
+
+const Eo_Class *ecore_con_connector_class_get(void) EINA_CONST;
+
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_connector.eo.legacy.h b/src/lib/ecore_con/ecore_con_connector.eo.legacy.h
--- a/src/lib/ecore_con/ecore_con_connector.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_connector.eo.legacy.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,17 @@
+#ifndef _ECORE_CON_CONNECTOR_EO_LEGACY_H_
+#define _ECORE_CON_CONNECTOR_EO_LEGACY_H_
+
+#ifndef _ECORE_CON_CONNECTOR_EO_CLASS_TYPE
+#define _ECORE_CON_CONNECTOR_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Connector;
+
+#endif
+
+#ifndef _ECORE_CON_CONNECTOR_EO_TYPES
+#define _ECORE_CON_CONNECTOR_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_server.eo.c b/src/lib/ecore_con/ecore_con_server.eo.c
--- a/src/lib/ecore_con/ecore_con_server.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_server.eo.c	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,121 @@
+
+void _ecore_con_server_name_set(Eo *obj, Ecore_Con_Server_Data *pd, const char *name);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_con_server_obj_name_set, EO_FUNC_CALL(name), const char *name);
+
+const char * _ecore_con_server_name_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_con_server_obj_name_get, const char *, 0);
+
+void _ecore_con_server_client_limit_set(Eo *obj, Ecore_Con_Server_Data *pd, int client_limit, char reject_excess_clients);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_con_server_obj_client_limit_set, EO_FUNC_CALL(client_limit, reject_excess_clients), int client_limit, char reject_excess_clients);
+
+void _ecore_con_server_client_limit_get(Eo *obj, Ecore_Con_Server_Data *pd, int *client_limit, char *reject_excess_clients);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_con_server_obj_client_limit_get, EO_FUNC_CALL(client_limit, reject_excess_clients), int *client_limit, char *reject_excess_clients);
+
+const Eina_List * _ecore_con_server_clients_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_con_server_obj_clients_get, const Eina_List *, 0);
+
+void _ecore_con_server_connection_type_set(Eo *obj, Ecore_Con_Server_Data *pd, Ecore_Con_Type conn_type);
+
+EOAPI EO_VOID_FUNC_BODYV(ecore_con_server_obj_connection_type_set, EO_FUNC_CALL(conn_type), Ecore_Con_Type conn_type);
+
+Ecore_Con_Type _ecore_con_server_connection_type_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_con_server_obj_connection_type_get, Ecore_Con_Type, 0);
+
+void _ecore_con_server_eo_base_constructor(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+void _ecore_con_server_eo_base_destructor(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+Eo * _ecore_con_server_eo_base_finalize(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+const char * _ecore_con_server_ecore_con_base_ip_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+double _ecore_con_server_ecore_con_base_uptime_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+void _ecore_con_server_ecore_con_base_port_set(Eo *obj, Ecore_Con_Server_Data *pd, int port);
+
+
+int _ecore_con_server_ecore_con_base_port_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+int _ecore_con_server_ecore_con_base_fd_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+Eina_Bool _ecore_con_server_ecore_con_base_connected_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+void _ecore_con_server_ecore_con_base_timeout_set(Eo *obj, Ecore_Con_Server_Data *pd, double timeout);
+
+
+double _ecore_con_server_ecore_con_base_timeout_get(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+void _ecore_con_server_ecore_con_base_flush(Eo *obj, Ecore_Con_Server_Data *pd);
+
+
+int _ecore_con_server_ecore_con_base_send(Eo *obj, Ecore_Con_Server_Data *pd, const void *data, int size);
+
+
+static Eo_Op_Description _ecore_con_server_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _ecore_con_server_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_con_server_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_finalize, _ecore_con_server_eo_base_finalize),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_ip_get, _ecore_con_server_ecore_con_base_ip_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_uptime_get, _ecore_con_server_ecore_con_base_uptime_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_port_set, _ecore_con_server_ecore_con_base_port_set),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_port_get, _ecore_con_server_ecore_con_base_port_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_fd_get, _ecore_con_server_ecore_con_base_fd_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_connected_get, _ecore_con_server_ecore_con_base_connected_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_timeout_set, _ecore_con_server_ecore_con_base_timeout_set),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_timeout_get, _ecore_con_server_ecore_con_base_timeout_get),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_flush, _ecore_con_server_ecore_con_base_flush),
+     EO_OP_FUNC_OVERRIDE(ecore_con_obj_send, _ecore_con_server_ecore_con_base_send),
+     EO_OP_FUNC(ecore_con_server_obj_name_set, _ecore_con_server_name_set, ""),
+     EO_OP_FUNC(ecore_con_server_obj_name_get, _ecore_con_server_name_get, ""),
+     EO_OP_FUNC(ecore_con_server_obj_client_limit_set, _ecore_con_server_client_limit_set, ""),
+     EO_OP_FUNC(ecore_con_server_obj_client_limit_get, _ecore_con_server_client_limit_get, ""),
+     EO_OP_FUNC(ecore_con_server_obj_clients_get, _ecore_con_server_clients_get, ""),
+     EO_OP_FUNC(ecore_con_server_obj_connection_type_set, _ecore_con_server_connection_type_set, ""),
+     EO_OP_FUNC(ecore_con_server_obj_connection_type_get, _ecore_con_server_connection_type_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_con_server_class_desc = {
+     EO_VERSION,
+     "Ecore_Con_Server",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_con_server_op_desc),
+     NULL,
+     sizeof(Ecore_Con_Server_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_con_server_class_get, &_ecore_con_server_class_desc, ECORE_CON_BASE_CLASS, NULL);
+EAPI const char *
+ecore_con_server_name_get(const Ecore_Con_Server *obj)
+{
+   return eo_do((Ecore_Con_Server *)obj, ecore_con_server_obj_name_get());
+}
+
+EAPI void
+ecore_con_server_client_limit_set(Ecore_Con_Server *obj, int client_limit, char reject_excess_clients)
+{
+   eo_do((Ecore_Con_Server *)obj, ecore_con_server_obj_client_limit_set(client_limit, reject_excess_clients));
+}
+
+EAPI const Eina_List *
+ecore_con_server_clients_get(const Ecore_Con_Server *obj)
+{
+   return eo_do((Ecore_Con_Server *)obj, ecore_con_server_obj_clients_get());
+}
diff -Naur a/src/lib/ecore_con/ecore_con_server.eo.h b/src/lib/ecore_con/ecore_con_server.eo.h
--- a/src/lib/ecore_con/ecore_con_server.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_server.eo.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,113 @@
+#ifndef _ECORE_CON_SERVER_EO_H_
+#define _ECORE_CON_SERVER_EO_H_
+
+#ifndef _ECORE_CON_SERVER_EO_CLASS_TYPE
+#define _ECORE_CON_SERVER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Server;
+
+#endif
+
+#ifndef _ECORE_CON_SERVER_EO_TYPES
+#define _ECORE_CON_SERVER_EO_TYPES
+
+
+#endif
+#define ECORE_CON_SERVER_CLASS ecore_con_server_class_get()
+
+const Eo_Class *ecore_con_server_class_get(void) EINA_CONST;
+
+/**
+ *
+ * * Retrieves the name of server.
+ * *
+ * * The name returned is the name used to connect on this server.
+ * 
+ *
+ * @param[in] name The name of the server.
+ *
+ */
+EOAPI void  ecore_con_server_obj_name_set(const char *name);
+
+/**
+ *
+ * * Retrieves the name of server.
+ * *
+ * * The name returned is the name used to connect on this server.
+ * 
+ *
+ *
+ */
+EOAPI const char * ecore_con_server_obj_name_get(void);
+
+/**
+ *
+ * * Sets a limit on the number of clients that can be handled concurrently
+ * * by the given server, and a policy on what to do if excess clients try to
+ * * connect.
+ * *
+ * *
+ * * Beware that if you set this once ecore is already running, you may
+ * * already have pending CLIENT_ADD events in your event queue.  Those
+ * * clients have already connected and will not be affected by this call.
+ * * Only clients subsequently trying to connect will be affected.
+ * 
+ *
+ * @param[in] client_limit The maximum number of clients to handle concurrently.  -1 means unlimited (default). 0 effectively disables the server.
+ * @param[in] reject_excess_clients Set to 1 to automatically disconnect excess clients as soon as they connect if you are already handling client_limit clients.  Set to 0 (default) to just hold off on the "accept()" system call until the number of active clients drops. This causes the kernel to queue up to 4096 connections (or your kernel's limit, whichever is lower).
+ *
+ */
+EOAPI void  ecore_con_server_obj_client_limit_set(int client_limit, char reject_excess_clients);
+
+/**
+ *
+ * * Sets a limit on the number of clients that can be handled concurrently
+ * * by the given server, and a policy on what to do if excess clients try to
+ * * connect.
+ * *
+ * *
+ * * Beware that if you set this once ecore is already running, you may
+ * * already have pending CLIENT_ADD events in your event queue.  Those
+ * * clients have already connected and will not be affected by this call.
+ * * Only clients subsequently trying to connect will be affected.
+ * 
+ *
+ * @param[out] client_limit The maximum number of clients to handle concurrently.  -1 means unlimited (default). 0 effectively disables the server.
+ * @param[out] reject_excess_clients Set to 1 to automatically disconnect excess clients as soon as they connect if you are already handling client_limit clients.  Set to 0 (default) to just hold off on the "accept()" system call until the number of active clients drops. This causes the kernel to queue up to 4096 connections (or your kernel's limit, whichever is lower).
+ *
+ */
+EOAPI void  ecore_con_server_obj_client_limit_get(int *client_limit, char *reject_excess_clients);
+
+/**
+ *
+ * * Retrieves the current list of clients.
+ * *
+ * *
+ * * Each node in the returned list points to an @ref Ecore_Con_Client. This list
+ * * cannot be modified or freed. It can also change if new clients are connected
+ * * or disconnected, and will become invalid when the server is deleted/freed.
+ * 
+ *
+ *
+ */
+EOAPI const Eina_List * ecore_con_server_obj_clients_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] conn_type No description supplied.
+ *
+ */
+EOAPI void  ecore_con_server_obj_connection_type_set(Ecore_Con_Type conn_type);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Ecore_Con_Type  ecore_con_server_obj_connection_type_get(void);
+
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_server.eo.legacy.h b/src/lib/ecore_con/ecore_con_server.eo.legacy.h
--- a/src/lib/ecore_con/ecore_con_server.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_server.eo.legacy.h	2014-11-27 00:57:33.427045986 +0200
@@ -0,0 +1,58 @@
+#ifndef _ECORE_CON_SERVER_EO_LEGACY_H_
+#define _ECORE_CON_SERVER_EO_LEGACY_H_
+
+#ifndef _ECORE_CON_SERVER_EO_CLASS_TYPE
+#define _ECORE_CON_SERVER_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Server;
+
+#endif
+
+#ifndef _ECORE_CON_SERVER_EO_TYPES
+#define _ECORE_CON_SERVER_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * * Retrieves the name of server.
+ * *
+ * * The name returned is the name used to connect on this server.
+ * 
+ *
+ */
+EAPI const char *ecore_con_server_name_get(const Ecore_Con_Server *obj);
+
+/**
+ *
+ * * Sets a limit on the number of clients that can be handled concurrently
+ * * by the given server, and a policy on what to do if excess clients try to
+ * * connect.
+ * *
+ * *
+ * * Beware that if you set this once ecore is already running, you may
+ * * already have pending CLIENT_ADD events in your event queue.  Those
+ * * clients have already connected and will not be affected by this call.
+ * * Only clients subsequently trying to connect will be affected.
+ * 
+ *
+ * @param[in] client_limit The maximum number of clients to handle concurrently.  -1 means unlimited (default). 0 effectively disables the server.
+ * @param[in] reject_excess_clients Set to 1 to automatically disconnect excess clients as soon as they connect if you are already handling client_limit clients.  Set to 0 (default) to just hold off on the "accept()" system call until the number of active clients drops. This causes the kernel to queue up to 4096 connections (or your kernel's limit, whichever is lower).
+ */
+EAPI void ecore_con_server_client_limit_set(Ecore_Con_Server *obj, int client_limit, char reject_excess_clients);
+
+/**
+ *
+ * * Retrieves the current list of clients.
+ * *
+ * *
+ * * Each node in the returned list points to an @ref Ecore_Con_Client. This list
+ * * cannot be modified or freed. It can also change if new clients are connected
+ * * or disconnected, and will become invalid when the server is deleted/freed.
+ * 
+ *
+ */
+EAPI const Eina_List *ecore_con_server_clients_get(const Ecore_Con_Server *obj);
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_url.eo.c b/src/lib/ecore_con/ecore_con_url.eo.c
--- a/src/lib/ecore_con/ecore_con_url.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_url.eo.c	2014-11-27 00:57:33.427045986 +0200
@@ -0,0 +1,50 @@
+
+Eina_Bool _ecore_con_url_url_set(Eo *obj, Ecore_Con_Url_Data *pd, const char *url);
+
+EOAPI EO_FUNC_BODYV(ecore_con_url_obj_url_set, Eina_Bool, EINA_FALSE, EO_FUNC_CALL(url), const char *url);
+
+const char * _ecore_con_url_url_get(Eo *obj, Ecore_Con_Url_Data *pd);
+
+EOAPI EO_FUNC_BODY(ecore_con_url_obj_url_get, const char *, 0);
+
+void _ecore_con_url_eo_base_constructor(Eo *obj, Ecore_Con_Url_Data *pd);
+
+
+void _ecore_con_url_eo_base_destructor(Eo *obj, Ecore_Con_Url_Data *pd);
+
+
+Eo * _ecore_con_url_eo_base_finalize(Eo *obj, Ecore_Con_Url_Data *pd);
+
+
+static Eo_Op_Description _ecore_con_url_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _ecore_con_url_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _ecore_con_url_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_finalize, _ecore_con_url_eo_base_finalize),
+     EO_OP_FUNC(ecore_con_url_obj_url_set, _ecore_con_url_url_set, ""),
+     EO_OP_FUNC(ecore_con_url_obj_url_get, _ecore_con_url_url_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _ecore_con_url_class_desc = {
+     EO_VERSION,
+     "Ecore_Con_Url",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_ecore_con_url_op_desc),
+     NULL,
+     sizeof(Ecore_Con_Url_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(ecore_con_url_class_get, &_ecore_con_url_class_desc, EO_BASE_CLASS, NULL);
+EAPI Eina_Bool
+ecore_con_url_url_set(Ecore_Con_Url *obj, const char *url)
+{
+   return eo_do((Ecore_Con_Url *)obj, ecore_con_url_obj_url_set(url));
+}
+
+EAPI const char *
+ecore_con_url_url_get(const Ecore_Con_Url *obj)
+{
+   return eo_do((Ecore_Con_Url *)obj, ecore_con_url_obj_url_get());
+}
diff -Naur a/src/lib/ecore_con/ecore_con_url.eo.h b/src/lib/ecore_con/ecore_con_url.eo.h
--- a/src/lib/ecore_con/ecore_con_url.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_url.eo.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,38 @@
+#ifndef _ECORE_CON_URL_EO_H_
+#define _ECORE_CON_URL_EO_H_
+
+#ifndef _ECORE_CON_URL_EO_CLASS_TYPE
+#define _ECORE_CON_URL_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Url;
+
+#endif
+
+#ifndef _ECORE_CON_URL_EO_TYPES
+#define _ECORE_CON_URL_EO_TYPES
+
+
+#endif
+#define ECORE_CON_URL_CLASS ecore_con_url_class_get()
+
+const Eo_Class *ecore_con_url_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] url The URL
+ *
+ */
+EOAPI Eina_Bool  ecore_con_url_obj_url_set(const char *url);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI const char * ecore_con_url_obj_url_get(void);
+
+
+#endif
diff -Naur a/src/lib/ecore_con/ecore_con_url.eo.legacy.h b/src/lib/ecore_con/ecore_con_url.eo.legacy.h
--- a/src/lib/ecore_con/ecore_con_url.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/ecore_con/ecore_con_url.eo.legacy.h	2014-11-27 00:57:33.430379381 +0200
@@ -0,0 +1,32 @@
+#ifndef _ECORE_CON_URL_EO_LEGACY_H_
+#define _ECORE_CON_URL_EO_LEGACY_H_
+
+#ifndef _ECORE_CON_URL_EO_CLASS_TYPE
+#define _ECORE_CON_URL_EO_CLASS_TYPE
+
+typedef Eo Ecore_Con_Url;
+
+#endif
+
+#ifndef _ECORE_CON_URL_EO_TYPES
+#define _ECORE_CON_URL_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] url The URL
+ */
+EAPI Eina_Bool ecore_con_url_url_set(Ecore_Con_Url *obj, const char *url);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI const char *ecore_con_url_url_get(const Ecore_Con_Url *obj);
+
+#endif
diff -Naur a/src/lib/ecore_x/ecore_x_version.h b/src/lib/ecore_x/ecore_x_version.h
--- a/src/lib/ecore_x/ecore_x_version.h	2014-11-24 13:08:40.000000000 +0200
+++ b/src/lib/ecore_x/ecore_x_version.h	2014-11-27 00:57:33.453713076 +0200
@@ -1,8 +1,8 @@
 #ifndef _ECORE_X_VERSION_H_
 #define _ECORE_X_VERSION_H_ 1
 
-#ifndef HAVE_ECORE_X_XLIB
-#define HAVE_ECORE_X_XLIB 1
+#ifndef 
+#define  1
 #endif
 
 #endif
diff -Naur a/src/lib/edje/Edje.hh b/src/lib/edje/Edje.hh
--- a/src/lib/edje/Edje.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/Edje.hh	2014-11-27 00:57:33.463713233 +0200
@@ -0,0 +1,10 @@
+#ifndef EFL_CXX_EDJE_HH
+#define EFL_CXX_EDJE_HH
+
+#ifdef EFL_BETA_API_SUPPORT
+#include <edje_object.eo.hh>
+#include <edje_edit.eo.hh>
+#endif
+
+#endif
+
diff -Naur a/src/lib/edje/edje_edit.eo.c b/src/lib/edje/edje_edit.eo.c
--- a/src/lib/edje/edje_edit.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_edit.eo.c	2014-11-27 00:57:33.470380026 +0200
@@ -0,0 +1,33 @@
+
+void _edje_edit_eo_base_constructor(Eo *obj, Edje_Edit *pd);
+
+
+void _edje_edit_eo_base_destructor(Eo *obj, Edje_Edit *pd);
+
+
+void _edje_edit_evas_object_smart_del(Eo *obj, Edje_Edit *pd);
+
+
+Eina_Bool _edje_edit_efl_file_file_set(Eo *obj, Edje_Edit *pd, const char *file, const char *key);
+
+
+static Eo_Op_Description _edje_edit_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _edje_edit_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _edje_edit_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_del, _edje_edit_evas_object_smart_del),
+     EO_OP_FUNC_OVERRIDE(efl_file_set, _edje_edit_efl_file_file_set),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _edje_edit_class_desc = {
+     EO_VERSION,
+     "Edje_Edit",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_edje_edit_op_desc),
+     NULL,
+     sizeof(Edje_Edit),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(edje_edit_class_get, &_edje_edit_class_desc, EDJE_OBJECT_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/edje/edje_edit.eo.h b/src/lib/edje/edje_edit.eo.h
--- a/src/lib/edje/edje_edit.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_edit.eo.h	2014-11-27 00:57:33.463713233 +0200
@@ -0,0 +1,21 @@
+#ifndef _EDJE_EDIT_EO_H_
+#define _EDJE_EDIT_EO_H_
+
+#ifndef _EDJE_EDIT_EO_CLASS_TYPE
+#define _EDJE_EDIT_EO_CLASS_TYPE
+
+typedef Eo Edje_Edit;
+
+#endif
+
+#ifndef _EDJE_EDIT_EO_TYPES
+#define _EDJE_EDIT_EO_TYPES
+
+
+#endif
+#define EDJE_EDIT_CLASS edje_edit_class_get()
+
+const Eo_Class *edje_edit_class_get(void) EINA_CONST;
+
+
+#endif
diff -Naur a/src/lib/edje/edje_edit.eo.hh b/src/lib/edje/edje_edit.eo.hh
--- a/src/lib/edje/edje_edit.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_edit.eo.hh	2014-11-27 00:57:33.470380026 +0200
@@ -0,0 +1,231 @@
+#ifndef EFL_GENERATED_EDJE_EDIT_HH
+#define EFL_GENERATED_EDJE_EDIT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "edje_edit.eo.h"
+}
+
+#include "edje_object.eo.hh"
+#include <string>
+
+namespace edje {
+
+struct edit
+      : edje::object
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit edit(Eo* eo)
+      : edje::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit edit(std::nullptr_t)
+      : edje::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   edit(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : edit(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   edit(edit const& other)
+      : edje::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~edit() {}
+
+   /// @brief Deletes a smart object.
+   ///
+   void del() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_del());
+   }
+
+   /// @brief Set the source file from where an image object must fetch the real
+   /// image data (it may be an Eet file, besides pure image ones).
+   ///
+   /// If the file supports multiple data stored in it (as Eet files do),
+   /// you can specify the key to be used as the index of the image in
+   /// this file.
+   ///
+   /// Example:
+   /// @code
+   /// img = evas_object_image_add(canvas);
+   /// evas_object_image_file_set(img, "/path/to/img", NULL);
+   /// err = evas_object_image_load_error_get(img);
+   /// if (err != EVAS_LOAD_ERROR_NONE)
+   /// {
+   /// fprintf(stderr, "could not load image '%s'. error string is \"%s\"\n",
+   /// valid_path, evas_load_error_str(err));
+   /// }
+   /// else
+   /// {
+   /// evas_object_image_fill_set(img, 0, 0, w, h);
+   /// evas_object_resize(img, w, h);
+   /// evas_object_show(img);
+   /// }
+   /// @endcode
+   ///
+   /// @param file The image file path.
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   bool file_set(std::string file_, std::string key_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EDJE_EDIT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EDJE_EDIT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void edje_edit_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->del();
+}
+
+template <typename T>
+bool edje_edit_file_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * file_, const char * key_)
+{
+   return static_cast<T*>(self->this_)->file_set(efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< edje::edit >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void del()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_del());
+      }
+
+      virtual bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< edje::edit >
+{
+   static const int value = 2;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<edje::edit>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::edje_edit_del_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_del);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::edje_edit_file_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_file_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< edje::edit >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<edje::edit, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< edje::edit >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<edje::edit, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< edje::edit>
+{
+   template <typename U>
+   struct type
+   {
+      operator edje::edit() const
+      {
+         return edje::edit(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void del()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_del());
+      }
+
+      bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<edje::edit>)
+{
+   return (EDJE_EDIT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EDJE_EDIT_HH
+
diff -Naur a/src/lib/edje/edje_edit.eo.legacy.h b/src/lib/edje/edje_edit.eo.legacy.h
--- a/src/lib/edje/edje_edit.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_edit.eo.legacy.h	2014-11-27 00:57:33.470380026 +0200
@@ -0,0 +1,17 @@
+#ifndef _EDJE_EDIT_EO_LEGACY_H_
+#define _EDJE_EDIT_EO_LEGACY_H_
+
+#ifndef _EDJE_EDIT_EO_CLASS_TYPE
+#define _EDJE_EDIT_EO_CLASS_TYPE
+
+typedef Eo Edje_Edit;
+
+#endif
+
+#ifndef _EDJE_EDIT_EO_TYPES
+#define _EDJE_EDIT_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/edje/edje_object.eo.c b/src/lib/edje/edje_object.eo.c
--- a/src/lib/edje/edje_object.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_object.eo.c	2014-11-27 00:57:33.463713233 +0200
@@ -0,0 +1,1620 @@
+
+void _edje_object_update_hints_set(Eo *obj, Edje *pd, Eina_Bool update);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_update_hints_set, EO_FUNC_CALL(update), Eina_Bool update);
+
+Eina_Bool _edje_object_update_hints_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_update_hints_get, Eina_Bool, 0);
+
+void _edje_object_mirrored_set(Eo *obj, Edje *pd, Eina_Bool rtl);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_mirrored_set, EO_FUNC_CALL(rtl), Eina_Bool rtl);
+
+Eina_Bool _edje_object_mirrored_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_mirrored_get, Eina_Bool, 0);
+
+void _edje_object_animation_set(Eo *obj, Edje *pd, Eina_Bool on);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_animation_set, EO_FUNC_CALL(on), Eina_Bool on);
+
+Eina_Bool _edje_object_animation_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_animation_get, Eina_Bool, 0);
+
+void _edje_object_play_set(Eo *obj, Edje *pd, Eina_Bool play);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_play_set, EO_FUNC_CALL(play), Eina_Bool play);
+
+Eina_Bool _edje_object_play_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_play_get, Eina_Bool, 0);
+
+void _edje_object_perspective_set(Eo *obj, Edje *pd, Edje_Perspective *ps);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_perspective_set, EO_FUNC_CALL(ps), Edje_Perspective *ps);
+
+const Edje_Perspective * _edje_object_perspective_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_perspective_get, const Edje_Perspective *, 0);
+
+Eina_Bool _edje_object_scale_set(Eo *obj, Edje *pd, double scale);
+
+EOAPI EO_FUNC_BODYV(edje_obj_scale_set, Eina_Bool, 0, EO_FUNC_CALL(scale), double scale);
+
+double _edje_object_scale_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_scale_get, double, 0);
+
+double _edje_object_base_scale_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_base_scale_get, double, 0);
+
+Eina_Bool _edje_object_mmap_set(Eo *obj, Edje *pd, const Eina_File *file, const char *group);
+
+EOAPI EO_FUNC_BODYV(edje_obj_mmap_set, Eina_Bool, 0, EO_FUNC_CALL(file, group), const Eina_File *file, const char *group);
+
+void _edje_object_text_change_cb_set(Eo *obj, Edje *pd, Edje_Text_Change_Cb func, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_text_change_cb_set, EO_FUNC_CALL(func, data), Edje_Text_Change_Cb func, void *data);
+
+void _edje_object_part_text_cursor_begin_set(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_cursor_begin_set, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+void _edje_object_part_text_cursor_line_end_set(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_cursor_line_end_set, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+Eina_Bool _edje_object_text_class_set(Eo *obj, Edje *pd, const char *text_class, const char *font, Evas_Font_Size size);
+
+EOAPI EO_FUNC_BODYV(edje_obj_text_class_set, Eina_Bool, 0, EO_FUNC_CALL(text_class, font, size), const char *text_class, const char *font, Evas_Font_Size size);
+
+Eina_Bool _edje_object_part_text_cursor_coord_set(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur, Evas_Coord x, Evas_Coord y);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_coord_set, Eina_Bool, 0, EO_FUNC_CALL(part, cur, x, y), const char *part, Edje_Cursor cur, Evas_Coord x, Evas_Coord y);
+
+void _edje_object_part_text_cursor_end_set(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_cursor_end_set, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+Eina_Bool _edje_object_part_text_escaped_set(Eo *obj, Edje *pd, const char *part, const char *text);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_escaped_set, Eina_Bool, 0, EO_FUNC_CALL(part, text), const char *part, const char *text);
+
+void _edje_object_item_provider_set(Eo *obj, Edje *pd, Edje_Item_Provider_Cb func, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_item_provider_set, EO_FUNC_CALL(func, data), Edje_Item_Provider_Cb func, void *data);
+
+void _edje_object_part_text_cursor_line_begin_set(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_cursor_line_begin_set, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+void _edje_object_message_handler_set(Eo *obj, Edje *pd, Edje_Message_Handler_Cb func, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_message_handler_set, EO_FUNC_CALL(func, data), Edje_Message_Handler_Cb func, void *data);
+
+void _edje_object_size_min_get(Eo *obj, Edje *pd, Evas_Coord *minw, Evas_Coord *minh);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_size_min_get, EO_FUNC_CALL(minw, minh), Evas_Coord *minw, Evas_Coord *minh);
+
+Eina_List * _edje_object_access_part_list_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_access_part_list_get, Eina_List *, 0);
+
+Edje_Load_Error _edje_object_load_error_get(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_load_error_get, Edje_Load_Error, 0);
+
+void _edje_object_size_max_get(Eo *obj, Edje *pd, Evas_Coord *maxw, Evas_Coord *maxh);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_size_max_get, EO_FUNC_CALL(maxw, maxh), Evas_Coord *maxw, Evas_Coord *maxh);
+
+Eina_Bool _edje_object_part_table_clear(Eo *obj, Edje *pd, const char *part, Eina_Bool clear);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_table_clear, Eina_Bool, 0, EO_FUNC_CALL(part, clear), const char *part, Eina_Bool clear);
+
+Edje_External_Param_Type _edje_object_part_external_param_type_get(Eo *obj, Edje *pd, const char *part, const char *param);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_external_param_type_get, Edje_External_Param_Type, 0, EO_FUNC_CALL(part, param), const char *part, const char *param);
+
+void _edje_object_part_text_select_allow_set(Eo *obj, Edje *pd, const char *part, Eina_Bool allow);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_select_allow_set, EO_FUNC_CALL(part, allow), const char *part, Eina_Bool allow);
+
+const char * _edje_object_part_state_get(Eo *obj, Edje *pd, const char *part, double *val_ret);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_state_get, const char *, 0, EO_FUNC_CALL(part, val_ret), const char *part, double *val_ret);
+
+void * _edje_object_text_markup_filter_callback_del_full(Eo *obj, Edje *pd, const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+EOAPI EO_FUNC_BODYV(edje_obj_text_markup_filter_callback_del_full, void *, 0, EO_FUNC_CALL(part, func, data), const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+Eina_Bool _edje_object_part_drag_step_set(Eo *obj, Edje *pd, const char *part, double dx, double dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_step_set, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double dx, double dy);
+
+Eina_Bool _edje_object_part_drag_step_get(Eo *obj, Edje *pd, const char *part, double *dx, double *dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_step_get, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double *dx, double *dy);
+
+void * _edje_object_part_text_imf_context_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_imf_context_get, void *, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_select_begin(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_select_begin, EO_FUNC_CALL(part), const char *part);
+
+const char * _edje_object_part_text_style_user_peek(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_style_user_peek, const char *, 0, EO_FUNC_CALL(part), const char *part);
+
+void * _edje_object_signal_callback_del(Eo *obj, Edje *pd, const char *emission, const char *source, Edje_Signal_Cb func, void *data);
+
+EOAPI EO_FUNC_BODYV(edje_obj_signal_callback_del, void *, 0, EO_FUNC_CALL(emission, source, func, data), const char *emission, const char *source, Edje_Signal_Cb func, void *data);
+
+Eina_Bool _edje_object_part_text_cursor_next(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_next, Eina_Bool, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+void _edje_object_part_text_style_user_push(Eo *obj, Edje *pd, const char *part, const char *style);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_style_user_push, EO_FUNC_CALL(part, style), const char *part, const char *style);
+
+void _edje_object_part_text_append(Eo *obj, Edje *pd, const char *part, const char *text);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_append, EO_FUNC_CALL(part, text), const char *part, const char *text);
+
+Eina_Bool _edje_object_part_geometry_get(Eo *obj, Edje *pd, const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_geometry_get, Eina_Bool, 0, EO_FUNC_CALL(part, x, y, w, h), const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+void _edje_object_part_text_input_panel_hide(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_hide, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_text_item_geometry_get(Eo *obj, Edje *pd, const char *part, const char *item, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_item_geometry_get, Eina_Bool, 0, EO_FUNC_CALL(part, item, cx, cy, cw, ch), const char *part, const char *item, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+Eina_Bool _edje_object_part_table_unpack(Eo *obj, Edje *pd, const char *part, Evas_Object *child_obj);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_table_unpack, Eina_Bool, 0, EO_FUNC_CALL(part, child_obj), const char *part, Evas_Object *child_obj);
+
+void _edje_object_part_text_select_abort(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_select_abort, EO_FUNC_CALL(part), const char *part);
+
+void * _edje_object_text_insert_filter_callback_del_full(Eo *obj, Edje *pd, const char *part, Edje_Text_Filter_Cb func, void *data);
+
+EOAPI EO_FUNC_BODYV(edje_obj_text_insert_filter_callback_del_full, void *, 0, EO_FUNC_CALL(part, func, data), const char *part, Edje_Text_Filter_Cb func, void *data);
+
+void _edje_object_part_text_style_user_pop(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_style_user_pop, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_input_panel_imdata_set(Eo *obj, Edje *pd, const char *part, const void *data, int len);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_imdata_set, EO_FUNC_CALL(part, data, len), const char *part, const void *data, int len);
+
+void _edje_object_part_text_input_panel_imdata_get(Eo *obj, Edje *pd, const char *part, void *data, int *len);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_imdata_get, EO_FUNC_CALL(part, data, len), const char *part, void *data, int *len);
+
+void _edje_object_part_text_insert(Eo *obj, Edje *pd, const char *part, const char *text);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_insert, EO_FUNC_CALL(part, text), const char *part, const char *text);
+
+Evas_Object * _edje_object_part_box_remove_at(Eo *obj, Edje *pd, const char *part, unsigned int pos);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_box_remove_at, Evas_Object *, 0, EO_FUNC_CALL(part, pos), const char *part, unsigned int pos);
+
+void _edje_object_part_text_cursor_copy(Eo *obj, Edje *pd, const char *part, Edje_Cursor src, Edje_Cursor dst);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_cursor_copy, EO_FUNC_CALL(part, src, dst), const char *part, Edje_Cursor src, Edje_Cursor dst);
+
+Eina_Bool _edje_object_parts_extends_calc(Eo *obj, Edje *pd, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_FUNC_BODYV(edje_obj_parts_extends_calc, Eina_Bool, 0, EO_FUNC_CALL(x, y, w, h), Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+Eina_Bool _edje_object_part_drag_value_set(Eo *obj, Edje *pd, const char *part, double dx, double dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_value_set, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double dx, double dy);
+
+Eina_Bool _edje_object_part_drag_value_get(Eo *obj, Edje *pd, const char *part, double *dx, double *dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_value_get, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double *dx, double *dy);
+
+void _edje_object_calc_force(Eo *obj, Edje *pd);
+
+EOAPI EO_VOID_FUNC_BODY(edje_obj_calc_force);
+
+void _edje_object_part_text_cursor_pos_set(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur, int pos);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_cursor_pos_set, EO_FUNC_CALL(part, cur, pos), const char *part, Edje_Cursor cur, int pos);
+
+int _edje_object_part_text_cursor_pos_get(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_pos_get, int, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+int _edje_object_freeze(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_freeze, int, 0);
+
+char * _edje_object_part_text_cursor_content_get(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_content_get, char *, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+void _edje_object_part_text_input_panel_layout_set(Eo *obj, Edje *pd, const char *part, Edje_Input_Panel_Layout layout);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_layout_set, EO_FUNC_CALL(part, layout), const char *part, Edje_Input_Panel_Layout layout);
+
+Edje_Input_Panel_Layout _edje_object_part_text_input_panel_layout_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_panel_layout_get, Edje_Input_Panel_Layout, 0, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_table_pack(Eo *obj, Edje *pd, const char *part, Evas_Object *child_obj, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_table_pack, Eina_Bool, 0, EO_FUNC_CALL(part, child_obj, col, row, colspan, rowspan), const char *part, Evas_Object *child_obj, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan);
+
+void _edje_object_part_text_input_panel_language_set(Eo *obj, Edje *pd, const char *part, Edje_Input_Panel_Lang lang);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_language_set, EO_FUNC_CALL(part, lang), const char *part, Edje_Input_Panel_Lang lang);
+
+Edje_Input_Panel_Lang _edje_object_part_text_input_panel_language_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_panel_language_get, Edje_Input_Panel_Lang, 0, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_table_col_row_size_get(Eo *obj, Edje *pd, const char *part, int *cols, int *rows);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_table_col_row_size_get, Eina_Bool, 0, EO_FUNC_CALL(part, cols, rows), const char *part, int *cols, int *rows);
+
+Evas_Object * _edje_object_part_external_object_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_external_object_get, Evas_Object *, 0, EO_FUNC_CALL(part), const char *part);
+
+Evas_Object * _edje_object_part_external_content_get(Eo *obj, Edje *pd, const char *part, const char *content);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_external_content_get, Evas_Object *, 0, EO_FUNC_CALL(part, content), const char *part, const char *content);
+
+Eina_Bool _edje_object_preload(Eo *obj, Edje *pd, Eina_Bool cancel);
+
+EOAPI EO_FUNC_BODYV(edje_obj_preload, Eina_Bool, 0, EO_FUNC_CALL(cancel), Eina_Bool cancel);
+
+void _edje_object_part_text_input_panel_enabled_set(Eo *obj, Edje *pd, const char *part, Eina_Bool enabled);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_enabled_set, EO_FUNC_CALL(part, enabled), const char *part, Eina_Bool enabled);
+
+Eina_Bool _edje_object_part_text_input_panel_enabled_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_panel_enabled_get, Eina_Bool, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_select_extend(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_select_extend, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_box_insert_at(Eo *obj, Edje *pd, const char *part, Evas_Object *child, unsigned int pos);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_box_insert_at, Eina_Bool, 0, EO_FUNC_CALL(part, child, pos), const char *part, Evas_Object *child, unsigned int pos);
+
+const Eina_List * _edje_object_part_text_anchor_geometry_get(Eo *obj, Edje *pd, const char *part, const char *anchor);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_anchor_geometry_get, const Eina_List *, 0, EO_FUNC_CALL(part, anchor), const char *part, const char *anchor);
+
+Eina_Bool _edje_object_part_text_cursor_down(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_down, Eina_Bool, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+Eina_Bool _edje_object_part_drag_page_set(Eo *obj, Edje *pd, const char *part, double dx, double dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_page_set, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double dx, double dy);
+
+Eina_Bool _edje_object_part_drag_page_get(Eo *obj, Edje *pd, const char *part, double *dx, double *dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_page_get, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double *dx, double *dy);
+
+Eina_Bool _edje_object_part_box_prepend(Eo *obj, Edje *pd, const char *part, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_box_prepend, Eina_Bool, 0, EO_FUNC_CALL(part, child), const char *part, Evas_Object *child);
+
+void _edje_object_signal_emit(Eo *obj, Edje *pd, const char *emission, const char *source);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_signal_emit, EO_FUNC_CALL(emission, source), const char *emission, const char *source);
+
+void _edje_object_part_text_input_panel_layout_variation_set(Eo *obj, Edje *pd, const char *part, int variation);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_layout_variation_set, EO_FUNC_CALL(part, variation), const char *part, int variation);
+
+int _edje_object_part_text_input_panel_layout_variation_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_panel_layout_variation_get, int, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_message_send(Eo *obj, Edje *pd, Edje_Message_Type type, int id, void *msg);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_message_send, EO_FUNC_CALL(type, id, msg), Edje_Message_Type type, int id, void *msg);
+
+void _edje_object_part_text_select_none(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_select_none, EO_FUNC_CALL(part), const char *part);
+
+const Evas_Object * _edje_object_part_object_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_object_get, const Evas_Object *, 0, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_drag_size_set(Eo *obj, Edje *pd, const char *part, double dw, double dh);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_size_set, Eina_Bool, 0, EO_FUNC_CALL(part, dw, dh), const char *part, double dw, double dh);
+
+Eina_Bool _edje_object_part_drag_size_get(Eo *obj, Edje *pd, const char *part, double *dw, double *dh);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_size_get, Eina_Bool, 0, EO_FUNC_CALL(part, dw, dh), const char *part, double *dw, double *dh);
+
+void * _edje_object_text_insert_filter_callback_del(Eo *obj, Edje *pd, const char *part, Edje_Text_Filter_Cb func);
+
+EOAPI EO_FUNC_BODYV(edje_obj_text_insert_filter_callback_del, void *, 0, EO_FUNC_CALL(part, func), const char *part, Edje_Text_Filter_Cb func);
+
+Edje_Drag_Dir _edje_object_part_drag_dir_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_dir_get, Edje_Drag_Dir, 0, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_text_unescaped_set(Eo *obj, Edje *pd, const char *part, const char *text_to_escape);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_unescaped_set, Eina_Bool, 0, EO_FUNC_CALL(part, text_to_escape), const char *part, const char *text_to_escape);
+
+char * _edje_object_part_text_unescaped_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_unescaped_get, char *, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_signal_callback_add(Eo *obj, Edje *pd, const char *emission, const char *source, Edje_Signal_Cb func, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_signal_callback_add, EO_FUNC_CALL(emission, source, func, data), const char *emission, const char *source, Edje_Signal_Cb func, void *data);
+
+void _edje_object_part_text_select_all(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_select_all, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_input_panel_return_key_disabled_set(Eo *obj, Edje *pd, const char *part, Eina_Bool disabled);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_return_key_disabled_set, EO_FUNC_CALL(part, disabled), const char *part, Eina_Bool disabled);
+
+Eina_Bool _edje_object_part_text_input_panel_return_key_disabled_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_panel_return_key_disabled_get, Eina_Bool, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_autocapital_type_set(Eo *obj, Edje *pd, const char *part, Edje_Text_Autocapital_Type autocapital_type);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_autocapital_type_set, EO_FUNC_CALL(part, autocapital_type), const char *part, Edje_Text_Autocapital_Type autocapital_type);
+
+Edje_Text_Autocapital_Type _edje_object_part_text_autocapital_type_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_autocapital_type_get, Edje_Text_Autocapital_Type, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_unswallow(Eo *obj, Edje *pd, Evas_Object *obj_swallow);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_unswallow, EO_FUNC_CALL(obj_swallow), Evas_Object *obj_swallow);
+
+void _edje_object_part_text_prediction_allow_set(Eo *obj, Edje *pd, const char *part, Eina_Bool prediction);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_prediction_allow_set, EO_FUNC_CALL(part, prediction), const char *part, Eina_Bool prediction);
+
+Eina_Bool _edje_object_part_text_prediction_allow_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_prediction_allow_get, Eina_Bool, 0, EO_FUNC_CALL(part), const char *part);
+
+const char * _edje_object_data_get(Eo *obj, Edje *pd, const char *key);
+
+EOAPI EO_FUNC_BODYV(edje_obj_data_get, const char *, 0, EO_FUNC_CALL(key), const char *key);
+
+void _edje_object_text_markup_filter_callback_add(Eo *obj, Edje *pd, const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_text_markup_filter_callback_add, EO_FUNC_CALL(part, func, data), const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+void _edje_object_message_signal_process(Eo *obj, Edje *pd);
+
+EOAPI EO_VOID_FUNC_BODY(edje_obj_message_signal_process);
+
+Evas_Object * _edje_object_part_box_remove(Eo *obj, Edje *pd, const char *part, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_box_remove, Evas_Object *, 0, EO_FUNC_CALL(part, child), const char *part, Evas_Object *child);
+
+int _edje_object_thaw(Eo *obj, Edje *pd);
+
+EOAPI EO_FUNC_BODY(edje_obj_thaw, int, 0);
+
+Evas_Object * _edje_object_part_swallow_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_swallow_get, Evas_Object *, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_imf_context_reset(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_imf_context_reset, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_input_panel_return_key_type_set(Eo *obj, Edje *pd, const char *part, Edje_Input_Panel_Return_Key_Type return_key_type);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_return_key_type_set, EO_FUNC_CALL(part, return_key_type), const char *part, Edje_Input_Panel_Return_Key_Type return_key_type);
+
+Edje_Input_Panel_Return_Key_Type _edje_object_part_text_input_panel_return_key_type_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_panel_return_key_type_get, Edje_Input_Panel_Return_Key_Type, 0, EO_FUNC_CALL(part), const char *part);
+
+Evas_Object * _edje_object_part_table_child_get(Eo *obj, Edje *pd, const char *part, unsigned int col, unsigned int row);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_table_child_get, Evas_Object *, 0, EO_FUNC_CALL(part, col, row), const char *part, unsigned int col, unsigned int row);
+
+Eina_Bool _edje_object_part_box_insert_before(Eo *obj, Edje *pd, const char *part, Evas_Object *child, const Evas_Object *reference);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_box_insert_before, Eina_Bool, 0, EO_FUNC_CALL(part, child, reference), const char *part, Evas_Object *child, const Evas_Object *reference);
+
+Eina_Bool _edje_object_part_external_param_set(Eo *obj, Edje *pd, const char *part, const Edje_External_Param *param);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_external_param_set, Eina_Bool, 0, EO_FUNC_CALL(part, param), const char *part, const Edje_External_Param *param);
+
+Eina_Bool _edje_object_part_external_param_get(Eo *obj, Edje *pd, const char *part, Edje_External_Param *param);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_external_param_get, Eina_Bool, 0, EO_FUNC_CALL(part, param), const char *part, Edje_External_Param *param);
+
+void _edje_object_size_min_calc(Eo *obj, Edje *pd, Evas_Coord *minw, Evas_Coord *minh);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_size_min_calc, EO_FUNC_CALL(minw, minh), Evas_Coord *minw, Evas_Coord *minh);
+
+Eina_Bool _edje_object_part_box_append(Eo *obj, Edje *pd, const char *part, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_box_append, Eina_Bool, 0, EO_FUNC_CALL(part, child), const char *part, Evas_Object *child);
+
+void _edje_object_size_min_restricted_calc(Eo *obj, Edje *pd, Evas_Coord *minw, Evas_Coord *minh, Evas_Coord restrictedw, Evas_Coord restrictedh);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_size_min_restricted_calc, EO_FUNC_CALL(minw, minh, restrictedw, restrictedh), Evas_Coord *minw, Evas_Coord *minh, Evas_Coord restrictedw, Evas_Coord restrictedh);
+
+Eina_Bool _edje_object_part_box_remove_all(Eo *obj, Edje *pd, const char *part, Eina_Bool clear);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_box_remove_all, Eina_Bool, 0, EO_FUNC_CALL(part, clear), const char *part, Eina_Bool clear);
+
+Eina_Bool _edje_object_part_drag_page(Eo *obj, Edje *pd, const char *part, double dx, double dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_page, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double dx, double dy);
+
+Eina_Bool _edje_object_part_text_set(Eo *obj, Edje *pd, const char *part, const char *text);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_set, Eina_Bool, 0, EO_FUNC_CALL(part, text), const char *part, const char *text);
+
+const char * _edje_object_part_text_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_get, const char *, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_input_panel_show_on_demand_set(Eo *obj, Edje *pd, const char *part, Eina_Bool ondemand);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_show_on_demand_set, EO_FUNC_CALL(part, ondemand), const char *part, Eina_Bool ondemand);
+
+Eina_Bool _edje_object_part_text_input_panel_show_on_demand_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_panel_show_on_demand_get, Eina_Bool, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_part_text_input_hint_set(Eo *obj, Edje *pd, const char *part, Edje_Input_Hints input_hints);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_hint_set, EO_FUNC_CALL(part, input_hints), const char *part, Edje_Input_Hints input_hints);
+
+Edje_Input_Hints _edje_object_part_text_input_hint_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_input_hint_get, Edje_Input_Hints, 0, EO_FUNC_CALL(part), const char *part);
+
+const char * _edje_object_part_text_selection_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_selection_get, const char *, 0, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_text_cursor_is_format_get(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_is_format_get, Eina_Bool, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+Eina_Bool _edje_object_color_class_set(Eo *obj, Edje *pd, const char *color_class, int r, int g, int b, int a, int r2, int g2, int b2, int a2, int r3, int g3, int b3, int a3);
+
+EOAPI EO_FUNC_BODYV(edje_obj_color_class_set, Eina_Bool, 0, EO_FUNC_CALL(color_class, r, g, b, a, r2, g2, b2, a2, r3, g3, b3, a3), const char *color_class, int r, int g, int b, int a, int r2, int g2, int b2, int a2, int r3, int g3, int b3, int a3);
+
+Eina_Bool _edje_object_color_class_get(Eo *obj, Edje *pd, const char *color_class, int *r, int *g, int *b, int *a, int *r2, int *g2, int *b2, int *a2, int *r3, int *g3, int *b3, int *a3);
+
+EOAPI EO_FUNC_BODYV(edje_obj_color_class_get, Eina_Bool, 0, EO_FUNC_CALL(color_class, r, g, b, a, r2, g2, b2, a2, r3, g3, b3, a3), const char *color_class, int *r, int *g, int *b, int *a, int *r2, int *g2, int *b2, int *a2, int *r3, int *g3, int *b3, int *a3);
+
+Eina_Bool _edje_object_part_drag_step(Eo *obj, Edje *pd, const char *part, double dx, double dy);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_drag_step, Eina_Bool, 0, EO_FUNC_CALL(part, dx, dy), const char *part, double dx, double dy);
+
+Eina_Bool _edje_object_part_text_cursor_up(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_up, Eina_Bool, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+void _edje_object_part_text_cursor_geometry_get(Eo *obj, Edje *pd, const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_cursor_geometry_get, EO_FUNC_CALL(part, x, y, w, h), const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+const Eina_List * _edje_object_part_text_anchor_list_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_anchor_list_get, const Eina_List *, 0, EO_FUNC_CALL(part), const char *part);
+
+void _edje_object_text_insert_filter_callback_add(Eo *obj, Edje *pd, const char *part, Edje_Text_Filter_Cb func, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_text_insert_filter_callback_add, EO_FUNC_CALL(part, func, data), const char *part, Edje_Text_Filter_Cb func, void *data);
+
+void _edje_object_part_text_input_panel_show(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_input_panel_show, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_exists(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_exists, Eina_Bool, 0, EO_FUNC_CALL(part), const char *part);
+
+void * _edje_object_text_markup_filter_callback_del(Eo *obj, Edje *pd, const char *part, Edje_Markup_Filter_Cb func);
+
+EOAPI EO_FUNC_BODYV(edje_obj_text_markup_filter_callback_del, void *, 0, EO_FUNC_CALL(part, func), const char *part, Edje_Markup_Filter_Cb func);
+
+Eina_Bool _edje_object_part_text_cursor_is_visible_format_get(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_is_visible_format_get, Eina_Bool, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+void _edje_object_part_text_user_insert(Eo *obj, Edje *pd, const char *part, const char *text);
+
+EOAPI EO_VOID_FUNC_BODYV(edje_obj_part_text_user_insert, EO_FUNC_CALL(part, text), const char *part, const char *text);
+
+Eina_Bool _edje_object_part_text_cursor_prev(Eo *obj, Edje *pd, const char *part, Edje_Cursor cur);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_cursor_prev, Eina_Bool, 0, EO_FUNC_CALL(part, cur), const char *part, Edje_Cursor cur);
+
+const Eina_List * _edje_object_part_text_item_list_get(Eo *obj, Edje *pd, const char *part);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_text_item_list_get, const Eina_List *, 0, EO_FUNC_CALL(part), const char *part);
+
+Eina_Bool _edje_object_part_swallow(Eo *obj, Edje *pd, const char *part, Evas_Object *obj_swallow);
+
+EOAPI EO_FUNC_BODYV(edje_obj_part_swallow, Eina_Bool, 0, EO_FUNC_CALL(part, obj_swallow), const char *part, Evas_Object *obj_swallow);
+
+void _edje_object_eo_base_constructor(Eo *obj, Edje *pd);
+
+
+void _edje_object_eo_base_destructor(Eo *obj, Edje *pd);
+
+
+void _edje_object_eo_base_dbg_info_get(Eo *obj, Edje *pd, Eo_Dbg_Info *root_node);
+
+
+void _edje_object_evas_object_smart_hide(Eo *obj, Edje *pd);
+
+
+void _edje_object_evas_object_smart_calculate(Eo *obj, Edje *pd);
+
+
+void _edje_object_evas_object_smart_show(Eo *obj, Edje *pd);
+
+
+void _edje_object_evas_object_smart_move(Eo *obj, Edje *pd, Evas_Coord x, Evas_Coord y);
+
+
+void _edje_object_evas_object_smart_add(Eo *obj, Edje *pd);
+
+
+void _edje_object_evas_object_smart_del(Eo *obj, Edje *pd);
+
+
+void _edje_object_evas_object_smart_resize(Eo *obj, Edje *pd, Evas_Coord w, Evas_Coord h);
+
+
+Eina_Bool _edje_object_efl_file_file_set(Eo *obj, Edje *pd, const char *file, const char *key);
+
+
+void _edje_object_efl_file_file_get(Eo *obj, Edje *pd, const char **file, const char **key);
+
+
+static Eo_Op_Description _edje_object_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _edje_object_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _edje_object_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_dbg_info_get, _edje_object_eo_base_dbg_info_get),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_hide, _edje_object_evas_object_smart_hide),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_calculate, _edje_object_evas_object_smart_calculate),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_show, _edje_object_evas_object_smart_show),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_move, _edje_object_evas_object_smart_move),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_add, _edje_object_evas_object_smart_add),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_del, _edje_object_evas_object_smart_del),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_resize, _edje_object_evas_object_smart_resize),
+     EO_OP_FUNC_OVERRIDE(efl_file_set, _edje_object_efl_file_file_set),
+     EO_OP_FUNC_OVERRIDE(efl_file_get, _edje_object_efl_file_file_get),
+     EO_OP_FUNC(edje_obj_update_hints_set, _edje_object_update_hints_set, "@brief Edje will automatically update the size hints on itself."),
+     EO_OP_FUNC(edje_obj_update_hints_get, _edje_object_update_hints_get, "@brief Whether or not Edje will update size hints on itself."),
+     EO_OP_FUNC(edje_obj_mirrored_set, _edje_object_mirrored_set, "@brief Set the RTL orientation for this object."),
+     EO_OP_FUNC(edje_obj_mirrored_get, _edje_object_mirrored_get, "@brief Get the RTL orientation for this object."),
+     EO_OP_FUNC(edje_obj_animation_set, _edje_object_animation_set, "@brief Set the object's animation state."),
+     EO_OP_FUNC(edje_obj_animation_get, _edje_object_animation_get, "@brief Get the Edje object's animation state."),
+     EO_OP_FUNC(edje_obj_play_set, _edje_object_play_set, "@brief Set the Edje object to playing or paused states."),
+     EO_OP_FUNC(edje_obj_play_get, _edje_object_play_get, "@brief Get the Edje object's state."),
+     EO_OP_FUNC(edje_obj_perspective_set, _edje_object_perspective_set, "Set the given perspective object on this Edje object."),
+     EO_OP_FUNC(edje_obj_perspective_get, _edje_object_perspective_get, "Get the current perspective used on this Edje object."),
+     EO_OP_FUNC(edje_obj_scale_set, _edje_object_scale_set, "@brief Set the scaling factor for a given Edje object."),
+     EO_OP_FUNC(edje_obj_scale_get, _edje_object_scale_get, "@brief Get a given Edje object's scaling factor."),
+     EO_OP_FUNC(edje_obj_base_scale_get, _edje_object_base_scale_get, "@brief Get a given Edje object's base_scale factor."),
+     EO_OP_FUNC(edje_obj_mmap_set, _edje_object_mmap_set, "@brief Sets the @b EDJ file (and group within it) to load an Edje"),
+     EO_OP_FUNC(edje_obj_text_change_cb_set, _edje_object_text_change_cb_set, "@brief Set the object text callback."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_begin_set, _edje_object_part_text_cursor_begin_set, "@brief Moves the cursor to the beginning of the text part"),
+     EO_OP_FUNC(edje_obj_part_text_cursor_line_end_set, _edje_object_part_text_cursor_line_end_set, "@brief Move the cursor to the end of the line."),
+     EO_OP_FUNC(edje_obj_text_class_set, _edje_object_text_class_set, "@brief Sets Edje text class."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_coord_set, _edje_object_part_text_cursor_coord_set, "Position the given cursor to a X,Y position."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_end_set, _edje_object_part_text_cursor_end_set, "@brief Moves the cursor to the end of the text part."),
+     EO_OP_FUNC(edje_obj_part_text_escaped_set, _edje_object_part_text_escaped_set, "@brief Sets the text for an object part, but converts HTML escapes to UTF8"),
+     EO_OP_FUNC(edje_obj_item_provider_set, _edje_object_item_provider_set, "@brief Set the function that provides item objects for named items in an edje entry text"),
+     EO_OP_FUNC(edje_obj_part_text_cursor_line_begin_set, _edje_object_part_text_cursor_line_begin_set, "@brief Move the cursor to the beginning of the line."),
+     EO_OP_FUNC(edje_obj_message_handler_set, _edje_object_message_handler_set, "@brief Set an Edje message handler function for a given Edje object."),
+     EO_OP_FUNC(edje_obj_size_min_get, _edje_object_size_min_get, "@brief Get the minimum size specified -- as an EDC property -- for a"),
+     EO_OP_FUNC(edje_obj_access_part_list_get, _edje_object_access_part_list_get, "@brief Retrieve a list all accessibility part names"),
+     EO_OP_FUNC(edje_obj_load_error_get, _edje_object_load_error_get, "@brief Gets the (last) file loading error for a given Edje object"),
+     EO_OP_FUNC(edje_obj_size_max_get, _edje_object_size_max_get, "@brief Get the maximum size specified -- as an EDC property -- for a"),
+     EO_OP_FUNC(edje_obj_part_table_clear, _edje_object_part_table_clear, "@brief Removes all object from the table."),
+     EO_OP_FUNC(edje_obj_part_external_param_type_get, _edje_object_part_external_param_type_get, "Facility to query the type of the given parameter of the given part."),
+     EO_OP_FUNC(edje_obj_part_text_select_allow_set, _edje_object_part_text_select_allow_set, "@brief Enables selection if the entry is an EXPLICIT selection mode"),
+     EO_OP_FUNC(edje_obj_part_state_get, _edje_object_part_state_get, "@brief Returns the state of the Edje part."),
+     EO_OP_FUNC(edje_obj_text_markup_filter_callback_del_full, _edje_object_text_markup_filter_callback_del_full, "Delete a function and matching user data from the markup filter list."),
+     EO_OP_FUNC(edje_obj_part_drag_step_set, _edje_object_part_drag_step_set, "@brief Sets the drag step increment."),
+     EO_OP_FUNC(edje_obj_part_drag_step_get, _edje_object_part_drag_step_get, "@brief Gets the drag step increment values."),
+     EO_OP_FUNC(edje_obj_part_text_imf_context_get, _edje_object_part_text_imf_context_get, "@brief Get the input method context in entry."),
+     EO_OP_FUNC(edje_obj_part_text_select_begin, _edje_object_part_text_select_begin, "@brief Starts selecting at current cursor position"),
+     EO_OP_FUNC(edje_obj_part_text_style_user_peek, _edje_object_part_text_style_user_peek, "@brief Return the text of the object part."),
+     EO_OP_FUNC(edje_obj_signal_callback_del, _edje_object_signal_callback_del, "@brief Remove a signal-triggered callback from an object."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_next, _edje_object_part_text_cursor_next, "@brief Advances the cursor to the next cursor position."),
+     EO_OP_FUNC(edje_obj_part_text_style_user_push, _edje_object_part_text_style_user_push, "@brief Set the style of the"),
+     EO_OP_FUNC(edje_obj_part_text_append, _edje_object_part_text_append, "@brief Insert text for an object part."),
+     EO_OP_FUNC(edje_obj_part_geometry_get, _edje_object_part_geometry_get, "@brief Retrieve the geometry of a given Edje part, in a given Edje"),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_hide, _edje_object_part_text_input_panel_hide, "@brief Hide the input panel (virtual keyboard)."),
+     EO_OP_FUNC(edje_obj_part_text_item_geometry_get, _edje_object_part_text_item_geometry_get, "@brief Return item geometry."),
+     EO_OP_FUNC(edje_obj_part_table_unpack, _edje_object_part_table_unpack, "@brief Removes an object from the table."),
+     EO_OP_FUNC(edje_obj_part_text_select_abort, _edje_object_part_text_select_abort, "@brief Aborts any selection action on a part."),
+     EO_OP_FUNC(edje_obj_text_insert_filter_callback_del_full, _edje_object_text_insert_filter_callback_del_full, "Delete a function and matching user data from the filter list."),
+     EO_OP_FUNC(edje_obj_part_text_style_user_pop, _edje_object_part_text_style_user_pop, "@brief Delete the top style form the user style stack."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_imdata_set, _edje_object_part_text_input_panel_imdata_set, "Set the input panel-specific data to deliver to the input panel."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_imdata_get, _edje_object_part_text_input_panel_imdata_get, "Get the specific data of the current active input panel."),
+     EO_OP_FUNC(edje_obj_part_text_insert, _edje_object_part_text_insert, "@brief Insert text for an object part."),
+     EO_OP_FUNC(edje_obj_part_box_remove_at, _edje_object_part_box_remove_at, "@brief Removes an object from the box."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_copy, _edje_object_part_text_cursor_copy, "@brief Copy the cursor to another cursor."),
+     EO_OP_FUNC(edje_obj_parts_extends_calc, _edje_object_parts_extends_calc, "Calculate the geometry of the region, relative to a given Edje"),
+     EO_OP_FUNC(edje_obj_part_drag_value_set, _edje_object_part_drag_value_set, "@brief Set the dragable object location."),
+     EO_OP_FUNC(edje_obj_part_drag_value_get, _edje_object_part_drag_value_get, "@brief Get the dragable object location."),
+     EO_OP_FUNC(edje_obj_calc_force, _edje_object_calc_force, "@brief Force a Size/Geometry calculation."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_pos_set, _edje_object_part_text_cursor_pos_set, "@brief Sets the cursor position to the given value"),
+     EO_OP_FUNC(edje_obj_part_text_cursor_pos_get, _edje_object_part_text_cursor_pos_get, "@brief Retrieves the current position of the cursor"),
+     EO_OP_FUNC(edje_obj_freeze, _edje_object_freeze, "@brief Freezes the Edje object."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_content_get, _edje_object_part_text_cursor_content_get, "@brief Returns the content (char) at the cursor position."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_layout_set, _edje_object_part_text_input_panel_layout_set, "@brief Set the layout of the input panel."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_layout_get, _edje_object_part_text_input_panel_layout_get, "@brief Get the layout of the input panel."),
+     EO_OP_FUNC(edje_obj_part_table_pack, _edje_object_part_table_pack, "@brief Packs an object into the table."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_language_set, _edje_object_part_text_input_panel_language_set, "Set the language mode of the input panel."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_language_get, _edje_object_part_text_input_panel_language_get, "Get the language mode of the input panel."),
+     EO_OP_FUNC(edje_obj_part_table_col_row_size_get, _edje_object_part_table_col_row_size_get, "@brief Gets the number of columns and rows the table has."),
+     EO_OP_FUNC(edje_obj_part_external_object_get, _edje_object_part_external_object_get, "@brief Get the object created by this external part."),
+     EO_OP_FUNC(edje_obj_part_external_content_get, _edje_object_part_external_content_get, "@brief Get an object contained in an part of type EXTERNAL"),
+     EO_OP_FUNC(edje_obj_preload, _edje_object_preload, "@brief Preload the images on the Edje Object in the background."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_enabled_set, _edje_object_part_text_input_panel_enabled_set, "@brief Sets the attribute to show the input panel automatically."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_enabled_get, _edje_object_part_text_input_panel_enabled_get, "@brief Retrieve the attribute to show the input panel automatically."),
+     EO_OP_FUNC(edje_obj_part_text_select_extend, _edje_object_part_text_select_extend, "@brief Extends the current selection to the current cursor position"),
+     EO_OP_FUNC(edje_obj_part_box_insert_at, _edje_object_part_box_insert_at, "@brief Inserts an object to the box."),
+     EO_OP_FUNC(edje_obj_part_text_anchor_geometry_get, _edje_object_part_text_anchor_geometry_get, "@brief Return a list of Evas_Textblock_Rectangle anchor rectangles."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_down, _edje_object_part_text_cursor_down, "@brief Moves the cursor to the char below the current cursor position."),
+     EO_OP_FUNC(edje_obj_part_drag_page_set, _edje_object_part_drag_page_set, "@brief Sets the page step increments."),
+     EO_OP_FUNC(edje_obj_part_drag_page_get, _edje_object_part_drag_page_get, "@brief Gets the page step increments."),
+     EO_OP_FUNC(edje_obj_part_box_prepend, _edje_object_part_box_prepend, "@brief Prepends an object to the box."),
+     EO_OP_FUNC(edje_obj_signal_emit, _edje_object_signal_emit, "@brief Send/emit an Edje signal to a given Edje object"),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_layout_variation_set, _edje_object_part_text_input_panel_layout_variation_set, "@brief Set the layout variation of the input panel."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_layout_variation_get, _edje_object_part_text_input_panel_layout_variation_get, "@brief Get the layout variation of the input panel."),
+     EO_OP_FUNC(edje_obj_message_send, _edje_object_message_send, "@brief Send an (Edje) message to a given Edje object"),
+     EO_OP_FUNC(edje_obj_part_text_select_none, _edje_object_part_text_select_none, "@brief Set the selection to be none."),
+     EO_OP_FUNC(edje_obj_part_object_get, _edje_object_part_object_get, "@brief Get a handle to the Evas object implementing a given Edje"),
+     EO_OP_FUNC(edje_obj_part_drag_size_set, _edje_object_part_drag_size_set, "@brief Set the dragable object size."),
+     EO_OP_FUNC(edje_obj_part_drag_size_get, _edje_object_part_drag_size_get, "@brief Get the dragable object size."),
+     EO_OP_FUNC(edje_obj_text_insert_filter_callback_del, _edje_object_text_insert_filter_callback_del, "Delete a function from the filter list."),
+     EO_OP_FUNC(edje_obj_part_drag_dir_get, _edje_object_part_drag_dir_get, "@brief Determine dragable directions."),
+     EO_OP_FUNC(edje_obj_part_text_unescaped_set, _edje_object_part_text_unescaped_set, "@brief Sets the raw (non escaped) text for an object part."),
+     EO_OP_FUNC(edje_obj_part_text_unescaped_get, _edje_object_part_text_unescaped_get, "@brief Returns the text of the object part, without escaping."),
+     EO_OP_FUNC(edje_obj_signal_callback_add, _edje_object_signal_callback_add, "@brief Add a callback for an arriving Edje signal, emitted by"),
+     EO_OP_FUNC(edje_obj_part_text_select_all, _edje_object_part_text_select_all, "@brief Set the selection to be everything."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_return_key_disabled_set, _edje_object_part_text_input_panel_return_key_disabled_set, "Set the return key on the input panel to be disabled."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_return_key_disabled_get, _edje_object_part_text_input_panel_return_key_disabled_get, "Get whether the return key on the input panel should be disabled or not."),
+     EO_OP_FUNC(edje_obj_part_text_autocapital_type_set, _edje_object_part_text_autocapital_type_set, "@brief Set the autocapitalization type on the immodule."),
+     EO_OP_FUNC(edje_obj_part_text_autocapital_type_get, _edje_object_part_text_autocapital_type_get, "@brief Retrieves the autocapitalization type"),
+     EO_OP_FUNC(edje_obj_part_unswallow, _edje_object_part_unswallow, "@brief Unswallow an object."),
+     EO_OP_FUNC(edje_obj_part_text_prediction_allow_set, _edje_object_part_text_prediction_allow_set, "@brief Set whether the prediction is allowed or not."),
+     EO_OP_FUNC(edje_obj_part_text_prediction_allow_get, _edje_object_part_text_prediction_allow_get, "@brief Get whether the prediction is allowed or not."),
+     EO_OP_FUNC(edje_obj_data_get, _edje_object_data_get, "@brief Retrive an <b>EDC data field's value</b> from a given Edje"),
+     EO_OP_FUNC(edje_obj_text_markup_filter_callback_add, _edje_object_text_markup_filter_callback_add, "Add a markup filter function for newly inserted text."),
+     EO_OP_FUNC(edje_obj_message_signal_process, _edje_object_message_signal_process, "@brief Process an object's message queue."),
+     EO_OP_FUNC(edje_obj_part_box_remove, _edje_object_part_box_remove, "@brief Removes an object from the box."),
+     EO_OP_FUNC(edje_obj_thaw, _edje_object_thaw, "@brief Thaws the Edje object."),
+     EO_OP_FUNC(edje_obj_part_swallow_get, _edje_object_part_swallow_get, "@brief Get the object currently swallowed by a part."),
+     EO_OP_FUNC(edje_obj_part_text_imf_context_reset, _edje_object_part_text_imf_context_reset, "@brief Reset the input method context if needed."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_return_key_type_set, _edje_object_part_text_input_panel_return_key_type_set, "Set the \"return\" key type. This type is used to set string or icon on the \"return\" key of the input panel."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_return_key_type_get, _edje_object_part_text_input_panel_return_key_type_get, "Get the \"return\" key type."),
+     EO_OP_FUNC(edje_obj_part_table_child_get, _edje_object_part_table_child_get, "@brief Retrieve a child from a table"),
+     EO_OP_FUNC(edje_obj_part_box_insert_before, _edje_object_part_box_insert_before, "@brief Adds an object to the box."),
+     EO_OP_FUNC(edje_obj_part_external_param_set, _edje_object_part_external_param_set, "@brief Set the parameter for the external part."),
+     EO_OP_FUNC(edje_obj_part_external_param_get, _edje_object_part_external_param_get, "@brief Get the parameter for the external part."),
+     EO_OP_FUNC(edje_obj_size_min_calc, _edje_object_size_min_calc, "@brief Calculate the minimum required size for a given Edje object."),
+     EO_OP_FUNC(edje_obj_part_box_append, _edje_object_part_box_append, "@brief Appends an object to the box."),
+     EO_OP_FUNC(edje_obj_size_min_restricted_calc, _edje_object_size_min_restricted_calc, "@brief Calculate the minimum required size for a given Edje object."),
+     EO_OP_FUNC(edje_obj_part_box_remove_all, _edje_object_part_box_remove_all, "@brief Removes all elements from the box."),
+     EO_OP_FUNC(edje_obj_part_drag_page, _edje_object_part_drag_page, "@brief Pages x,y steps."),
+     EO_OP_FUNC(edje_obj_part_text_set, _edje_object_part_text_set, "@brief Sets the text for an object part"),
+     EO_OP_FUNC(edje_obj_part_text_get, _edje_object_part_text_get, "@brief Return the text of the object part."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_show_on_demand_set, _edje_object_part_text_input_panel_show_on_demand_set, "Set the attribute to show the input panel in case of only an user's explicit Mouse Up event."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_show_on_demand_get, _edje_object_part_text_input_panel_show_on_demand_get, "Get the attribute to show the input panel in case of only an user's explicit Mouse Up event."),
+     EO_OP_FUNC(edje_obj_part_text_input_hint_set, _edje_object_part_text_input_hint_set, "Sets the input hint which allows input methods to fine-tune their behavior."),
+     EO_OP_FUNC(edje_obj_part_text_input_hint_get, _edje_object_part_text_input_hint_get, "Gets the value of input hint"),
+     EO_OP_FUNC(edje_obj_part_text_selection_get, _edje_object_part_text_selection_get, "@brief Return the selection text of the object part."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_is_format_get, _edje_object_part_text_cursor_is_format_get, "@brief Returns whether the cursor points to a format."),
+     EO_OP_FUNC(edje_obj_color_class_set, _edje_object_color_class_set, "@brief Sets the object color class."),
+     EO_OP_FUNC(edje_obj_color_class_get, _edje_object_color_class_get, "@brief Gets the object color class."),
+     EO_OP_FUNC(edje_obj_part_drag_step, _edje_object_part_drag_step, "@brief Steps the dragable x,y steps."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_up, _edje_object_part_text_cursor_up, "@brief Move the cursor to the char above the current cursor position."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_geometry_get, _edje_object_part_text_cursor_geometry_get, "@brief Returns the cursor geometry of the part relative to the edje"),
+     EO_OP_FUNC(edje_obj_part_text_anchor_list_get, _edje_object_part_text_anchor_list_get, "@brief Return a list of char anchor names."),
+     EO_OP_FUNC(edje_obj_text_insert_filter_callback_add, _edje_object_text_insert_filter_callback_add, "Add a filter function for newly inserted text."),
+     EO_OP_FUNC(edje_obj_part_text_input_panel_show, _edje_object_part_text_input_panel_show, "@brief Show the input panel (virtual keyboard) based on the input panel property such as layout, autocapital types, and so on."),
+     EO_OP_FUNC(edje_obj_part_exists, _edje_object_part_exists, "@brief Check if an Edje part exists in a given Edje object's group"),
+     EO_OP_FUNC(edje_obj_text_markup_filter_callback_del, _edje_object_text_markup_filter_callback_del, "Delete a function from the markup filter list."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_is_visible_format_get, _edje_object_part_text_cursor_is_visible_format_get, "@brief Return true if the cursor points to a visible format"),
+     EO_OP_FUNC(edje_obj_part_text_user_insert, _edje_object_part_text_user_insert, "@brief This function inserts text as if the user has inserted it."),
+     EO_OP_FUNC(edje_obj_part_text_cursor_prev, _edje_object_part_text_cursor_prev, "@brief Moves the cursor to the previous char"),
+     EO_OP_FUNC(edje_obj_part_text_item_list_get, _edje_object_part_text_item_list_get, "@brief Return a list of char item names."),
+     EO_OP_FUNC(edje_obj_part_swallow, _edje_object_part_swallow, "@brief \"Swallows\" an object into one of the Edje object @c SWALLOW"),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _edje_object_class_desc = {
+     EO_VERSION,
+     "Edje_Object",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_edje_object_op_desc),
+     NULL,
+     sizeof(Edje),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(edje_object_class_get, &_edje_object_class_desc, EVAS_SMART_CLIPPED_CLASS, EFL_FILE_INTERFACE, NULL);
+EAPI void
+edje_object_update_hints_set(Edje_Object *obj, Eina_Bool update)
+{
+   eo_do((Edje_Object *)obj, edje_obj_update_hints_set(update));
+}
+
+EAPI Eina_Bool
+edje_object_update_hints_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_update_hints_get());
+}
+
+EAPI void
+edje_object_mirrored_set(Edje_Object *obj, Eina_Bool rtl)
+{
+   eo_do((Edje_Object *)obj, edje_obj_mirrored_set(rtl));
+}
+
+EAPI Eina_Bool
+edje_object_mirrored_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_mirrored_get());
+}
+
+EAPI void
+edje_object_animation_set(Edje_Object *obj, Eina_Bool on)
+{
+   eo_do((Edje_Object *)obj, edje_obj_animation_set(on));
+}
+
+EAPI Eina_Bool
+edje_object_animation_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_animation_get());
+}
+
+EAPI void
+edje_object_play_set(Edje_Object *obj, Eina_Bool play)
+{
+   eo_do((Edje_Object *)obj, edje_obj_play_set(play));
+}
+
+EAPI Eina_Bool
+edje_object_play_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_play_get());
+}
+
+EAPI void
+edje_object_perspective_set(Edje_Object *obj, Edje_Perspective *ps)
+{
+   eo_do((Edje_Object *)obj, edje_obj_perspective_set(ps));
+}
+
+EAPI const Edje_Perspective *
+edje_object_perspective_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_perspective_get());
+}
+
+EAPI Eina_Bool
+edje_object_scale_set(Edje_Object *obj, double scale)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_scale_set(scale));
+}
+
+EAPI double
+edje_object_scale_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_scale_get());
+}
+
+EAPI double
+edje_object_base_scale_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_base_scale_get());
+}
+
+EAPI Eina_Bool
+edje_object_mmap_set(Edje_Object *obj, const Eina_File *file, const char *group)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_mmap_set(file, group));
+}
+
+EAPI void
+edje_object_text_change_cb_set(Edje_Object *obj, Edje_Text_Change_Cb func, void *data)
+{
+   eo_do((Edje_Object *)obj, edje_obj_text_change_cb_set(func, data));
+}
+
+EAPI void
+edje_object_part_text_cursor_begin_set(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_begin_set(part, cur));
+}
+
+EAPI void
+edje_object_part_text_cursor_line_end_set(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_line_end_set(part, cur));
+}
+
+EAPI Eina_Bool
+edje_object_text_class_set(Edje_Object *obj, const char *text_class, const char *font, Evas_Font_Size size)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_text_class_set(text_class, font, size));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_cursor_coord_set(Edje_Object *obj, const char *part, Edje_Cursor cur, Evas_Coord x, Evas_Coord y)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_coord_set(part, cur, x, y));
+}
+
+EAPI void
+edje_object_part_text_cursor_end_set(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_end_set(part, cur));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_escaped_set(Edje_Object *obj, const char *part, const char *text)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_escaped_set(part, text));
+}
+
+EAPI void
+edje_object_item_provider_set(Edje_Object *obj, Edje_Item_Provider_Cb func, void *data)
+{
+   eo_do((Edje_Object *)obj, edje_obj_item_provider_set(func, data));
+}
+
+EAPI void
+edje_object_part_text_cursor_line_begin_set(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_line_begin_set(part, cur));
+}
+
+EAPI void
+edje_object_message_handler_set(Edje_Object *obj, Edje_Message_Handler_Cb func, void *data)
+{
+   eo_do((Edje_Object *)obj, edje_obj_message_handler_set(func, data));
+}
+
+EAPI void
+edje_object_size_min_get(const Edje_Object *obj, Evas_Coord *minw, Evas_Coord *minh)
+{
+   eo_do((Edje_Object *)obj, edje_obj_size_min_get(minw, minh));
+}
+
+EAPI Eina_List *
+edje_object_access_part_list_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_access_part_list_get());
+}
+
+EAPI Edje_Load_Error
+edje_object_load_error_get(const Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_load_error_get());
+}
+
+EAPI void
+edje_object_size_max_get(const Edje_Object *obj, Evas_Coord *maxw, Evas_Coord *maxh)
+{
+   eo_do((Edje_Object *)obj, edje_obj_size_max_get(maxw, maxh));
+}
+
+EAPI Eina_Bool
+edje_object_part_table_clear(Edje_Object *obj, const char *part, Eina_Bool clear)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_table_clear(part, clear));
+}
+
+EAPI Edje_External_Param_Type
+edje_object_part_external_param_type_get(const Edje_Object *obj, const char *part, const char *param)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_external_param_type_get(part, param));
+}
+
+EAPI void
+edje_object_part_text_select_allow_set(const Edje_Object *obj, const char *part, Eina_Bool allow)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_select_allow_set(part, allow));
+}
+
+EAPI const char *
+edje_object_part_state_get(const Edje_Object *obj, const char *part, double *val_ret)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_state_get(part, val_ret));
+}
+
+EAPI void *
+edje_object_text_markup_filter_callback_del_full(Edje_Object *obj, const char *part, Edje_Markup_Filter_Cb func, void *data)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_text_markup_filter_callback_del_full(part, func, data));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_step_set(Edje_Object *obj, const char *part, double dx, double dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_step_set(part, dx, dy));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_step_get(const Edje_Object *obj, const char *part, double *dx, double *dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_step_get(part, dx, dy));
+}
+
+EAPI void *
+edje_object_part_text_imf_context_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_imf_context_get(part));
+}
+
+EAPI void
+edje_object_part_text_select_begin(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_select_begin(part));
+}
+
+EAPI const char *
+edje_object_part_text_style_user_peek(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_style_user_peek(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_cursor_next(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_next(part, cur));
+}
+
+EAPI void
+edje_object_part_text_style_user_push(Edje_Object *obj, const char *part, const char *style)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_style_user_push(part, style));
+}
+
+EAPI void
+edje_object_part_text_append(Edje_Object *obj, const char *part, const char *text)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_append(part, text));
+}
+
+EAPI Eina_Bool
+edje_object_part_geometry_get(const Edje_Object *obj, const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_geometry_get(part, x, y, w, h));
+}
+
+EAPI void
+edje_object_part_text_input_panel_hide(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_hide(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_item_geometry_get(const Edje_Object *obj, const char *part, const char *item, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_item_geometry_get(part, item, cx, cy, cw, ch));
+}
+
+EAPI Eina_Bool
+edje_object_part_table_unpack(Edje_Object *obj, const char *part, Evas_Object *child_obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_table_unpack(part, child_obj));
+}
+
+EAPI void
+edje_object_part_text_select_abort(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_select_abort(part));
+}
+
+EAPI void *
+edje_object_text_insert_filter_callback_del_full(Edje_Object *obj, const char *part, Edje_Text_Filter_Cb func, void *data)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_text_insert_filter_callback_del_full(part, func, data));
+}
+
+EAPI void
+edje_object_part_text_style_user_pop(Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_style_user_pop(part));
+}
+
+EAPI void
+edje_object_part_text_input_panel_imdata_set(Edje_Object *obj, const char *part, const void *data, int len)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_imdata_set(part, data, len));
+}
+
+EAPI void
+edje_object_part_text_input_panel_imdata_get(const Edje_Object *obj, const char *part, void *data, int *len)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_imdata_get(part, data, len));
+}
+
+EAPI void
+edje_object_part_text_insert(Edje_Object *obj, const char *part, const char *text)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_insert(part, text));
+}
+
+EAPI Evas_Object *
+edje_object_part_box_remove_at(Edje_Object *obj, const char *part, unsigned int pos)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_box_remove_at(part, pos));
+}
+
+EAPI void
+edje_object_part_text_cursor_copy(Edje_Object *obj, const char *part, Edje_Cursor src, Edje_Cursor dst)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_copy(part, src, dst));
+}
+
+EAPI Eina_Bool
+edje_object_parts_extends_calc(Edje_Object *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_parts_extends_calc(x, y, w, h));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_value_set(Edje_Object *obj, const char *part, double dx, double dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_value_set(part, dx, dy));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_value_get(const Edje_Object *obj, const char *part, double *dx, double *dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_value_get(part, dx, dy));
+}
+
+EAPI void
+edje_object_calc_force(Edje_Object *obj)
+{
+   eo_do((Edje_Object *)obj, edje_obj_calc_force());
+}
+
+EAPI void
+edje_object_part_text_cursor_pos_set(Edje_Object *obj, const char *part, Edje_Cursor cur, int pos)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_pos_set(part, cur, pos));
+}
+
+EAPI int
+edje_object_part_text_cursor_pos_get(const Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_pos_get(part, cur));
+}
+
+EAPI int
+edje_object_freeze(Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_freeze());
+}
+
+EAPI char *
+edje_object_part_text_cursor_content_get(const Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_content_get(part, cur));
+}
+
+EAPI void
+edje_object_part_text_input_panel_layout_set(Edje_Object *obj, const char *part, Edje_Input_Panel_Layout layout)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_layout_set(part, layout));
+}
+
+EAPI Edje_Input_Panel_Layout
+edje_object_part_text_input_panel_layout_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_layout_get(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_table_pack(Edje_Object *obj, const char *part, Evas_Object *child_obj, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_table_pack(part, child_obj, col, row, colspan, rowspan));
+}
+
+EAPI void
+edje_object_part_text_input_panel_language_set(Edje_Object *obj, const char *part, Edje_Input_Panel_Lang lang)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_language_set(part, lang));
+}
+
+EAPI Edje_Input_Panel_Lang
+edje_object_part_text_input_panel_language_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_language_get(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_table_col_row_size_get(const Edje_Object *obj, const char *part, int *cols, int *rows)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_table_col_row_size_get(part, cols, rows));
+}
+
+EAPI Evas_Object *
+edje_object_part_external_object_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_external_object_get(part));
+}
+
+EAPI Evas_Object *
+edje_object_part_external_content_get(const Edje_Object *obj, const char *part, const char *content)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_external_content_get(part, content));
+}
+
+EAPI Eina_Bool
+edje_object_preload(Edje_Object *obj, Eina_Bool cancel)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_preload(cancel));
+}
+
+EAPI void
+edje_object_part_text_input_panel_enabled_set(Edje_Object *obj, const char *part, Eina_Bool enabled)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_enabled_set(part, enabled));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_input_panel_enabled_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_enabled_get(part));
+}
+
+EAPI void
+edje_object_part_text_select_extend(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_select_extend(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_box_insert_at(Edje_Object *obj, const char *part, Evas_Object *child, unsigned int pos)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_box_insert_at(part, child, pos));
+}
+
+EAPI const Eina_List *
+edje_object_part_text_anchor_geometry_get(const Edje_Object *obj, const char *part, const char *anchor)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_anchor_geometry_get(part, anchor));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_cursor_down(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_down(part, cur));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_page_set(Edje_Object *obj, const char *part, double dx, double dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_page_set(part, dx, dy));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_page_get(const Edje_Object *obj, const char *part, double *dx, double *dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_page_get(part, dx, dy));
+}
+
+EAPI Eina_Bool
+edje_object_part_box_prepend(Edje_Object *obj, const char *part, Evas_Object *child)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_box_prepend(part, child));
+}
+
+EAPI void
+edje_object_signal_emit(Edje_Object *obj, const char *emission, const char *source)
+{
+   eo_do((Edje_Object *)obj, edje_obj_signal_emit(emission, source));
+}
+
+EAPI void
+edje_object_part_text_input_panel_layout_variation_set(Edje_Object *obj, const char *part, int variation)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_layout_variation_set(part, variation));
+}
+
+EAPI int
+edje_object_part_text_input_panel_layout_variation_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_layout_variation_get(part));
+}
+
+EAPI void
+edje_object_message_send(Edje_Object *obj, Edje_Message_Type type, int id, void *msg)
+{
+   eo_do((Edje_Object *)obj, edje_obj_message_send(type, id, msg));
+}
+
+EAPI void
+edje_object_part_text_select_none(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_select_none(part));
+}
+
+EAPI const Evas_Object *
+edje_object_part_object_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_object_get(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_size_set(Edje_Object *obj, const char *part, double dw, double dh)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_size_set(part, dw, dh));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_size_get(const Edje_Object *obj, const char *part, double *dw, double *dh)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_size_get(part, dw, dh));
+}
+
+EAPI void *
+edje_object_text_insert_filter_callback_del(Edje_Object *obj, const char *part, Edje_Text_Filter_Cb func)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_text_insert_filter_callback_del(part, func));
+}
+
+EAPI Edje_Drag_Dir
+edje_object_part_drag_dir_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_dir_get(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_unescaped_set(Edje_Object *obj, const char *part, const char *text_to_escape)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_unescaped_set(part, text_to_escape));
+}
+
+EAPI char *
+edje_object_part_text_unescaped_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_unescaped_get(part));
+}
+
+EAPI void
+edje_object_signal_callback_add(Edje_Object *obj, const char *emission, const char *source, Edje_Signal_Cb func, void *data)
+{
+   eo_do((Edje_Object *)obj, edje_obj_signal_callback_add(emission, source, func, data));
+}
+
+EAPI void
+edje_object_part_text_select_all(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_select_all(part));
+}
+
+EAPI void
+edje_object_part_text_input_panel_return_key_disabled_set(Edje_Object *obj, const char *part, Eina_Bool disabled)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_return_key_disabled_set(part, disabled));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_input_panel_return_key_disabled_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_return_key_disabled_get(part));
+}
+
+EAPI void
+edje_object_part_text_autocapital_type_set(Edje_Object *obj, const char *part, Edje_Text_Autocapital_Type autocapital_type)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_autocapital_type_set(part, autocapital_type));
+}
+
+EAPI Edje_Text_Autocapital_Type
+edje_object_part_text_autocapital_type_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_autocapital_type_get(part));
+}
+
+EAPI void
+edje_object_part_unswallow(Edje_Object *obj, Evas_Object *obj_swallow)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_unswallow(obj_swallow));
+}
+
+EAPI void
+edje_object_part_text_prediction_allow_set(Edje_Object *obj, const char *part, Eina_Bool prediction)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_prediction_allow_set(part, prediction));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_prediction_allow_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_prediction_allow_get(part));
+}
+
+EAPI const char *
+edje_object_data_get(const Edje_Object *obj, const char *key)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_data_get(key));
+}
+
+EAPI void
+edje_object_text_markup_filter_callback_add(Edje_Object *obj, const char *part, Edje_Markup_Filter_Cb func, void *data)
+{
+   eo_do((Edje_Object *)obj, edje_obj_text_markup_filter_callback_add(part, func, data));
+}
+
+EAPI void
+edje_object_message_signal_process(Edje_Object *obj)
+{
+   eo_do((Edje_Object *)obj, edje_obj_message_signal_process());
+}
+
+EAPI Evas_Object *
+edje_object_part_box_remove(Edje_Object *obj, const char *part, Evas_Object *child)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_box_remove(part, child));
+}
+
+EAPI int
+edje_object_thaw(Edje_Object *obj)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_thaw());
+}
+
+EAPI Evas_Object *
+edje_object_part_swallow_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_swallow_get(part));
+}
+
+EAPI void
+edje_object_part_text_imf_context_reset(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_imf_context_reset(part));
+}
+
+EAPI void
+edje_object_part_text_input_panel_return_key_type_set(Edje_Object *obj, const char *part, Edje_Input_Panel_Return_Key_Type return_key_type)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_return_key_type_set(part, return_key_type));
+}
+
+EAPI Edje_Input_Panel_Return_Key_Type
+edje_object_part_text_input_panel_return_key_type_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_return_key_type_get(part));
+}
+
+EAPI Evas_Object *
+edje_object_part_table_child_get(const Edje_Object *obj, const char *part, unsigned int col, unsigned int row)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_table_child_get(part, col, row));
+}
+
+EAPI Eina_Bool
+edje_object_part_box_insert_before(Edje_Object *obj, const char *part, Evas_Object *child, const Evas_Object *reference)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_box_insert_before(part, child, reference));
+}
+
+EAPI Eina_Bool
+edje_object_part_external_param_set(Edje_Object *obj, const char *part, const Edje_External_Param *param)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_external_param_set(part, param));
+}
+
+EAPI Eina_Bool
+edje_object_part_external_param_get(const Edje_Object *obj, const char *part, Edje_External_Param *param)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_external_param_get(part, param));
+}
+
+EAPI void
+edje_object_size_min_calc(Edje_Object *obj, Evas_Coord *minw, Evas_Coord *minh)
+{
+   eo_do((Edje_Object *)obj, edje_obj_size_min_calc(minw, minh));
+}
+
+EAPI Eina_Bool
+edje_object_part_box_append(Edje_Object *obj, const char *part, Evas_Object *child)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_box_append(part, child));
+}
+
+EAPI void
+edje_object_size_min_restricted_calc(Edje_Object *obj, Evas_Coord *minw, Evas_Coord *minh, Evas_Coord restrictedw, Evas_Coord restrictedh)
+{
+   eo_do((Edje_Object *)obj, edje_obj_size_min_restricted_calc(minw, minh, restrictedw, restrictedh));
+}
+
+EAPI Eina_Bool
+edje_object_part_box_remove_all(Edje_Object *obj, const char *part, Eina_Bool clear)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_box_remove_all(part, clear));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_page(Edje_Object *obj, const char *part, double dx, double dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_page(part, dx, dy));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_set(Edje_Object *obj, const char *part, const char *text)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_set(part, text));
+}
+
+EAPI const char *
+edje_object_part_text_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_get(part));
+}
+
+EAPI void
+edje_object_part_text_input_panel_show_on_demand_set(Edje_Object *obj, const char *part, Eina_Bool ondemand)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_show_on_demand_set(part, ondemand));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_input_panel_show_on_demand_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_show_on_demand_get(part));
+}
+
+EAPI void
+edje_object_part_text_input_hint_set(Edje_Object *obj, const char *part, Edje_Input_Hints input_hints)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_hint_set(part, input_hints));
+}
+
+EAPI Edje_Input_Hints
+edje_object_part_text_input_hint_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_input_hint_get(part));
+}
+
+EAPI const char *
+edje_object_part_text_selection_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_selection_get(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_cursor_is_format_get(const Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_is_format_get(part, cur));
+}
+
+EAPI Eina_Bool
+edje_object_color_class_set(Edje_Object *obj, const char *color_class, int r, int g, int b, int a, int r2, int g2, int b2, int a2, int r3, int g3, int b3, int a3)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_color_class_set(color_class, r, g, b, a, r2, g2, b2, a2, r3, g3, b3, a3));
+}
+
+EAPI Eina_Bool
+edje_object_color_class_get(const Edje_Object *obj, const char *color_class, int *r, int *g, int *b, int *a, int *r2, int *g2, int *b2, int *a2, int *r3, int *g3, int *b3, int *a3)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_color_class_get(color_class, r, g, b, a, r2, g2, b2, a2, r3, g3, b3, a3));
+}
+
+EAPI Eina_Bool
+edje_object_part_drag_step(Edje_Object *obj, const char *part, double dx, double dy)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_drag_step(part, dx, dy));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_cursor_up(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_up(part, cur));
+}
+
+EAPI void
+edje_object_part_text_cursor_geometry_get(const Edje_Object *obj, const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_geometry_get(part, x, y, w, h));
+}
+
+EAPI const Eina_List *
+edje_object_part_text_anchor_list_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_anchor_list_get(part));
+}
+
+EAPI void
+edje_object_text_insert_filter_callback_add(Edje_Object *obj, const char *part, Edje_Text_Filter_Cb func, void *data)
+{
+   eo_do((Edje_Object *)obj, edje_obj_text_insert_filter_callback_add(part, func, data));
+}
+
+EAPI void
+edje_object_part_text_input_panel_show(const Edje_Object *obj, const char *part)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_input_panel_show(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_exists(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_exists(part));
+}
+
+EAPI void *
+edje_object_text_markup_filter_callback_del(Edje_Object *obj, const char *part, Edje_Markup_Filter_Cb func)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_text_markup_filter_callback_del(part, func));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_cursor_is_visible_format_get(const Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_is_visible_format_get(part, cur));
+}
+
+EAPI void
+edje_object_part_text_user_insert(const Edje_Object *obj, const char *part, const char *text)
+{
+   eo_do((Edje_Object *)obj, edje_obj_part_text_user_insert(part, text));
+}
+
+EAPI Eina_Bool
+edje_object_part_text_cursor_prev(Edje_Object *obj, const char *part, Edje_Cursor cur)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_cursor_prev(part, cur));
+}
+
+EAPI const Eina_List *
+edje_object_part_text_item_list_get(const Edje_Object *obj, const char *part)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_text_item_list_get(part));
+}
+
+EAPI Eina_Bool
+edje_object_part_swallow(Edje_Object *obj, const char *part, Evas_Object *obj_swallow)
+{
+   return eo_do((Edje_Object *)obj, edje_obj_part_swallow(part, obj_swallow));
+}
diff -Naur a/src/lib/edje/edje_object.eo.h b/src/lib/edje/edje_object.eo.h
--- a/src/lib/edje/edje_object.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_object.eo.h	2014-11-27 00:57:33.463713233 +0200
@@ -0,0 +1,2619 @@
+#ifndef _EDJE_OBJECT_EO_H_
+#define _EDJE_OBJECT_EO_H_
+
+#ifndef _EDJE_OBJECT_EO_CLASS_TYPE
+#define _EDJE_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Edje_Object;
+
+#endif
+
+#ifndef _EDJE_OBJECT_EO_TYPES
+#define _EDJE_OBJECT_EO_TYPES
+
+
+#endif
+#define EDJE_OBJECT_CLASS edje_object_class_get()
+
+const Eo_Class *edje_object_class_get(void) EINA_CONST;
+
+/**
+ *
+ * @brief Edje will automatically update the size hints on itself.
+ *
+ * By default edje doesn't set size hints on itself. With this function
+ * call, it will do so if update is true. Be carefully, it cost a lot to
+ * trigger this feature as it will recalc the object every time it make
+ * sense to be sure that's its minimal size hint is always accurate.
+ *
+ * @param[in] update Whether or not update the size hints.
+ *
+ */
+EOAPI void  edje_obj_update_hints_set(Eina_Bool update);
+
+/**
+ *
+ * @brief Whether or not Edje will update size hints on itself.
+ *
+ * @return @c true if does, @c false if it doesn't.
+ *
+ *
+ */
+EOAPI Eina_Bool  edje_obj_update_hints_get(void);
+
+/**
+ *
+ * @brief Set the RTL orientation for this object.
+ *
+ * @since 1.1.0
+ *
+ * @param[in] rtl new value of flag EINA_TRUE/EINA_FALSE
+ *
+ */
+EOAPI void  edje_obj_mirrored_set(Eina_Bool rtl);
+
+/**
+ *
+ * @brief Get the RTL orientation for this object.
+ *
+ * You can RTL orientation explicitly with edje_object_mirrored_set.
+ *
+ * @return @c EINA_TRUE if the flag is set or @c EINA_FALSE if not.
+ * @since 1.1.0
+ *
+ *
+ */
+EOAPI Eina_Bool  edje_obj_mirrored_get(void);
+
+/**
+ *
+ * @brief Set the object's animation state.
+ *
+ * This function starts or stops an Edje object's animation. The
+ * information if it's stopped can be retrieved by
+ * edje_object_animation_get().
+ *
+ * @see edje_object_animation_get()
+ *
+ * @param[in] on The animation state. @c EINA_TRUE to starts or
+@c EINA_FALSE to stops.
+ *
+ */
+EOAPI void  edje_obj_animation_set(Eina_Bool on);
+
+/**
+ *
+ * @brief Get the Edje object's animation state.
+ *
+ * @return @c EINA_FALSE on error or if object is not animated;
+ * @c EINA_TRUE if animated.
+ *
+ * This function returns if the animation is stopped or not. The
+ * animation state is set by edje_object_animation_set().
+ *
+ * @see edje_object_animation_set().
+ *
+ *
+ */
+EOAPI Eina_Bool  edje_obj_animation_get(void);
+
+/**
+ *
+ * @brief Set the Edje object to playing or paused states.
+ *
+ * This function sets the Edje object @a obj to playing or paused
+ * states, depending on the parameter @a play. This has no effect if
+ * the object was already at that state.
+ *
+ * @see edje_object_play_get().
+ *
+ * @param[in] play Object state (@c EINA_TRUE to playing,
+@c EINA_FALSE to paused).
+ *
+ */
+EOAPI void  edje_obj_play_set(Eina_Bool play);
+
+/**
+ *
+ * @brief Get the Edje object's state.
+ *
+ * @return @c EINA_FALSE if the object is not connected, its @c delete_me flag
+ * is set, or it is at paused state; @c EINA_TRUE if the object is at playing
+ * state.
+ *
+ * This function tells if an Edje object is playing or not. This state
+ * is set by edje_object_play_set().
+ *
+ * @see edje_object_play_set().
+ *
+ *
+ */
+EOAPI Eina_Bool  edje_obj_play_get(void);
+
+/**
+ *
+ * Set the given perspective object on this Edje object.
+ *
+ * Make the given perspective object be the default perspective for this Edje
+ * object.
+ *
+ * There can be only one perspective object per Edje object, and if a
+ * previous one was set, it will be removed and the new perspective object
+ * will be used.
+ *
+ * An Edje perspective will only affect a part if it doesn't point to another
+ * part to be used as perspective.
+ *
+ * @see edje_object_perspective_new()
+ * @see edje_object_perspective_get()
+ * @see edje_perspective_set()
+ *
+ * @param[in] ps The perspective object that will be used.
+ *
+ */
+EOAPI void  edje_obj_perspective_set(Edje_Perspective *ps);
+
+/**
+ *
+ * Get the current perspective used on this Edje object.
+ *
+ * @return The perspective object being used on this Edje object. Or @c NULL
+ * if there was none, and on errors.
+ *
+ * @see edje_object_perspective_set()
+ *
+ *
+ */
+EOAPI const Edje_Perspective * edje_obj_perspective_get(void);
+
+/**
+ *
+ * @brief Set the scaling factor for a given Edje object.
+ *
+ * This function sets an @b individual scaling factor on the @a obj
+ * Edje object. This property (or Edje's global scaling factor, when
+ * applicable), will affect this object's part sizes. If @p scale is
+ * not zero, than the individual scaling will @b override any global
+ * scaling set, for the object @p obj's parts. Put it back to zero to
+ * get the effects of the global scaling again.
+ *
+ * @warning Only parts which, at EDC level, had the @c "scale"
+ * property set to @c 1, will be affected by this function. Check the
+ * complete @ref edcref "syntax reference" for EDC files.
+ *
+ * @see edje_object_scale_get()
+ * @see edje_scale_get() for more details
+ *
+ * @param[in] scale The scaling factor (the default value is @c 0.0,
+meaning individual scaling @b not set)
+ *
+ */
+EOAPI Eina_Bool  edje_obj_scale_set(double scale);
+
+/**
+ *
+ * @brief Get a given Edje object's scaling factor.
+ *
+ * This function returns the @c individual scaling factor set on the
+ * @a obj Edje object.
+ *
+ * @see edje_object_scale_set() for more details
+ *
+ *
+ */
+EOAPI double  edje_obj_scale_get(void);
+
+/**
+ *
+ * @brief Get a given Edje object's base_scale factor.
+ *
+ * This function returns the base_scale factor set on the
+ * @a obj Edje object.
+ * The base_scale can be set in the collection of edc.
+ * If it isn't set, the default value is 1.0
+ *
+ *
+ */
+EOAPI double  edje_obj_base_scale_get(void);
+
+/**
+ *
+ * @brief Sets the @b EDJ file (and group within it) to load an Edje
+ * object's contents from
+ *
+ * @return @c EINA_TRUE, on success or @c EINA_FALSE, on errors (check
+ * edje_object_load_error_get() after this call to get errors causes)
+ *
+ * Edje expects EDJ files, which are theming objects' descriptions and
+ * resources packed together in an EET file, to read Edje object
+ * definitions from. They usually are created with the @c .edj
+ * extension. EDJ files, in turn, are assembled from @b textual object
+ * description files, where one describes Edje objects declaratively
+ * -- the EDC files (see @ref edcref "the syntax" for those files).
+ *
+ * Those description files were designed so that many Edje object
+ * definitions -- also called @b groups (or collections) -- could be
+ * packed together <b>in the same EDJ file</b>, so that a whole
+ * application's theme could be packed in one file only. This is the
+ * reason for the @p group argument.
+ *
+ * Use this function after you instantiate a new Edje object, so that
+ * you can "give him life", telling where to get its contents from.
+ *
+ * @see edje_object_add()
+ * @see edje_object_file_get()
+ * @see edje_object_mmap_set()
+ * @since 1.8
+ *
+ * @param[in] file The Eina.File pointing to the EDJ file to load @p from
+ * @param[in] group The name of the group, in @p file, which implements an
+Edje object
+ *
+ */
+EOAPI Eina_Bool  edje_obj_mmap_set(const Eina_File *file, const char *group);
+
+/**
+ *
+ * @brief Set the object text callback.
+ *
+ * This function sets the callback to be called when the text changes.
+ *
+ * @param[in] func The callback function to handle the text change
+ * @param[in] data The data associated to the callback function.
+ *
+ */
+EOAPI void  edje_obj_text_change_cb_set(Edje_Text_Change_Cb func, void *data);
+
+/**
+ *
+ * @brief Moves the cursor to the beginning of the text part
+ * @see evas_textblock_cursor_paragraph_first
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ *
+ */
+EOAPI void  edje_obj_part_text_cursor_begin_set(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Move the cursor to the end of the line.
+ * @see evas_textblock_cursor_line_char_last
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ *
+ */
+EOAPI void  edje_obj_part_text_cursor_line_end_set(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets Edje text class.
+ *
+ * @return @c EINA_TRUE, on success or @c EINA_FALSE, on error
+ *
+ * This function sets the text class for the Edje.
+ *
+ * @param[in] text_class The text class name
+ * @param[in] font Font name
+ * @param[in] size Font Size
+ *
+ */
+EOAPI Eina_Bool  edje_obj_text_class_set(const char *text_class, const char *font, Evas_Font_Size size);
+
+/**
+ *
+ * Position the given cursor to a X,Y position.
+ *
+ * This is frequently used with the user cursor.
+ *
+ * @return True on success, false on error.
+ *
+ * @param[in] part The part containing the object.
+ * @param[in] cur The cursor to adjust.
+ * @param[in] x X Coordinate.
+ * @param[in] y Y Coordinate.
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_cursor_coord_set(const char *part, Edje_Cursor cur, Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * @brief Moves the cursor to the end of the text part.
+ * @see evas_textblock_cursor_paragraph_last
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ *
+ */
+EOAPI void  edje_obj_part_text_cursor_end_set(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets the text for an object part, but converts HTML escapes to UTF8
+ *
+ * This converts the given string @p text to UTF8 assuming it contains HTML
+ * style escapes like "&amp;" and "&copy;" etc. IF the part is of type TEXT,
+ * as opposed to TEXTBLOCK.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE otherwise
+ *
+ * @since 1.2
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_escaped_set(const char *part, const char *text);
+
+/**
+ *
+ * @brief Set the function that provides item objects for named items in an edje entry text
+ *
+ * Item objects may be deleted any time by Edje, and will be deleted when the
+ * Edje object is deleted (or file is set to a new file).
+ *
+ * @param[in] func The function to call (or NULL to disable) to get item objects
+ * @param[in] data The data pointer to pass to the @p func callback
+ *
+ */
+EOAPI void  edje_obj_item_provider_set(Edje_Item_Provider_Cb func, void *data);
+
+/**
+ *
+ * @brief Move the cursor to the beginning of the line.
+ * @see evas_textblock_cursor_line_char_first
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ *
+ */
+EOAPI void  edje_obj_part_text_cursor_line_begin_set(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Set an Edje message handler function for a given Edje object.
+ *
+ * For scriptable programs on an Edje object's defining EDC file which
+ * send messages with the @c send_message() primitive, one can attach
+ * <b>handler functions</b>, to be called in the code which creates
+ * that object (see @ref edcref "the syntax" for EDC files).
+ *
+ * This function associates a message handler function and the
+ * attached data pointer to the object @p obj.
+ *
+ * @see edje_object_message_send()
+ *
+ * @param[in] func The function to handle messages @b coming from @p obj
+ * @param[in] data Auxiliary data to be passed to @p func
+ *
+ */
+EOAPI void  edje_obj_message_handler_set(Edje_Message_Handler_Cb func, void *data);
+
+/**
+ *
+ * @brief Get the minimum size specified -- as an EDC property -- for a
+ * given Edje object
+ *
+ * This function retrieves the @p obj object's minimum size values,
+ * <b>as declared in its EDC group definition</b>. Minimum size of
+ * groups have the following syntax
+ * @code
+ * collections {
+ * group {
+ * name: "a_group";
+ * min: 100 100;
+ * }
+ * }
+ * @endcode
+ *
+ * where one declares a minimum size of 100 pixels both for width and
+ * height. Those are (hint) values which should be respected when the
+ * given object/group is to be controlled by a given container object
+ * (e.g. an Edje object being "swallowed" into a given @c SWALLOW
+ * typed part, as in edje_object_part_swallow()). Check the complete
+ * @ref edcref "syntax reference" for EDC files.
+ *
+ * @note If the @c min EDC property was not declared for @p obj, this
+ * call will return the value 0, for each axis.
+ *
+ * @note On failure, this function will make all non-@c NULL size
+ * pointers' pointed variables be set to zero.
+ *
+ * @see edje_object_size_max_get()
+ *
+ * @param[out] minw Pointer to a variable where to store the minimum width
+ * @param[out] minh Pointer to a variable where to store the minimum height
+ *
+ */
+EOAPI void  edje_obj_size_min_get(Evas_Coord *minw, Evas_Coord *minh);
+
+/**
+ *
+ * @brief Retrieve a list all accessibility part names
+ *
+ * @return A list all accessibility part names on @p obj
+ * @since 1.7.0
+ *
+ *
+ */
+EOAPI Eina_List * edje_obj_access_part_list_get(void);
+
+/**
+ *
+ * @brief Gets the (last) file loading error for a given Edje object
+ *
+ * @return The Edje loading error, one of:
+ * - #EDJE_LOAD_ERROR_NONE
+ * - #EDJE_LOAD_ERROR_GENERIC
+ * - #EDJE_LOAD_ERROR_DOES_NOT_EXIST
+ * - #EDJE_LOAD_ERROR_PERMISSION_DENIED
+ * - #EDJE_LOAD_ERROR_RESOURCE_ALLOCATION_FAILED
+ * - #EDJE_LOAD_ERROR_CORRUPT_FILE
+ * - #EDJE_LOAD_ERROR_UNKNOWN_FORMAT
+ * - #EDJE_LOAD_ERROR_INCOMPATIBLE_FILE
+ * - #EDJE_LOAD_ERROR_UNKNOWN_COLLECTION
+ * - #EDJE_LOAD_ERROR_RECURSIVE_REFERENCE
+ *
+ * This function is meant to be used after an Edje EDJ <b>file
+ * loading</b>, what takes place with the edje_object_file_set()
+ * function. If that function does not return @c EINA_TRUE, one should
+ * check for the reason of failure with this one.
+ *
+ * @see edje_load_error_str()
+ *
+ *
+ */
+EOAPI Edje_Load_Error  edje_obj_load_error_get(void);
+
+/**
+ *
+ * @brief Get the maximum size specified -- as an EDC property -- for a
+ * given Edje object
+ *
+ * This function retrieves the @p obj object's maximum size values,
+ * <b>as declared in its EDC group definition</b>. Maximum size of
+ * groups have the following syntax
+ * @code
+ * collections {
+ * group {
+ * name: "a_group";
+ * max: 100 100;
+ * }
+ * }
+ * @endcode
+ *
+ * where one declares a maximum size of 100 pixels both for width and
+ * height. Those are (hint) values which should be respected when the
+ * given object/group is to be controlled by a given container object
+ * (e.g. an Edje object being "swallowed" into a given @c SWALLOW
+ * typed part, as in edje_object_part_swallow()). Check the complete
+ * @ref edcref "syntax reference" for EDC files.
+ *
+ * @note If the @c max EDC property was not declared for @p obj, this
+ * call will return the maximum size a given Edje object may have, for
+ * each axis.
+ *
+ * @note On failure, this function will make all non-@c NULL size
+ * pointers' pointed variables be set to zero.
+ *
+ * @see edje_object_size_min_get()
+ *
+ * @param[out] maxw Pointer to a variable where to store the maximum width
+ * @param[out] maxh Pointer to a variable where to store the maximum height
+ *
+ */
+EOAPI void  edje_obj_size_max_get(Evas_Coord *maxw, Evas_Coord *maxh);
+
+/**
+ *
+ * @brief Removes all object from the table.
+ *
+ * @return @c EINA_TRUE clear the table, @c EINA_FALSE on failure
+ *
+ * Removes all object from the table indicated by part, except the
+ * internal ones set from the theme.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] clear If set, will delete subobjs on remove
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_table_clear(const char *part, Eina_Bool clear);
+
+/**
+ *
+ * Facility to query the type of the given parameter of the given part.
+ *
+ * @return @c EDJE_EXTERNAL_PARAM_TYPE_MAX on errors, or another value
+ * from #Edje_External_Param_Type on success.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] param the parameter name to use.
+ *
+ */
+EOAPI Edje_External_Param_Type  edje_obj_part_external_param_type_get(const char *part, const char *param);
+
+/**
+ *
+ * @brief Enables selection if the entry is an EXPLICIT selection mode
+ * type.
+ *
+ * The default is to @b not allow selection. This function only affects user
+ * selection, functions such as edje_object_part_text_select_all() and
+ * edje_object_part_text_select_none() are not affected.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] allow EINA_TRUE to enable, EINA_FALSE otherwise
+ *
+ */
+EOAPI void  edje_obj_part_text_select_allow_set(const char *part, Eina_Bool allow);
+
+/**
+ *
+ * @brief Returns the state of the Edje part.
+ *
+ * @return The part state:\n
+ * "default" for the default state\n
+ * "" for other states
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] val_ret No description supplied.
+ *
+ */
+EOAPI const char * edje_obj_part_state_get(const char *part, double *val_ret);
+
+/**
+ *
+ * Delete a function and matching user data from the markup filter list.
+ *
+ * Delete the given @p func filter and @p data user data from the list
+ * in @p part.
+ * Returns the user data pointer given when added.
+ *
+ * @see edje_object_text_markup_filter_callback_add
+ * @see edje_object_text_markup_filter_callback_del
+ *
+ * @return The same data pointer if successful, or NULL otherwise
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ * @param[in] data The data passed to the callback function
+ *
+ */
+EOAPI void * edje_obj_text_markup_filter_callback_del_full(const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Sets the drag step increment.
+ *
+ * Sets the x,y step increments for a dragable object.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative size of the dragable area on that axis by which the
+ * part will be moved.
+ *
+ * @see edje_object_part_drag_step_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x step amount
+ * @param[in] dy The y step amount
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_step_set(const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Gets the drag step increment values.
+ *
+ * Gets the x and y step increments for the dragable object.
+ *
+ *
+ * @see edje_object_part_drag_step_set()
+ * 
+ *
+ * @param[in] part The part
+ * @param[out] dx The x step increment pointer
+ * @param[out] dy The y step increment pointer
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_step_get(const char *part, double *dx, double *dy);
+
+/**
+ *
+ * @brief Get the input method context in entry.
+ *
+ * If ecore_imf was not available when edje was compiled, this function returns NULL
+ * otherwise, the returned pointer is an Ecore_IMF
+ *
+ * @return The input method context (Ecore_IMF_Context *) in entry
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void * edje_obj_part_text_imf_context_get(const char *part);
+
+/**
+ *
+ * @brief Starts selecting at current cursor position
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_select_begin(const char *part);
+
+/**
+ *
+ * @brief Return the text of the object part.
+ *
+ * @return The text string
+ *
+ * This function returns the style associated with the textblock part.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI const char * edje_obj_part_text_style_user_peek(const char *part);
+
+/**
+ *
+ * @brief Remove a signal-triggered callback from an object.
+ *
+ * @return The data pointer
+ *
+ * This function removes a callback, previously attached to the
+ * emittion of a signal, from the object @a obj. The parameters @a
+ * emission, @a source and @a func must match exactly those passed to
+ * a previous call to edje_object_signal_callback_add(). The data
+ * pointer that was passed to this call will be returned.
+ *
+ * @see edje_object_signal_callback_add().
+ * @see edje_object_signal_callback_del_full().
+ * 
+ *
+ * @param[in] emission The emission string.
+ * @param[in] source The source string.
+ * @param[in] func The callback function.
+ * @param[in] data The callback function.
+ *
+ */
+EOAPI void * edje_obj_signal_callback_del(const char *emission, const char *source, Edje_Signal_Cb func, void *data);
+
+/**
+ *
+ * @brief Advances the cursor to the next cursor position.
+ * @see evas_textblock_cursor_char_next
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The edje cursor to advance
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_cursor_next(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Set the style of the
+ *
+ * This function sets the style associated with the textblock part.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] style The style to set (textblock conventions).
+ *
+ */
+EOAPI void  edje_obj_part_text_style_user_push(const char *part, const char *style);
+
+/**
+ *
+ * @brief Insert text for an object part.
+ *
+ * This function inserts the text for an object part at the end; It does not
+ * move the cursor.
+ *
+ * @since 1.1
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ *
+ */
+EOAPI void  edje_obj_part_text_append(const char *part, const char *text);
+
+/**
+ *
+ * @brief Retrieve the geometry of a given Edje part, in a given Edje
+ * object's group definition, <b>relative to the object's area</b>
+ *
+ * This function gets the geometry of an Edje part within its
+ * group. The @p x and @p y coordinates are relative to the top left
+ * corner of the whole @p obj object's area.
+ *
+ * @note Use @c NULL pointers on the geometry components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @note On failure, this function will make all non-@c NULL geometry
+ * pointers' pointed variables be set to zero.
+ * 
+ *
+ * @param[in] part The Edje part's name
+ * @param[out] x A pointer to a variable where to store the part's x
+coordinate
+ * @param[out] y A pointer to a variable where to store the part's y
+coordinate
+ * @param[out] w A pointer to a variable where to store the part's width
+ * @param[out] h A pointer to a variable where to store the part's height
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_geometry_get(const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * @brief Hide the input panel (virtual keyboard).
+ * @see edje_object_part_text_input_panel_show
+ *
+ * Note that input panel is shown or hidden automatically according to the focus state.
+ * This API can be used in the case of manually controlling by using edje_object_part_text_input_panel_enabled_set.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_hide(const char *part);
+
+/**
+ *
+ * @brief Return item geometry.
+ *
+ * @return 1 if item exists, 0 if not
+ *
+ * This function return a list of Evas_Textblock_Rectangle item
+ * rectangles.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] item The item name
+ * @param[out] cx Item x return (relative to entry part)
+ * @param[out] cy Item y return (relative to entry part)
+ * @param[out] cw Item width return
+ * @param[out] ch Item height return
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_item_geometry_get(const char *part, const char *item, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+/**
+ *
+ * @brief Removes an object from the table.
+ *
+ * @return @c EINA_TRUE object removed, @c EINA_FALSE on failure
+ *
+ * Removes an object from the table indicated by part.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child_obj The object to pack in
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_table_unpack(const char *part, Evas_Object *child_obj);
+
+/**
+ *
+ * @brief Aborts any selection action on a part.
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_select_abort(const char *part);
+
+/**
+ *
+ * Delete a function and matching user data from the filter list.
+ *
+ * Delete the given @p func filter and @p data user data from the list
+ * in @p part.
+ * Returns the user data pointer given when added.
+ *
+ * @see edje_object_text_insert_filter_callback_add
+ * @see edje_object_text_insert_filter_callback_del
+ *
+ * @return The same data pointer if successful, or NULL otherwise
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ * @param[in] data The data passed to the callback function
+ *
+ */
+EOAPI void * edje_obj_text_insert_filter_callback_del_full(const char *part, Edje_Text_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Delete the top style form the user style stack.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_style_user_pop(const char *part);
+
+/**
+ *
+ * Set the input panel-specific data to deliver to the input panel.
+ *
+ * This API is used by applications to deliver specific data to the input panel.
+ * The data format MUST be negotiated by both application and the input panel.
+ * The size and format of data are defined by the input panel.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] data The specific data to be set to the input panel.
+ * @param[in] len the length of data, in bytes, to send to the input panel
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_imdata_set(const char *part, const void *data, int len);
+
+/**
+ *
+ * Get the specific data of the current active input panel.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] data The specific data to be got from the input panel
+ * @param[in] len The length of data
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_imdata_get(const char *part, void *data, int *len);
+
+/**
+ *
+ * @brief Insert text for an object part.
+ *
+ * This function inserts the text for an object part just before the
+ * cursor position.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ *
+ */
+EOAPI void  edje_obj_part_text_insert(const char *part, const char *text);
+
+/**
+ *
+ * @brief Removes an object from the box.
+ *
+ * @return Pointer to the object removed, or @c NULL.
+ *
+ * Removes from the box indicated by part, the object in the position
+ * pos.
+ *
+ * @see edje_object_part_box_remove()
+ * @see edje_object_part_box_remove_all()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] pos The position index of the object (starts counting from 0)
+ *
+ */
+EOAPI Evas_Object * edje_obj_part_box_remove_at(const char *part, unsigned int pos);
+
+/**
+ *
+ * @brief Copy the cursor to another cursor.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] src the cursor to copy from
+ * @param[in] dst the cursor to copy to
+ *
+ */
+EOAPI void  edje_obj_part_text_cursor_copy(const char *part, Edje_Cursor src, Edje_Cursor dst);
+
+/**
+ *
+ * Calculate the geometry of the region, relative to a given Edje
+ * object's area, <b>occupied by all parts in the object</b>
+ *
+ * This function gets the geometry of the rectangle equal to the area
+ * required to group all parts in @p obj's group/collection. The @p x
+ * and @p y coordinates are relative to the top left corner of the
+ * whole @p obj object's area. Parts placed out of the group's
+ * boundaries will also be taken in account, so that @p x and @p y
+ * <b>may be negative</b>.
+ *
+ * @note Use @c NULL pointers on the geometry components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @note On failure, this function will make all non-@c NULL geometry
+ * pointers' pointed variables be set to zero.
+ * 
+ *
+ * @param[out] x A pointer to a variable where to store the parts region's
+x coordinate
+ * @param[out] y A pointer to a variable where to store the parts region's
+y coordinate
+ * @param[out] w A pointer to a variable where to store the parts region's
+width
+ * @param[out] h A pointer to a variable where to store the parts region's
+height
+ *
+ */
+EOAPI Eina_Bool  edje_obj_parts_extends_calc(Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * @brief Set the dragable object location.
+ *
+ * Places the dragable object at the given location.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative position to the dragable area on that axis.
+ *
+ * This value means, for the vertical axis, that 0.0 will be at the top if the
+ * first parameter of @c y in the dragable part theme is 1, and at bottom if it
+ * is -1.
+ *
+ * For the horizontal axis, 0.0 means left if the first parameter of @c x in the
+ * dragable part theme is 1, and right if it is -1.
+ *
+ * @see edje_object_part_drag_value_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x value
+ * @param[in] dy The y value
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_value_set(const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Get the dragable object location.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative position to the dragable area on that axis.
+ *
+ * @see edje_object_part_drag_value_set()
+ *
+ * Gets the drag location values.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] dx The X value pointer
+ * @param[out] dy The Y value pointer
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_value_get(const char *part, double *dx, double *dy);
+
+/**
+ *
+ * @brief Force a Size/Geometry calculation.
+ *
+ * Forces the object @p obj to recalculation layout regardless of
+ * freeze/thaw.
+ * 
+ *
+ *
+ */
+EOAPI void  edje_obj_calc_force(void);
+
+/**
+ *
+ * @brief Sets the cursor position to the given value
+ *
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to move
+ * @param[in] pos the position of the cursor
+ *
+ */
+EOAPI void  edje_obj_part_text_cursor_pos_set(const char *part, Edje_Cursor cur, int pos);
+
+/**
+ *
+ * @brief Retrieves the current position of the cursor
+ *
+ * @return The cursor position
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to get the position
+ *
+ */
+EOAPI int  edje_obj_part_text_cursor_pos_get(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Freezes the Edje object.
+ *
+ * @return The frozen state or 0 on Error
+ *
+ * This function puts all changes on hold. Successive freezes will
+ * nest, requiring an equal number of thaws.
+ *
+ * @see edje_object_thaw()
+ * 
+ *
+ *
+ */
+EOAPI int  edje_obj_freeze(void);
+
+/**
+ *
+ * @brief Returns the content (char) at the cursor position.
+ * @see evas_textblock_cursor_content_get
+ *
+ * You must free the return (if not NULL) after you are done with it.
+ *
+ * @return The character string pointed to (may be a multi-byte utf8 sequence) terminated by a nul byte.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to use
+ *
+ */
+EOAPI char * edje_obj_part_text_cursor_content_get(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Set the layout of the input panel.
+ *
+ * The layout of the input panel or virtual keyboard can make it easier or
+ * harder to enter content. This allows you to hint what kind of input you
+ * are expecting to enter and thus have the input panel automatically
+ * come up with the right mode.
+ *
+ * @since 1.1
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] layout layout type
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_layout_set(const char *part, Edje_Input_Panel_Layout layout);
+
+/**
+ *
+ * @brief Get the layout of the input panel.
+ *
+ * @return Layout type of the input panel
+ *
+ * @see edje_object_part_text_input_panel_layout_set
+ * @since 1.1
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Edje_Input_Panel_Layout  edje_obj_part_text_input_panel_layout_get(const char *part);
+
+/**
+ *
+ * @brief Packs an object into the table.
+ *
+ * @return @c EINA_TRUE object was added, @c EINA_FALSE on failure
+ *
+ * Packs an object into the table indicated by part.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child_obj The object to pack in
+ * @param[in] col The column to place it in
+ * @param[in] row The row to place it in
+ * @param[in] colspan Columns the child will take
+ * @param[in] rowspan Rows the child will take
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_table_pack(const char *part, Evas_Object *child_obj, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan);
+
+/**
+ *
+ * Set the language mode of the input panel.
+ *
+ * This API can be used if you want to show the Alphabet keyboard.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] lang the language to be set to the input panel.
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_language_set(const char *part, Edje_Input_Panel_Lang lang);
+
+/**
+ *
+ * Get the language mode of the input panel.
+ *
+ * See @ref edje_object_part_text_input_panel_language_set for more details.
+ *
+ * @return input panel language type
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Edje_Input_Panel_Lang  edje_obj_part_text_input_panel_language_get(const char *part);
+
+/**
+ *
+ * @brief Gets the number of columns and rows the table has.
+ *
+ * @return @c EINA_TRUE get some data, @c EINA_FALSE on failure
+ *
+ * Retrieves the size of the table in number of columns and rows.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] cols Pointer where to store number of columns (can be NULL)
+ * @param[out] rows Pointer where to store number of rows (can be NULL)
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_table_col_row_size_get(const char *part, int *cols, int *rows);
+
+/**
+ *
+ * @brief Get the object created by this external part.
+ *
+ * Parts of type external creates the part object using information
+ * provided by external plugins. It's somehow like "swallow"
+ * (edje_object_part_swallow()), but it's all set automatically.
+ *
+ * This function returns the part created by such external plugins and
+ * being currently managed by this Edje.
+ *
+ * @note Almost all swallow rules apply: you should not move, resize,
+ * hide, show, set the color or clipper of such part. It's a bit
+ * more restrictive as one must @b never delete this object!
+ *
+ * @return The externally created object, or NULL if there is none or
+ * part is not an external.
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Evas_Object * edje_obj_part_external_object_get(const char *part);
+
+/**
+ *
+ * @brief Get an object contained in an part of type EXTERNAL
+ *
+ * The @p content string must not be NULL. Its actual value depends on the
+ * code providing the EXTERNAL.
+ * 
+ *
+ * @param[in] part The name of the part holding the EXTERNAL
+ * @param[out] content A string identifying which content from the EXTERNAL to get
+ *
+ */
+EOAPI Evas_Object * edje_obj_part_external_content_get(const char *part, const char *content);
+
+/**
+ *
+ * @brief Preload the images on the Edje Object in the background.
+ *
+ * @return @c EINA_FASLE if obj was not a valid Edje object
+ * otherwise @c EINA_TRUE
+ *
+ * This function requests the preload of all data images (on the given
+ * object) in the background. The work is queued before being processed
+ * (because there might be other pending requests of this type).
+ * It emits a signal "preload,done" when finished.
+ *
+ * @note Use @c EINA_TRUE on scenarios where you don't need
+ * the image data preloaded anymore.
+ * 
+ *
+ * @param[in] cancel @c EINA_FALSE will add it the preloading work queue,
+@c EINA_TRUE will remove it (if it was issued before).
+ *
+ */
+EOAPI Eina_Bool  edje_obj_preload(Eina_Bool cancel);
+
+/**
+ *
+ * @brief Sets the attribute to show the input panel automatically.
+ *
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] enabled If true, the input panel is appeared when entry is clicked or has a focus
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_enabled_set(const char *part, Eina_Bool enabled);
+
+/**
+ *
+ * @brief Retrieve the attribute to show the input panel automatically.
+ * @see edje_object_part_text_input_panel_enabled_set
+ *
+ * @return EINA_TRUE if it supports or EINA_FALSE otherwise
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_input_panel_enabled_get(const char *part);
+
+/**
+ *
+ * @brief Extends the current selection to the current cursor position
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_select_extend(const char *part);
+
+/**
+ *
+ * @brief Inserts an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Adds child to the box indicated by part, in the position given by
+ * pos.
+ *
+ * @see edje_object_part_box_append()
+ * @see edje_object_part_box_prepend()
+ * @see edje_object_part_box_insert_before()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to insert
+ * @param[in] pos The position where to insert child
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_box_insert_at(const char *part, Evas_Object *child, unsigned int pos);
+
+/**
+ *
+ * @brief Return a list of Evas_Textblock_Rectangle anchor rectangles.
+ *
+ * @return The list of anchor rects (const Evas_Textblock_Rectangle
+ * *), do not modify! Geometry is relative to entry part.
+ *
+ * This function return a list of Evas_Textblock_Rectangle anchor
+ * rectangles.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] anchor The anchor name
+ *
+ */
+EOAPI const Eina_List * edje_obj_part_text_anchor_geometry_get(const char *part, const char *anchor);
+
+/**
+ *
+ * @brief Moves the cursor to the char below the current cursor position.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_cursor_down(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets the page step increments.
+ *
+ * Sets the x,y page step increment values.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative size of the dragable area on that axis by which the
+ * part will be moved.
+ *
+ * @see edje_object_part_drag_page_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x page step increment
+ * @param[in] dy The y page step increment
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_page_set(const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Gets the page step increments.
+ *
+ * Gets the x,y page step increments for the dragable object.
+ *
+ * @see edje_object_part_drag_page_set()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] dx The dx page increment pointer
+ * @param[out] dy The dy page increment pointer
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_page_get(const char *part, double *dx, double *dy);
+
+/**
+ *
+ * @brief Prepends an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Prepends child to the box indicated by part.
+ *
+ * @see edje_object_part_box_append()
+ * @see edje_object_part_box_insert_before()
+ * @see edje_object_part_box_insert_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to prepend
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_box_prepend(const char *part, Evas_Object *child);
+
+/**
+ *
+ * @brief Send/emit an Edje signal to a given Edje object
+ *
+ * This function sends a signal to the object @a obj. An Edje program,
+ * at @p obj's EDC specification level, can respond to a signal by
+ * having declared matching @c 'signal' and @c 'source' fields on its
+ * block (see @ref edcref "the syntax" for EDC files).
+ *
+ * As an example,
+ * @code
+ * edje_object_signal_emit(obj, "a_signal", "");
+ * @endcode
+ * would trigger a program which had an EDC declaration block like
+ * @code
+ * program {
+ * name: "a_program";
+ * signal: "a_signal";
+ * source: "";
+ * action: ...
+ * }
+ * @endcode
+ *
+ * @see edje_object_signal_callback_add() for more on Edje signals.
+ * 
+ *
+ * @param[in] emission The signal's "emission" string
+ * @param[in] source The signal's "source" string
+ *
+ */
+EOAPI void  edje_obj_signal_emit(const char *emission, const char *source);
+
+/**
+ *
+ * @brief Set the layout variation of the input panel.
+ *
+ * The layout variation of the input panel or virtual keyboard can make it easier or
+ * harder to enter content. This allows you to hint what kind of input you
+ * are expecting to enter and thus have the input panel automatically
+ * come up with the right mode.
+ *
+ * @since 1.8
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] variation layout variation type
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_layout_variation_set(const char *part, int variation);
+
+/**
+ *
+ * @brief Get the layout variation of the input panel.
+ *
+ * @return Layout variation type of the input panel
+ *
+ * @see edje_object_part_text_input_panel_layout_variation_set
+ * @since 1.8
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI int  edje_obj_part_text_input_panel_layout_variation_get(const char *part);
+
+/**
+ *
+ * @brief Send an (Edje) message to a given Edje object
+ *
+ * This function sends an Edje message to @p obj and to all of its
+ * child objects, if it has any (swallowed objects are one kind of
+ * child object). @p type and @p msg @b must be matched accordingly,
+ * as documented in #Edje_Message_Type.
+ *
+ * The @p id argument as a form of code and theme defining a common
+ * interface on message communication. One should define the same IDs
+ * on both code and EDC declaration (see @ref edcref "the syntax" for
+ * EDC files), to individualize messages (binding them to a given
+ * context).
+ *
+ * The function to handle messages arriving @b from @b obj is set with
+ * edje_object_message_handler_set().
+ * 
+ *
+ * @param[in] type The type of message to send to @p obj
+ * @param[in] id A identification number for the message to be sent
+ * @param[in] msg The message's body, a struct depending on @p type
+ *
+ */
+EOAPI void  edje_obj_message_send(Edje_Message_Type type, int id, void *msg);
+
+/**
+ *
+ * @brief Set the selection to be none.
+ *
+ * This function sets the selection text to be none.
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_select_none(const char *part);
+
+/**
+ *
+ * @brief Get a handle to the Evas object implementing a given Edje
+ * part, in an Edje object.
+ *
+ * @return A pointer to the Evas object implementing the given part,
+ * or @c NULL on failure (e.g. the given part doesn't exist)
+ *
+ * This function gets a pointer of the Evas object corresponding to a
+ * given part in the @p obj object's group.
+ *
+ * You should @b never modify the state of the returned object (with
+ * @c evas_object_move() or @c evas_object_hide() for example),
+ * because it's meant to be managed by Edje, solely. You are safe to
+ * query information about its current state (with @c
+ * evas_object_visible_get() or @c evas_object_color_get() for
+ * example), though.
+ * 
+ *
+ * @param[in] part The Edje part's name
+ *
+ */
+EOAPI const Evas_Object * edje_obj_part_object_get(const char *part);
+
+/**
+ *
+ * @brief Set the dragable object size.
+ *
+ * Values for @p dw and @p dh are real numbers that range from 0 to 1,
+ * representing the relative size of the dragable area on that axis.
+ *
+ * Sets the size of the dragable object.
+ *
+ * @see edje_object_part_drag_size_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dw The drag width
+ * @param[in] dh The drag height
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_size_set(const char *part, double dw, double dh);
+
+/**
+ *
+ * @brief Get the dragable object size.
+ *
+ * Gets the dragable object size.
+ *
+ * @see edje_object_part_drag_size_set()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] dw The drag width pointer
+ * @param[out] dh The drag height pointer
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_size_get(const char *part, double *dw, double *dh);
+
+/**
+ *
+ * Delete a function from the filter list.
+ *
+ * Delete the given @p func filter from the list in @p part. Returns
+ * the user data pointer given when added.
+ *
+ * @see edje_object_text_insert_filter_callback_add
+ * @see edje_object_text_insert_filter_callback_del_full
+ *
+ * @return The user data pointer if successful, or NULL otherwise
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ *
+ */
+EOAPI void * edje_obj_text_insert_filter_callback_del(const char *part, Edje_Text_Filter_Cb func);
+
+/**
+ *
+ * @brief Determine dragable directions.
+ *
+ * The dragable directions are defined in the EDC file, inside the @c dragable
+ * section, by the attributes @c x and @c y. See the @ref edcref for more
+ * information.
+ *
+ * @return #EDJE_DRAG_DIR_NONE: Not dragable\n
+ * #EDJE_DRAG_DIR_X: Dragable in X direction\n
+ * #EDJE_DRAG_DIR_Y: Dragable in Y direction\n
+ * #EDJE_DRAG_DIR_XY: Dragable in X & Y directions
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Edje_Drag_Dir  edje_obj_part_drag_dir_get(const char *part);
+
+/**
+ *
+ * @brief Sets the raw (non escaped) text for an object part.
+ *
+ * This funciton will not do escape for you if it is a TEXTBLOCK part, that is,
+ * if text contain tags, these tags will not be interpreted/parsed by TEXTBLOCK.
+ *
+ * @see edje_object_part_text_unescaped_get().
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text_to_escape The text string
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_unescaped_set(const char *part, const char *text_to_escape);
+
+/**
+ *
+ * @brief Returns the text of the object part, without escaping.
+ *
+ * @return The @b allocated text string without escaping, or NULL on
+ * problems.
+ *
+ * This function is the counterpart of
+ * edje_object_part_text_unescaped_set(). Please notice that the
+ * result is newly allocated memory and should be released with free()
+ * when done.
+ *
+ * @see edje_object_part_text_unescaped_set().
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI char * edje_obj_part_text_unescaped_get(const char *part);
+
+/**
+ *
+ * @brief Add a callback for an arriving Edje signal, emitted by
+ * a given Edje object.
+ *
+ * Edje signals are one of the communication interfaces between
+ * @b code and a given Edje object's @b theme. With signals, one can
+ * communicate two string values at a time, which are:
+ * - "emission" value: the name of the signal, in general
+ * - "source" value: a name for the signal's context, in general
+ *
+ * Though there are those common uses for the two strings, one is free
+ * to use them however they like.
+ *
+ * This function adds a callback function to a signal emitted by @a obj, to
+ * be issued every time an EDC program like the following
+ * @code
+ * program {
+ * name: "emit_example";
+ * action: SIGNAL_EMIT "a_signal" "a_source";
+ * }
+ * @endcode
+ * is run, if @p emission and @p source are given those same values,
+ * here.
+ *
+ * Signal callback registration is powerful, in the way that @b blobs
+ * may be used to match <b>multiple signals at once</b>. All the @c
+ * "*?[\" set of @c fnmatch() operators can be used, both for @p
+ * emission and @p source.
+ *
+ * Edje has @b internal signals it will emit, automatically, on
+ * various actions taking place on group parts. For example, the mouse
+ * cursor being moved, pressed, released, etc., over a given part's
+ * area, all generate individual signals.
+ *
+ * By using something like
+ * @code
+ * edje_object_signal_callback_add(obj, "mouse,down,*", "button.*",
+ * signal_cb, NULL);
+ * @endcode
+ * being @c "button.*" the pattern for the names of parts implementing
+ * buttons on an interface, you'd be registering for notifications on
+ * events of mouse buttons being pressed down on either of those parts
+ * (those events all have the @c "mouse,down," common prefix on their
+ * names, with a suffix giving the button number). The actual emission
+ * and source strings of an event will be passed in as the @a emission
+ * and @a source parameters of the callback function (e.g. @c
+ * "mouse,down,2" and @c "button.close"), for each of those events.
+ *
+ * @note See @ref edcref "the syntax" for EDC files
+ * @see edje_object_signal_emit() on how to emits Edje signals from
+ * code to a an object
+ * @see edje_object_signal_callback_del_full()
+ * 
+ *
+ * @param[in] emission The signal's "emission" string
+ * @param[in] source The signal's "source" string
+ * @param[in] func The callback function to be executed when the signal is
+emitted.
+ * @param[in] data A pointer to data to pass in to @p func.
+ *
+ */
+EOAPI void  edje_obj_signal_callback_add(const char *emission, const char *source, Edje_Signal_Cb func, void *data);
+
+/**
+ *
+ * @brief Set the selection to be everything.
+ *
+ * This function selects all text of the object of the part.
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_select_all(const char *part);
+
+/**
+ *
+ * Set the return key on the input panel to be disabled.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] disabled The state
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_return_key_disabled_set(const char *part, Eina_Bool disabled);
+
+/**
+ *
+ * Get whether the return key on the input panel should be disabled or not.
+ *
+ * @return EINA_TRUE if it should be disabled
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_input_panel_return_key_disabled_get(const char *part);
+
+/**
+ *
+ * @brief Set the autocapitalization type on the immodule.
+ *
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] autocapital_type The type of autocapitalization
+ *
+ */
+EOAPI void  edje_obj_part_text_autocapital_type_set(const char *part, Edje_Text_Autocapital_Type autocapital_type);
+
+/**
+ *
+ * @brief Retrieves the autocapitalization type
+ *
+ * @return The autocapitalization type
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Edje_Text_Autocapital_Type  edje_obj_part_text_autocapital_type_get(const char *part);
+
+/**
+ *
+ * @brief Unswallow an object.
+ *
+ * Causes the edje to regurgitate a previously swallowed object. :)
+ *
+ * @note @p obj_swallow will @b not be deleted or hidden.
+ * @note @p obj_swallow may appear shown on the evas depending on its state when
+ * it got unswallowed. Make sure you delete it or hide it if you do not want it to.
+ * 
+ *
+ * @param[in] obj_swallow The swallowed object
+ *
+ */
+EOAPI void  edje_obj_part_unswallow(Evas_Object *obj_swallow);
+
+/**
+ *
+ * @brief Set whether the prediction is allowed or not.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] prediction If true, the prediction feature is allowed.
+ *
+ */
+EOAPI void  edje_obj_part_text_prediction_allow_set(const char *part, Eina_Bool prediction);
+
+/**
+ *
+ * @brief Get whether the prediction is allowed or not.
+ *
+ * @return EINA_TRUE if prediction feature is allowed.
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_prediction_allow_get(const char *part);
+
+/**
+ *
+ * @brief Retrive an <b>EDC data field's value</b> from a given Edje
+ * object's group.
+ *
+ * @return The data's value string. Must not be freed.
+ *
+ * This function fetches an EDC data field's value, which is declared
+ * on the objects building EDC file, <b>under its group</b>. EDC data
+ * blocks are most commonly used to pass arbitrary parameters from an
+ * application's theme to its code.
+ *
+ * They look like the following:
+ *
+ * @code
+ * collections {
+ * group {
+ * name: "a_group";
+ * data {
+ * item: "key1" "value1";
+ * item: "key2" "value2";
+ * }
+ * }
+ * }
+ * @endcode
+ *
+ * EDC data fields always hold @b strings as values, hence the return
+ * type of this function. Check the complete @ref edcref "syntax reference"
+ * for EDC files.
+ *
+ * @warning Do not confuse this call with edje_file_data_get(), which
+ * queries for a @b global EDC data field on an EDC declaration file.
+ *
+ * @see edje_object_file_set()
+ * 
+ *
+ * @param[in] key The data field's key string
+ *
+ */
+EOAPI const char * edje_obj_data_get(const char *key);
+
+/**
+ *
+ * Add a markup filter function for newly inserted text.
+ *
+ * Whenever text is inserted (not the same as set) into the given @p part,
+ * the list of markup filter functions will be called to decide if and how
+ * the new text will be accepted.
+ * The text parameter in the @p func filter is always markup. It can be
+ * modified by the user and it's up to him to free the one passed if he's to
+ * change the pointer. If doing so, the newly set text should be malloc'ed,
+ * as once all the filters are called Edje will free it.
+ * If the text is to be rejected, freeing it and setting the pointer to NULL
+ * will make Edje break out of the filter cycle and reject the inserted
+ * text.
+ * This function is different from edje_object_text_insert_filter_callback_add()
+ * in that the text parameter in the @p fucn filter is always markup.
+ *
+ * @warning If you use this function with
+ * edje_object_text_insert_filter_callback_add() togehter, all
+ * Edje_Text_Filter_Cb functions and Edje_Markup_Filter_Cb functions
+ * will be executed, and then filtered text will be inserted.
+ *
+ * @see edje_object_text_markup_filter_callback_del
+ * @see edje_object_text_markup_filter_callback_del_full
+ * @see edje_object_text_insert_filter_callback_add
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The callback function that will act as markup filter
+ * @param[in] data User provided data to pass to the filter function
+ *
+ */
+EOAPI void  edje_obj_text_markup_filter_callback_add(const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Process an object's message queue.
+ *
+ * This function goes through the object message queue processing the
+ * pending messages for @b this specific Edje object. Normally they'd
+ * be processed only at idle time.
+ * 
+ *
+ *
+ */
+EOAPI void  edje_obj_message_signal_process(void);
+
+/**
+ *
+ * @brief Removes an object from the box.
+ *
+ * @return Pointer to the object removed, or @c NULL.
+ *
+ * Removes child from the box indicated by part.
+ *
+ * @see edje_object_part_box_remove_at()
+ * @see edje_object_part_box_remove_all()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to remove
+ *
+ */
+EOAPI Evas_Object * edje_obj_part_box_remove(const char *part, Evas_Object *child);
+
+/**
+ *
+ * @brief Thaws the Edje object.
+ *
+ * @return The frozen state or 0 if the object is not frozen or on error.
+ *
+ * This function thaws the given Edje object.
+ *
+ * @note: If sucessives freezes were done, an equal number of
+ * thaws will be required.
+ *
+ * @see edje_object_freeze()
+ * 
+ *
+ *
+ */
+EOAPI int  edje_obj_thaw(void);
+
+/**
+ *
+ * @brief Get the object currently swallowed by a part.
+ *
+ * @return The swallowed object, or NULL if there is none.
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Evas_Object * edje_obj_part_swallow_get(const char *part);
+
+/**
+ *
+ * @brief Reset the input method context if needed.
+ *
+ * This can be necessary in the case where modifying the buffer would confuse on-going input method behavior
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_imf_context_reset(const char *part);
+
+/**
+ *
+ * Set the "return" key type. This type is used to set string or icon on the "return" key of the input panel.
+ *
+ * An input panel displays the string or icon associated with this type
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] return_key_type The type of "return" key on the input panel
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_return_key_type_set(const char *part, Edje_Input_Panel_Return_Key_Type return_key_type);
+
+/**
+ *
+ * Get the "return" key type.
+ *
+ * @see edje_object_part_text_input_panel_return_key_type_set() for more details
+ *
+ * @return The type of "return" key on the input panel
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Edje_Input_Panel_Return_Key_Type  edje_obj_part_text_input_panel_return_key_type_get(const char *part);
+
+/**
+ *
+ * @brief Retrieve a child from a table
+ *
+ * @return The child Evas_Object
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] col The column of the child to get
+ * @param[in] row The row of the child to get
+ *
+ */
+EOAPI Evas_Object * edje_obj_part_table_child_get(const char *part, unsigned int col, unsigned int row);
+
+/**
+ *
+ * @brief Adds an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Inserts child in the box given by part, in the position marked by
+ * reference.
+ *
+ * @see edje_object_part_box_append()
+ * @see edje_object_part_box_prepend()
+ * @see edje_object_part_box_insert_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to insert
+ * @param[in] reference The object to be used as reference
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_box_insert_before(const char *part, Evas_Object *child, const Evas_Object *reference);
+
+/**
+ *
+ * @brief Set the parameter for the external part.
+ *
+ * Parts of type external may carry extra properties that have
+ * meanings defined by the external plugin. For instance, it may be a
+ * string that defines a button label and setting this property will
+ * change that label on the fly.
+ *
+ * @note external parts have parameters set when they change
+ * states. Those parameters will never be changed by this
+ * function. The interpretation of how state_set parameters and
+ * param_set will interact is up to the external plugin.
+ *
+ * @note this function will not check if parameter value is valid
+ * using #Edje_External_Param_Info minimum, maximum, valid
+ * choices and others. However these should be checked by the
+ * underlying implementation provided by the external
+ * plugin. This is done for performance reasons.
+ *
+ * @return @c EINA_TRUE if everything went fine, @c EINA_FALSE on errors.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] param the parameter details, including its name, type and
+actual value. This pointer should be valid, and the
+parameter must exist in
+#Edje_External_Type.parameters_info, with the exact type,
+otherwise the operation will fail and @c EINA_FALSE will be
+returned.
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_external_param_set(const char *part, const Edje_External_Param *param);
+
+/**
+ *
+ * @brief Get the parameter for the external part.
+ *
+ * Parts of type external may carry extra properties that have
+ * meanings defined by the external plugin. For instance, it may be a
+ * string that defines a button label. This property can be modified by
+ * state parameters, by explicit calls to
+ * edje_object_part_external_param_set() or getting the actual object
+ * with edje_object_part_external_object_get() and calling native
+ * functions.
+ *
+ * This function asks the external plugin what is the current value,
+ * independent on how it was set.
+ *
+ * @return @c EINA_TRUE if everything went fine and @p param members
+ * are filled with information, @c EINA_FALSE on errors and @p
+ * param member values are not set or valid.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] param the parameter details. It is used as both input and
+output variable. This pointer should be valid, and the
+parameter must exist in
+#Edje_External_Type.parameters_info, with the exact type,
+otherwise the operation will fail and @c EINA_FALSE will be
+returned.
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_external_param_get(const char *part, Edje_External_Param *param);
+
+/**
+ *
+ * @brief Calculate the minimum required size for a given Edje object.
+ *
+ * This call works exactly as edje_object_size_min_restricted_calc(),
+ * with the last two arguments set to 0. Please refer to its
+ * documentation, then.
+ * 
+ *
+ * @param[out] minw Pointer to a variable where to store the minimum
+required width
+ * @param[out] minh Pointer to a variable where to store the minimum
+required height
+ *
+ */
+EOAPI void  edje_obj_size_min_calc(Evas_Coord *minw, Evas_Coord *minh);
+
+/**
+ *
+ * @brief Appends an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Appends child to the box indicated by part.
+ *
+ * @see edje_object_part_box_prepend()
+ * @see edje_object_part_box_insert_before()
+ * @see edje_object_part_box_insert_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to append
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_box_append(const char *part, Evas_Object *child);
+
+/**
+ *
+ * @brief Calculate the minimum required size for a given Edje object.
+ *
+ * This call will trigger an internal recalculation of all parts of
+ * the @p obj object, in order to return its minimum required
+ * dimensions for width and height. The user might choose to @b impose
+ * those minimum sizes, making the resulting calculation to get to values
+ * equal or bigger than @p restrictedw and @p restrictedh, for width and
+ * height, respectively.
+ *
+ * @note At the end of this call, @p obj @b won't be automatically
+ * resized to new dimensions, but just return the calculated
+ * sizes. The caller is the one up to change its geometry or not.
+ *
+ * @warning Be advised that invisible parts in @p obj @b will be taken
+ * into account in this calculation.
+ * 
+ *
+ * @param[out] minw Pointer to a variable where to store the minimum
+required width
+ * @param[out] minh Pointer to a variable where to store the minimum
+required height
+ * @param[in] restrictedw Do not allow object's calculated (minimum) width
+to be less than this value
+ * @param[in] restrictedh Do not allow object's calculated (minimum)
+height to be less than this value
+ *
+ */
+EOAPI void  edje_obj_size_min_restricted_calc(Evas_Coord *minw, Evas_Coord *minh, Evas_Coord restrictedw, Evas_Coord restrictedh);
+
+/**
+ *
+ * @brief Removes all elements from the box.
+ *
+ * @return 1: Successfully cleared.\n
+ * 0: An error occurred.
+ *
+ * Removes all the external objects from the box indicated by part.
+ * Elements created from the theme will not be removed.
+ *
+ * @see edje_object_part_box_remove()
+ * @see edje_object_part_box_remove_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] clear Delete objects on removal
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_box_remove_all(const char *part, Eina_Bool clear);
+
+/**
+ *
+ * @brief Pages x,y steps.
+ *
+ * Pages x,y where the increment is defined by
+ * edje_object_part_drag_page_set.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1.
+ *
+ * @warning Paging is bugged!
+ *
+ * @see edje_object_part_drag_step()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x step
+ * @param[in] dy The y step
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_page(const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Sets the text for an object part
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE otherwise
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_set(const char *part, const char *text);
+
+/**
+ *
+ * @brief Return the text of the object part.
+ *
+ * @return The text string
+ *
+ * This function returns the text associated to the object part.
+ *
+ * @see edje_object_part_text_set().
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI const char * edje_obj_part_text_get(const char *part);
+
+/**
+ *
+ * Set the attribute to show the input panel in case of only an user's explicit Mouse Up event.
+ * It doesn't request to show the input panel even though it has focus.
+ *
+ * @since 1.9.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] ondemand If true, the input panel will be shown in case of only Mouse up event. (Focus event will be ignored.)
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_show_on_demand_set(const char *part, Eina_Bool ondemand);
+
+/**
+ *
+ * Get the attribute to show the input panel in case of only an user's explicit Mouse Up event.
+ *
+ * @return @c EINA_TRUE if the input panel will be shown in case of only Mouse up event.
+ * @since 1.9.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_input_panel_show_on_demand_get(const char *part);
+
+/**
+ *
+ * Sets the input hint which allows input methods to fine-tune their behavior.
+ *
+ * @since 1.12.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] input_hints input hints
+ *
+ */
+EOAPI void  edje_obj_part_text_input_hint_set(const char *part, Edje_Input_Hints input_hints);
+
+/**
+ *
+ * Gets the value of input hint
+ *
+ * @return The value of input hint
+ * @since 1.12.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI Edje_Input_Hints  edje_obj_part_text_input_hint_get(const char *part);
+
+/**
+ *
+ * @brief Return the selection text of the object part.
+ *
+ * @return The text string
+ *
+ * This function returns selection text of the object part.
+ *
+ * @see edje_object_part_text_select_all()
+ * @see edje_object_part_text_select_none()
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI const char * edje_obj_part_text_selection_get(const char *part);
+
+/**
+ *
+ * @brief Returns whether the cursor points to a format.
+ * @see evas_textblock_cursor_is_format
+ *
+ * @return EINA_TRUE if it's true, EINA_FALSE otherwise.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to adjust.
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_cursor_is_format_get(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets the object color class.
+ *
+ * This function sets the color values for an object level color
+ * class. This will cause all edje parts in the specified object that
+ * have the specified color class to have their colors multiplied by
+ * these values.
+ *
+ * The first color is the object, the second is the text outline, and
+ * the third is the text shadow. (Note that the second two only apply
+ * to text parts).
+ *
+ * Setting color emits a signal "color_class,set" with source being
+ * the given color.
+ *
+ * @note unlike Evas, Edje colors are @b not pre-multiplied. That is,
+ * half-transparent white is 255 255 255 128.
+ * 
+ *
+ * @param[in] color_class No description supplied.
+ * @param[in] r Object Red value
+ * @param[in] g Object Green value
+ * @param[in] b Object Blue value
+ * @param[in] a Object Alpha value
+ * @param[in] r2 Outline Red value
+ * @param[in] g2 Outline Green value
+ * @param[in] b2 Outline Blue value
+ * @param[in] a2 Outline Alpha value
+ * @param[in] r3 Shadow Red value
+ * @param[in] g3 Shadow Green value
+ * @param[in] b3 Shadow Blue value
+ * @param[in] a3 Shadow Alpha value
+ *
+ */
+EOAPI Eina_Bool  edje_obj_color_class_set(const char *color_class, int r, int g, int b, int a, int r2, int g2, int b2, int a2, int r3, int g3, int b3, int a3);
+
+/**
+ *
+ * @brief Gets the object color class.
+ *
+ * @return EINA_TRUE if found or EINA_FALSE if not found and all
+ * values are zeroed.
+ *
+ * This function gets the color values for an object level color
+ * class. If no explicit object color is set, then global values will
+ * be used.
+ *
+ * The first color is the object, the second is the text outline, and
+ * the third is the text shadow. (Note that the second two only apply
+ * to text parts).
+ *
+ * @note unlike Evas, Edje colors are @b not pre-multiplied. That is,
+ * half-transparent white is 255 255 255 128.
+ * 
+ *
+ * @param[in] color_class No description supplied.
+ * @param[out] r Object Red value
+ * @param[out] g Object Green value
+ * @param[out] b Object Blue value
+ * @param[out] a Object Alpha value
+ * @param[out] r2 Outline Red value
+ * @param[out] g2 Outline Green value
+ * @param[out] b2 Outline Blue value
+ * @param[out] a2 Outline Alpha value
+ * @param[out] r3 Shadow Red value
+ * @param[out] g3 Shadow Green value
+ * @param[out] b3 Shadow Blue value
+ * @param[out] a3 Shadow Alpha value
+ *
+ */
+EOAPI Eina_Bool  edje_obj_color_class_get(const char *color_class, int *r, int *g, int *b, int *a, int *r2, int *g2, int *b2, int *a2, int *r3, int *g3, int *b3, int *a3);
+
+/**
+ *
+ * @brief Steps the dragable x,y steps.
+ *
+ * Steps x,y where the step increment is the amount set by
+ * edje_object_part_drag_step_set.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1.
+ *
+ * @see edje_object_part_drag_page()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x step
+ * @param[in] dy The y step
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_drag_step(const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Move the cursor to the char above the current cursor position.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_cursor_up(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Returns the cursor geometry of the part relative to the edje
+ * object.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] x Cursor X position
+ * @param[out] y Cursor Y position
+ * @param[out] w Cursor width
+ * @param[out] h Cursor height
+ *
+ */
+EOAPI void  edje_obj_part_text_cursor_geometry_get(const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * @brief Return a list of char anchor names.
+ *
+ * @return The list of anchors (const char *), do not modify!
+ *
+ * This function returns a list of char anchor names.
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI const Eina_List * edje_obj_part_text_anchor_list_get(const char *part);
+
+/**
+ *
+ * Add a filter function for newly inserted text.
+ *
+ * Whenever text is inserted (not the same as set) into the given @p part,
+ * the list of filter functions will be called to decide if and how the new
+ * text will be accepted.
+ * There are three types of filters, EDJE_TEXT_FILTER_TEXT,
+ * EDJE_TEXT_FILTER_FORMAT and EDJE_TEXT_FILTER_MARKUP.
+ * The text parameter in the @p func filter can be modified by the user and
+ * it's up to him to free the one passed if he's to change the pointer. If
+ * doing so, the newly set text should be malloc'ed, as once all the filters
+ * are called Edje will free it.
+ * If the text is to be rejected, freeing it and setting the pointer to NULL
+ * will make Edje break out of the filter cycle and reject the inserted
+ * text.
+ *
+ * @warning This function will be deprecated because of difficulty in use.
+ * The type(format, text, or markup) of text should be always
+ * checked in the filter function for correct filtering.
+ * Please use edje_object_text_markup_filter_callback_add() instead. There
+ * is no need to check the type of text in the filter function
+ * because the text is always markup.
+ * @warning If you use this function with
+ * edje_object_text_markup_filter_callback_add() together, all
+ * Edje_Text_Filter_Cb functions and Edje_Markup_Filter_Cb functions
+ * will be executed, and then filtered text will be inserted.
+ *
+ * @see edje_object_text_insert_filter_callback_del
+ * @see edje_object_text_insert_filter_callback_del_full
+ * @see edje_object_text_markup_filter_callback_add
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The callback function that will act as filter
+ * @param[in] data User provided data to pass to the filter function
+ *
+ */
+EOAPI void  edje_obj_text_insert_filter_callback_add(const char *part, Edje_Text_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Show the input panel (virtual keyboard) based on the input panel property such as layout, autocapital types, and so on.
+ *
+ * Note that input panel is shown or hidden automatically according to the focus state.
+ * This API can be used in the case of manually controlling by using edje_object_part_text_input_panel_enabled_set.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI void  edje_obj_part_text_input_panel_show(const char *part);
+
+/**
+ *
+ * @brief Check if an Edje part exists in a given Edje object's group
+ * definition.
+ *
+ * @return @c EINA_TRUE, if the Edje part exists in @p obj's group or
+ * @c EINA_FALSE, otherwise (and on errors)
+ *
+ * This function returns if a given part exists in the Edje group
+ * bound to object @p obj (with edje_object_file_set()).
+ *
+ * This call is useful, for example, when one could expect or not a
+ * given GUI element, depending on the @b theme applied to @p obj.
+ * 
+ *
+ * @param[in] part The part's name to check for existence in @p obj's
+group
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_exists(const char *part);
+
+/**
+ *
+ * Delete a function from the markup filter list.
+ *
+ * Delete the given @p func filter from the list in @p part. Returns
+ * the user data pointer given when added.
+ *
+ * @see edje_object_text_markup_filter_callback_add
+ * @see edje_object_text_markup_filter_callback_del_full
+ *
+ * @return The user data pointer if successful, or NULL otherwise
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ *
+ */
+EOAPI void * edje_obj_text_markup_filter_callback_del(const char *part, Edje_Markup_Filter_Cb func);
+
+/**
+ *
+ * @brief Return true if the cursor points to a visible format
+ * For example \\t, \\n, item and etc.
+ * @see  evas_textblock_cursor_format_is_visible_get
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to adjust.
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_cursor_is_visible_format_get(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief This function inserts text as if the user has inserted it.
+ *
+ * This means it actually registers as a change and emits signals, triggers
+ * callbacks as appropriate.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ *
+ */
+EOAPI void  edje_obj_part_text_user_insert(const char *part, const char *text);
+
+/**
+ *
+ * @brief Moves the cursor to the previous char
+ * @see evas_textblock_cursor_char_prev
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_text_cursor_prev(const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Return a list of char item names.
+ *
+ * @return The list of items (const char *), do not modify!
+ *
+ * This function returns a list of char item names.
+ * 
+ *
+ * @param[in] part The part name
+ *
+ */
+EOAPI const Eina_List * edje_obj_part_text_item_list_get(const char *part);
+
+/**
+ *
+ * @brief "Swallows" an object into one of the Edje object @c SWALLOW
+ * parts.
+ *
+ * Swallowing an object into an Edje object is, for a given part of
+ * type @c SWALLOW in the EDC group which gave life to @a obj, to set
+ * an external object to be controlled by @a obj, being displayed
+ * exactly over that part's region inside the whole Edje object's
+ * viewport.
+ *
+ * From this point on, @a obj will have total control over @a
+ * obj_swallow's geometry and visibility. For instance, if @a obj is
+ * visible, as in @c evas_object_show(), the swallowed object will be
+ * visible too -- if the given @c SWALLOW part it's in is also
+ * visible. Other actions on @a obj will also reflect on the swallowed
+ * object as well (e.g. resizing, moving, raising/lowering, etc.).
+ *
+ * Finally, all internal changes to @a part, specifically, will
+ * reflect on the displaying of @a obj_swallow, for example state
+ * changes leading to different visibility states, geometries,
+ * positions, etc.
+ *
+ * If an object has already been swallowed into this part, then it
+ * will first be unswallowed (as in edje_object_part_unswallow())
+ * before the new object is swallowed.
+ *
+ * @note @a obj @b won't delete the swallowed object once it is
+ * deleted -- @a obj_swallow will get to an unparented state again.
+ *
+ * For more details on EDC @c SWALLOW parts, see @ref edcref "syntax
+ * reference".
+ * 
+ *
+ * @param[in] part The swallow part's name
+ * @param[in] obj_swallow The object to occupy that part
+ *
+ */
+EOAPI Eina_Bool  edje_obj_part_swallow(const char *part, Evas_Object *obj_swallow);
+
+
+#endif
diff -Naur a/src/lib/edje/edje_object.eo.hh b/src/lib/edje/edje_object.eo.hh
--- a/src/lib/edje/edje_object.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_object.eo.hh	2014-11-27 00:57:33.470380026 +0200
@@ -0,0 +1,6951 @@
+#ifndef EFL_GENERATED_EDJE_OBJECT_HH
+#define EFL_GENERATED_EDJE_OBJECT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "edje_object.eo.h"
+}
+
+#include "evas_smart_clipped.eo.hh"
+#include "efl_file.eo.hh"
+#include <canvas/evas_object.eo.hh>
+#include <string>
+
+namespace edje {
+
+struct object
+      : evas::smart_clipped,
+      efl::eo::detail::extension_inheritance<efl::file>::template type< ::edje::object>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit object(Eo* eo)
+      : evas::smart_clipped(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit object(std::nullptr_t)
+      : evas::smart_clipped(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   object(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : object(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   object(object const& other)
+      : evas::smart_clipped(eo_ref(other._eo_ptr()))
+   {}
+
+   ~object() {}
+
+   /// @brief Get dbg information from the object.
+   ///
+   /// @param root_node node of the tree
+   ///
+   void dbg_info_get(Eo_Dbg_Info * root_node_) const
+   {
+      eo_do(_eo_ptr(), ::eo_dbg_info_get(root_node_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void hide() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_hide());
+   }
+
+   /// @brief Call the @b calculate() smart function immediately on a given smart
+   /// object.
+   ///
+   /// This will force immediate calculations (see #Evas_Smart_Class)
+   /// needed for renderization of this object and, besides, unset the
+   /// flag on it telling it needs recalculation for the next rendering
+   /// phase.
+   ///
+   /// @see evas_object_smart_need_recalculate_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void calculate() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_calculate());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void show() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_show());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param x 
+   /// @param y 
+   ///
+   void move(Evas_Coord x_, Evas_Coord y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_move(x_, y_));
+   }
+
+   /// @brief Instantiates a new smart object described by @p s.
+   ///
+   /// @return a new #Evas_Object handle
+   ///
+   /// This is the function one should use when defining the public
+   /// function @b adding an instance of the new smart object to a given
+   /// canvas. It will take care of setting all of its internals to work
+   /// as they should, if the user set things properly, as seem on the
+   /// #EVAS_SMART_SUBCLASS_NEW, for example.
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void add() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_add());
+   }
+
+   /// @brief Deletes a smart object.
+   ///
+   void del() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_del());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param w 
+   /// @param h 
+   ///
+   void resize(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+   }
+
+   /// @brief Set the source file from where an image object must fetch the real
+   /// image data (it may be an Eet file, besides pure image ones).
+   ///
+   /// If the file supports multiple data stored in it (as Eet files do),
+   /// you can specify the key to be used as the index of the image in
+   /// this file.
+   ///
+   /// Example:
+   /// @code
+   /// img = evas_object_image_add(canvas);
+   /// evas_object_image_file_set(img, "/path/to/img", NULL);
+   /// err = evas_object_image_load_error_get(img);
+   /// if (err != EVAS_LOAD_ERROR_NONE)
+   /// {
+   /// fprintf(stderr, "could not load image '%s'. error string is \"%s\"\n",
+   /// valid_path, evas_load_error_str(err));
+   /// }
+   /// else
+   /// {
+   /// evas_object_image_fill_set(img, 0, 0, w, h);
+   /// evas_object_resize(img, w, h);
+   /// evas_object_show(img);
+   /// }
+   /// @endcode
+   ///
+   /// @param file The image file path.
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   bool file_set(std::string file_, std::string key_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve the source file from where an image object is to fetch the
+   /// real image data (it may be an Eet file, besides pure image ones).
+   ///
+   /// You must @b not modify the strings on the returned pointers.
+   ///
+   /// @note Use @c NULL pointers on the file components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @param file The image file path.
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   void file_get(const char ** file_, const char ** key_) const
+   {
+      eo_do(_eo_ptr(), ::efl_file_get(file_, key_));
+   }
+
+   /// @brief @brief Whether or not Edje will update size hints on itself.
+   ///
+   /// @return @c true if does, @c false if it doesn't.
+   ///
+   /// @param update Whether or not update the size hints.
+   ///
+   bool update_hints_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_update_hints_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Edje will automatically update the size hints on itself.
+   ///
+   /// By default edje doesn't set size hints on itself. With this function
+   /// call, it will do so if update is true. Be carefully, it cost a lot to
+   /// trigger this feature as it will recalc the object every time it make
+   /// sense to be sure that's its minimal size hint is always accurate.
+   ///
+   /// @param update Whether or not update the size hints.
+   ///
+   void update_hints_set(bool update_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_update_hints_set(efl::eolian::to_c(update_)));
+   }
+
+   /// @brief @brief Get the RTL orientation for this object.
+   ///
+   /// You can RTL orientation explicitly with edje_object_mirrored_set.
+   ///
+   /// @return @c EINA_TRUE if the flag is set or @c EINA_FALSE if not.
+   /// @since 1.1.0
+   ///
+   /// @param rtl new value of flag EINA_TRUE/EINA_FALSE
+   ///
+   bool mirrored_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_mirrored_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the RTL orientation for this object.
+   ///
+   /// @since 1.1.0
+   ///
+   /// @param rtl new value of flag EINA_TRUE/EINA_FALSE
+   ///
+   void mirrored_set(bool rtl_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_mirrored_set(efl::eolian::to_c(rtl_)));
+   }
+
+   /// @brief @brief Get the Edje object's animation state.
+   ///
+   /// @return @c EINA_FALSE on error or if object is not animated;
+   /// @c EINA_TRUE if animated.
+   ///
+   /// This function returns if the animation is stopped or not. The
+   /// animation state is set by edje_object_animation_set().
+   ///
+   /// @see edje_object_animation_set().
+   ///
+   /// @param on The animation state. @c EINA_TRUE to starts or
+   /// @c EINA_FALSE to stops.
+   ///
+   bool animation_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_animation_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the object's animation state.
+   ///
+   /// This function starts or stops an Edje object's animation. The
+   /// information if it's stopped can be retrieved by
+   /// edje_object_animation_get().
+   ///
+   /// @see edje_object_animation_get()
+   ///
+   /// @param on The animation state. @c EINA_TRUE to starts or
+   /// @c EINA_FALSE to stops.
+   ///
+   void animation_set(bool on_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_animation_set(efl::eolian::to_c(on_)));
+   }
+
+   /// @brief @brief Get the Edje object's state.
+   ///
+   /// @return @c EINA_FALSE if the object is not connected, its @c delete_me flag
+   /// is set, or it is at paused state; @c EINA_TRUE if the object is at playing
+   /// state.
+   ///
+   /// This function tells if an Edje object is playing or not. This state
+   /// is set by edje_object_play_set().
+   ///
+   /// @see edje_object_play_set().
+   ///
+   /// @param play Object state (@c EINA_TRUE to playing,
+   /// @c EINA_FALSE to paused).
+   ///
+   bool play_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_play_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the Edje object to playing or paused states.
+   ///
+   /// This function sets the Edje object @a obj to playing or paused
+   /// states, depending on the parameter @a play. This has no effect if
+   /// the object was already at that state.
+   ///
+   /// @see edje_object_play_get().
+   ///
+   /// @param play Object state (@c EINA_TRUE to playing,
+   /// @c EINA_FALSE to paused).
+   ///
+   void play_set(bool play_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_play_set(efl::eolian::to_c(play_)));
+   }
+
+   /// @brief Get the current perspective used on this Edje object.
+   ///
+   /// @return The perspective object being used on this Edje object. Or @c NULL
+   /// if there was none, and on errors.
+   ///
+   /// @see edje_object_perspective_set()
+   ///
+   /// @param ps The perspective object that will be used.
+   ///
+   const Edje_Perspective * perspective_get() const
+   {
+      const Edje_Perspective * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_perspective_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the given perspective object on this Edje object.
+   ///
+   /// Make the given perspective object be the default perspective for this Edje
+   /// object.
+   ///
+   /// There can be only one perspective object per Edje object, and if a
+   /// previous one was set, it will be removed and the new perspective object
+   /// will be used.
+   ///
+   /// An Edje perspective will only affect a part if it doesn't point to another
+   /// part to be used as perspective.
+   ///
+   /// @see edje_object_perspective_new()
+   /// @see edje_object_perspective_get()
+   /// @see edje_perspective_set()
+   ///
+   /// @param ps The perspective object that will be used.
+   ///
+   void perspective_set(Edje_Perspective * ps_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_perspective_set(ps_));
+   }
+
+   /// @brief @brief Get a given Edje object's scaling factor.
+   ///
+   /// This function returns the @c individual scaling factor set on the
+   /// @a obj Edje object.
+   ///
+   /// @see edje_object_scale_set() for more details
+   ///
+   /// @param scale The scaling factor (the default value is @c 0.0,
+   /// meaning individual scaling @b not set)
+   ///
+   double scale_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_scale_get());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Set the scaling factor for a given Edje object.
+   ///
+   /// This function sets an @b individual scaling factor on the @a obj
+   /// Edje object. This property (or Edje's global scaling factor, when
+   /// applicable), will affect this object's part sizes. If @p scale is
+   /// not zero, than the individual scaling will @b override any global
+   /// scaling set, for the object @p obj's parts. Put it back to zero to
+   /// get the effects of the global scaling again.
+   ///
+   /// @warning Only parts which, at EDC level, had the @c "scale"
+   /// property set to @c 1, will be affected by this function. Check the
+   /// complete @ref edcref "syntax reference" for EDC files.
+   ///
+   /// @see edje_object_scale_get()
+   /// @see edje_scale_get() for more details
+   ///
+   /// @param scale The scaling factor (the default value is @c 0.0,
+   /// meaning individual scaling @b not set)
+   ///
+   bool scale_set(double scale_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_scale_set(scale_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get a given Edje object's base_scale factor.
+   ///
+   /// This function returns the base_scale factor set on the
+   /// @a obj Edje object.
+   /// The base_scale can be set in the collection of edc.
+   /// If it isn't set, the default value is 1.0
+   ///
+   /// @param base_scale 
+   ///
+   double base_scale_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_base_scale_get());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Sets the @b EDJ file (and group within it) to load an Edje
+   /// object's contents from
+   ///
+   /// @return @c EINA_TRUE, on success or @c EINA_FALSE, on errors (check
+   /// edje_object_load_error_get() after this call to get errors causes)
+   ///
+   /// Edje expects EDJ files, which are theming objects' descriptions and
+   /// resources packed together in an EET file, to read Edje object
+   /// definitions from. They usually are created with the @c .edj
+   /// extension. EDJ files, in turn, are assembled from @b textual object
+   /// description files, where one describes Edje objects declaratively
+   /// -- the EDC files (see @ref edcref "the syntax" for those files).
+   ///
+   /// Those description files were designed so that many Edje object
+   /// definitions -- also called @b groups (or collections) -- could be
+   /// packed together <b>in the same EDJ file</b>, so that a whole
+   /// application's theme could be packed in one file only. This is the
+   /// reason for the @p group argument.
+   ///
+   /// Use this function after you instantiate a new Edje object, so that
+   /// you can "give him life", telling where to get its contents from.
+   ///
+   /// @see edje_object_add()
+   /// @see edje_object_file_get()
+   /// @see edje_object_mmap_set()
+   /// @since 1.8
+   ///
+   /// @param file The Eina.File pointing to the EDJ file to load @p from
+   /// @param group The name of the group, in @p file, which implements an
+   /// Edje object
+   ///
+   bool mmap_set(const Eina_File * file_, std::string group_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_mmap_set(file_, efl::eolian::to_c(group_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the object text callback.
+   ///
+   /// This function sets the callback to be called when the text changes.
+   ///
+   /// @param func The callback function to handle the text change
+   /// @param data The data associated to the callback function.
+   ///
+   void text_change_cb_set(Edje_Text_Change_Cb func_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_text_change_cb_set(func_, data_));
+   }
+
+   /// @brief @brief Moves the cursor to the beginning of the text part
+   /// @see evas_textblock_cursor_paragraph_first
+   ///
+   /// @param part The part name
+   /// @param cur the edje cursor to work on
+   ///
+   void part_text_cursor_begin_set(std::string part_, Edje_Cursor cur_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_cursor_begin_set(efl::eolian::to_c(part_), cur_));
+   }
+
+   /// @brief @brief Move the cursor to the end of the line.
+   /// @see evas_textblock_cursor_line_char_last
+   ///
+   /// @param part The part name
+   /// @param cur the edje cursor to work on
+   ///
+   void part_text_cursor_line_end_set(std::string part_, Edje_Cursor cur_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_cursor_line_end_set(efl::eolian::to_c(part_), cur_));
+   }
+
+   /// @brief @brief Sets Edje text class.
+   ///
+   /// @return @c EINA_TRUE, on success or @c EINA_FALSE, on error
+   ///
+   /// This function sets the text class for the Edje.
+   ///
+   /// @param text_class The text class name
+   /// @param font Font name
+   /// @param size Font Size
+   ///
+   bool text_class_set(std::string text_class_, std::string font_, Evas_Font_Size size_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_text_class_set(efl::eolian::to_c(text_class_), efl::eolian::to_c(font_), size_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Position the given cursor to a X,Y position.
+   ///
+   /// This is frequently used with the user cursor.
+   ///
+   /// @return True on success, false on error.
+   ///
+   /// @param part The part containing the object.
+   /// @param cur The cursor to adjust.
+   /// @param x X Coordinate.
+   /// @param y Y Coordinate.
+   ///
+   bool part_text_cursor_coord_set(std::string part_, Edje_Cursor cur_, Evas_Coord x_, Evas_Coord y_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_coord_set(efl::eolian::to_c(part_), cur_, x_, y_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Moves the cursor to the end of the text part.
+   /// @see evas_textblock_cursor_paragraph_last
+   ///
+   /// @param part The part name
+   /// @param cur the edje cursor to work on
+   ///
+   void part_text_cursor_end_set(std::string part_, Edje_Cursor cur_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_cursor_end_set(efl::eolian::to_c(part_), cur_));
+   }
+
+   /// @brief @brief Sets the text for an object part, but converts HTML escapes to UTF8
+   ///
+   /// This converts the given string @p text to UTF8 assuming it contains HTML
+   /// style escapes like "&amp;" and "&copy;" etc. IF the part is of type TEXT,
+   /// as opposed to TEXTBLOCK.
+   ///
+   /// @return @c EINA_TRUE on success, @c EINA_FALSE otherwise
+   ///
+   /// @since 1.2
+   ///
+   /// @param part The part name
+   /// @param text The text string
+   ///
+   bool part_text_escaped_set(std::string part_, std::string text_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_escaped_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the function that provides item objects for named items in an edje entry text
+   ///
+   /// Item objects may be deleted any time by Edje, and will be deleted when the
+   /// Edje object is deleted (or file is set to a new file).
+   ///
+   /// @param func The function to call (or NULL to disable) to get item objects
+   /// @param data The data pointer to pass to the @p func callback
+   ///
+   void item_provider_set(Edje_Item_Provider_Cb func_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_item_provider_set(func_, data_));
+   }
+
+   /// @brief @brief Move the cursor to the beginning of the line.
+   /// @see evas_textblock_cursor_line_char_first
+   ///
+   /// @param part The part name
+   /// @param cur the edje cursor to work on
+   ///
+   void part_text_cursor_line_begin_set(std::string part_, Edje_Cursor cur_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_cursor_line_begin_set(efl::eolian::to_c(part_), cur_));
+   }
+
+   /// @brief @brief Set an Edje message handler function for a given Edje object.
+   ///
+   /// For scriptable programs on an Edje object's defining EDC file which
+   /// send messages with the @c send_message() primitive, one can attach
+   /// <b>handler functions</b>, to be called in the code which creates
+   /// that object (see @ref edcref "the syntax" for EDC files).
+   ///
+   /// This function associates a message handler function and the
+   /// attached data pointer to the object @p obj.
+   ///
+   /// @see edje_object_message_send()
+   ///
+   /// @param func The function to handle messages @b coming from @p obj
+   /// @param data Auxiliary data to be passed to @p func
+   ///
+   void message_handler_set(Edje_Message_Handler_Cb func_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_message_handler_set(func_, data_));
+   }
+
+   /// @brief @brief Get the minimum size specified -- as an EDC property -- for a
+   /// given Edje object
+   ///
+   /// This function retrieves the @p obj object's minimum size values,
+   /// <b>as declared in its EDC group definition</b>. Minimum size of
+   /// groups have the following syntax
+   /// @code
+   /// collections {
+   /// group {
+   /// name: "a_group";
+   /// min: 100 100;
+   /// }
+   /// }
+   /// @endcode
+   ///
+   /// where one declares a minimum size of 100 pixels both for width and
+   /// height. Those are (hint) values which should be respected when the
+   /// given object/group is to be controlled by a given container object
+   /// (e.g. an Edje object being "swallowed" into a given @c SWALLOW
+   /// typed part, as in edje_object_part_swallow()). Check the complete
+   /// @ref edcref "syntax reference" for EDC files.
+   ///
+   /// @note If the @c min EDC property was not declared for @p obj, this
+   /// call will return the value 0, for each axis.
+   ///
+   /// @note On failure, this function will make all non-@c NULL size
+   /// pointers' pointed variables be set to zero.
+   ///
+   /// @see edje_object_size_max_get()
+   ///
+   /// @param minw Pointer to a variable where to store the minimum width
+   /// @param minh Pointer to a variable where to store the minimum height
+   ///
+   void size_min_get(Evas_Coord* minw_, Evas_Coord* minh_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_size_min_get(minw_, minh_));
+   }
+
+   /// @brief @brief Retrieve a list all accessibility part names
+   ///
+   /// @return A list all accessibility part names on @p obj
+   /// @since 1.7.0
+   ///
+   efl::eina::range_list< std::string > access_part_list_get() const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_access_part_list_get());
+      return efl::eolian::to_cxx<efl::eina::range_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief @brief Gets the (last) file loading error for a given Edje object
+   ///
+   /// @return The Edje loading error, one of:
+   /// - #EDJE_LOAD_ERROR_NONE
+   /// - #EDJE_LOAD_ERROR_GENERIC
+   /// - #EDJE_LOAD_ERROR_DOES_NOT_EXIST
+   /// - #EDJE_LOAD_ERROR_PERMISSION_DENIED
+   /// - #EDJE_LOAD_ERROR_RESOURCE_ALLOCATION_FAILED
+   /// - #EDJE_LOAD_ERROR_CORRUPT_FILE
+   /// - #EDJE_LOAD_ERROR_UNKNOWN_FORMAT
+   /// - #EDJE_LOAD_ERROR_INCOMPATIBLE_FILE
+   /// - #EDJE_LOAD_ERROR_UNKNOWN_COLLECTION
+   /// - #EDJE_LOAD_ERROR_RECURSIVE_REFERENCE
+   ///
+   /// This function is meant to be used after an Edje EDJ <b>file
+   /// loading</b>, what takes place with the edje_object_file_set()
+   /// function. If that function does not return @c EINA_TRUE, one should
+   /// check for the reason of failure with this one.
+   ///
+   /// @see edje_load_error_str()
+   ///
+   Edje_Load_Error load_error_get() const
+   {
+      Edje_Load_Error _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_load_error_get());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Get the maximum size specified -- as an EDC property -- for a
+   /// given Edje object
+   ///
+   /// This function retrieves the @p obj object's maximum size values,
+   /// <b>as declared in its EDC group definition</b>. Maximum size of
+   /// groups have the following syntax
+   /// @code
+   /// collections {
+   /// group {
+   /// name: "a_group";
+   /// max: 100 100;
+   /// }
+   /// }
+   /// @endcode
+   ///
+   /// where one declares a maximum size of 100 pixels both for width and
+   /// height. Those are (hint) values which should be respected when the
+   /// given object/group is to be controlled by a given container object
+   /// (e.g. an Edje object being "swallowed" into a given @c SWALLOW
+   /// typed part, as in edje_object_part_swallow()). Check the complete
+   /// @ref edcref "syntax reference" for EDC files.
+   ///
+   /// @note If the @c max EDC property was not declared for @p obj, this
+   /// call will return the maximum size a given Edje object may have, for
+   /// each axis.
+   ///
+   /// @note On failure, this function will make all non-@c NULL size
+   /// pointers' pointed variables be set to zero.
+   ///
+   /// @see edje_object_size_min_get()
+   ///
+   /// @param maxw Pointer to a variable where to store the maximum width
+   /// @param maxh Pointer to a variable where to store the maximum height
+   ///
+   void size_max_get(Evas_Coord* maxw_, Evas_Coord* maxh_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_size_max_get(maxw_, maxh_));
+   }
+
+   /// @brief @brief Removes all object from the table.
+   ///
+   /// @return @c EINA_TRUE clear the table, @c EINA_FALSE on failure
+   ///
+   /// Removes all object from the table indicated by part, except the
+   /// internal ones set from the theme.
+   ///
+   /// @param part The part name
+   /// @param clear If set, will delete subobjs on remove
+   ///
+   bool part_table_clear(std::string part_, bool clear_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_table_clear(efl::eolian::to_c(part_), efl::eolian::to_c(clear_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Facility to query the type of the given parameter of the given part.
+   ///
+   /// @return @c EDJE_EXTERNAL_PARAM_TYPE_MAX on errors, or another value
+   /// from #Edje_External_Param_Type on success.
+   ///
+   /// @param part The part name
+   /// @param[out] param the parameter name to use.
+   ///
+   Edje_External_Param_Type part_external_param_type_get(std::string part_, const char* param_) const
+   {
+      Edje_External_Param_Type _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_external_param_type_get(efl::eolian::to_c(part_), param_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Enables selection if the entry is an EXPLICIT selection mode
+   /// type.
+   ///
+   /// The default is to @b not allow selection. This function only affects user
+   /// selection, functions such as edje_object_part_text_select_all() and
+   /// edje_object_part_text_select_none() are not affected.
+   ///
+   /// @param part The part name
+   /// @param allow EINA_TRUE to enable, EINA_FALSE otherwise
+   ///
+   void part_text_select_allow_set(std::string part_, bool allow_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_select_allow_set(efl::eolian::to_c(part_), efl::eolian::to_c(allow_)));
+   }
+
+   /// @brief @brief Returns the state of the Edje part.
+   ///
+   /// @return The part state:\n
+   /// "default" for the default state\n
+   /// "" for other states
+   ///
+   /// @param part The part name
+   /// @param[out] val_ret 
+   ///
+   std::string part_state_get(std::string part_, double* val_ret_) const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_state_get(efl::eolian::to_c(part_), val_ret_));
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Delete a function and matching user data from the markup filter list.
+   ///
+   /// Delete the given @p func filter and @p data user data from the list
+   /// in @p part.
+   /// Returns the user data pointer given when added.
+   ///
+   /// @see edje_object_text_markup_filter_callback_add
+   /// @see edje_object_text_markup_filter_callback_del
+   ///
+   /// @return The same data pointer if successful, or NULL otherwise
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param func The function callback to remove
+   /// @param data The data passed to the callback function
+   ///
+   void * text_markup_filter_callback_del_full(std::string part_, Edje_Markup_Filter_Cb func_, void * data_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_text_markup_filter_callback_del_full(efl::eolian::to_c(part_), func_, data_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Sets the drag step increment.
+   ///
+   /// Sets the x,y step increments for a dragable object.
+   ///
+   /// Values for @p dx and @p dy are real numbers that range from 0 to 1,
+   /// representing the relative size of the dragable area on that axis by which the
+   /// part will be moved.
+   ///
+   /// @see edje_object_part_drag_step_get()
+   ///
+   /// @param part The part name
+   /// @param dx The x step amount
+   /// @param dy The y step amount
+   ///
+   bool part_drag_step_set(std::string part_, double dx_, double dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_step_set(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Gets the drag step increment values.
+   ///
+   /// Gets the x and y step increments for the dragable object.
+   ///
+   ///
+   /// @see edje_object_part_drag_step_set()
+   ///
+   /// @param part The part
+   /// @param[out] dx The x step increment pointer
+   /// @param[out] dy The y step increment pointer
+   ///
+   bool part_drag_step_get(std::string part_, double* dx_, double* dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_step_get(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get the input method context in entry.
+   ///
+   /// If ecore_imf was not available when edje was compiled, this function returns NULL
+   /// otherwise, the returned pointer is an Ecore_IMF
+   ///
+   /// @return The input method context (Ecore_IMF_Context *) in entry
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   void * part_text_imf_context_get(std::string part_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_imf_context_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Starts selecting at current cursor position
+   ///
+   /// @param part The part name
+   ///
+   void part_text_select_begin(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_select_begin(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief @brief Return the text of the object part.
+   ///
+   /// @return The text string
+   ///
+   /// This function returns the style associated with the textblock part.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   std::string part_text_style_user_peek(std::string part_) const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_style_user_peek(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Remove a signal-triggered callback from an object.
+   ///
+   /// @return The data pointer
+   ///
+   /// This function removes a callback, previously attached to the
+   /// emittion of a signal, from the object @a obj. The parameters @a
+   /// emission, @a source and @a func must match exactly those passed to
+   /// a previous call to edje_object_signal_callback_add(). The data
+   /// pointer that was passed to this call will be returned.
+   ///
+   /// @see edje_object_signal_callback_add().
+   /// @see edje_object_signal_callback_del_full().
+   ///
+   /// @param emission The emission string.
+   /// @param source The source string.
+   /// @param func The callback function.
+   /// @param data The callback function.
+   ///
+   void * signal_callback_del(std::string emission_, std::string source_, Edje_Signal_Cb func_, void * data_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_signal_callback_del(efl::eolian::to_c(emission_), efl::eolian::to_c(source_), func_, data_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Advances the cursor to the next cursor position.
+   /// @see evas_textblock_cursor_char_next
+   ///
+   /// @param part The part name
+   /// @param cur The edje cursor to advance
+   ///
+   bool part_text_cursor_next(std::string part_, Edje_Cursor cur_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_next(efl::eolian::to_c(part_), cur_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the style of the
+   ///
+   /// This function sets the style associated with the textblock part.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param style The style to set (textblock conventions).
+   ///
+   void part_text_style_user_push(std::string part_, std::string style_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_style_user_push(efl::eolian::to_c(part_), efl::eolian::to_c(style_)));
+   }
+
+   /// @brief @brief Insert text for an object part.
+   ///
+   /// This function inserts the text for an object part at the end; It does not
+   /// move the cursor.
+   ///
+   /// @since 1.1
+   ///
+   /// @param part The part name
+   /// @param text The text string
+   ///
+   void part_text_append(std::string part_, std::string text_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_append(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+   }
+
+   /// @brief @brief Retrieve the geometry of a given Edje part, in a given Edje
+   /// object's group definition, <b>relative to the object's area</b>
+   ///
+   /// This function gets the geometry of an Edje part within its
+   /// group. The @p x and @p y coordinates are relative to the top left
+   /// corner of the whole @p obj object's area.
+   ///
+   /// @note Use @c NULL pointers on the geometry components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @note On failure, this function will make all non-@c NULL geometry
+   /// pointers' pointed variables be set to zero.
+   ///
+   /// @param part The Edje part's name
+   /// @param[out] x A pointer to a variable where to store the part's x
+   /// coordinate
+   /// @param[out] y A pointer to a variable where to store the part's y
+   /// coordinate
+   /// @param[out] w A pointer to a variable where to store the part's width
+   /// @param[out] h A pointer to a variable where to store the part's height
+   ///
+   bool part_geometry_get(std::string part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_geometry_get(efl::eolian::to_c(part_), x_, y_, w_, h_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Hide the input panel (virtual keyboard).
+   /// @see edje_object_part_text_input_panel_show
+   ///
+   /// Note that input panel is shown or hidden automatically according to the focus state.
+   /// This API can be used in the case of manually controlling by using edje_object_part_text_input_panel_enabled_set.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   void part_text_input_panel_hide(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_hide(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief @brief Return item geometry.
+   ///
+   /// @return 1 if item exists, 0 if not
+   ///
+   /// This function return a list of Evas_Textblock_Rectangle item
+   /// rectangles.
+   ///
+   /// @param part The part name
+   /// @param item The item name
+   /// @param[out] cx Item x return (relative to entry part)
+   /// @param[out] cy Item y return (relative to entry part)
+   /// @param[out] cw Item width return
+   /// @param[out] ch Item height return
+   ///
+   bool part_text_item_geometry_get(std::string part_, std::string item_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_item_geometry_get(efl::eolian::to_c(part_), efl::eolian::to_c(item_), cx_, cy_, cw_, ch_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Removes an object from the table.
+   ///
+   /// @return @c EINA_TRUE object removed, @c EINA_FALSE on failure
+   ///
+   /// Removes an object from the table indicated by part.
+   ///
+   /// @param part The part name
+   /// @param child_obj The object to pack in
+   ///
+   bool part_table_unpack(std::string part_, evas::object child_obj_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_table_unpack(efl::eolian::to_c(part_), efl::eolian::to_c(child_obj_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Aborts any selection action on a part.
+   ///
+   /// @param part The part name
+   ///
+   void part_text_select_abort(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_select_abort(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief Delete a function and matching user data from the filter list.
+   ///
+   /// Delete the given @p func filter and @p data user data from the list
+   /// in @p part.
+   /// Returns the user data pointer given when added.
+   ///
+   /// @see edje_object_text_insert_filter_callback_add
+   /// @see edje_object_text_insert_filter_callback_del
+   ///
+   /// @return The same data pointer if successful, or NULL otherwise
+   ///
+   /// @param part The part name
+   /// @param func The function callback to remove
+   /// @param data The data passed to the callback function
+   ///
+   void * text_insert_filter_callback_del_full(std::string part_, Edje_Text_Filter_Cb func_, void * data_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_text_insert_filter_callback_del_full(efl::eolian::to_c(part_), func_, data_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Delete the top style form the user style stack.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   void part_text_style_user_pop(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_style_user_pop(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief Set the input panel-specific data to deliver to the input panel.
+   ///
+   /// This API is used by applications to deliver specific data to the input panel.
+   /// The data format MUST be negotiated by both application and the input panel.
+   /// The size and format of data are defined by the input panel.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param data The specific data to be set to the input panel.
+   /// @param len the length of data, in bytes, to send to the input panel
+   ///
+   void part_text_input_panel_imdata_set(std::string part_, const void * data_, int len_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_imdata_set(efl::eolian::to_c(part_), data_, len_));
+   }
+
+   /// @brief Get the specific data of the current active input panel.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param data The specific data to be got from the input panel
+   /// @param len The length of data
+   ///
+   void part_text_input_panel_imdata_get(std::string part_, void * data_, int * len_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_imdata_get(efl::eolian::to_c(part_), data_, len_));
+   }
+
+   /// @brief @brief Insert text for an object part.
+   ///
+   /// This function inserts the text for an object part just before the
+   /// cursor position.
+   ///
+   /// @param part The part name
+   /// @param text The text string
+   ///
+   void part_text_insert(std::string part_, std::string text_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_insert(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+   }
+
+   /// @brief @brief Removes an object from the box.
+   ///
+   /// @return Pointer to the object removed, or @c NULL.
+   ///
+   /// Removes from the box indicated by part, the object in the position
+   /// pos.
+   ///
+   /// @see edje_object_part_box_remove()
+   /// @see edje_object_part_box_remove_all()
+   ///
+   /// @param part The part name
+   /// @param pos The position index of the object (starts counting from 0)
+   ///
+   evas::object part_box_remove_at(std::string part_, unsigned int pos_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_box_remove_at(efl::eolian::to_c(part_), pos_));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Copy the cursor to another cursor.
+   ///
+   /// @param part The part name
+   /// @param src the cursor to copy from
+   /// @param dst the cursor to copy to
+   ///
+   void part_text_cursor_copy(std::string part_, Edje_Cursor src_, Edje_Cursor dst_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_cursor_copy(efl::eolian::to_c(part_), src_, dst_));
+   }
+
+   /// @brief Calculate the geometry of the region, relative to a given Edje
+   /// object's area, <b>occupied by all parts in the object</b>
+   ///
+   /// This function gets the geometry of the rectangle equal to the area
+   /// required to group all parts in @p obj's group/collection. The @p x
+   /// and @p y coordinates are relative to the top left corner of the
+   /// whole @p obj object's area. Parts placed out of the group's
+   /// boundaries will also be taken in account, so that @p x and @p y
+   /// <b>may be negative</b>.
+   ///
+   /// @note Use @c NULL pointers on the geometry components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @note On failure, this function will make all non-@c NULL geometry
+   /// pointers' pointed variables be set to zero.
+   ///
+   /// @param[out] x A pointer to a variable where to store the parts region's
+   /// x coordinate
+   /// @param[out] y A pointer to a variable where to store the parts region's
+   /// y coordinate
+   /// @param[out] w A pointer to a variable where to store the parts region's
+   /// width
+   /// @param[out] h A pointer to a variable where to store the parts region's
+   /// height
+   ///
+   bool parts_extends_calc(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_parts_extends_calc(x_, y_, w_, h_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the dragable object location.
+   ///
+   /// Places the dragable object at the given location.
+   ///
+   /// Values for @p dx and @p dy are real numbers that range from 0 to 1,
+   /// representing the relative position to the dragable area on that axis.
+   ///
+   /// This value means, for the vertical axis, that 0.0 will be at the top if the
+   /// first parameter of @c y in the dragable part theme is 1, and at bottom if it
+   /// is -1.
+   ///
+   /// For the horizontal axis, 0.0 means left if the first parameter of @c x in the
+   /// dragable part theme is 1, and right if it is -1.
+   ///
+   /// @see edje_object_part_drag_value_get()
+   ///
+   /// @param part The part name
+   /// @param dx The x value
+   /// @param dy The y value
+   ///
+   bool part_drag_value_set(std::string part_, double dx_, double dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_value_set(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get the dragable object location.
+   ///
+   /// Values for @p dx and @p dy are real numbers that range from 0 to 1,
+   /// representing the relative position to the dragable area on that axis.
+   ///
+   /// @see edje_object_part_drag_value_set()
+   ///
+   /// Gets the drag location values.
+   ///
+   /// @param part The part name
+   /// @param[out] dx The X value pointer
+   /// @param[out] dy The Y value pointer
+   ///
+   bool part_drag_value_get(std::string part_, double* dx_, double* dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_value_get(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Force a Size/Geometry calculation.
+   ///
+   /// Forces the object @p obj to recalculation layout regardless of
+   /// freeze/thaw.
+   ///
+   void calc_force() const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_calc_force());
+   }
+
+   /// @brief @brief Sets the cursor position to the given value
+   ///
+   /// @since 1.1.0
+   ///
+   /// @param part The part name
+   /// @param cur The cursor to move
+   /// @param pos the position of the cursor
+   ///
+   void part_text_cursor_pos_set(std::string part_, Edje_Cursor cur_, int pos_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_cursor_pos_set(efl::eolian::to_c(part_), cur_, pos_));
+   }
+
+   /// @brief @brief Retrieves the current position of the cursor
+   ///
+   /// @return The cursor position
+   /// @since 1.1.0
+   ///
+   /// @param part The part name
+   /// @param cur The cursor to get the position
+   ///
+   int part_text_cursor_pos_get(std::string part_, Edje_Cursor cur_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_pos_get(efl::eolian::to_c(part_), cur_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Freezes the Edje object.
+   ///
+   /// @return The frozen state or 0 on Error
+   ///
+   /// This function puts all changes on hold. Successive freezes will
+   /// nest, requiring an equal number of thaws.
+   ///
+   /// @see edje_object_thaw()
+   ///
+   int freeze() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_freeze());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Returns the content (char) at the cursor position.
+   /// @see evas_textblock_cursor_content_get
+   ///
+   /// You must free the return (if not NULL) after you are done with it.
+   ///
+   /// @return The character string pointed to (may be a multi-byte utf8 sequence) terminated by a nul byte.
+   ///
+   /// @param part The part name
+   /// @param cur The cursor to use
+   ///
+   char * part_text_cursor_content_get(std::string part_, Edje_Cursor cur_) const
+   {
+      char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_content_get(efl::eolian::to_c(part_), cur_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Set the layout of the input panel.
+   ///
+   /// The layout of the input panel or virtual keyboard can make it easier or
+   /// harder to enter content. This allows you to hint what kind of input you
+   /// are expecting to enter and thus have the input panel automatically
+   /// come up with the right mode.
+   ///
+   /// @since 1.1
+   ///
+   /// @param part The part name
+   /// @param layout layout type
+   ///
+   void part_text_input_panel_layout_set(std::string part_, Edje_Input_Panel_Layout layout_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_layout_set(efl::eolian::to_c(part_), layout_));
+   }
+
+   /// @brief @brief Get the layout of the input panel.
+   ///
+   /// @return Layout type of the input panel
+   ///
+   /// @see edje_object_part_text_input_panel_layout_set
+   /// @since 1.1
+   ///
+   /// @param part The part name
+   ///
+   Edje_Input_Panel_Layout part_text_input_panel_layout_get(std::string part_) const
+   {
+      Edje_Input_Panel_Layout _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_layout_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Packs an object into the table.
+   ///
+   /// @return @c EINA_TRUE object was added, @c EINA_FALSE on failure
+   ///
+   /// Packs an object into the table indicated by part.
+   ///
+   /// @param part The part name
+   /// @param child_obj The object to pack in
+   /// @param col The column to place it in
+   /// @param row The row to place it in
+   /// @param colspan Columns the child will take
+   /// @param rowspan Rows the child will take
+   ///
+   bool part_table_pack(std::string part_, evas::object child_obj_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_table_pack(efl::eolian::to_c(part_), efl::eolian::to_c(child_obj_), col_, row_, colspan_, rowspan_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the language mode of the input panel.
+   ///
+   /// This API can be used if you want to show the Alphabet keyboard.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param lang the language to be set to the input panel.
+   ///
+   void part_text_input_panel_language_set(std::string part_, Edje_Input_Panel_Lang lang_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_language_set(efl::eolian::to_c(part_), lang_));
+   }
+
+   /// @brief Get the language mode of the input panel.
+   ///
+   /// See @ref edje_object_part_text_input_panel_language_set for more details.
+   ///
+   /// @return input panel language type
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   Edje_Input_Panel_Lang part_text_input_panel_language_get(std::string part_) const
+   {
+      Edje_Input_Panel_Lang _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_language_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Gets the number of columns and rows the table has.
+   ///
+   /// @return @c EINA_TRUE get some data, @c EINA_FALSE on failure
+   ///
+   /// Retrieves the size of the table in number of columns and rows.
+   ///
+   /// @param part The part name
+   /// @param[out] cols Pointer where to store number of columns (can be NULL)
+   /// @param[out] rows Pointer where to store number of rows (can be NULL)
+   ///
+   bool part_table_col_row_size_get(std::string part_, int* cols_, int* rows_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_table_col_row_size_get(efl::eolian::to_c(part_), cols_, rows_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get the object created by this external part.
+   ///
+   /// Parts of type external creates the part object using information
+   /// provided by external plugins. It's somehow like "swallow"
+   /// (edje_object_part_swallow()), but it's all set automatically.
+   ///
+   /// This function returns the part created by such external plugins and
+   /// being currently managed by this Edje.
+   ///
+   /// @note Almost all swallow rules apply: you should not move, resize,
+   /// hide, show, set the color or clipper of such part. It's a bit
+   /// more restrictive as one must @b never delete this object!
+   ///
+   /// @return The externally created object, or NULL if there is none or
+   /// part is not an external.
+   ///
+   /// @param part The part name
+   ///
+   evas::object part_external_object_get(std::string part_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_external_object_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get an object contained in an part of type EXTERNAL
+   ///
+   /// The @p content string must not be NULL. Its actual value depends on the
+   /// code providing the EXTERNAL.
+   ///
+   /// @param part The name of the part holding the EXTERNAL
+   /// @param[out] content A string identifying which content from the EXTERNAL to get
+   ///
+   evas::object part_external_content_get(std::string part_, const char* content_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_external_content_get(efl::eolian::to_c(part_), content_));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Preload the images on the Edje Object in the background.
+   ///
+   /// @return @c EINA_FASLE if obj was not a valid Edje object
+   /// otherwise @c EINA_TRUE
+   ///
+   /// This function requests the preload of all data images (on the given
+   /// object) in the background. The work is queued before being processed
+   /// (because there might be other pending requests of this type).
+   /// It emits a signal "preload,done" when finished.
+   ///
+   /// @note Use @c EINA_TRUE on scenarios where you don't need
+   /// the image data preloaded anymore.
+   ///
+   /// @param cancel @c EINA_FALSE will add it the preloading work queue,
+   /// @c EINA_TRUE will remove it (if it was issued before).
+   ///
+   bool preload(bool cancel_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_preload(efl::eolian::to_c(cancel_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Sets the attribute to show the input panel automatically.
+   ///
+   /// @since 1.1.0
+   ///
+   /// @param part The part name
+   /// @param enabled If true, the input panel is appeared when entry is clicked or has a focus
+   ///
+   void part_text_input_panel_enabled_set(std::string part_, bool enabled_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_enabled_set(efl::eolian::to_c(part_), efl::eolian::to_c(enabled_)));
+   }
+
+   /// @brief @brief Retrieve the attribute to show the input panel automatically.
+   /// @see edje_object_part_text_input_panel_enabled_set
+   ///
+   /// @return EINA_TRUE if it supports or EINA_FALSE otherwise
+   /// @since 1.1.0
+   ///
+   /// @param part The part name
+   ///
+   bool part_text_input_panel_enabled_get(std::string part_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_enabled_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Extends the current selection to the current cursor position
+   ///
+   /// @param part The part name
+   ///
+   void part_text_select_extend(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_select_extend(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief @brief Inserts an object to the box.
+   ///
+   /// @return @c EINA_TRUE: Successfully added.\n
+   /// @c EINA_FALSE: An error occurred.
+   ///
+   /// Adds child to the box indicated by part, in the position given by
+   /// pos.
+   ///
+   /// @see edje_object_part_box_append()
+   /// @see edje_object_part_box_prepend()
+   /// @see edje_object_part_box_insert_before()
+   ///
+   /// @param part The part name
+   /// @param child The object to insert
+   /// @param pos The position where to insert child
+   ///
+   bool part_box_insert_at(std::string part_, evas::object child_, unsigned int pos_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_box_insert_at(efl::eolian::to_c(part_), efl::eolian::to_c(child_), pos_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Return a list of Evas_Textblock_Rectangle anchor rectangles.
+   ///
+   /// @return The list of anchor rects (const Evas_Textblock_Rectangle
+   /// *), do not modify! Geometry is relative to entry part.
+   ///
+   /// This function return a list of Evas_Textblock_Rectangle anchor
+   /// rectangles.
+   ///
+   /// @param part The part name
+   /// @param anchor The anchor name
+   ///
+   efl::eina::crange_list< const Evas_Textblock_Rectangle * > part_text_anchor_geometry_get(std::string part_, std::string anchor_) const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_anchor_geometry_get(efl::eolian::to_c(part_), efl::eolian::to_c(anchor_)));
+      return efl::eolian::to_cxx<efl::eina::crange_list< const Evas_Textblock_Rectangle * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief @brief Moves the cursor to the char below the current cursor position.
+   ///
+   /// @param part The part name
+   /// @param cur the edje cursor to work on
+   ///
+   bool part_text_cursor_down(std::string part_, Edje_Cursor cur_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_down(efl::eolian::to_c(part_), cur_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Sets the page step increments.
+   ///
+   /// Sets the x,y page step increment values.
+   ///
+   /// Values for @p dx and @p dy are real numbers that range from 0 to 1,
+   /// representing the relative size of the dragable area on that axis by which the
+   /// part will be moved.
+   ///
+   /// @see edje_object_part_drag_page_get()
+   ///
+   /// @param part The part name
+   /// @param dx The x page step increment
+   /// @param dy The y page step increment
+   ///
+   bool part_drag_page_set(std::string part_, double dx_, double dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_page_set(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Gets the page step increments.
+   ///
+   /// Gets the x,y page step increments for the dragable object.
+   ///
+   /// @see edje_object_part_drag_page_set()
+   ///
+   /// @param part The part name
+   /// @param[out] dx The dx page increment pointer
+   /// @param[out] dy The dy page increment pointer
+   ///
+   bool part_drag_page_get(std::string part_, double* dx_, double* dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_page_get(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Prepends an object to the box.
+   ///
+   /// @return @c EINA_TRUE: Successfully added.\n
+   /// @c EINA_FALSE: An error occurred.
+   ///
+   /// Prepends child to the box indicated by part.
+   ///
+   /// @see edje_object_part_box_append()
+   /// @see edje_object_part_box_insert_before()
+   /// @see edje_object_part_box_insert_at()
+   ///
+   /// @param part The part name
+   /// @param child The object to prepend
+   ///
+   bool part_box_prepend(std::string part_, evas::object child_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_box_prepend(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Send/emit an Edje signal to a given Edje object
+   ///
+   /// This function sends a signal to the object @a obj. An Edje program,
+   /// at @p obj's EDC specification level, can respond to a signal by
+   /// having declared matching @c 'signal' and @c 'source' fields on its
+   /// block (see @ref edcref "the syntax" for EDC files).
+   ///
+   /// As an example,
+   /// @code
+   /// edje_object_signal_emit(obj, "a_signal", "");
+   /// @endcode
+   /// would trigger a program which had an EDC declaration block like
+   /// @code
+   /// program {
+   /// name: "a_program";
+   /// signal: "a_signal";
+   /// source: "";
+   /// action: ...
+   /// }
+   /// @endcode
+   ///
+   /// @see edje_object_signal_callback_add() for more on Edje signals.
+   ///
+   /// @param emission The signal's "emission" string
+   /// @param source The signal's "source" string
+   ///
+   void signal_emit(std::string emission_, std::string source_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_signal_emit(efl::eolian::to_c(emission_), efl::eolian::to_c(source_)));
+   }
+
+   /// @brief @brief Set the layout variation of the input panel.
+   ///
+   /// The layout variation of the input panel or virtual keyboard can make it easier or
+   /// harder to enter content. This allows you to hint what kind of input you
+   /// are expecting to enter and thus have the input panel automatically
+   /// come up with the right mode.
+   ///
+   /// @since 1.8
+   ///
+   /// @param part The part name
+   /// @param variation layout variation type
+   ///
+   void part_text_input_panel_layout_variation_set(std::string part_, int variation_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_layout_variation_set(efl::eolian::to_c(part_), variation_));
+   }
+
+   /// @brief @brief Get the layout variation of the input panel.
+   ///
+   /// @return Layout variation type of the input panel
+   ///
+   /// @see edje_object_part_text_input_panel_layout_variation_set
+   /// @since 1.8
+   ///
+   /// @param part The part name
+   ///
+   int part_text_input_panel_layout_variation_get(std::string part_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_layout_variation_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Send an (Edje) message to a given Edje object
+   ///
+   /// This function sends an Edje message to @p obj and to all of its
+   /// child objects, if it has any (swallowed objects are one kind of
+   /// child object). @p type and @p msg @b must be matched accordingly,
+   /// as documented in #Edje_Message_Type.
+   ///
+   /// The @p id argument as a form of code and theme defining a common
+   /// interface on message communication. One should define the same IDs
+   /// on both code and EDC declaration (see @ref edcref "the syntax" for
+   /// EDC files), to individualize messages (binding them to a given
+   /// context).
+   ///
+   /// The function to handle messages arriving @b from @b obj is set with
+   /// edje_object_message_handler_set().
+   ///
+   /// @param type The type of message to send to @p obj
+   /// @param id A identification number for the message to be sent
+   /// @param msg The message's body, a struct depending on @p type
+   ///
+   void message_send(Edje_Message_Type type_, int id_, void * msg_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_message_send(type_, id_, msg_));
+   }
+
+   /// @brief @brief Set the selection to be none.
+   ///
+   /// This function sets the selection text to be none.
+   ///
+   /// @param part The part name
+   ///
+   void part_text_select_none(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_select_none(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief @brief Get a handle to the Evas object implementing a given Edje
+   /// part, in an Edje object.
+   ///
+   /// @return A pointer to the Evas object implementing the given part,
+   /// or @c NULL on failure (e.g. the given part doesn't exist)
+   ///
+   /// This function gets a pointer of the Evas object corresponding to a
+   /// given part in the @p obj object's group.
+   ///
+   /// You should @b never modify the state of the returned object (with
+   /// @c evas_object_move() or @c evas_object_hide() for example),
+   /// because it's meant to be managed by Edje, solely. You are safe to
+   /// query information about its current state (with @c
+   /// evas_object_visible_get() or @c evas_object_color_get() for
+   /// example), though.
+   ///
+   /// @param part The Edje part's name
+   ///
+   const Evas_Object * part_object_get(std::string part_) const
+   {
+      const Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_object_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Set the dragable object size.
+   ///
+   /// Values for @p dw and @p dh are real numbers that range from 0 to 1,
+   /// representing the relative size of the dragable area on that axis.
+   ///
+   /// Sets the size of the dragable object.
+   ///
+   /// @see edje_object_part_drag_size_get()
+   ///
+   /// @param part The part name
+   /// @param dw The drag width
+   /// @param dh The drag height
+   ///
+   bool part_drag_size_set(std::string part_, double dw_, double dh_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_size_set(efl::eolian::to_c(part_), dw_, dh_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get the dragable object size.
+   ///
+   /// Gets the dragable object size.
+   ///
+   /// @see edje_object_part_drag_size_set()
+   ///
+   /// @param part The part name
+   /// @param[out] dw The drag width pointer
+   /// @param[out] dh The drag height pointer
+   ///
+   bool part_drag_size_get(std::string part_, double* dw_, double* dh_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_size_get(efl::eolian::to_c(part_), dw_, dh_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Delete a function from the filter list.
+   ///
+   /// Delete the given @p func filter from the list in @p part. Returns
+   /// the user data pointer given when added.
+   ///
+   /// @see edje_object_text_insert_filter_callback_add
+   /// @see edje_object_text_insert_filter_callback_del_full
+   ///
+   /// @return The user data pointer if successful, or NULL otherwise
+   ///
+   /// @param part The part name
+   /// @param func The function callback to remove
+   ///
+   void * text_insert_filter_callback_del(std::string part_, Edje_Text_Filter_Cb func_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_text_insert_filter_callback_del(efl::eolian::to_c(part_), func_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Determine dragable directions.
+   ///
+   /// The dragable directions are defined in the EDC file, inside the @c dragable
+   /// section, by the attributes @c x and @c y. See the @ref edcref for more
+   /// information.
+   ///
+   /// @return #EDJE_DRAG_DIR_NONE: Not dragable\n
+   /// #EDJE_DRAG_DIR_X: Dragable in X direction\n
+   /// #EDJE_DRAG_DIR_Y: Dragable in Y direction\n
+   /// #EDJE_DRAG_DIR_XY: Dragable in X & Y directions
+   ///
+   /// @param part The part name
+   ///
+   Edje_Drag_Dir part_drag_dir_get(std::string part_) const
+   {
+      Edje_Drag_Dir _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_dir_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Sets the raw (non escaped) text for an object part.
+   ///
+   /// This funciton will not do escape for you if it is a TEXTBLOCK part, that is,
+   /// if text contain tags, these tags will not be interpreted/parsed by TEXTBLOCK.
+   ///
+   /// @see edje_object_part_text_unescaped_get().
+   ///
+   /// @param part The part name
+   /// @param text_to_escape The text string
+   ///
+   bool part_text_unescaped_set(std::string part_, std::string text_to_escape_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_unescaped_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_to_escape_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Returns the text of the object part, without escaping.
+   ///
+   /// @return The @b allocated text string without escaping, or NULL on
+   /// problems.
+   ///
+   /// This function is the counterpart of
+   /// edje_object_part_text_unescaped_set(). Please notice that the
+   /// result is newly allocated memory and should be released with free()
+   /// when done.
+   ///
+   /// @see edje_object_part_text_unescaped_set().
+   ///
+   /// @param part The part name
+   ///
+   char * part_text_unescaped_get(std::string part_) const
+   {
+      char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_unescaped_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Add a callback for an arriving Edje signal, emitted by
+   /// a given Edje object.
+   ///
+   /// Edje signals are one of the communication interfaces between
+   /// @b code and a given Edje object's @b theme. With signals, one can
+   /// communicate two string values at a time, which are:
+   /// - "emission" value: the name of the signal, in general
+   /// - "source" value: a name for the signal's context, in general
+   ///
+   /// Though there are those common uses for the two strings, one is free
+   /// to use them however they like.
+   ///
+   /// This function adds a callback function to a signal emitted by @a obj, to
+   /// be issued every time an EDC program like the following
+   /// @code
+   /// program {
+   /// name: "emit_example";
+   /// action: SIGNAL_EMIT "a_signal" "a_source";
+   /// }
+   /// @endcode
+   /// is run, if @p emission and @p source are given those same values,
+   /// here.
+   ///
+   /// Signal callback registration is powerful, in the way that @b blobs
+   /// may be used to match <b>multiple signals at once</b>. All the @c
+   /// "*?[\" set of @c fnmatch() operators can be used, both for @p
+   /// emission and @p source.
+   ///
+   /// Edje has @b internal signals it will emit, automatically, on
+   /// various actions taking place on group parts. For example, the mouse
+   /// cursor being moved, pressed, released, etc., over a given part's
+   /// area, all generate individual signals.
+   ///
+   /// By using something like
+   /// @code
+   /// edje_object_signal_callback_add(obj, "mouse,down,*", "button.*",
+   /// signal_cb, NULL);
+   /// @endcode
+   /// being @c "button.*" the pattern for the names of parts implementing
+   /// buttons on an interface, you'd be registering for notifications on
+   /// events of mouse buttons being pressed down on either of those parts
+   /// (those events all have the @c "mouse,down," common prefix on their
+   /// names, with a suffix giving the button number). The actual emission
+   /// and source strings of an event will be passed in as the @a emission
+   /// and @a source parameters of the callback function (e.g. @c
+   /// "mouse,down,2" and @c "button.close"), for each of those events.
+   ///
+   /// @note See @ref edcref "the syntax" for EDC files
+   /// @see edje_object_signal_emit() on how to emits Edje signals from
+   /// code to a an object
+   /// @see edje_object_signal_callback_del_full()
+   ///
+   /// @param emission The signal's "emission" string
+   /// @param source The signal's "source" string
+   /// @param func The callback function to be executed when the signal is
+   /// emitted.
+   /// @param data A pointer to data to pass in to @p func.
+   ///
+   void signal_callback_add(std::string emission_, std::string source_, Edje_Signal_Cb func_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_signal_callback_add(efl::eolian::to_c(emission_), efl::eolian::to_c(source_), func_, data_));
+   }
+
+   /// @brief @brief Set the selection to be everything.
+   ///
+   /// This function selects all text of the object of the part.
+   ///
+   /// @param part The part name
+   ///
+   void part_text_select_all(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_select_all(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief Set the return key on the input panel to be disabled.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param disabled The state
+   ///
+   void part_text_input_panel_return_key_disabled_set(std::string part_, bool disabled_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_return_key_disabled_set(efl::eolian::to_c(part_), efl::eolian::to_c(disabled_)));
+   }
+
+   /// @brief Get whether the return key on the input panel should be disabled or not.
+   ///
+   /// @return EINA_TRUE if it should be disabled
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   bool part_text_input_panel_return_key_disabled_get(std::string part_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_return_key_disabled_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the autocapitalization type on the immodule.
+   ///
+   /// @since 1.1.0
+   ///
+   /// @param part The part name
+   /// @param autocapital_type The type of autocapitalization
+   ///
+   void part_text_autocapital_type_set(std::string part_, Edje_Text_Autocapital_Type autocapital_type_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_autocapital_type_set(efl::eolian::to_c(part_), autocapital_type_));
+   }
+
+   /// @brief @brief Retrieves the autocapitalization type
+   ///
+   /// @return The autocapitalization type
+   /// @since 1.1.0
+   ///
+   /// @param part The part name
+   ///
+   Edje_Text_Autocapital_Type part_text_autocapital_type_get(std::string part_) const
+   {
+      Edje_Text_Autocapital_Type _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_autocapital_type_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Unswallow an object.
+   ///
+   /// Causes the edje to regurgitate a previously swallowed object. :)
+   ///
+   /// @note @p obj_swallow will @b not be deleted or hidden.
+   /// @note @p obj_swallow may appear shown on the evas depending on its state when
+   /// it got unswallowed. Make sure you delete it or hide it if you do not want it to.
+   ///
+   /// @param obj_swallow The swallowed object
+   ///
+   void part_unswallow(evas::object obj_swallow_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_unswallow(efl::eolian::to_c(obj_swallow_)));
+   }
+
+   /// @brief @brief Set whether the prediction is allowed or not.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param prediction If true, the prediction feature is allowed.
+   ///
+   void part_text_prediction_allow_set(std::string part_, bool prediction_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_prediction_allow_set(efl::eolian::to_c(part_), efl::eolian::to_c(prediction_)));
+   }
+
+   /// @brief @brief Get whether the prediction is allowed or not.
+   ///
+   /// @return EINA_TRUE if prediction feature is allowed.
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   bool part_text_prediction_allow_get(std::string part_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_prediction_allow_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Retrive an <b>EDC data field's value</b> from a given Edje
+   /// object's group.
+   ///
+   /// @return The data's value string. Must not be freed.
+   ///
+   /// This function fetches an EDC data field's value, which is declared
+   /// on the objects building EDC file, <b>under its group</b>. EDC data
+   /// blocks are most commonly used to pass arbitrary parameters from an
+   /// application's theme to its code.
+   ///
+   /// They look like the following:
+   ///
+   /// @code
+   /// collections {
+   /// group {
+   /// name: "a_group";
+   /// data {
+   /// item: "key1" "value1";
+   /// item: "key2" "value2";
+   /// }
+   /// }
+   /// }
+   /// @endcode
+   ///
+   /// EDC data fields always hold @b strings as values, hence the return
+   /// type of this function. Check the complete @ref edcref "syntax reference"
+   /// for EDC files.
+   ///
+   /// @warning Do not confuse this call with edje_file_data_get(), which
+   /// queries for a @b global EDC data field on an EDC declaration file.
+   ///
+   /// @see edje_object_file_set()
+   ///
+   /// @param key The data field's key string
+   ///
+   std::string data_get(std::string key_) const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_data_get(efl::eolian::to_c(key_)));
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Add a markup filter function for newly inserted text.
+   ///
+   /// Whenever text is inserted (not the same as set) into the given @p part,
+   /// the list of markup filter functions will be called to decide if and how
+   /// the new text will be accepted.
+   /// The text parameter in the @p func filter is always markup. It can be
+   /// modified by the user and it's up to him to free the one passed if he's to
+   /// change the pointer. If doing so, the newly set text should be malloc'ed,
+   /// as once all the filters are called Edje will free it.
+   /// If the text is to be rejected, freeing it and setting the pointer to NULL
+   /// will make Edje break out of the filter cycle and reject the inserted
+   /// text.
+   /// This function is different from edje_object_text_insert_filter_callback_add()
+   /// in that the text parameter in the @p fucn filter is always markup.
+   ///
+   /// @warning If you use this function with
+   /// edje_object_text_insert_filter_callback_add() togehter, all
+   /// Edje_Text_Filter_Cb functions and Edje_Markup_Filter_Cb functions
+   /// will be executed, and then filtered text will be inserted.
+   ///
+   /// @see edje_object_text_markup_filter_callback_del
+   /// @see edje_object_text_markup_filter_callback_del_full
+   /// @see edje_object_text_insert_filter_callback_add
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param func The callback function that will act as markup filter
+   /// @param data User provided data to pass to the filter function
+   ///
+   void text_markup_filter_callback_add(std::string part_, Edje_Markup_Filter_Cb func_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_text_markup_filter_callback_add(efl::eolian::to_c(part_), func_, data_));
+   }
+
+   /// @brief @brief Process an object's message queue.
+   ///
+   /// This function goes through the object message queue processing the
+   /// pending messages for @b this specific Edje object. Normally they'd
+   /// be processed only at idle time.
+   ///
+   void message_signal_process() const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_message_signal_process());
+   }
+
+   /// @brief @brief Removes an object from the box.
+   ///
+   /// @return Pointer to the object removed, or @c NULL.
+   ///
+   /// Removes child from the box indicated by part.
+   ///
+   /// @see edje_object_part_box_remove_at()
+   /// @see edje_object_part_box_remove_all()
+   ///
+   /// @param part The part name
+   /// @param child The object to remove
+   ///
+   evas::object part_box_remove(std::string part_, evas::object child_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_box_remove(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Thaws the Edje object.
+   ///
+   /// @return The frozen state or 0 if the object is not frozen or on error.
+   ///
+   /// This function thaws the given Edje object.
+   ///
+   /// @note: If sucessives freezes were done, an equal number of
+   /// thaws will be required.
+   ///
+   /// @see edje_object_freeze()
+   ///
+   int thaw() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_thaw());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Get the object currently swallowed by a part.
+   ///
+   /// @return The swallowed object, or NULL if there is none.
+   ///
+   /// @param part The part name
+   ///
+   evas::object part_swallow_get(std::string part_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_swallow_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Reset the input method context if needed.
+   ///
+   /// This can be necessary in the case where modifying the buffer would confuse on-going input method behavior
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   void part_text_imf_context_reset(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_imf_context_reset(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief Set the "return" key type. This type is used to set string or icon on the "return" key of the input panel.
+   ///
+   /// An input panel displays the string or icon associated with this type
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param return_key_type The type of "return" key on the input panel
+   ///
+   void part_text_input_panel_return_key_type_set(std::string part_, Edje_Input_Panel_Return_Key_Type return_key_type_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_return_key_type_set(efl::eolian::to_c(part_), return_key_type_));
+   }
+
+   /// @brief Get the "return" key type.
+   ///
+   /// @see edje_object_part_text_input_panel_return_key_type_set() for more details
+   ///
+   /// @return The type of "return" key on the input panel
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   Edje_Input_Panel_Return_Key_Type part_text_input_panel_return_key_type_get(std::string part_) const
+   {
+      Edje_Input_Panel_Return_Key_Type _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_return_key_type_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Retrieve a child from a table
+   ///
+   /// @return The child Evas_Object
+   ///
+   /// @param part The part name
+   /// @param col The column of the child to get
+   /// @param row The row of the child to get
+   ///
+   evas::object part_table_child_get(std::string part_, unsigned int col_, unsigned int row_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_table_child_get(efl::eolian::to_c(part_), col_, row_));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Adds an object to the box.
+   ///
+   /// @return @c EINA_TRUE: Successfully added.\n
+   /// @c EINA_FALSE: An error occurred.
+   ///
+   /// Inserts child in the box given by part, in the position marked by
+   /// reference.
+   ///
+   /// @see edje_object_part_box_append()
+   /// @see edje_object_part_box_prepend()
+   /// @see edje_object_part_box_insert_at()
+   ///
+   /// @param part The part name
+   /// @param child The object to insert
+   /// @param reference The object to be used as reference
+   ///
+   bool part_box_insert_before(std::string part_, evas::object child_, const Evas_Object * reference_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_box_insert_before(efl::eolian::to_c(part_), efl::eolian::to_c(child_), reference_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Set the parameter for the external part.
+   ///
+   /// Parts of type external may carry extra properties that have
+   /// meanings defined by the external plugin. For instance, it may be a
+   /// string that defines a button label and setting this property will
+   /// change that label on the fly.
+   ///
+   /// @note external parts have parameters set when they change
+   /// states. Those parameters will never be changed by this
+   /// function. The interpretation of how state_set parameters and
+   /// param_set will interact is up to the external plugin.
+   ///
+   /// @note this function will not check if parameter value is valid
+   /// using #Edje_External_Param_Info minimum, maximum, valid
+   /// choices and others. However these should be checked by the
+   /// underlying implementation provided by the external
+   /// plugin. This is done for performance reasons.
+   ///
+   /// @return @c EINA_TRUE if everything went fine, @c EINA_FALSE on errors.
+   ///
+   /// @param part The part name
+   /// @param param the parameter details, including its name, type and
+   /// actual value. This pointer should be valid, and the
+   /// parameter must exist in
+   /// #Edje_External_Type.parameters_info, with the exact type,
+   /// otherwise the operation will fail and @c EINA_FALSE will be
+   /// returned.
+   ///
+   bool part_external_param_set(std::string part_, const Edje_External_Param * param_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_external_param_set(efl::eolian::to_c(part_), param_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get the parameter for the external part.
+   ///
+   /// Parts of type external may carry extra properties that have
+   /// meanings defined by the external plugin. For instance, it may be a
+   /// string that defines a button label. This property can be modified by
+   /// state parameters, by explicit calls to
+   /// edje_object_part_external_param_set() or getting the actual object
+   /// with edje_object_part_external_object_get() and calling native
+   /// functions.
+   ///
+   /// This function asks the external plugin what is the current value,
+   /// independent on how it was set.
+   ///
+   /// @return @c EINA_TRUE if everything went fine and @p param members
+   /// are filled with information, @c EINA_FALSE on errors and @p
+   /// param member values are not set or valid.
+   ///
+   /// @param part The part name
+   /// @param[out] param the parameter details. It is used as both input and
+   /// output variable. This pointer should be valid, and the
+   /// parameter must exist in
+   /// #Edje_External_Type.parameters_info, with the exact type,
+   /// otherwise the operation will fail and @c EINA_FALSE will be
+   /// returned.
+   ///
+   bool part_external_param_get(std::string part_, Edje_External_Param* param_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_external_param_get(efl::eolian::to_c(part_), param_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Calculate the minimum required size for a given Edje object.
+   ///
+   /// This call works exactly as edje_object_size_min_restricted_calc(),
+   /// with the last two arguments set to 0. Please refer to its
+   /// documentation, then.
+   ///
+   /// @param[out] minw Pointer to a variable where to store the minimum
+   /// required width
+   /// @param[out] minh Pointer to a variable where to store the minimum
+   /// required height
+   ///
+   void size_min_calc(Evas_Coord* minw_, Evas_Coord* minh_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_size_min_calc(minw_, minh_));
+   }
+
+   /// @brief @brief Appends an object to the box.
+   ///
+   /// @return @c EINA_TRUE: Successfully added.\n
+   /// @c EINA_FALSE: An error occurred.
+   ///
+   /// Appends child to the box indicated by part.
+   ///
+   /// @see edje_object_part_box_prepend()
+   /// @see edje_object_part_box_insert_before()
+   /// @see edje_object_part_box_insert_at()
+   ///
+   /// @param part The part name
+   /// @param child The object to append
+   ///
+   bool part_box_append(std::string part_, evas::object child_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_box_append(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Calculate the minimum required size for a given Edje object.
+   ///
+   /// This call will trigger an internal recalculation of all parts of
+   /// the @p obj object, in order to return its minimum required
+   /// dimensions for width and height. The user might choose to @b impose
+   /// those minimum sizes, making the resulting calculation to get to values
+   /// equal or bigger than @p restrictedw and @p restrictedh, for width and
+   /// height, respectively.
+   ///
+   /// @note At the end of this call, @p obj @b won't be automatically
+   /// resized to new dimensions, but just return the calculated
+   /// sizes. The caller is the one up to change its geometry or not.
+   ///
+   /// @warning Be advised that invisible parts in @p obj @b will be taken
+   /// into account in this calculation.
+   ///
+   /// @param[out] minw Pointer to a variable where to store the minimum
+   /// required width
+   /// @param[out] minh Pointer to a variable where to store the minimum
+   /// required height
+   /// @param restrictedw Do not allow object's calculated (minimum) width
+   /// to be less than this value
+   /// @param restrictedh Do not allow object's calculated (minimum)
+   /// height to be less than this value
+   ///
+   void size_min_restricted_calc(Evas_Coord* minw_, Evas_Coord* minh_, Evas_Coord restrictedw_, Evas_Coord restrictedh_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_size_min_restricted_calc(minw_, minh_, restrictedw_, restrictedh_));
+   }
+
+   /// @brief @brief Removes all elements from the box.
+   ///
+   /// @return 1: Successfully cleared.\n
+   /// 0: An error occurred.
+   ///
+   /// Removes all the external objects from the box indicated by part.
+   /// Elements created from the theme will not be removed.
+   ///
+   /// @see edje_object_part_box_remove()
+   /// @see edje_object_part_box_remove_at()
+   ///
+   /// @param part The part name
+   /// @param clear Delete objects on removal
+   ///
+   bool part_box_remove_all(std::string part_, bool clear_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_box_remove_all(efl::eolian::to_c(part_), efl::eolian::to_c(clear_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Pages x,y steps.
+   ///
+   /// Pages x,y where the increment is defined by
+   /// edje_object_part_drag_page_set.
+   ///
+   /// Values for @p dx and @p dy are real numbers that range from 0 to 1.
+   ///
+   /// @warning Paging is bugged!
+   ///
+   /// @see edje_object_part_drag_step()
+   ///
+   /// @param part The part name
+   /// @param dx The x step
+   /// @param dy The y step
+   ///
+   bool part_drag_page(std::string part_, double dx_, double dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_page(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Sets the text for an object part
+   ///
+   /// @return @c EINA_TRUE on success, @c EINA_FALSE otherwise
+   ///
+   /// @param part The part name
+   /// @param text The text string
+   ///
+   bool part_text_set(std::string part_, std::string text_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Return the text of the object part.
+   ///
+   /// @return The text string
+   ///
+   /// This function returns the text associated to the object part.
+   ///
+   /// @see edje_object_part_text_set().
+   ///
+   /// @param part The part name
+   ///
+   std::string part_text_get(std::string part_) const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the attribute to show the input panel in case of only an user's explicit Mouse Up event.
+   /// It doesn't request to show the input panel even though it has focus.
+   ///
+   /// @since 1.9.0
+   ///
+   /// @param part The part name
+   /// @param ondemand If true, the input panel will be shown in case of only Mouse up event. (Focus event will be ignored.)
+   ///
+   void part_text_input_panel_show_on_demand_set(std::string part_, bool ondemand_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_show_on_demand_set(efl::eolian::to_c(part_), efl::eolian::to_c(ondemand_)));
+   }
+
+   /// @brief Get the attribute to show the input panel in case of only an user's explicit Mouse Up event.
+   ///
+   /// @return @c EINA_TRUE if the input panel will be shown in case of only Mouse up event.
+   /// @since 1.9.0
+   ///
+   /// @param part The part name
+   ///
+   bool part_text_input_panel_show_on_demand_get(std::string part_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_show_on_demand_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets the input hint which allows input methods to fine-tune their behavior.
+   ///
+   /// @since 1.12.0
+   ///
+   /// @param part The part name
+   /// @param input_hints input hints
+   ///
+   void part_text_input_hint_set(std::string part_, Edje_Input_Hints input_hints_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_hint_set(efl::eolian::to_c(part_), input_hints_));
+   }
+
+   /// @brief Gets the value of input hint
+   ///
+   /// @return The value of input hint
+   /// @since 1.12.0
+   ///
+   /// @param part The part name
+   ///
+   Edje_Input_Hints part_text_input_hint_get(std::string part_) const
+   {
+      Edje_Input_Hints _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_hint_get(efl::eolian::to_c(part_)));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Return the selection text of the object part.
+   ///
+   /// @return The text string
+   ///
+   /// This function returns selection text of the object part.
+   ///
+   /// @see edje_object_part_text_select_all()
+   /// @see edje_object_part_text_select_none()
+   ///
+   /// @param part The part name
+   ///
+   std::string part_text_selection_get(std::string part_) const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_selection_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Returns whether the cursor points to a format.
+   /// @see evas_textblock_cursor_is_format
+   ///
+   /// @return EINA_TRUE if it's true, EINA_FALSE otherwise.
+   ///
+   /// @param part The part name
+   /// @param cur The cursor to adjust.
+   ///
+   bool part_text_cursor_is_format_get(std::string part_, Edje_Cursor cur_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_is_format_get(efl::eolian::to_c(part_), cur_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Sets the object color class.
+   ///
+   /// This function sets the color values for an object level color
+   /// class. This will cause all edje parts in the specified object that
+   /// have the specified color class to have their colors multiplied by
+   /// these values.
+   ///
+   /// The first color is the object, the second is the text outline, and
+   /// the third is the text shadow. (Note that the second two only apply
+   /// to text parts).
+   ///
+   /// Setting color emits a signal "color_class,set" with source being
+   /// the given color.
+   ///
+   /// @note unlike Evas, Edje colors are @b not pre-multiplied. That is,
+   /// half-transparent white is 255 255 255 128.
+   ///
+   /// @param color_class 
+   /// @param r Object Red value
+   /// @param g Object Green value
+   /// @param b Object Blue value
+   /// @param a Object Alpha value
+   /// @param r2 Outline Red value
+   /// @param g2 Outline Green value
+   /// @param b2 Outline Blue value
+   /// @param a2 Outline Alpha value
+   /// @param r3 Shadow Red value
+   /// @param g3 Shadow Green value
+   /// @param b3 Shadow Blue value
+   /// @param a3 Shadow Alpha value
+   ///
+   bool color_class_set(std::string color_class_, int r_, int g_, int b_, int a_, int r2_, int g2_, int b2_, int a2_, int r3_, int g3_, int b3_, int a3_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_color_class_set(efl::eolian::to_c(color_class_), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Gets the object color class.
+   ///
+   /// @return EINA_TRUE if found or EINA_FALSE if not found and all
+   /// values are zeroed.
+   ///
+   /// This function gets the color values for an object level color
+   /// class. If no explicit object color is set, then global values will
+   /// be used.
+   ///
+   /// The first color is the object, the second is the text outline, and
+   /// the third is the text shadow. (Note that the second two only apply
+   /// to text parts).
+   ///
+   /// @note unlike Evas, Edje colors are @b not pre-multiplied. That is,
+   /// half-transparent white is 255 255 255 128.
+   ///
+   /// @param color_class 
+   /// @param[out] r Object Red value
+   /// @param[out] g Object Green value
+   /// @param[out] b Object Blue value
+   /// @param[out] a Object Alpha value
+   /// @param[out] r2 Outline Red value
+   /// @param[out] g2 Outline Green value
+   /// @param[out] b2 Outline Blue value
+   /// @param[out] a2 Outline Alpha value
+   /// @param[out] r3 Shadow Red value
+   /// @param[out] g3 Shadow Green value
+   /// @param[out] b3 Shadow Blue value
+   /// @param[out] a3 Shadow Alpha value
+   ///
+   bool color_class_get(std::string color_class_, int* r_, int* g_, int* b_, int* a_, int* r2_, int* g2_, int* b2_, int* a2_, int* r3_, int* g3_, int* b3_, int* a3_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_color_class_get(efl::eolian::to_c(color_class_), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Steps the dragable x,y steps.
+   ///
+   /// Steps x,y where the step increment is the amount set by
+   /// edje_object_part_drag_step_set.
+   ///
+   /// Values for @p dx and @p dy are real numbers that range from 0 to 1.
+   ///
+   /// @see edje_object_part_drag_page()
+   ///
+   /// @param part The part name
+   /// @param dx The x step
+   /// @param dy The y step
+   ///
+   bool part_drag_step(std::string part_, double dx_, double dy_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_step(efl::eolian::to_c(part_), dx_, dy_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Move the cursor to the char above the current cursor position.
+   ///
+   /// @param part The part name
+   /// @param cur the edje cursor to work on
+   ///
+   bool part_text_cursor_up(std::string part_, Edje_Cursor cur_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_up(efl::eolian::to_c(part_), cur_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Returns the cursor geometry of the part relative to the edje
+   /// object.
+   ///
+   /// @param part The part name
+   /// @param[out] x Cursor X position
+   /// @param[out] y Cursor Y position
+   /// @param[out] w Cursor width
+   /// @param[out] h Cursor height
+   ///
+   void part_text_cursor_geometry_get(std::string part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_cursor_geometry_get(efl::eolian::to_c(part_), x_, y_, w_, h_));
+   }
+
+   /// @brief @brief Return a list of char anchor names.
+   ///
+   /// @return The list of anchors (const char *), do not modify!
+   ///
+   /// This function returns a list of char anchor names.
+   ///
+   /// @param part The part name
+   ///
+   efl::eina::crange_list< std::string > part_text_anchor_list_get(std::string part_) const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_anchor_list_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief Add a filter function for newly inserted text.
+   ///
+   /// Whenever text is inserted (not the same as set) into the given @p part,
+   /// the list of filter functions will be called to decide if and how the new
+   /// text will be accepted.
+   /// There are three types of filters, EDJE_TEXT_FILTER_TEXT,
+   /// EDJE_TEXT_FILTER_FORMAT and EDJE_TEXT_FILTER_MARKUP.
+   /// The text parameter in the @p func filter can be modified by the user and
+   /// it's up to him to free the one passed if he's to change the pointer. If
+   /// doing so, the newly set text should be malloc'ed, as once all the filters
+   /// are called Edje will free it.
+   /// If the text is to be rejected, freeing it and setting the pointer to NULL
+   /// will make Edje break out of the filter cycle and reject the inserted
+   /// text.
+   ///
+   /// @warning This function will be deprecated because of difficulty in use.
+   /// The type(format, text, or markup) of text should be always
+   /// checked in the filter function for correct filtering.
+   /// Please use edje_object_text_markup_filter_callback_add() instead. There
+   /// is no need to check the type of text in the filter function
+   /// because the text is always markup.
+   /// @warning If you use this function with
+   /// edje_object_text_markup_filter_callback_add() together, all
+   /// Edje_Text_Filter_Cb functions and Edje_Markup_Filter_Cb functions
+   /// will be executed, and then filtered text will be inserted.
+   ///
+   /// @see edje_object_text_insert_filter_callback_del
+   /// @see edje_object_text_insert_filter_callback_del_full
+   /// @see edje_object_text_markup_filter_callback_add
+   ///
+   /// @param part The part name
+   /// @param func The callback function that will act as filter
+   /// @param data User provided data to pass to the filter function
+   ///
+   void text_insert_filter_callback_add(std::string part_, Edje_Text_Filter_Cb func_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_text_insert_filter_callback_add(efl::eolian::to_c(part_), func_, data_));
+   }
+
+   /// @brief @brief Show the input panel (virtual keyboard) based on the input panel property such as layout, autocapital types, and so on.
+   ///
+   /// Note that input panel is shown or hidden automatically according to the focus state.
+   /// This API can be used in the case of manually controlling by using edje_object_part_text_input_panel_enabled_set.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   ///
+   void part_text_input_panel_show(std::string part_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_input_panel_show(efl::eolian::to_c(part_)));
+   }
+
+   /// @brief @brief Check if an Edje part exists in a given Edje object's group
+   /// definition.
+   ///
+   /// @return @c EINA_TRUE, if the Edje part exists in @p obj's group or
+   /// @c EINA_FALSE, otherwise (and on errors)
+   ///
+   /// This function returns if a given part exists in the Edje group
+   /// bound to object @p obj (with edje_object_file_set()).
+   ///
+   /// This call is useful, for example, when one could expect or not a
+   /// given GUI element, depending on the @b theme applied to @p obj.
+   ///
+   /// @param part The part's name to check for existence in @p obj's
+   /// group
+   ///
+   bool part_exists(std::string part_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_exists(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Delete a function from the markup filter list.
+   ///
+   /// Delete the given @p func filter from the list in @p part. Returns
+   /// the user data pointer given when added.
+   ///
+   /// @see edje_object_text_markup_filter_callback_add
+   /// @see edje_object_text_markup_filter_callback_del_full
+   ///
+   /// @return The user data pointer if successful, or NULL otherwise
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param func The function callback to remove
+   ///
+   void * text_markup_filter_callback_del(std::string part_, Edje_Markup_Filter_Cb func_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_text_markup_filter_callback_del(efl::eolian::to_c(part_), func_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Return true if the cursor points to a visible format
+   /// For example \\t, \\n, item and etc.
+   /// @see  evas_textblock_cursor_format_is_visible_get
+   ///
+   /// @param part The part name
+   /// @param cur The cursor to adjust.
+   ///
+   bool part_text_cursor_is_visible_format_get(std::string part_, Edje_Cursor cur_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_is_visible_format_get(efl::eolian::to_c(part_), cur_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief This function inserts text as if the user has inserted it.
+   ///
+   /// This means it actually registers as a change and emits signals, triggers
+   /// callbacks as appropriate.
+   ///
+   /// @since 1.2.0
+   ///
+   /// @param part The part name
+   /// @param text The text string
+   ///
+   void part_text_user_insert(std::string part_, std::string text_) const
+   {
+      eo_do(_eo_ptr(), ::edje_obj_part_text_user_insert(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+   }
+
+   /// @brief @brief Moves the cursor to the previous char
+   /// @see evas_textblock_cursor_char_prev
+   ///
+   /// @param part The part name
+   /// @param cur the edje cursor to work on
+   ///
+   bool part_text_cursor_prev(std::string part_, Edje_Cursor cur_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_prev(efl::eolian::to_c(part_), cur_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Return a list of char item names.
+   ///
+   /// @return The list of items (const char *), do not modify!
+   ///
+   /// This function returns a list of char item names.
+   ///
+   /// @param part The part name
+   ///
+   efl::eina::crange_list< std::string > part_text_item_list_get(std::string part_) const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_text_item_list_get(efl::eolian::to_c(part_)));
+      return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief @brief "Swallows" an object into one of the Edje object @c SWALLOW
+   /// parts.
+   ///
+   /// Swallowing an object into an Edje object is, for a given part of
+   /// type @c SWALLOW in the EDC group which gave life to @a obj, to set
+   /// an external object to be controlled by @a obj, being displayed
+   /// exactly over that part's region inside the whole Edje object's
+   /// viewport.
+   ///
+   /// From this point on, @a obj will have total control over @a
+   /// obj_swallow's geometry and visibility. For instance, if @a obj is
+   /// visible, as in @c evas_object_show(), the swallowed object will be
+   /// visible too -- if the given @c SWALLOW part it's in is also
+   /// visible. Other actions on @a obj will also reflect on the swallowed
+   /// object as well (e.g. resizing, moving, raising/lowering, etc.).
+   ///
+   /// Finally, all internal changes to @a part, specifically, will
+   /// reflect on the displaying of @a obj_swallow, for example state
+   /// changes leading to different visibility states, geometries,
+   /// positions, etc.
+   ///
+   /// If an object has already been swallowed into this part, then it
+   /// will first be unswallowed (as in edje_object_part_unswallow())
+   /// before the new object is swallowed.
+   ///
+   /// @note @a obj @b won't delete the swallowed object once it is
+   /// deleted -- @a obj_swallow will get to an unparented state again.
+   ///
+   /// For more details on EDC @c SWALLOW parts, see @ref edcref "syntax
+   /// reference".
+   ///
+   /// @param part The swallow part's name
+   /// @param obj_swallow The object to occupy that part
+   ///
+   bool part_swallow(std::string part_, evas::object obj_swallow_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::edje_obj_part_swallow(efl::eolian::to_c(part_), efl::eolian::to_c(obj_swallow_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EDJE_OBJECT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EDJE_OBJECT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void edje_object_dbg_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo_Dbg_Info * root_node_)
+{
+   static_cast<T*>(self->this_)->dbg_info_get(root_node_);
+}
+
+template <typename T>
+void edje_object_hide_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->hide();
+}
+
+template <typename T>
+void edje_object_calculate_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->calculate();
+}
+
+template <typename T>
+void edje_object_show_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->show();
+}
+
+template <typename T>
+void edje_object_move_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_)
+{
+   static_cast<T*>(self->this_)->move(x_, y_);
+}
+
+template <typename T>
+void edje_object_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->add();
+}
+
+template <typename T>
+void edje_object_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->del();
+}
+
+template <typename T>
+void edje_object_resize_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->resize(w_, h_);
+}
+
+template <typename T>
+bool edje_object_file_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * file_, const char * key_)
+{
+   return static_cast<T*>(self->this_)->file_set(efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_file_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char ** file_, const char ** key_)
+{
+   static_cast<T*>(self->this_)->file_get(file_, key_);
+}
+
+template <typename T>
+bool edje_object_update_hints_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->update_hints_get();
+}
+
+template <typename T>
+void edje_object_update_hints_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool update_)
+{
+   static_cast<T*>(self->this_)->update_hints_set(efl::eolian::to_cxx<bool>(update_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_mirrored_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->mirrored_get();
+}
+
+template <typename T>
+void edje_object_mirrored_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool rtl_)
+{
+   static_cast<T*>(self->this_)->mirrored_set(efl::eolian::to_cxx<bool>(rtl_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_animation_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->animation_get();
+}
+
+template <typename T>
+void edje_object_animation_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool on_)
+{
+   static_cast<T*>(self->this_)->animation_set(efl::eolian::to_cxx<bool>(on_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_play_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->play_get();
+}
+
+template <typename T>
+void edje_object_play_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool play_)
+{
+   static_cast<T*>(self->this_)->play_set(efl::eolian::to_cxx<bool>(play_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+const Edje_Perspective * edje_object_perspective_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->perspective_get();
+}
+
+template <typename T>
+void edje_object_perspective_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Edje_Perspective * ps_)
+{
+   static_cast<T*>(self->this_)->perspective_set(ps_);
+}
+
+template <typename T>
+double edje_object_scale_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->scale_get();
+}
+
+template <typename T>
+bool edje_object_scale_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double scale_)
+{
+   return static_cast<T*>(self->this_)->scale_set(scale_);
+}
+
+template <typename T>
+double edje_object_base_scale_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->base_scale_get();
+}
+
+template <typename T>
+bool edje_object_mmap_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Eina_File * file_, const char * group_)
+{
+   return static_cast<T*>(self->this_)->mmap_set(file_, efl::eolian::to_cxx<std::string>(group_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_text_change_cb_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Edje_Text_Change_Cb func_, void * data_)
+{
+   static_cast<T*>(self->this_)->text_change_cb_set(func_, data_);
+}
+
+template <typename T>
+void edje_object_part_text_cursor_begin_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   static_cast<T*>(self->this_)->part_text_cursor_begin_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+void edje_object_part_text_cursor_line_end_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   static_cast<T*>(self->this_)->part_text_cursor_line_end_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+bool edje_object_text_class_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * text_class_, const char * font_, Evas_Font_Size size_)
+{
+   return static_cast<T*>(self->this_)->text_class_set(efl::eolian::to_cxx<std::string>(text_class_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(font_, std::tuple<std::false_type>()), size_);
+}
+
+template <typename T>
+bool edje_object_part_text_cursor_coord_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_, Evas_Coord x_, Evas_Coord y_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_coord_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_, x_, y_);
+}
+
+template <typename T>
+void edje_object_part_text_cursor_end_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   static_cast<T*>(self->this_)->part_text_cursor_end_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+bool edje_object_part_text_escaped_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * text_)
+{
+   return static_cast<T*>(self->this_)->part_text_escaped_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_item_provider_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Edje_Item_Provider_Cb func_, void * data_)
+{
+   static_cast<T*>(self->this_)->item_provider_set(func_, data_);
+}
+
+template <typename T>
+void edje_object_part_text_cursor_line_begin_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   static_cast<T*>(self->this_)->part_text_cursor_line_begin_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+void edje_object_message_handler_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Edje_Message_Handler_Cb func_, void * data_)
+{
+   static_cast<T*>(self->this_)->message_handler_set(func_, data_);
+}
+
+template <typename T>
+void edje_object_size_min_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* minw_, Evas_Coord* minh_)
+{
+   static_cast<T*>(self->this_)->size_min_get(minw_, minh_);
+}
+
+template <typename T>
+efl::eina::range_list< std::string > edje_object_access_part_list_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->access_part_list_get();
+}
+
+template <typename T>
+Edje_Load_Error edje_object_load_error_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->load_error_get();
+}
+
+template <typename T>
+void edje_object_size_max_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* maxw_, Evas_Coord* maxh_)
+{
+   static_cast<T*>(self->this_)->size_max_get(maxw_, maxh_);
+}
+
+template <typename T>
+bool edje_object_part_table_clear_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Eina_Bool clear_)
+{
+   return static_cast<T*>(self->this_)->part_table_clear(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(clear_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Edje_External_Param_Type edje_object_part_external_param_type_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char* param_)
+{
+   return static_cast<T*>(self->this_)->part_external_param_type_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), param_);
+}
+
+template <typename T>
+void edje_object_part_text_select_allow_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Eina_Bool allow_)
+{
+   static_cast<T*>(self->this_)->part_text_select_allow_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(allow_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string edje_object_part_state_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double* val_ret_)
+{
+   return static_cast<T*>(self->this_)->part_state_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), val_ret_);
+}
+
+template <typename T>
+void * edje_object_text_markup_filter_callback_del_full_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Markup_Filter_Cb func_, void * data_)
+{
+   return static_cast<T*>(self->this_)->text_markup_filter_callback_del_full(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), func_, data_);
+}
+
+template <typename T>
+bool edje_object_part_drag_step_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double dx_, double dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_step_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+bool edje_object_part_drag_step_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double* dx_, double* dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_step_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+void * edje_object_part_text_imf_context_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_imf_context_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_select_begin_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_select_begin(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string edje_object_part_text_style_user_peek_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_style_user_peek(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void * edje_object_signal_callback_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * emission_, const char * source_, Edje_Signal_Cb func_, void * data_)
+{
+   return static_cast<T*>(self->this_)->signal_callback_del(efl::eolian::to_cxx<std::string>(emission_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(source_, std::tuple<std::false_type>()), func_, data_);
+}
+
+template <typename T>
+bool edje_object_part_text_cursor_next_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_next(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+void edje_object_part_text_style_user_push_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * style_)
+{
+   static_cast<T*>(self->this_)->part_text_style_user_push(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(style_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_append_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * text_)
+{
+   static_cast<T*>(self->this_)->part_text_append(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_geometry_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   return static_cast<T*>(self->this_)->part_geometry_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), x_, y_, w_, h_);
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_hide_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_hide(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_item_geometry_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * item_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+{
+   return static_cast<T*>(self->this_)->part_text_item_geometry_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(item_, std::tuple<std::false_type>()), cx_, cy_, cw_, ch_);
+}
+
+template <typename T>
+bool edje_object_part_table_unpack_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * child_obj_)
+{
+   return static_cast<T*>(self->this_)->part_table_unpack(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(child_obj_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_select_abort_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_select_abort(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void * edje_object_text_insert_filter_callback_del_full_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Text_Filter_Cb func_, void * data_)
+{
+   return static_cast<T*>(self->this_)->text_insert_filter_callback_del_full(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), func_, data_);
+}
+
+template <typename T>
+void edje_object_part_text_style_user_pop_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_style_user_pop(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_imdata_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const void * data_, int len_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_imdata_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), data_, len_);
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_imdata_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, void * data_, int * len_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_imdata_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), data_, len_);
+}
+
+template <typename T>
+void edje_object_part_text_insert_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * text_)
+{
+   static_cast<T*>(self->this_)->part_text_insert(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+evas::object edje_object_part_box_remove_at_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, unsigned int pos_)
+{
+   return static_cast<T*>(self->this_)->part_box_remove_at(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), pos_);
+}
+
+template <typename T>
+void edje_object_part_text_cursor_copy_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor src_, Edje_Cursor dst_)
+{
+   static_cast<T*>(self->this_)->part_text_cursor_copy(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), src_, dst_);
+}
+
+template <typename T>
+bool edje_object_parts_extends_calc_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   return static_cast<T*>(self->this_)->parts_extends_calc(x_, y_, w_, h_);
+}
+
+template <typename T>
+bool edje_object_part_drag_value_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double dx_, double dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_value_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+bool edje_object_part_drag_value_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double* dx_, double* dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_value_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+void edje_object_calc_force_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->calc_force();
+}
+
+template <typename T>
+void edje_object_part_text_cursor_pos_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_, int pos_)
+{
+   static_cast<T*>(self->this_)->part_text_cursor_pos_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_, pos_);
+}
+
+template <typename T>
+int edje_object_part_text_cursor_pos_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_pos_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+int edje_object_freeze_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->freeze();
+}
+
+template <typename T>
+char * edje_object_part_text_cursor_content_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_content_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_layout_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Input_Panel_Layout layout_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_layout_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), layout_);
+}
+
+template <typename T>
+Edje_Input_Panel_Layout edje_object_part_text_input_panel_layout_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_panel_layout_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_table_pack_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * child_obj_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_)
+{
+   return static_cast<T*>(self->this_)->part_table_pack(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(child_obj_, std::tuple<std::false_type>()), col_, row_, colspan_, rowspan_);
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_language_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Input_Panel_Lang lang_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_language_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), lang_);
+}
+
+template <typename T>
+Edje_Input_Panel_Lang edje_object_part_text_input_panel_language_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_panel_language_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_table_col_row_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, int* cols_, int* rows_)
+{
+   return static_cast<T*>(self->this_)->part_table_col_row_size_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cols_, rows_);
+}
+
+template <typename T>
+evas::object edje_object_part_external_object_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_external_object_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+evas::object edje_object_part_external_content_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char* content_)
+{
+   return static_cast<T*>(self->this_)->part_external_content_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), content_);
+}
+
+template <typename T>
+bool edje_object_preload_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool cancel_)
+{
+   return static_cast<T*>(self->this_)->preload(efl::eolian::to_cxx<bool>(cancel_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_enabled_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Eina_Bool enabled_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_enabled_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(enabled_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_input_panel_enabled_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_panel_enabled_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_select_extend_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_select_extend(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_box_insert_at_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * child_, unsigned int pos_)
+{
+   return static_cast<T*>(self->this_)->part_box_insert_at(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), pos_);
+}
+
+template <typename T>
+efl::eina::crange_list< const Evas_Textblock_Rectangle * > edje_object_part_text_anchor_geometry_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * anchor_)
+{
+   return static_cast<T*>(self->this_)->part_text_anchor_geometry_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(anchor_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_cursor_down_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_down(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+bool edje_object_part_drag_page_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double dx_, double dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_page_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+bool edje_object_part_drag_page_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double* dx_, double* dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_page_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+bool edje_object_part_box_prepend_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->part_box_prepend(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_signal_emit_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * emission_, const char * source_)
+{
+   static_cast<T*>(self->this_)->signal_emit(efl::eolian::to_cxx<std::string>(emission_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_layout_variation_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, int variation_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_layout_variation_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), variation_);
+}
+
+template <typename T>
+int edje_object_part_text_input_panel_layout_variation_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_panel_layout_variation_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_message_send_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Edje_Message_Type type_, int id_, void * msg_)
+{
+   static_cast<T*>(self->this_)->message_send(type_, id_, msg_);
+}
+
+template <typename T>
+void edje_object_part_text_select_none_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_select_none(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+const Evas_Object * edje_object_part_object_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_object_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_drag_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double dw_, double dh_)
+{
+   return static_cast<T*>(self->this_)->part_drag_size_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dw_, dh_);
+}
+
+template <typename T>
+bool edje_object_part_drag_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double* dw_, double* dh_)
+{
+   return static_cast<T*>(self->this_)->part_drag_size_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dw_, dh_);
+}
+
+template <typename T>
+void * edje_object_text_insert_filter_callback_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Text_Filter_Cb func_)
+{
+   return static_cast<T*>(self->this_)->text_insert_filter_callback_del(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), func_);
+}
+
+template <typename T>
+Edje_Drag_Dir edje_object_part_drag_dir_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_drag_dir_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_unescaped_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * text_to_escape_)
+{
+   return static_cast<T*>(self->this_)->part_text_unescaped_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(text_to_escape_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+char * edje_object_part_text_unescaped_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_unescaped_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_signal_callback_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * emission_, const char * source_, Edje_Signal_Cb func_, void * data_)
+{
+   static_cast<T*>(self->this_)->signal_callback_add(efl::eolian::to_cxx<std::string>(emission_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(source_, std::tuple<std::false_type>()), func_, data_);
+}
+
+template <typename T>
+void edje_object_part_text_select_all_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_select_all(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_return_key_disabled_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Eina_Bool disabled_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_return_key_disabled_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(disabled_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_input_panel_return_key_disabled_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_panel_return_key_disabled_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_autocapital_type_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Text_Autocapital_Type autocapital_type_)
+{
+   static_cast<T*>(self->this_)->part_text_autocapital_type_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), autocapital_type_);
+}
+
+template <typename T>
+Edje_Text_Autocapital_Type edje_object_part_text_autocapital_type_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_autocapital_type_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_unswallow_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * obj_swallow_)
+{
+   static_cast<T*>(self->this_)->part_unswallow(efl::eolian::to_cxx<evas::object>(obj_swallow_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_prediction_allow_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Eina_Bool prediction_)
+{
+   static_cast<T*>(self->this_)->part_text_prediction_allow_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(prediction_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_prediction_allow_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_prediction_allow_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string edje_object_data_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * key_)
+{
+   return static_cast<T*>(self->this_)->data_get(efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_text_markup_filter_callback_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Markup_Filter_Cb func_, void * data_)
+{
+   static_cast<T*>(self->this_)->text_markup_filter_callback_add(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), func_, data_);
+}
+
+template <typename T>
+void edje_object_message_signal_process_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->message_signal_process();
+}
+
+template <typename T>
+evas::object edje_object_part_box_remove_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->part_box_remove(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+int edje_object_thaw_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->thaw();
+}
+
+template <typename T>
+evas::object edje_object_part_swallow_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_swallow_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_imf_context_reset_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_imf_context_reset(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_return_key_type_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Input_Panel_Return_Key_Type return_key_type_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_return_key_type_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), return_key_type_);
+}
+
+template <typename T>
+Edje_Input_Panel_Return_Key_Type edje_object_part_text_input_panel_return_key_type_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_panel_return_key_type_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+evas::object edje_object_part_table_child_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, unsigned int col_, unsigned int row_)
+{
+   return static_cast<T*>(self->this_)->part_table_child_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), col_, row_);
+}
+
+template <typename T>
+bool edje_object_part_box_insert_before_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * child_, const Evas_Object * reference_)
+{
+   return static_cast<T*>(self->this_)->part_box_insert_before(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), reference_);
+}
+
+template <typename T>
+bool edje_object_part_external_param_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const Edje_External_Param * param_)
+{
+   return static_cast<T*>(self->this_)->part_external_param_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), param_);
+}
+
+template <typename T>
+bool edje_object_part_external_param_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_External_Param* param_)
+{
+   return static_cast<T*>(self->this_)->part_external_param_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), param_);
+}
+
+template <typename T>
+void edje_object_size_min_calc_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* minw_, Evas_Coord* minh_)
+{
+   static_cast<T*>(self->this_)->size_min_calc(minw_, minh_);
+}
+
+template <typename T>
+bool edje_object_part_box_append_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->part_box_append(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_size_min_restricted_calc_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* minw_, Evas_Coord* minh_, Evas_Coord restrictedw_, Evas_Coord restrictedh_)
+{
+   static_cast<T*>(self->this_)->size_min_restricted_calc(minw_, minh_, restrictedw_, restrictedh_);
+}
+
+template <typename T>
+bool edje_object_part_box_remove_all_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Eina_Bool clear_)
+{
+   return static_cast<T*>(self->this_)->part_box_remove_all(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(clear_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_drag_page_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double dx_, double dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_page(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+bool edje_object_part_text_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * text_)
+{
+   return static_cast<T*>(self->this_)->part_text_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string edje_object_part_text_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_show_on_demand_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Eina_Bool ondemand_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_show_on_demand_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(ondemand_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_input_panel_show_on_demand_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_panel_show_on_demand_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_part_text_input_hint_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Input_Hints input_hints_)
+{
+   static_cast<T*>(self->this_)->part_text_input_hint_set(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), input_hints_);
+}
+
+template <typename T>
+Edje_Input_Hints edje_object_part_text_input_hint_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_input_hint_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string edje_object_part_text_selection_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_selection_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_cursor_is_format_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_is_format_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+bool edje_object_color_class_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * color_class_, int r_, int g_, int b_, int a_, int r2_, int g2_, int b2_, int a2_, int r3_, int g3_, int b3_, int a3_)
+{
+   return static_cast<T*>(self->this_)->color_class_set(efl::eolian::to_cxx<std::string>(color_class_, std::tuple<std::false_type>()), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_);
+}
+
+template <typename T>
+bool edje_object_color_class_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * color_class_, int* r_, int* g_, int* b_, int* a_, int* r2_, int* g2_, int* b2_, int* a2_, int* r3_, int* g3_, int* b3_, int* a3_)
+{
+   return static_cast<T*>(self->this_)->color_class_get(efl::eolian::to_cxx<std::string>(color_class_, std::tuple<std::false_type>()), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_);
+}
+
+template <typename T>
+bool edje_object_part_drag_step_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, double dx_, double dy_)
+{
+   return static_cast<T*>(self->this_)->part_drag_step(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), dx_, dy_);
+}
+
+template <typename T>
+bool edje_object_part_text_cursor_up_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_up(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+void edje_object_part_text_cursor_geometry_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->part_text_cursor_geometry_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), x_, y_, w_, h_);
+}
+
+template <typename T>
+efl::eina::crange_list< std::string > edje_object_part_text_anchor_list_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_anchor_list_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void edje_object_text_insert_filter_callback_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Text_Filter_Cb func_, void * data_)
+{
+   static_cast<T*>(self->this_)->text_insert_filter_callback_add(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), func_, data_);
+}
+
+template <typename T>
+void edje_object_part_text_input_panel_show_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   static_cast<T*>(self->this_)->part_text_input_panel_show(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_exists_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_exists(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void * edje_object_text_markup_filter_callback_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Markup_Filter_Cb func_)
+{
+   return static_cast<T*>(self->this_)->text_markup_filter_callback_del(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), func_);
+}
+
+template <typename T>
+bool edje_object_part_text_cursor_is_visible_format_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_is_visible_format_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+void edje_object_part_text_user_insert_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, const char * text_)
+{
+   static_cast<T*>(self->this_)->part_text_user_insert(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_text_cursor_prev_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Edje_Cursor cur_)
+{
+   return static_cast<T*>(self->this_)->part_text_cursor_prev(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), cur_);
+}
+
+template <typename T>
+efl::eina::crange_list< std::string > edje_object_part_text_item_list_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_)
+{
+   return static_cast<T*>(self->this_)->part_text_item_list_get(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool edje_object_part_swallow_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * part_, Evas_Object * obj_swallow_)
+{
+   return static_cast<T*>(self->this_)->part_swallow(efl::eolian::to_cxx<std::string>(part_, std::tuple<std::false_type>()), efl::eolian::to_cxx<evas::object>(obj_swallow_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< edje::object >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_dbg_info_get(root_node_));
+      }
+
+      virtual void hide()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_hide());
+      }
+
+      virtual void calculate()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_calculate());
+      }
+
+      virtual void show()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_show());
+      }
+
+      virtual void move(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_move(x_, y_));
+      }
+
+      virtual void add()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_add());
+      }
+
+      virtual void del()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_del());
+      }
+
+      virtual void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_resize(w_, h_));
+      }
+
+      virtual bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void file_get(const char ** file_, const char ** key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_file_get(file_, key_));
+      }
+
+      virtual bool update_hints_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_update_hints_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void update_hints_set(bool update_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_update_hints_set(efl::eolian::to_c(update_)));
+      }
+
+      virtual bool mirrored_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_mirrored_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void mirrored_set(bool rtl_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_mirrored_set(efl::eolian::to_c(rtl_)));
+      }
+
+      virtual bool animation_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_animation_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void animation_set(bool on_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_animation_set(efl::eolian::to_c(on_)));
+      }
+
+      virtual bool play_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_play_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void play_set(bool play_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_play_set(efl::eolian::to_c(play_)));
+      }
+
+      virtual const Edje_Perspective * perspective_get()
+      {
+         const Edje_Perspective * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_perspective_get());
+            return _tmp_ret;
+      }
+
+      virtual void perspective_set(Edje_Perspective * ps_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_perspective_set(ps_));
+      }
+
+      virtual double scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_scale_get());
+            return _tmp_ret;
+      }
+
+      virtual bool scale_set(double scale_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_scale_set(scale_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual double base_scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_base_scale_get());
+            return _tmp_ret;
+      }
+
+      virtual bool mmap_set(const Eina_File * file_, std::string group_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_mmap_set(file_, efl::eolian::to_c(group_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void text_change_cb_set(Edje_Text_Change_Cb func_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_text_change_cb_set(func_, data_));
+      }
+
+      virtual void part_text_cursor_begin_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_cursor_begin_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      virtual void part_text_cursor_line_end_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_cursor_line_end_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      virtual bool text_class_set(std::string text_class_, std::string font_, Evas_Font_Size size_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_text_class_set(efl::eolian::to_c(text_class_), efl::eolian::to_c(font_), size_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_text_cursor_coord_set(std::string part_, Edje_Cursor cur_, Evas_Coord x_, Evas_Coord y_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_coord_set(efl::eolian::to_c(part_), cur_, x_, y_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_cursor_end_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_cursor_end_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      virtual bool part_text_escaped_set(std::string part_, std::string text_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_escaped_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void item_provider_set(Edje_Item_Provider_Cb func_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_item_provider_set(func_, data_));
+      }
+
+      virtual void part_text_cursor_line_begin_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_cursor_line_begin_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      virtual void message_handler_set(Edje_Message_Handler_Cb func_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_message_handler_set(func_, data_));
+      }
+
+      virtual void size_min_get(Evas_Coord* minw_, Evas_Coord* minh_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_size_min_get(minw_, minh_));
+      }
+
+      virtual efl::eina::range_list< std::string > access_part_list_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_access_part_list_get());
+            return efl::eolian::to_cxx<efl::eina::range_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual Edje_Load_Error load_error_get()
+      {
+         Edje_Load_Error _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_load_error_get());
+            return _tmp_ret;
+      }
+
+      virtual void size_max_get(Evas_Coord* maxw_, Evas_Coord* maxh_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_size_max_get(maxw_, maxh_));
+      }
+
+      virtual bool part_table_clear(std::string part_, bool clear_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_table_clear(efl::eolian::to_c(part_), efl::eolian::to_c(clear_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Edje_External_Param_Type part_external_param_type_get(std::string part_, const char* param_)
+      {
+         Edje_External_Param_Type _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_external_param_type_get(efl::eolian::to_c(part_), param_));
+            return _tmp_ret;
+      }
+
+      virtual void part_text_select_allow_set(std::string part_, bool allow_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_select_allow_set(efl::eolian::to_c(part_), efl::eolian::to_c(allow_)));
+      }
+
+      virtual std::string part_state_get(std::string part_, double* val_ret_)
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_state_get(efl::eolian::to_c(part_), val_ret_));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void * text_markup_filter_callback_del_full(std::string part_, Edje_Markup_Filter_Cb func_, void * data_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_text_markup_filter_callback_del_full(efl::eolian::to_c(part_), func_, data_));
+            return _tmp_ret;
+      }
+
+      virtual bool part_drag_step_set(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_step_set(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_step_get(std::string part_, double* dx_, double* dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_step_get(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void * part_text_imf_context_get(std::string part_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_imf_context_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual void part_text_select_begin(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_select_begin(efl::eolian::to_c(part_)));
+      }
+
+      virtual std::string part_text_style_user_peek(std::string part_)
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_style_user_peek(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void * signal_callback_del(std::string emission_, std::string source_, Edje_Signal_Cb func_, void * data_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_signal_callback_del(efl::eolian::to_c(emission_), efl::eolian::to_c(source_), func_, data_));
+            return _tmp_ret;
+      }
+
+      virtual bool part_text_cursor_next(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_next(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_style_user_push(std::string part_, std::string style_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_style_user_push(efl::eolian::to_c(part_), efl::eolian::to_c(style_)));
+      }
+
+      virtual void part_text_append(std::string part_, std::string text_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_append(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      }
+
+      virtual bool part_geometry_get(std::string part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_geometry_get(efl::eolian::to_c(part_), x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_input_panel_hide(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_hide(efl::eolian::to_c(part_)));
+      }
+
+      virtual bool part_text_item_geometry_get(std::string part_, std::string item_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_item_geometry_get(efl::eolian::to_c(part_), efl::eolian::to_c(item_), cx_, cy_, cw_, ch_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_table_unpack(std::string part_, evas::object child_obj_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_table_unpack(efl::eolian::to_c(part_), efl::eolian::to_c(child_obj_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_select_abort(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_select_abort(efl::eolian::to_c(part_)));
+      }
+
+      virtual void * text_insert_filter_callback_del_full(std::string part_, Edje_Text_Filter_Cb func_, void * data_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_text_insert_filter_callback_del_full(efl::eolian::to_c(part_), func_, data_));
+            return _tmp_ret;
+      }
+
+      virtual void part_text_style_user_pop(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_style_user_pop(efl::eolian::to_c(part_)));
+      }
+
+      virtual void part_text_input_panel_imdata_set(std::string part_, const void * data_, int len_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_imdata_set(efl::eolian::to_c(part_), data_, len_));
+      }
+
+      virtual void part_text_input_panel_imdata_get(std::string part_, void * data_, int * len_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_imdata_get(efl::eolian::to_c(part_), data_, len_));
+      }
+
+      virtual void part_text_insert(std::string part_, std::string text_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_insert(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      }
+
+      virtual evas::object part_box_remove_at(std::string part_, unsigned int pos_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_box_remove_at(efl::eolian::to_c(part_), pos_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_cursor_copy(std::string part_, Edje_Cursor src_, Edje_Cursor dst_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_cursor_copy(efl::eolian::to_c(part_), src_, dst_));
+      }
+
+      virtual bool parts_extends_calc(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_parts_extends_calc(x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_value_set(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_value_set(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_value_get(std::string part_, double* dx_, double* dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_value_get(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void calc_force()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_calc_force());
+      }
+
+      virtual void part_text_cursor_pos_set(std::string part_, Edje_Cursor cur_, int pos_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_cursor_pos_set(efl::eolian::to_c(part_), cur_, pos_));
+      }
+
+      virtual int part_text_cursor_pos_get(std::string part_, Edje_Cursor cur_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_pos_get(efl::eolian::to_c(part_), cur_));
+            return _tmp_ret;
+      }
+
+      virtual int freeze()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_freeze());
+            return _tmp_ret;
+      }
+
+      virtual char * part_text_cursor_content_get(std::string part_, Edje_Cursor cur_)
+      {
+         char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_content_get(efl::eolian::to_c(part_), cur_));
+            return _tmp_ret;
+      }
+
+      virtual void part_text_input_panel_layout_set(std::string part_, Edje_Input_Panel_Layout layout_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_layout_set(efl::eolian::to_c(part_), layout_));
+      }
+
+      virtual Edje_Input_Panel_Layout part_text_input_panel_layout_get(std::string part_)
+      {
+         Edje_Input_Panel_Layout _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_panel_layout_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual bool part_table_pack(std::string part_, evas::object child_obj_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_table_pack(efl::eolian::to_c(part_), efl::eolian::to_c(child_obj_), col_, row_, colspan_, rowspan_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_input_panel_language_set(std::string part_, Edje_Input_Panel_Lang lang_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_language_set(efl::eolian::to_c(part_), lang_));
+      }
+
+      virtual Edje_Input_Panel_Lang part_text_input_panel_language_get(std::string part_)
+      {
+         Edje_Input_Panel_Lang _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_panel_language_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual bool part_table_col_row_size_get(std::string part_, int* cols_, int* rows_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_table_col_row_size_get(efl::eolian::to_c(part_), cols_, rows_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object part_external_object_get(std::string part_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_external_object_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object part_external_content_get(std::string part_, const char* content_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_external_content_get(efl::eolian::to_c(part_), content_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool preload(bool cancel_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_preload(efl::eolian::to_c(cancel_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_input_panel_enabled_set(std::string part_, bool enabled_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_enabled_set(efl::eolian::to_c(part_), efl::eolian::to_c(enabled_)));
+      }
+
+      virtual bool part_text_input_panel_enabled_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_panel_enabled_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_select_extend(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_select_extend(efl::eolian::to_c(part_)));
+      }
+
+      virtual bool part_box_insert_at(std::string part_, evas::object child_, unsigned int pos_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_box_insert_at(efl::eolian::to_c(part_), efl::eolian::to_c(child_), pos_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual efl::eina::crange_list< const Evas_Textblock_Rectangle * > part_text_anchor_geometry_get(std::string part_, std::string anchor_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_anchor_geometry_get(efl::eolian::to_c(part_), efl::eolian::to_c(anchor_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< const Evas_Textblock_Rectangle * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual bool part_text_cursor_down(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_down(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_page_set(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_page_set(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_page_get(std::string part_, double* dx_, double* dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_page_get(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_box_prepend(std::string part_, evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_box_prepend(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void signal_emit(std::string emission_, std::string source_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_signal_emit(efl::eolian::to_c(emission_), efl::eolian::to_c(source_)));
+      }
+
+      virtual void part_text_input_panel_layout_variation_set(std::string part_, int variation_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_layout_variation_set(efl::eolian::to_c(part_), variation_));
+      }
+
+      virtual int part_text_input_panel_layout_variation_get(std::string part_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_panel_layout_variation_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual void message_send(Edje_Message_Type type_, int id_, void * msg_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_message_send(type_, id_, msg_));
+      }
+
+      virtual void part_text_select_none(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_select_none(efl::eolian::to_c(part_)));
+      }
+
+      virtual const Evas_Object * part_object_get(std::string part_)
+      {
+         const Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_object_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual bool part_drag_size_set(std::string part_, double dw_, double dh_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_size_set(efl::eolian::to_c(part_), dw_, dh_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_size_get(std::string part_, double* dw_, double* dh_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_size_get(efl::eolian::to_c(part_), dw_, dh_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void * text_insert_filter_callback_del(std::string part_, Edje_Text_Filter_Cb func_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_text_insert_filter_callback_del(efl::eolian::to_c(part_), func_));
+            return _tmp_ret;
+      }
+
+      virtual Edje_Drag_Dir part_drag_dir_get(std::string part_)
+      {
+         Edje_Drag_Dir _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_dir_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual bool part_text_unescaped_set(std::string part_, std::string text_to_escape_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_unescaped_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_to_escape_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual char * part_text_unescaped_get(std::string part_)
+      {
+         char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_unescaped_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual void signal_callback_add(std::string emission_, std::string source_, Edje_Signal_Cb func_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_signal_callback_add(efl::eolian::to_c(emission_), efl::eolian::to_c(source_), func_, data_));
+      }
+
+      virtual void part_text_select_all(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_select_all(efl::eolian::to_c(part_)));
+      }
+
+      virtual void part_text_input_panel_return_key_disabled_set(std::string part_, bool disabled_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_return_key_disabled_set(efl::eolian::to_c(part_), efl::eolian::to_c(disabled_)));
+      }
+
+      virtual bool part_text_input_panel_return_key_disabled_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_panel_return_key_disabled_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_autocapital_type_set(std::string part_, Edje_Text_Autocapital_Type autocapital_type_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_autocapital_type_set(efl::eolian::to_c(part_), autocapital_type_));
+      }
+
+      virtual Edje_Text_Autocapital_Type part_text_autocapital_type_get(std::string part_)
+      {
+         Edje_Text_Autocapital_Type _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_autocapital_type_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual void part_unswallow(evas::object obj_swallow_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_unswallow(efl::eolian::to_c(obj_swallow_)));
+      }
+
+      virtual void part_text_prediction_allow_set(std::string part_, bool prediction_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_prediction_allow_set(efl::eolian::to_c(part_), efl::eolian::to_c(prediction_)));
+      }
+
+      virtual bool part_text_prediction_allow_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_prediction_allow_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual std::string data_get(std::string key_)
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_data_get(efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void text_markup_filter_callback_add(std::string part_, Edje_Markup_Filter_Cb func_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_text_markup_filter_callback_add(efl::eolian::to_c(part_), func_, data_));
+      }
+
+      virtual void message_signal_process()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_message_signal_process());
+      }
+
+      virtual evas::object part_box_remove(std::string part_, evas::object child_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_box_remove(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual int thaw()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_thaw());
+            return _tmp_ret;
+      }
+
+      virtual evas::object part_swallow_get(std::string part_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_swallow_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_imf_context_reset(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_imf_context_reset(efl::eolian::to_c(part_)));
+      }
+
+      virtual void part_text_input_panel_return_key_type_set(std::string part_, Edje_Input_Panel_Return_Key_Type return_key_type_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_return_key_type_set(efl::eolian::to_c(part_), return_key_type_));
+      }
+
+      virtual Edje_Input_Panel_Return_Key_Type part_text_input_panel_return_key_type_get(std::string part_)
+      {
+         Edje_Input_Panel_Return_Key_Type _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_panel_return_key_type_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual evas::object part_table_child_get(std::string part_, unsigned int col_, unsigned int row_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_table_child_get(efl::eolian::to_c(part_), col_, row_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_box_insert_before(std::string part_, evas::object child_, const Evas_Object * reference_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_box_insert_before(efl::eolian::to_c(part_), efl::eolian::to_c(child_), reference_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_external_param_set(std::string part_, const Edje_External_Param * param_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_external_param_set(efl::eolian::to_c(part_), param_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_external_param_get(std::string part_, Edje_External_Param* param_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_external_param_get(efl::eolian::to_c(part_), param_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void size_min_calc(Evas_Coord* minw_, Evas_Coord* minh_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_size_min_calc(minw_, minh_));
+      }
+
+      virtual bool part_box_append(std::string part_, evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_box_append(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void size_min_restricted_calc(Evas_Coord* minw_, Evas_Coord* minh_, Evas_Coord restrictedw_, Evas_Coord restrictedh_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_size_min_restricted_calc(minw_, minh_, restrictedw_, restrictedh_));
+      }
+
+      virtual bool part_box_remove_all(std::string part_, bool clear_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_box_remove_all(efl::eolian::to_c(part_), efl::eolian::to_c(clear_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_page(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_page(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_text_set(std::string part_, std::string text_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual std::string part_text_get(std::string part_)
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_input_panel_show_on_demand_set(std::string part_, bool ondemand_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_show_on_demand_set(efl::eolian::to_c(part_), efl::eolian::to_c(ondemand_)));
+      }
+
+      virtual bool part_text_input_panel_show_on_demand_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_panel_show_on_demand_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_input_hint_set(std::string part_, Edje_Input_Hints input_hints_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_hint_set(efl::eolian::to_c(part_), input_hints_));
+      }
+
+      virtual Edje_Input_Hints part_text_input_hint_get(std::string part_)
+      {
+         Edje_Input_Hints _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_input_hint_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      virtual std::string part_text_selection_get(std::string part_)
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_selection_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_text_cursor_is_format_get(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_is_format_get(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool color_class_set(std::string color_class_, int r_, int g_, int b_, int a_, int r2_, int g2_, int b2_, int a2_, int r3_, int g3_, int b3_, int a3_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_color_class_set(efl::eolian::to_c(color_class_), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool color_class_get(std::string color_class_, int* r_, int* g_, int* b_, int* a_, int* r2_, int* g2_, int* b2_, int* a2_, int* r3_, int* g3_, int* b3_, int* a3_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_color_class_get(efl::eolian::to_c(color_class_), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_drag_step(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_drag_step(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool part_text_cursor_up(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_up(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_cursor_geometry_get(std::string part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_cursor_geometry_get(efl::eolian::to_c(part_), x_, y_, w_, h_));
+      }
+
+      virtual efl::eina::crange_list< std::string > part_text_anchor_list_get(std::string part_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_anchor_list_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual void text_insert_filter_callback_add(std::string part_, Edje_Text_Filter_Cb func_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_text_insert_filter_callback_add(efl::eolian::to_c(part_), func_, data_));
+      }
+
+      virtual void part_text_input_panel_show(std::string part_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_input_panel_show(efl::eolian::to_c(part_)));
+      }
+
+      virtual bool part_exists(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_exists(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void * text_markup_filter_callback_del(std::string part_, Edje_Markup_Filter_Cb func_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_text_markup_filter_callback_del(efl::eolian::to_c(part_), func_));
+            return _tmp_ret;
+      }
+
+      virtual bool part_text_cursor_is_visible_format_get(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_is_visible_format_get(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void part_text_user_insert(std::string part_, std::string text_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::edje_obj_part_text_user_insert(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      }
+
+      virtual bool part_text_cursor_prev(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_cursor_prev(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual efl::eina::crange_list< std::string > part_text_item_list_get(std::string part_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_text_item_list_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual bool part_swallow(std::string part_, evas::object obj_swallow_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::edje_obj_part_swallow(efl::eolian::to_c(part_), efl::eolian::to_c(obj_swallow_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< edje::object >
+{
+   static const int value = 152;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<edje::object>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::edje_object_dbg_info_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_dbg_info_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::edje_object_hide_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_hide);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::edje_object_calculate_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_calculate);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::edje_object_show_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_show);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::edje_object_move_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_move);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::edje_object_add_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_add);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::edje_object_del_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_del);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::edje_object_resize_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_resize);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::edje_object_file_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::efl_file_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::edje_object_file_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::efl_file_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::edje_object_update_hints_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::edje_obj_update_hints_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::edje_object_update_hints_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::edje_obj_update_hints_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::edje_object_mirrored_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::edje_obj_mirrored_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::edje_object_mirrored_set_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::edje_obj_mirrored_set);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::edje_object_animation_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::edje_obj_animation_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::edje_object_animation_set_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::edje_obj_animation_set);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::edje_object_play_get_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::edje_obj_play_get);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::edje_object_play_set_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::edje_obj_play_set);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::edje_object_perspective_get_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::edje_obj_perspective_get);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::edje_object_perspective_set_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::edje_obj_perspective_set);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::edje_object_scale_get_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::edje_obj_scale_get);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::edje_object_scale_set_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::edje_obj_scale_set);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::edje_object_base_scale_get_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::edje_obj_base_scale_get);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::edje_object_mmap_set_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::edje_obj_mmap_set);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::edje_object_text_change_cb_set_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::edje_obj_text_change_cb_set);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_begin_set_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_begin_set);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_line_end_set_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_line_end_set);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::edje_object_text_class_set_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::edje_obj_text_class_set);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_coord_set_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_coord_set);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   ops[29].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_end_set_wrapper<T>);
+   ops[29].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_end_set);
+   ops[29].op = EO_OP_OVERRIDE;
+   ops[29].op_type = EO_OP_TYPE_REGULAR;
+   ops[29].doc = NULL;
+
+   ops[30].func = reinterpret_cast<void*>(& ::edje_object_part_text_escaped_set_wrapper<T>);
+   ops[30].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_escaped_set);
+   ops[30].op = EO_OP_OVERRIDE;
+   ops[30].op_type = EO_OP_TYPE_REGULAR;
+   ops[30].doc = NULL;
+
+   ops[31].func = reinterpret_cast<void*>(& ::edje_object_item_provider_set_wrapper<T>);
+   ops[31].api_func = reinterpret_cast<void*>(& ::edje_obj_item_provider_set);
+   ops[31].op = EO_OP_OVERRIDE;
+   ops[31].op_type = EO_OP_TYPE_REGULAR;
+   ops[31].doc = NULL;
+
+   ops[32].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_line_begin_set_wrapper<T>);
+   ops[32].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_line_begin_set);
+   ops[32].op = EO_OP_OVERRIDE;
+   ops[32].op_type = EO_OP_TYPE_REGULAR;
+   ops[32].doc = NULL;
+
+   ops[33].func = reinterpret_cast<void*>(& ::edje_object_message_handler_set_wrapper<T>);
+   ops[33].api_func = reinterpret_cast<void*>(& ::edje_obj_message_handler_set);
+   ops[33].op = EO_OP_OVERRIDE;
+   ops[33].op_type = EO_OP_TYPE_REGULAR;
+   ops[33].doc = NULL;
+
+   ops[34].func = reinterpret_cast<void*>(& ::edje_object_size_min_get_wrapper<T>);
+   ops[34].api_func = reinterpret_cast<void*>(& ::edje_obj_size_min_get);
+   ops[34].op = EO_OP_OVERRIDE;
+   ops[34].op_type = EO_OP_TYPE_REGULAR;
+   ops[34].doc = NULL;
+
+   ops[35].func = reinterpret_cast<void*>(& ::edje_object_access_part_list_get_wrapper<T>);
+   ops[35].api_func = reinterpret_cast<void*>(& ::edje_obj_access_part_list_get);
+   ops[35].op = EO_OP_OVERRIDE;
+   ops[35].op_type = EO_OP_TYPE_REGULAR;
+   ops[35].doc = NULL;
+
+   ops[36].func = reinterpret_cast<void*>(& ::edje_object_load_error_get_wrapper<T>);
+   ops[36].api_func = reinterpret_cast<void*>(& ::edje_obj_load_error_get);
+   ops[36].op = EO_OP_OVERRIDE;
+   ops[36].op_type = EO_OP_TYPE_REGULAR;
+   ops[36].doc = NULL;
+
+   ops[37].func = reinterpret_cast<void*>(& ::edje_object_size_max_get_wrapper<T>);
+   ops[37].api_func = reinterpret_cast<void*>(& ::edje_obj_size_max_get);
+   ops[37].op = EO_OP_OVERRIDE;
+   ops[37].op_type = EO_OP_TYPE_REGULAR;
+   ops[37].doc = NULL;
+
+   ops[38].func = reinterpret_cast<void*>(& ::edje_object_part_table_clear_wrapper<T>);
+   ops[38].api_func = reinterpret_cast<void*>(& ::edje_obj_part_table_clear);
+   ops[38].op = EO_OP_OVERRIDE;
+   ops[38].op_type = EO_OP_TYPE_REGULAR;
+   ops[38].doc = NULL;
+
+   ops[39].func = reinterpret_cast<void*>(& ::edje_object_part_external_param_type_get_wrapper<T>);
+   ops[39].api_func = reinterpret_cast<void*>(& ::edje_obj_part_external_param_type_get);
+   ops[39].op = EO_OP_OVERRIDE;
+   ops[39].op_type = EO_OP_TYPE_REGULAR;
+   ops[39].doc = NULL;
+
+   ops[40].func = reinterpret_cast<void*>(& ::edje_object_part_text_select_allow_set_wrapper<T>);
+   ops[40].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_select_allow_set);
+   ops[40].op = EO_OP_OVERRIDE;
+   ops[40].op_type = EO_OP_TYPE_REGULAR;
+   ops[40].doc = NULL;
+
+   ops[41].func = reinterpret_cast<void*>(& ::edje_object_part_state_get_wrapper<T>);
+   ops[41].api_func = reinterpret_cast<void*>(& ::edje_obj_part_state_get);
+   ops[41].op = EO_OP_OVERRIDE;
+   ops[41].op_type = EO_OP_TYPE_REGULAR;
+   ops[41].doc = NULL;
+
+   ops[42].func = reinterpret_cast<void*>(& ::edje_object_text_markup_filter_callback_del_full_wrapper<T>);
+   ops[42].api_func = reinterpret_cast<void*>(& ::edje_obj_text_markup_filter_callback_del_full);
+   ops[42].op = EO_OP_OVERRIDE;
+   ops[42].op_type = EO_OP_TYPE_REGULAR;
+   ops[42].doc = NULL;
+
+   ops[43].func = reinterpret_cast<void*>(& ::edje_object_part_drag_step_set_wrapper<T>);
+   ops[43].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_step_set);
+   ops[43].op = EO_OP_OVERRIDE;
+   ops[43].op_type = EO_OP_TYPE_REGULAR;
+   ops[43].doc = NULL;
+
+   ops[44].func = reinterpret_cast<void*>(& ::edje_object_part_drag_step_get_wrapper<T>);
+   ops[44].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_step_get);
+   ops[44].op = EO_OP_OVERRIDE;
+   ops[44].op_type = EO_OP_TYPE_REGULAR;
+   ops[44].doc = NULL;
+
+   ops[45].func = reinterpret_cast<void*>(& ::edje_object_part_text_imf_context_get_wrapper<T>);
+   ops[45].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_imf_context_get);
+   ops[45].op = EO_OP_OVERRIDE;
+   ops[45].op_type = EO_OP_TYPE_REGULAR;
+   ops[45].doc = NULL;
+
+   ops[46].func = reinterpret_cast<void*>(& ::edje_object_part_text_select_begin_wrapper<T>);
+   ops[46].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_select_begin);
+   ops[46].op = EO_OP_OVERRIDE;
+   ops[46].op_type = EO_OP_TYPE_REGULAR;
+   ops[46].doc = NULL;
+
+   ops[47].func = reinterpret_cast<void*>(& ::edje_object_part_text_style_user_peek_wrapper<T>);
+   ops[47].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_style_user_peek);
+   ops[47].op = EO_OP_OVERRIDE;
+   ops[47].op_type = EO_OP_TYPE_REGULAR;
+   ops[47].doc = NULL;
+
+   ops[48].func = reinterpret_cast<void*>(& ::edje_object_signal_callback_del_wrapper<T>);
+   ops[48].api_func = reinterpret_cast<void*>(& ::edje_obj_signal_callback_del);
+   ops[48].op = EO_OP_OVERRIDE;
+   ops[48].op_type = EO_OP_TYPE_REGULAR;
+   ops[48].doc = NULL;
+
+   ops[49].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_next_wrapper<T>);
+   ops[49].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_next);
+   ops[49].op = EO_OP_OVERRIDE;
+   ops[49].op_type = EO_OP_TYPE_REGULAR;
+   ops[49].doc = NULL;
+
+   ops[50].func = reinterpret_cast<void*>(& ::edje_object_part_text_style_user_push_wrapper<T>);
+   ops[50].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_style_user_push);
+   ops[50].op = EO_OP_OVERRIDE;
+   ops[50].op_type = EO_OP_TYPE_REGULAR;
+   ops[50].doc = NULL;
+
+   ops[51].func = reinterpret_cast<void*>(& ::edje_object_part_text_append_wrapper<T>);
+   ops[51].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_append);
+   ops[51].op = EO_OP_OVERRIDE;
+   ops[51].op_type = EO_OP_TYPE_REGULAR;
+   ops[51].doc = NULL;
+
+   ops[52].func = reinterpret_cast<void*>(& ::edje_object_part_geometry_get_wrapper<T>);
+   ops[52].api_func = reinterpret_cast<void*>(& ::edje_obj_part_geometry_get);
+   ops[52].op = EO_OP_OVERRIDE;
+   ops[52].op_type = EO_OP_TYPE_REGULAR;
+   ops[52].doc = NULL;
+
+   ops[53].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_hide_wrapper<T>);
+   ops[53].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_hide);
+   ops[53].op = EO_OP_OVERRIDE;
+   ops[53].op_type = EO_OP_TYPE_REGULAR;
+   ops[53].doc = NULL;
+
+   ops[54].func = reinterpret_cast<void*>(& ::edje_object_part_text_item_geometry_get_wrapper<T>);
+   ops[54].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_item_geometry_get);
+   ops[54].op = EO_OP_OVERRIDE;
+   ops[54].op_type = EO_OP_TYPE_REGULAR;
+   ops[54].doc = NULL;
+
+   ops[55].func = reinterpret_cast<void*>(& ::edje_object_part_table_unpack_wrapper<T>);
+   ops[55].api_func = reinterpret_cast<void*>(& ::edje_obj_part_table_unpack);
+   ops[55].op = EO_OP_OVERRIDE;
+   ops[55].op_type = EO_OP_TYPE_REGULAR;
+   ops[55].doc = NULL;
+
+   ops[56].func = reinterpret_cast<void*>(& ::edje_object_part_text_select_abort_wrapper<T>);
+   ops[56].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_select_abort);
+   ops[56].op = EO_OP_OVERRIDE;
+   ops[56].op_type = EO_OP_TYPE_REGULAR;
+   ops[56].doc = NULL;
+
+   ops[57].func = reinterpret_cast<void*>(& ::edje_object_text_insert_filter_callback_del_full_wrapper<T>);
+   ops[57].api_func = reinterpret_cast<void*>(& ::edje_obj_text_insert_filter_callback_del_full);
+   ops[57].op = EO_OP_OVERRIDE;
+   ops[57].op_type = EO_OP_TYPE_REGULAR;
+   ops[57].doc = NULL;
+
+   ops[58].func = reinterpret_cast<void*>(& ::edje_object_part_text_style_user_pop_wrapper<T>);
+   ops[58].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_style_user_pop);
+   ops[58].op = EO_OP_OVERRIDE;
+   ops[58].op_type = EO_OP_TYPE_REGULAR;
+   ops[58].doc = NULL;
+
+   ops[59].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_imdata_set_wrapper<T>);
+   ops[59].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_imdata_set);
+   ops[59].op = EO_OP_OVERRIDE;
+   ops[59].op_type = EO_OP_TYPE_REGULAR;
+   ops[59].doc = NULL;
+
+   ops[60].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_imdata_get_wrapper<T>);
+   ops[60].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_imdata_get);
+   ops[60].op = EO_OP_OVERRIDE;
+   ops[60].op_type = EO_OP_TYPE_REGULAR;
+   ops[60].doc = NULL;
+
+   ops[61].func = reinterpret_cast<void*>(& ::edje_object_part_text_insert_wrapper<T>);
+   ops[61].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_insert);
+   ops[61].op = EO_OP_OVERRIDE;
+   ops[61].op_type = EO_OP_TYPE_REGULAR;
+   ops[61].doc = NULL;
+
+   ops[62].func = reinterpret_cast<void*>(& ::edje_object_part_box_remove_at_wrapper<T>);
+   ops[62].api_func = reinterpret_cast<void*>(& ::edje_obj_part_box_remove_at);
+   ops[62].op = EO_OP_OVERRIDE;
+   ops[62].op_type = EO_OP_TYPE_REGULAR;
+   ops[62].doc = NULL;
+
+   ops[63].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_copy_wrapper<T>);
+   ops[63].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_copy);
+   ops[63].op = EO_OP_OVERRIDE;
+   ops[63].op_type = EO_OP_TYPE_REGULAR;
+   ops[63].doc = NULL;
+
+   ops[64].func = reinterpret_cast<void*>(& ::edje_object_parts_extends_calc_wrapper<T>);
+   ops[64].api_func = reinterpret_cast<void*>(& ::edje_obj_parts_extends_calc);
+   ops[64].op = EO_OP_OVERRIDE;
+   ops[64].op_type = EO_OP_TYPE_REGULAR;
+   ops[64].doc = NULL;
+
+   ops[65].func = reinterpret_cast<void*>(& ::edje_object_part_drag_value_set_wrapper<T>);
+   ops[65].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_value_set);
+   ops[65].op = EO_OP_OVERRIDE;
+   ops[65].op_type = EO_OP_TYPE_REGULAR;
+   ops[65].doc = NULL;
+
+   ops[66].func = reinterpret_cast<void*>(& ::edje_object_part_drag_value_get_wrapper<T>);
+   ops[66].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_value_get);
+   ops[66].op = EO_OP_OVERRIDE;
+   ops[66].op_type = EO_OP_TYPE_REGULAR;
+   ops[66].doc = NULL;
+
+   ops[67].func = reinterpret_cast<void*>(& ::edje_object_calc_force_wrapper<T>);
+   ops[67].api_func = reinterpret_cast<void*>(& ::edje_obj_calc_force);
+   ops[67].op = EO_OP_OVERRIDE;
+   ops[67].op_type = EO_OP_TYPE_REGULAR;
+   ops[67].doc = NULL;
+
+   ops[68].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_pos_set_wrapper<T>);
+   ops[68].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_pos_set);
+   ops[68].op = EO_OP_OVERRIDE;
+   ops[68].op_type = EO_OP_TYPE_REGULAR;
+   ops[68].doc = NULL;
+
+   ops[69].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_pos_get_wrapper<T>);
+   ops[69].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_pos_get);
+   ops[69].op = EO_OP_OVERRIDE;
+   ops[69].op_type = EO_OP_TYPE_REGULAR;
+   ops[69].doc = NULL;
+
+   ops[70].func = reinterpret_cast<void*>(& ::edje_object_freeze_wrapper<T>);
+   ops[70].api_func = reinterpret_cast<void*>(& ::edje_obj_freeze);
+   ops[70].op = EO_OP_OVERRIDE;
+   ops[70].op_type = EO_OP_TYPE_REGULAR;
+   ops[70].doc = NULL;
+
+   ops[71].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_content_get_wrapper<T>);
+   ops[71].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_content_get);
+   ops[71].op = EO_OP_OVERRIDE;
+   ops[71].op_type = EO_OP_TYPE_REGULAR;
+   ops[71].doc = NULL;
+
+   ops[72].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_layout_set_wrapper<T>);
+   ops[72].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_layout_set);
+   ops[72].op = EO_OP_OVERRIDE;
+   ops[72].op_type = EO_OP_TYPE_REGULAR;
+   ops[72].doc = NULL;
+
+   ops[73].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_layout_get_wrapper<T>);
+   ops[73].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_layout_get);
+   ops[73].op = EO_OP_OVERRIDE;
+   ops[73].op_type = EO_OP_TYPE_REGULAR;
+   ops[73].doc = NULL;
+
+   ops[74].func = reinterpret_cast<void*>(& ::edje_object_part_table_pack_wrapper<T>);
+   ops[74].api_func = reinterpret_cast<void*>(& ::edje_obj_part_table_pack);
+   ops[74].op = EO_OP_OVERRIDE;
+   ops[74].op_type = EO_OP_TYPE_REGULAR;
+   ops[74].doc = NULL;
+
+   ops[75].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_language_set_wrapper<T>);
+   ops[75].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_language_set);
+   ops[75].op = EO_OP_OVERRIDE;
+   ops[75].op_type = EO_OP_TYPE_REGULAR;
+   ops[75].doc = NULL;
+
+   ops[76].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_language_get_wrapper<T>);
+   ops[76].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_language_get);
+   ops[76].op = EO_OP_OVERRIDE;
+   ops[76].op_type = EO_OP_TYPE_REGULAR;
+   ops[76].doc = NULL;
+
+   ops[77].func = reinterpret_cast<void*>(& ::edje_object_part_table_col_row_size_get_wrapper<T>);
+   ops[77].api_func = reinterpret_cast<void*>(& ::edje_obj_part_table_col_row_size_get);
+   ops[77].op = EO_OP_OVERRIDE;
+   ops[77].op_type = EO_OP_TYPE_REGULAR;
+   ops[77].doc = NULL;
+
+   ops[78].func = reinterpret_cast<void*>(& ::edje_object_part_external_object_get_wrapper<T>);
+   ops[78].api_func = reinterpret_cast<void*>(& ::edje_obj_part_external_object_get);
+   ops[78].op = EO_OP_OVERRIDE;
+   ops[78].op_type = EO_OP_TYPE_REGULAR;
+   ops[78].doc = NULL;
+
+   ops[79].func = reinterpret_cast<void*>(& ::edje_object_part_external_content_get_wrapper<T>);
+   ops[79].api_func = reinterpret_cast<void*>(& ::edje_obj_part_external_content_get);
+   ops[79].op = EO_OP_OVERRIDE;
+   ops[79].op_type = EO_OP_TYPE_REGULAR;
+   ops[79].doc = NULL;
+
+   ops[80].func = reinterpret_cast<void*>(& ::edje_object_preload_wrapper<T>);
+   ops[80].api_func = reinterpret_cast<void*>(& ::edje_obj_preload);
+   ops[80].op = EO_OP_OVERRIDE;
+   ops[80].op_type = EO_OP_TYPE_REGULAR;
+   ops[80].doc = NULL;
+
+   ops[81].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_enabled_set_wrapper<T>);
+   ops[81].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_enabled_set);
+   ops[81].op = EO_OP_OVERRIDE;
+   ops[81].op_type = EO_OP_TYPE_REGULAR;
+   ops[81].doc = NULL;
+
+   ops[82].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_enabled_get_wrapper<T>);
+   ops[82].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_enabled_get);
+   ops[82].op = EO_OP_OVERRIDE;
+   ops[82].op_type = EO_OP_TYPE_REGULAR;
+   ops[82].doc = NULL;
+
+   ops[83].func = reinterpret_cast<void*>(& ::edje_object_part_text_select_extend_wrapper<T>);
+   ops[83].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_select_extend);
+   ops[83].op = EO_OP_OVERRIDE;
+   ops[83].op_type = EO_OP_TYPE_REGULAR;
+   ops[83].doc = NULL;
+
+   ops[84].func = reinterpret_cast<void*>(& ::edje_object_part_box_insert_at_wrapper<T>);
+   ops[84].api_func = reinterpret_cast<void*>(& ::edje_obj_part_box_insert_at);
+   ops[84].op = EO_OP_OVERRIDE;
+   ops[84].op_type = EO_OP_TYPE_REGULAR;
+   ops[84].doc = NULL;
+
+   ops[85].func = reinterpret_cast<void*>(& ::edje_object_part_text_anchor_geometry_get_wrapper<T>);
+   ops[85].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_anchor_geometry_get);
+   ops[85].op = EO_OP_OVERRIDE;
+   ops[85].op_type = EO_OP_TYPE_REGULAR;
+   ops[85].doc = NULL;
+
+   ops[86].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_down_wrapper<T>);
+   ops[86].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_down);
+   ops[86].op = EO_OP_OVERRIDE;
+   ops[86].op_type = EO_OP_TYPE_REGULAR;
+   ops[86].doc = NULL;
+
+   ops[87].func = reinterpret_cast<void*>(& ::edje_object_part_drag_page_set_wrapper<T>);
+   ops[87].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_page_set);
+   ops[87].op = EO_OP_OVERRIDE;
+   ops[87].op_type = EO_OP_TYPE_REGULAR;
+   ops[87].doc = NULL;
+
+   ops[88].func = reinterpret_cast<void*>(& ::edje_object_part_drag_page_get_wrapper<T>);
+   ops[88].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_page_get);
+   ops[88].op = EO_OP_OVERRIDE;
+   ops[88].op_type = EO_OP_TYPE_REGULAR;
+   ops[88].doc = NULL;
+
+   ops[89].func = reinterpret_cast<void*>(& ::edje_object_part_box_prepend_wrapper<T>);
+   ops[89].api_func = reinterpret_cast<void*>(& ::edje_obj_part_box_prepend);
+   ops[89].op = EO_OP_OVERRIDE;
+   ops[89].op_type = EO_OP_TYPE_REGULAR;
+   ops[89].doc = NULL;
+
+   ops[90].func = reinterpret_cast<void*>(& ::edje_object_signal_emit_wrapper<T>);
+   ops[90].api_func = reinterpret_cast<void*>(& ::edje_obj_signal_emit);
+   ops[90].op = EO_OP_OVERRIDE;
+   ops[90].op_type = EO_OP_TYPE_REGULAR;
+   ops[90].doc = NULL;
+
+   ops[91].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_layout_variation_set_wrapper<T>);
+   ops[91].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_layout_variation_set);
+   ops[91].op = EO_OP_OVERRIDE;
+   ops[91].op_type = EO_OP_TYPE_REGULAR;
+   ops[91].doc = NULL;
+
+   ops[92].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_layout_variation_get_wrapper<T>);
+   ops[92].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_layout_variation_get);
+   ops[92].op = EO_OP_OVERRIDE;
+   ops[92].op_type = EO_OP_TYPE_REGULAR;
+   ops[92].doc = NULL;
+
+   ops[93].func = reinterpret_cast<void*>(& ::edje_object_message_send_wrapper<T>);
+   ops[93].api_func = reinterpret_cast<void*>(& ::edje_obj_message_send);
+   ops[93].op = EO_OP_OVERRIDE;
+   ops[93].op_type = EO_OP_TYPE_REGULAR;
+   ops[93].doc = NULL;
+
+   ops[94].func = reinterpret_cast<void*>(& ::edje_object_part_text_select_none_wrapper<T>);
+   ops[94].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_select_none);
+   ops[94].op = EO_OP_OVERRIDE;
+   ops[94].op_type = EO_OP_TYPE_REGULAR;
+   ops[94].doc = NULL;
+
+   ops[95].func = reinterpret_cast<void*>(& ::edje_object_part_object_get_wrapper<T>);
+   ops[95].api_func = reinterpret_cast<void*>(& ::edje_obj_part_object_get);
+   ops[95].op = EO_OP_OVERRIDE;
+   ops[95].op_type = EO_OP_TYPE_REGULAR;
+   ops[95].doc = NULL;
+
+   ops[96].func = reinterpret_cast<void*>(& ::edje_object_part_drag_size_set_wrapper<T>);
+   ops[96].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_size_set);
+   ops[96].op = EO_OP_OVERRIDE;
+   ops[96].op_type = EO_OP_TYPE_REGULAR;
+   ops[96].doc = NULL;
+
+   ops[97].func = reinterpret_cast<void*>(& ::edje_object_part_drag_size_get_wrapper<T>);
+   ops[97].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_size_get);
+   ops[97].op = EO_OP_OVERRIDE;
+   ops[97].op_type = EO_OP_TYPE_REGULAR;
+   ops[97].doc = NULL;
+
+   ops[98].func = reinterpret_cast<void*>(& ::edje_object_text_insert_filter_callback_del_wrapper<T>);
+   ops[98].api_func = reinterpret_cast<void*>(& ::edje_obj_text_insert_filter_callback_del);
+   ops[98].op = EO_OP_OVERRIDE;
+   ops[98].op_type = EO_OP_TYPE_REGULAR;
+   ops[98].doc = NULL;
+
+   ops[99].func = reinterpret_cast<void*>(& ::edje_object_part_drag_dir_get_wrapper<T>);
+   ops[99].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_dir_get);
+   ops[99].op = EO_OP_OVERRIDE;
+   ops[99].op_type = EO_OP_TYPE_REGULAR;
+   ops[99].doc = NULL;
+
+   ops[100].func = reinterpret_cast<void*>(& ::edje_object_part_text_unescaped_set_wrapper<T>);
+   ops[100].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_unescaped_set);
+   ops[100].op = EO_OP_OVERRIDE;
+   ops[100].op_type = EO_OP_TYPE_REGULAR;
+   ops[100].doc = NULL;
+
+   ops[101].func = reinterpret_cast<void*>(& ::edje_object_part_text_unescaped_get_wrapper<T>);
+   ops[101].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_unescaped_get);
+   ops[101].op = EO_OP_OVERRIDE;
+   ops[101].op_type = EO_OP_TYPE_REGULAR;
+   ops[101].doc = NULL;
+
+   ops[102].func = reinterpret_cast<void*>(& ::edje_object_signal_callback_add_wrapper<T>);
+   ops[102].api_func = reinterpret_cast<void*>(& ::edje_obj_signal_callback_add);
+   ops[102].op = EO_OP_OVERRIDE;
+   ops[102].op_type = EO_OP_TYPE_REGULAR;
+   ops[102].doc = NULL;
+
+   ops[103].func = reinterpret_cast<void*>(& ::edje_object_part_text_select_all_wrapper<T>);
+   ops[103].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_select_all);
+   ops[103].op = EO_OP_OVERRIDE;
+   ops[103].op_type = EO_OP_TYPE_REGULAR;
+   ops[103].doc = NULL;
+
+   ops[104].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_return_key_disabled_set_wrapper<T>);
+   ops[104].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_return_key_disabled_set);
+   ops[104].op = EO_OP_OVERRIDE;
+   ops[104].op_type = EO_OP_TYPE_REGULAR;
+   ops[104].doc = NULL;
+
+   ops[105].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_return_key_disabled_get_wrapper<T>);
+   ops[105].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_return_key_disabled_get);
+   ops[105].op = EO_OP_OVERRIDE;
+   ops[105].op_type = EO_OP_TYPE_REGULAR;
+   ops[105].doc = NULL;
+
+   ops[106].func = reinterpret_cast<void*>(& ::edje_object_part_text_autocapital_type_set_wrapper<T>);
+   ops[106].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_autocapital_type_set);
+   ops[106].op = EO_OP_OVERRIDE;
+   ops[106].op_type = EO_OP_TYPE_REGULAR;
+   ops[106].doc = NULL;
+
+   ops[107].func = reinterpret_cast<void*>(& ::edje_object_part_text_autocapital_type_get_wrapper<T>);
+   ops[107].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_autocapital_type_get);
+   ops[107].op = EO_OP_OVERRIDE;
+   ops[107].op_type = EO_OP_TYPE_REGULAR;
+   ops[107].doc = NULL;
+
+   ops[108].func = reinterpret_cast<void*>(& ::edje_object_part_unswallow_wrapper<T>);
+   ops[108].api_func = reinterpret_cast<void*>(& ::edje_obj_part_unswallow);
+   ops[108].op = EO_OP_OVERRIDE;
+   ops[108].op_type = EO_OP_TYPE_REGULAR;
+   ops[108].doc = NULL;
+
+   ops[109].func = reinterpret_cast<void*>(& ::edje_object_part_text_prediction_allow_set_wrapper<T>);
+   ops[109].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_prediction_allow_set);
+   ops[109].op = EO_OP_OVERRIDE;
+   ops[109].op_type = EO_OP_TYPE_REGULAR;
+   ops[109].doc = NULL;
+
+   ops[110].func = reinterpret_cast<void*>(& ::edje_object_part_text_prediction_allow_get_wrapper<T>);
+   ops[110].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_prediction_allow_get);
+   ops[110].op = EO_OP_OVERRIDE;
+   ops[110].op_type = EO_OP_TYPE_REGULAR;
+   ops[110].doc = NULL;
+
+   ops[111].func = reinterpret_cast<void*>(& ::edje_object_data_get_wrapper<T>);
+   ops[111].api_func = reinterpret_cast<void*>(& ::edje_obj_data_get);
+   ops[111].op = EO_OP_OVERRIDE;
+   ops[111].op_type = EO_OP_TYPE_REGULAR;
+   ops[111].doc = NULL;
+
+   ops[112].func = reinterpret_cast<void*>(& ::edje_object_text_markup_filter_callback_add_wrapper<T>);
+   ops[112].api_func = reinterpret_cast<void*>(& ::edje_obj_text_markup_filter_callback_add);
+   ops[112].op = EO_OP_OVERRIDE;
+   ops[112].op_type = EO_OP_TYPE_REGULAR;
+   ops[112].doc = NULL;
+
+   ops[113].func = reinterpret_cast<void*>(& ::edje_object_message_signal_process_wrapper<T>);
+   ops[113].api_func = reinterpret_cast<void*>(& ::edje_obj_message_signal_process);
+   ops[113].op = EO_OP_OVERRIDE;
+   ops[113].op_type = EO_OP_TYPE_REGULAR;
+   ops[113].doc = NULL;
+
+   ops[114].func = reinterpret_cast<void*>(& ::edje_object_part_box_remove_wrapper<T>);
+   ops[114].api_func = reinterpret_cast<void*>(& ::edje_obj_part_box_remove);
+   ops[114].op = EO_OP_OVERRIDE;
+   ops[114].op_type = EO_OP_TYPE_REGULAR;
+   ops[114].doc = NULL;
+
+   ops[115].func = reinterpret_cast<void*>(& ::edje_object_thaw_wrapper<T>);
+   ops[115].api_func = reinterpret_cast<void*>(& ::edje_obj_thaw);
+   ops[115].op = EO_OP_OVERRIDE;
+   ops[115].op_type = EO_OP_TYPE_REGULAR;
+   ops[115].doc = NULL;
+
+   ops[116].func = reinterpret_cast<void*>(& ::edje_object_part_swallow_get_wrapper<T>);
+   ops[116].api_func = reinterpret_cast<void*>(& ::edje_obj_part_swallow_get);
+   ops[116].op = EO_OP_OVERRIDE;
+   ops[116].op_type = EO_OP_TYPE_REGULAR;
+   ops[116].doc = NULL;
+
+   ops[117].func = reinterpret_cast<void*>(& ::edje_object_part_text_imf_context_reset_wrapper<T>);
+   ops[117].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_imf_context_reset);
+   ops[117].op = EO_OP_OVERRIDE;
+   ops[117].op_type = EO_OP_TYPE_REGULAR;
+   ops[117].doc = NULL;
+
+   ops[118].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_return_key_type_set_wrapper<T>);
+   ops[118].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_return_key_type_set);
+   ops[118].op = EO_OP_OVERRIDE;
+   ops[118].op_type = EO_OP_TYPE_REGULAR;
+   ops[118].doc = NULL;
+
+   ops[119].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_return_key_type_get_wrapper<T>);
+   ops[119].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_return_key_type_get);
+   ops[119].op = EO_OP_OVERRIDE;
+   ops[119].op_type = EO_OP_TYPE_REGULAR;
+   ops[119].doc = NULL;
+
+   ops[120].func = reinterpret_cast<void*>(& ::edje_object_part_table_child_get_wrapper<T>);
+   ops[120].api_func = reinterpret_cast<void*>(& ::edje_obj_part_table_child_get);
+   ops[120].op = EO_OP_OVERRIDE;
+   ops[120].op_type = EO_OP_TYPE_REGULAR;
+   ops[120].doc = NULL;
+
+   ops[121].func = reinterpret_cast<void*>(& ::edje_object_part_box_insert_before_wrapper<T>);
+   ops[121].api_func = reinterpret_cast<void*>(& ::edje_obj_part_box_insert_before);
+   ops[121].op = EO_OP_OVERRIDE;
+   ops[121].op_type = EO_OP_TYPE_REGULAR;
+   ops[121].doc = NULL;
+
+   ops[122].func = reinterpret_cast<void*>(& ::edje_object_part_external_param_set_wrapper<T>);
+   ops[122].api_func = reinterpret_cast<void*>(& ::edje_obj_part_external_param_set);
+   ops[122].op = EO_OP_OVERRIDE;
+   ops[122].op_type = EO_OP_TYPE_REGULAR;
+   ops[122].doc = NULL;
+
+   ops[123].func = reinterpret_cast<void*>(& ::edje_object_part_external_param_get_wrapper<T>);
+   ops[123].api_func = reinterpret_cast<void*>(& ::edje_obj_part_external_param_get);
+   ops[123].op = EO_OP_OVERRIDE;
+   ops[123].op_type = EO_OP_TYPE_REGULAR;
+   ops[123].doc = NULL;
+
+   ops[124].func = reinterpret_cast<void*>(& ::edje_object_size_min_calc_wrapper<T>);
+   ops[124].api_func = reinterpret_cast<void*>(& ::edje_obj_size_min_calc);
+   ops[124].op = EO_OP_OVERRIDE;
+   ops[124].op_type = EO_OP_TYPE_REGULAR;
+   ops[124].doc = NULL;
+
+   ops[125].func = reinterpret_cast<void*>(& ::edje_object_part_box_append_wrapper<T>);
+   ops[125].api_func = reinterpret_cast<void*>(& ::edje_obj_part_box_append);
+   ops[125].op = EO_OP_OVERRIDE;
+   ops[125].op_type = EO_OP_TYPE_REGULAR;
+   ops[125].doc = NULL;
+
+   ops[126].func = reinterpret_cast<void*>(& ::edje_object_size_min_restricted_calc_wrapper<T>);
+   ops[126].api_func = reinterpret_cast<void*>(& ::edje_obj_size_min_restricted_calc);
+   ops[126].op = EO_OP_OVERRIDE;
+   ops[126].op_type = EO_OP_TYPE_REGULAR;
+   ops[126].doc = NULL;
+
+   ops[127].func = reinterpret_cast<void*>(& ::edje_object_part_box_remove_all_wrapper<T>);
+   ops[127].api_func = reinterpret_cast<void*>(& ::edje_obj_part_box_remove_all);
+   ops[127].op = EO_OP_OVERRIDE;
+   ops[127].op_type = EO_OP_TYPE_REGULAR;
+   ops[127].doc = NULL;
+
+   ops[128].func = reinterpret_cast<void*>(& ::edje_object_part_drag_page_wrapper<T>);
+   ops[128].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_page);
+   ops[128].op = EO_OP_OVERRIDE;
+   ops[128].op_type = EO_OP_TYPE_REGULAR;
+   ops[128].doc = NULL;
+
+   ops[129].func = reinterpret_cast<void*>(& ::edje_object_part_text_set_wrapper<T>);
+   ops[129].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_set);
+   ops[129].op = EO_OP_OVERRIDE;
+   ops[129].op_type = EO_OP_TYPE_REGULAR;
+   ops[129].doc = NULL;
+
+   ops[130].func = reinterpret_cast<void*>(& ::edje_object_part_text_get_wrapper<T>);
+   ops[130].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_get);
+   ops[130].op = EO_OP_OVERRIDE;
+   ops[130].op_type = EO_OP_TYPE_REGULAR;
+   ops[130].doc = NULL;
+
+   ops[131].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_show_on_demand_set_wrapper<T>);
+   ops[131].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_show_on_demand_set);
+   ops[131].op = EO_OP_OVERRIDE;
+   ops[131].op_type = EO_OP_TYPE_REGULAR;
+   ops[131].doc = NULL;
+
+   ops[132].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_show_on_demand_get_wrapper<T>);
+   ops[132].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_show_on_demand_get);
+   ops[132].op = EO_OP_OVERRIDE;
+   ops[132].op_type = EO_OP_TYPE_REGULAR;
+   ops[132].doc = NULL;
+
+   ops[133].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_hint_set_wrapper<T>);
+   ops[133].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_hint_set);
+   ops[133].op = EO_OP_OVERRIDE;
+   ops[133].op_type = EO_OP_TYPE_REGULAR;
+   ops[133].doc = NULL;
+
+   ops[134].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_hint_get_wrapper<T>);
+   ops[134].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_hint_get);
+   ops[134].op = EO_OP_OVERRIDE;
+   ops[134].op_type = EO_OP_TYPE_REGULAR;
+   ops[134].doc = NULL;
+
+   ops[135].func = reinterpret_cast<void*>(& ::edje_object_part_text_selection_get_wrapper<T>);
+   ops[135].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_selection_get);
+   ops[135].op = EO_OP_OVERRIDE;
+   ops[135].op_type = EO_OP_TYPE_REGULAR;
+   ops[135].doc = NULL;
+
+   ops[136].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_is_format_get_wrapper<T>);
+   ops[136].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_is_format_get);
+   ops[136].op = EO_OP_OVERRIDE;
+   ops[136].op_type = EO_OP_TYPE_REGULAR;
+   ops[136].doc = NULL;
+
+   ops[137].func = reinterpret_cast<void*>(& ::edje_object_color_class_set_wrapper<T>);
+   ops[137].api_func = reinterpret_cast<void*>(& ::edje_obj_color_class_set);
+   ops[137].op = EO_OP_OVERRIDE;
+   ops[137].op_type = EO_OP_TYPE_REGULAR;
+   ops[137].doc = NULL;
+
+   ops[138].func = reinterpret_cast<void*>(& ::edje_object_color_class_get_wrapper<T>);
+   ops[138].api_func = reinterpret_cast<void*>(& ::edje_obj_color_class_get);
+   ops[138].op = EO_OP_OVERRIDE;
+   ops[138].op_type = EO_OP_TYPE_REGULAR;
+   ops[138].doc = NULL;
+
+   ops[139].func = reinterpret_cast<void*>(& ::edje_object_part_drag_step_wrapper<T>);
+   ops[139].api_func = reinterpret_cast<void*>(& ::edje_obj_part_drag_step);
+   ops[139].op = EO_OP_OVERRIDE;
+   ops[139].op_type = EO_OP_TYPE_REGULAR;
+   ops[139].doc = NULL;
+
+   ops[140].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_up_wrapper<T>);
+   ops[140].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_up);
+   ops[140].op = EO_OP_OVERRIDE;
+   ops[140].op_type = EO_OP_TYPE_REGULAR;
+   ops[140].doc = NULL;
+
+   ops[141].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_geometry_get_wrapper<T>);
+   ops[141].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_geometry_get);
+   ops[141].op = EO_OP_OVERRIDE;
+   ops[141].op_type = EO_OP_TYPE_REGULAR;
+   ops[141].doc = NULL;
+
+   ops[142].func = reinterpret_cast<void*>(& ::edje_object_part_text_anchor_list_get_wrapper<T>);
+   ops[142].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_anchor_list_get);
+   ops[142].op = EO_OP_OVERRIDE;
+   ops[142].op_type = EO_OP_TYPE_REGULAR;
+   ops[142].doc = NULL;
+
+   ops[143].func = reinterpret_cast<void*>(& ::edje_object_text_insert_filter_callback_add_wrapper<T>);
+   ops[143].api_func = reinterpret_cast<void*>(& ::edje_obj_text_insert_filter_callback_add);
+   ops[143].op = EO_OP_OVERRIDE;
+   ops[143].op_type = EO_OP_TYPE_REGULAR;
+   ops[143].doc = NULL;
+
+   ops[144].func = reinterpret_cast<void*>(& ::edje_object_part_text_input_panel_show_wrapper<T>);
+   ops[144].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_input_panel_show);
+   ops[144].op = EO_OP_OVERRIDE;
+   ops[144].op_type = EO_OP_TYPE_REGULAR;
+   ops[144].doc = NULL;
+
+   ops[145].func = reinterpret_cast<void*>(& ::edje_object_part_exists_wrapper<T>);
+   ops[145].api_func = reinterpret_cast<void*>(& ::edje_obj_part_exists);
+   ops[145].op = EO_OP_OVERRIDE;
+   ops[145].op_type = EO_OP_TYPE_REGULAR;
+   ops[145].doc = NULL;
+
+   ops[146].func = reinterpret_cast<void*>(& ::edje_object_text_markup_filter_callback_del_wrapper<T>);
+   ops[146].api_func = reinterpret_cast<void*>(& ::edje_obj_text_markup_filter_callback_del);
+   ops[146].op = EO_OP_OVERRIDE;
+   ops[146].op_type = EO_OP_TYPE_REGULAR;
+   ops[146].doc = NULL;
+
+   ops[147].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_is_visible_format_get_wrapper<T>);
+   ops[147].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_is_visible_format_get);
+   ops[147].op = EO_OP_OVERRIDE;
+   ops[147].op_type = EO_OP_TYPE_REGULAR;
+   ops[147].doc = NULL;
+
+   ops[148].func = reinterpret_cast<void*>(& ::edje_object_part_text_user_insert_wrapper<T>);
+   ops[148].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_user_insert);
+   ops[148].op = EO_OP_OVERRIDE;
+   ops[148].op_type = EO_OP_TYPE_REGULAR;
+   ops[148].doc = NULL;
+
+   ops[149].func = reinterpret_cast<void*>(& ::edje_object_part_text_cursor_prev_wrapper<T>);
+   ops[149].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_cursor_prev);
+   ops[149].op = EO_OP_OVERRIDE;
+   ops[149].op_type = EO_OP_TYPE_REGULAR;
+   ops[149].doc = NULL;
+
+   ops[150].func = reinterpret_cast<void*>(& ::edje_object_part_text_item_list_get_wrapper<T>);
+   ops[150].api_func = reinterpret_cast<void*>(& ::edje_obj_part_text_item_list_get);
+   ops[150].op = EO_OP_OVERRIDE;
+   ops[150].op_type = EO_OP_TYPE_REGULAR;
+   ops[150].doc = NULL;
+
+   ops[151].func = reinterpret_cast<void*>(& ::edje_object_part_swallow_wrapper<T>);
+   ops[151].api_func = reinterpret_cast<void*>(& ::edje_obj_part_swallow);
+   ops[151].op = EO_OP_OVERRIDE;
+   ops[151].op_type = EO_OP_TYPE_REGULAR;
+   ops[151].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< edje::object >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<edje::object, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< edje::object >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<edje::object, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< edje::object>
+{
+   template <typename U>
+   struct type
+   {
+      operator edje::object() const
+      {
+         return edje::object(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_dbg_info_get(root_node_));
+      }
+
+      void hide()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_hide());
+      }
+
+      void calculate()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_calculate());
+      }
+
+      void show()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_show());
+      }
+
+      void move(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_move(x_, y_));
+      }
+
+      void add()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_add());
+      }
+
+      void del()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_del());
+      }
+
+      void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+      }
+
+      bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void file_get(const char ** file_, const char ** key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_file_get(file_, key_));
+      }
+
+      bool update_hints_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_update_hints_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void update_hints_set(bool update_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_update_hints_set(efl::eolian::to_c(update_)));
+      }
+
+      bool mirrored_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_mirrored_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void mirrored_set(bool rtl_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_mirrored_set(efl::eolian::to_c(rtl_)));
+      }
+
+      bool animation_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_animation_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void animation_set(bool on_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_animation_set(efl::eolian::to_c(on_)));
+      }
+
+      bool play_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_play_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void play_set(bool play_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_play_set(efl::eolian::to_c(play_)));
+      }
+
+      const Edje_Perspective * perspective_get()
+      {
+         const Edje_Perspective * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_perspective_get());
+            return _tmp_ret;
+      }
+
+      void perspective_set(Edje_Perspective * ps_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_perspective_set(ps_));
+      }
+
+      double scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_scale_get());
+            return _tmp_ret;
+      }
+
+      bool scale_set(double scale_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_scale_set(scale_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      double base_scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_base_scale_get());
+            return _tmp_ret;
+      }
+
+      bool mmap_set(const Eina_File * file_, std::string group_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_mmap_set(file_, efl::eolian::to_c(group_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void text_change_cb_set(Edje_Text_Change_Cb func_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_text_change_cb_set(func_, data_));
+      }
+
+      void part_text_cursor_begin_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_cursor_begin_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      void part_text_cursor_line_end_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_cursor_line_end_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      bool text_class_set(std::string text_class_, std::string font_, Evas_Font_Size size_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_text_class_set(efl::eolian::to_c(text_class_), efl::eolian::to_c(font_), size_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_text_cursor_coord_set(std::string part_, Edje_Cursor cur_, Evas_Coord x_, Evas_Coord y_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_coord_set(efl::eolian::to_c(part_), cur_, x_, y_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_cursor_end_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_cursor_end_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      bool part_text_escaped_set(std::string part_, std::string text_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_escaped_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void item_provider_set(Edje_Item_Provider_Cb func_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_item_provider_set(func_, data_));
+      }
+
+      void part_text_cursor_line_begin_set(std::string part_, Edje_Cursor cur_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_cursor_line_begin_set(efl::eolian::to_c(part_), cur_));
+      }
+
+      void message_handler_set(Edje_Message_Handler_Cb func_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_message_handler_set(func_, data_));
+      }
+
+      void size_min_get(Evas_Coord* minw_, Evas_Coord* minh_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_size_min_get(minw_, minh_));
+      }
+
+      efl::eina::range_list< std::string > access_part_list_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_access_part_list_get());
+            return efl::eolian::to_cxx<efl::eina::range_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      Edje_Load_Error load_error_get()
+      {
+         Edje_Load_Error _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_load_error_get());
+            return _tmp_ret;
+      }
+
+      void size_max_get(Evas_Coord* maxw_, Evas_Coord* maxh_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_size_max_get(maxw_, maxh_));
+      }
+
+      bool part_table_clear(std::string part_, bool clear_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_table_clear(efl::eolian::to_c(part_), efl::eolian::to_c(clear_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Edje_External_Param_Type part_external_param_type_get(std::string part_, const char* param_)
+      {
+         Edje_External_Param_Type _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_external_param_type_get(efl::eolian::to_c(part_), param_));
+            return _tmp_ret;
+      }
+
+      void part_text_select_allow_set(std::string part_, bool allow_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_select_allow_set(efl::eolian::to_c(part_), efl::eolian::to_c(allow_)));
+      }
+
+      std::string part_state_get(std::string part_, double* val_ret_)
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_state_get(efl::eolian::to_c(part_), val_ret_));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void * text_markup_filter_callback_del_full(std::string part_, Edje_Markup_Filter_Cb func_, void * data_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_text_markup_filter_callback_del_full(efl::eolian::to_c(part_), func_, data_));
+            return _tmp_ret;
+      }
+
+      bool part_drag_step_set(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_step_set(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_step_get(std::string part_, double* dx_, double* dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_step_get(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void * part_text_imf_context_get(std::string part_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_imf_context_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      void part_text_select_begin(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_select_begin(efl::eolian::to_c(part_)));
+      }
+
+      std::string part_text_style_user_peek(std::string part_)
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_style_user_peek(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void * signal_callback_del(std::string emission_, std::string source_, Edje_Signal_Cb func_, void * data_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_signal_callback_del(efl::eolian::to_c(emission_), efl::eolian::to_c(source_), func_, data_));
+            return _tmp_ret;
+      }
+
+      bool part_text_cursor_next(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_next(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_style_user_push(std::string part_, std::string style_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_style_user_push(efl::eolian::to_c(part_), efl::eolian::to_c(style_)));
+      }
+
+      void part_text_append(std::string part_, std::string text_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_append(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      }
+
+      bool part_geometry_get(std::string part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_geometry_get(efl::eolian::to_c(part_), x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_input_panel_hide(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_hide(efl::eolian::to_c(part_)));
+      }
+
+      bool part_text_item_geometry_get(std::string part_, std::string item_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_item_geometry_get(efl::eolian::to_c(part_), efl::eolian::to_c(item_), cx_, cy_, cw_, ch_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_table_unpack(std::string part_, evas::object child_obj_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_table_unpack(efl::eolian::to_c(part_), efl::eolian::to_c(child_obj_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_select_abort(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_select_abort(efl::eolian::to_c(part_)));
+      }
+
+      void * text_insert_filter_callback_del_full(std::string part_, Edje_Text_Filter_Cb func_, void * data_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_text_insert_filter_callback_del_full(efl::eolian::to_c(part_), func_, data_));
+            return _tmp_ret;
+      }
+
+      void part_text_style_user_pop(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_style_user_pop(efl::eolian::to_c(part_)));
+      }
+
+      void part_text_input_panel_imdata_set(std::string part_, const void * data_, int len_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_imdata_set(efl::eolian::to_c(part_), data_, len_));
+      }
+
+      void part_text_input_panel_imdata_get(std::string part_, void * data_, int * len_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_imdata_get(efl::eolian::to_c(part_), data_, len_));
+      }
+
+      void part_text_insert(std::string part_, std::string text_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_insert(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      }
+
+      evas::object part_box_remove_at(std::string part_, unsigned int pos_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_box_remove_at(efl::eolian::to_c(part_), pos_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_cursor_copy(std::string part_, Edje_Cursor src_, Edje_Cursor dst_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_cursor_copy(efl::eolian::to_c(part_), src_, dst_));
+      }
+
+      bool parts_extends_calc(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_parts_extends_calc(x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_value_set(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_value_set(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_value_get(std::string part_, double* dx_, double* dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_value_get(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void calc_force()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_calc_force());
+      }
+
+      void part_text_cursor_pos_set(std::string part_, Edje_Cursor cur_, int pos_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_cursor_pos_set(efl::eolian::to_c(part_), cur_, pos_));
+      }
+
+      int part_text_cursor_pos_get(std::string part_, Edje_Cursor cur_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_pos_get(efl::eolian::to_c(part_), cur_));
+            return _tmp_ret;
+      }
+
+      int freeze()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_freeze());
+            return _tmp_ret;
+      }
+
+      char * part_text_cursor_content_get(std::string part_, Edje_Cursor cur_)
+      {
+         char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_content_get(efl::eolian::to_c(part_), cur_));
+            return _tmp_ret;
+      }
+
+      void part_text_input_panel_layout_set(std::string part_, Edje_Input_Panel_Layout layout_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_layout_set(efl::eolian::to_c(part_), layout_));
+      }
+
+      Edje_Input_Panel_Layout part_text_input_panel_layout_get(std::string part_)
+      {
+         Edje_Input_Panel_Layout _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_layout_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      bool part_table_pack(std::string part_, evas::object child_obj_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_table_pack(efl::eolian::to_c(part_), efl::eolian::to_c(child_obj_), col_, row_, colspan_, rowspan_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_input_panel_language_set(std::string part_, Edje_Input_Panel_Lang lang_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_language_set(efl::eolian::to_c(part_), lang_));
+      }
+
+      Edje_Input_Panel_Lang part_text_input_panel_language_get(std::string part_)
+      {
+         Edje_Input_Panel_Lang _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_language_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      bool part_table_col_row_size_get(std::string part_, int* cols_, int* rows_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_table_col_row_size_get(efl::eolian::to_c(part_), cols_, rows_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object part_external_object_get(std::string part_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_external_object_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object part_external_content_get(std::string part_, const char* content_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_external_content_get(efl::eolian::to_c(part_), content_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool preload(bool cancel_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_preload(efl::eolian::to_c(cancel_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_input_panel_enabled_set(std::string part_, bool enabled_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_enabled_set(efl::eolian::to_c(part_), efl::eolian::to_c(enabled_)));
+      }
+
+      bool part_text_input_panel_enabled_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_enabled_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_select_extend(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_select_extend(efl::eolian::to_c(part_)));
+      }
+
+      bool part_box_insert_at(std::string part_, evas::object child_, unsigned int pos_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_box_insert_at(efl::eolian::to_c(part_), efl::eolian::to_c(child_), pos_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      efl::eina::crange_list< const Evas_Textblock_Rectangle * > part_text_anchor_geometry_get(std::string part_, std::string anchor_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_anchor_geometry_get(efl::eolian::to_c(part_), efl::eolian::to_c(anchor_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< const Evas_Textblock_Rectangle * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      bool part_text_cursor_down(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_down(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_page_set(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_page_set(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_page_get(std::string part_, double* dx_, double* dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_page_get(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_box_prepend(std::string part_, evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_box_prepend(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void signal_emit(std::string emission_, std::string source_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_signal_emit(efl::eolian::to_c(emission_), efl::eolian::to_c(source_)));
+      }
+
+      void part_text_input_panel_layout_variation_set(std::string part_, int variation_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_layout_variation_set(efl::eolian::to_c(part_), variation_));
+      }
+
+      int part_text_input_panel_layout_variation_get(std::string part_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_layout_variation_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      void message_send(Edje_Message_Type type_, int id_, void * msg_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_message_send(type_, id_, msg_));
+      }
+
+      void part_text_select_none(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_select_none(efl::eolian::to_c(part_)));
+      }
+
+      const Evas_Object * part_object_get(std::string part_)
+      {
+         const Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_object_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      bool part_drag_size_set(std::string part_, double dw_, double dh_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_size_set(efl::eolian::to_c(part_), dw_, dh_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_size_get(std::string part_, double* dw_, double* dh_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_size_get(efl::eolian::to_c(part_), dw_, dh_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void * text_insert_filter_callback_del(std::string part_, Edje_Text_Filter_Cb func_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_text_insert_filter_callback_del(efl::eolian::to_c(part_), func_));
+            return _tmp_ret;
+      }
+
+      Edje_Drag_Dir part_drag_dir_get(std::string part_)
+      {
+         Edje_Drag_Dir _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_dir_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      bool part_text_unescaped_set(std::string part_, std::string text_to_escape_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_unescaped_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_to_escape_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      char * part_text_unescaped_get(std::string part_)
+      {
+         char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_unescaped_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      void signal_callback_add(std::string emission_, std::string source_, Edje_Signal_Cb func_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_signal_callback_add(efl::eolian::to_c(emission_), efl::eolian::to_c(source_), func_, data_));
+      }
+
+      void part_text_select_all(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_select_all(efl::eolian::to_c(part_)));
+      }
+
+      void part_text_input_panel_return_key_disabled_set(std::string part_, bool disabled_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_return_key_disabled_set(efl::eolian::to_c(part_), efl::eolian::to_c(disabled_)));
+      }
+
+      bool part_text_input_panel_return_key_disabled_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_return_key_disabled_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_autocapital_type_set(std::string part_, Edje_Text_Autocapital_Type autocapital_type_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_autocapital_type_set(efl::eolian::to_c(part_), autocapital_type_));
+      }
+
+      Edje_Text_Autocapital_Type part_text_autocapital_type_get(std::string part_)
+      {
+         Edje_Text_Autocapital_Type _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_autocapital_type_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      void part_unswallow(evas::object obj_swallow_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_unswallow(efl::eolian::to_c(obj_swallow_)));
+      }
+
+      void part_text_prediction_allow_set(std::string part_, bool prediction_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_prediction_allow_set(efl::eolian::to_c(part_), efl::eolian::to_c(prediction_)));
+      }
+
+      bool part_text_prediction_allow_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_prediction_allow_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      std::string data_get(std::string key_)
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_data_get(efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void text_markup_filter_callback_add(std::string part_, Edje_Markup_Filter_Cb func_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_text_markup_filter_callback_add(efl::eolian::to_c(part_), func_, data_));
+      }
+
+      void message_signal_process()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_message_signal_process());
+      }
+
+      evas::object part_box_remove(std::string part_, evas::object child_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_box_remove(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      int thaw()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_thaw());
+            return _tmp_ret;
+      }
+
+      evas::object part_swallow_get(std::string part_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_swallow_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_imf_context_reset(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_imf_context_reset(efl::eolian::to_c(part_)));
+      }
+
+      void part_text_input_panel_return_key_type_set(std::string part_, Edje_Input_Panel_Return_Key_Type return_key_type_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_return_key_type_set(efl::eolian::to_c(part_), return_key_type_));
+      }
+
+      Edje_Input_Panel_Return_Key_Type part_text_input_panel_return_key_type_get(std::string part_)
+      {
+         Edje_Input_Panel_Return_Key_Type _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_return_key_type_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      evas::object part_table_child_get(std::string part_, unsigned int col_, unsigned int row_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_table_child_get(efl::eolian::to_c(part_), col_, row_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_box_insert_before(std::string part_, evas::object child_, const Evas_Object * reference_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_box_insert_before(efl::eolian::to_c(part_), efl::eolian::to_c(child_), reference_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_external_param_set(std::string part_, const Edje_External_Param * param_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_external_param_set(efl::eolian::to_c(part_), param_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_external_param_get(std::string part_, Edje_External_Param* param_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_external_param_get(efl::eolian::to_c(part_), param_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void size_min_calc(Evas_Coord* minw_, Evas_Coord* minh_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_size_min_calc(minw_, minh_));
+      }
+
+      bool part_box_append(std::string part_, evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_box_append(efl::eolian::to_c(part_), efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void size_min_restricted_calc(Evas_Coord* minw_, Evas_Coord* minh_, Evas_Coord restrictedw_, Evas_Coord restrictedh_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_size_min_restricted_calc(minw_, minh_, restrictedw_, restrictedh_));
+      }
+
+      bool part_box_remove_all(std::string part_, bool clear_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_box_remove_all(efl::eolian::to_c(part_), efl::eolian::to_c(clear_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_page(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_page(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_text_set(std::string part_, std::string text_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_set(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      std::string part_text_get(std::string part_)
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_input_panel_show_on_demand_set(std::string part_, bool ondemand_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_show_on_demand_set(efl::eolian::to_c(part_), efl::eolian::to_c(ondemand_)));
+      }
+
+      bool part_text_input_panel_show_on_demand_get(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_panel_show_on_demand_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_input_hint_set(std::string part_, Edje_Input_Hints input_hints_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_hint_set(efl::eolian::to_c(part_), input_hints_));
+      }
+
+      Edje_Input_Hints part_text_input_hint_get(std::string part_)
+      {
+         Edje_Input_Hints _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_input_hint_get(efl::eolian::to_c(part_)));
+            return _tmp_ret;
+      }
+
+      std::string part_text_selection_get(std::string part_)
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_selection_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_text_cursor_is_format_get(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_is_format_get(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool color_class_set(std::string color_class_, int r_, int g_, int b_, int a_, int r2_, int g2_, int b2_, int a2_, int r3_, int g3_, int b3_, int a3_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_color_class_set(efl::eolian::to_c(color_class_), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool color_class_get(std::string color_class_, int* r_, int* g_, int* b_, int* a_, int* r2_, int* g2_, int* b2_, int* a2_, int* r3_, int* g3_, int* b3_, int* a3_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_color_class_get(efl::eolian::to_c(color_class_), r_, g_, b_, a_, r2_, g2_, b2_, a2_, r3_, g3_, b3_, a3_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_drag_step(std::string part_, double dx_, double dy_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_drag_step(efl::eolian::to_c(part_), dx_, dy_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool part_text_cursor_up(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_up(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_cursor_geometry_get(std::string part_, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_cursor_geometry_get(efl::eolian::to_c(part_), x_, y_, w_, h_));
+      }
+
+      efl::eina::crange_list< std::string > part_text_anchor_list_get(std::string part_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_anchor_list_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      void text_insert_filter_callback_add(std::string part_, Edje_Text_Filter_Cb func_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_text_insert_filter_callback_add(efl::eolian::to_c(part_), func_, data_));
+      }
+
+      void part_text_input_panel_show(std::string part_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_input_panel_show(efl::eolian::to_c(part_)));
+      }
+
+      bool part_exists(std::string part_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_exists(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void * text_markup_filter_callback_del(std::string part_, Edje_Markup_Filter_Cb func_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_text_markup_filter_callback_del(efl::eolian::to_c(part_), func_));
+            return _tmp_ret;
+      }
+
+      bool part_text_cursor_is_visible_format_get(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_is_visible_format_get(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void part_text_user_insert(std::string part_, std::string text_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::edje_obj_part_text_user_insert(efl::eolian::to_c(part_), efl::eolian::to_c(text_)));
+      }
+
+      bool part_text_cursor_prev(std::string part_, Edje_Cursor cur_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_cursor_prev(efl::eolian::to_c(part_), cur_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      efl::eina::crange_list< std::string > part_text_item_list_get(std::string part_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_text_item_list_get(efl::eolian::to_c(part_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      bool part_swallow(std::string part_, evas::object obj_swallow_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::edje_obj_part_swallow(efl::eolian::to_c(part_), efl::eolian::to_c(obj_swallow_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<edje::object>)
+{
+   return (EDJE_OBJECT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EDJE_OBJECT_HH
+
diff -Naur a/src/lib/edje/edje_object.eo.legacy.h b/src/lib/edje/edje_object.eo.legacy.h
--- a/src/lib/edje/edje_object.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/edje/edje_object.eo.legacy.h	2014-11-27 00:57:33.470380026 +0200
@@ -0,0 +1,2450 @@
+#ifndef _EDJE_OBJECT_EO_LEGACY_H_
+#define _EDJE_OBJECT_EO_LEGACY_H_
+
+#ifndef _EDJE_OBJECT_EO_CLASS_TYPE
+#define _EDJE_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Edje_Object;
+
+#endif
+
+#ifndef _EDJE_OBJECT_EO_TYPES
+#define _EDJE_OBJECT_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * @brief Edje will automatically update the size hints on itself.
+ *
+ * By default edje doesn't set size hints on itself. With this function
+ * call, it will do so if update is true. Be carefully, it cost a lot to
+ * trigger this feature as it will recalc the object every time it make
+ * sense to be sure that's its minimal size hint is always accurate.
+ *
+ * @param[in] update Whether or not update the size hints.
+ */
+EAPI void edje_object_update_hints_set(Edje_Object *obj, Eina_Bool update);
+
+/**
+ *
+ * @brief Whether or not Edje will update size hints on itself.
+ *
+ * @return @c true if does, @c false if it doesn't.
+ *
+ */
+EAPI Eina_Bool edje_object_update_hints_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Set the RTL orientation for this object.
+ *
+ * @since 1.1.0
+ *
+ * @param[in] rtl new value of flag EINA_TRUE/EINA_FALSE
+ */
+EAPI void edje_object_mirrored_set(Edje_Object *obj, Eina_Bool rtl);
+
+/**
+ *
+ * @brief Get the RTL orientation for this object.
+ *
+ * You can RTL orientation explicitly with edje_object_mirrored_set.
+ *
+ * @return @c EINA_TRUE if the flag is set or @c EINA_FALSE if not.
+ * @since 1.1.0
+ *
+ */
+EAPI Eina_Bool edje_object_mirrored_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Set the object's animation state.
+ *
+ * This function starts or stops an Edje object's animation. The
+ * information if it's stopped can be retrieved by
+ * edje_object_animation_get().
+ *
+ * @see edje_object_animation_get()
+ *
+ * @param[in] on The animation state. @c EINA_TRUE to starts or
+@c EINA_FALSE to stops.
+ */
+EAPI void edje_object_animation_set(Edje_Object *obj, Eina_Bool on);
+
+/**
+ *
+ * @brief Get the Edje object's animation state.
+ *
+ * @return @c EINA_FALSE on error or if object is not animated;
+ * @c EINA_TRUE if animated.
+ *
+ * This function returns if the animation is stopped or not. The
+ * animation state is set by edje_object_animation_set().
+ *
+ * @see edje_object_animation_set().
+ *
+ */
+EAPI Eina_Bool edje_object_animation_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Set the Edje object to playing or paused states.
+ *
+ * This function sets the Edje object @a obj to playing or paused
+ * states, depending on the parameter @a play. This has no effect if
+ * the object was already at that state.
+ *
+ * @see edje_object_play_get().
+ *
+ * @param[in] play Object state (@c EINA_TRUE to playing,
+@c EINA_FALSE to paused).
+ */
+EAPI void edje_object_play_set(Edje_Object *obj, Eina_Bool play);
+
+/**
+ *
+ * @brief Get the Edje object's state.
+ *
+ * @return @c EINA_FALSE if the object is not connected, its @c delete_me flag
+ * is set, or it is at paused state; @c EINA_TRUE if the object is at playing
+ * state.
+ *
+ * This function tells if an Edje object is playing or not. This state
+ * is set by edje_object_play_set().
+ *
+ * @see edje_object_play_set().
+ *
+ */
+EAPI Eina_Bool edje_object_play_get(const Edje_Object *obj);
+
+/**
+ *
+ * Set the given perspective object on this Edje object.
+ *
+ * Make the given perspective object be the default perspective for this Edje
+ * object.
+ *
+ * There can be only one perspective object per Edje object, and if a
+ * previous one was set, it will be removed and the new perspective object
+ * will be used.
+ *
+ * An Edje perspective will only affect a part if it doesn't point to another
+ * part to be used as perspective.
+ *
+ * @see edje_object_perspective_new()
+ * @see edje_object_perspective_get()
+ * @see edje_perspective_set()
+ *
+ * @param[in] ps The perspective object that will be used.
+ */
+EAPI void edje_object_perspective_set(Edje_Object *obj, Edje_Perspective *ps);
+
+/**
+ *
+ * Get the current perspective used on this Edje object.
+ *
+ * @return The perspective object being used on this Edje object. Or @c NULL
+ * if there was none, and on errors.
+ *
+ * @see edje_object_perspective_set()
+ *
+ */
+EAPI const Edje_Perspective *edje_object_perspective_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Set the scaling factor for a given Edje object.
+ *
+ * This function sets an @b individual scaling factor on the @a obj
+ * Edje object. This property (or Edje's global scaling factor, when
+ * applicable), will affect this object's part sizes. If @p scale is
+ * not zero, than the individual scaling will @b override any global
+ * scaling set, for the object @p obj's parts. Put it back to zero to
+ * get the effects of the global scaling again.
+ *
+ * @warning Only parts which, at EDC level, had the @c "scale"
+ * property set to @c 1, will be affected by this function. Check the
+ * complete @ref edcref "syntax reference" for EDC files.
+ *
+ * @see edje_object_scale_get()
+ * @see edje_scale_get() for more details
+ *
+ * @param[in] scale The scaling factor (the default value is @c 0.0,
+meaning individual scaling @b not set)
+ */
+EAPI Eina_Bool edje_object_scale_set(Edje_Object *obj, double scale);
+
+/**
+ *
+ * @brief Get a given Edje object's scaling factor.
+ *
+ * This function returns the @c individual scaling factor set on the
+ * @a obj Edje object.
+ *
+ * @see edje_object_scale_set() for more details
+ *
+ */
+EAPI double edje_object_scale_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Get a given Edje object's base_scale factor.
+ *
+ * This function returns the base_scale factor set on the
+ * @a obj Edje object.
+ * The base_scale can be set in the collection of edc.
+ * If it isn't set, the default value is 1.0
+ *
+ */
+EAPI double edje_object_base_scale_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Sets the @b EDJ file (and group within it) to load an Edje
+ * object's contents from
+ *
+ * @return @c EINA_TRUE, on success or @c EINA_FALSE, on errors (check
+ * edje_object_load_error_get() after this call to get errors causes)
+ *
+ * Edje expects EDJ files, which are theming objects' descriptions and
+ * resources packed together in an EET file, to read Edje object
+ * definitions from. They usually are created with the @c .edj
+ * extension. EDJ files, in turn, are assembled from @b textual object
+ * description files, where one describes Edje objects declaratively
+ * -- the EDC files (see @ref edcref "the syntax" for those files).
+ *
+ * Those description files were designed so that many Edje object
+ * definitions -- also called @b groups (or collections) -- could be
+ * packed together <b>in the same EDJ file</b>, so that a whole
+ * application's theme could be packed in one file only. This is the
+ * reason for the @p group argument.
+ *
+ * Use this function after you instantiate a new Edje object, so that
+ * you can "give him life", telling where to get its contents from.
+ *
+ * @see edje_object_add()
+ * @see edje_object_file_get()
+ * @see edje_object_mmap_set()
+ * @since 1.8
+ *
+ * @param[in] file The Eina.File pointing to the EDJ file to load @p from
+ * @param[in] group The name of the group, in @p file, which implements an
+Edje object
+ */
+EAPI Eina_Bool edje_object_mmap_set(Edje_Object *obj, const Eina_File *file, const char *group);
+
+/**
+ *
+ * @brief Set the object text callback.
+ *
+ * This function sets the callback to be called when the text changes.
+ *
+ * @param[in] func The callback function to handle the text change
+ * @param[in] data The data associated to the callback function.
+ */
+EAPI void edje_object_text_change_cb_set(Edje_Object *obj, Edje_Text_Change_Cb func, void *data);
+
+/**
+ *
+ * @brief Moves the cursor to the beginning of the text part
+ * @see evas_textblock_cursor_paragraph_first
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ */
+EAPI void edje_object_part_text_cursor_begin_set(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Move the cursor to the end of the line.
+ * @see evas_textblock_cursor_line_char_last
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ */
+EAPI void edje_object_part_text_cursor_line_end_set(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets Edje text class.
+ *
+ * @return @c EINA_TRUE, on success or @c EINA_FALSE, on error
+ *
+ * This function sets the text class for the Edje.
+ *
+ * @param[in] text_class The text class name
+ * @param[in] font Font name
+ * @param[in] size Font Size
+ */
+EAPI Eina_Bool edje_object_text_class_set(Edje_Object *obj, const char *text_class, const char *font, Evas_Font_Size size);
+
+/**
+ *
+ * Position the given cursor to a X,Y position.
+ *
+ * This is frequently used with the user cursor.
+ *
+ * @return True on success, false on error.
+ *
+ * @param[in] part The part containing the object.
+ * @param[in] cur The cursor to adjust.
+ * @param[in] x X Coordinate.
+ * @param[in] y Y Coordinate.
+ */
+EAPI Eina_Bool edje_object_part_text_cursor_coord_set(Edje_Object *obj, const char *part, Edje_Cursor cur, Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * @brief Moves the cursor to the end of the text part.
+ * @see evas_textblock_cursor_paragraph_last
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ */
+EAPI void edje_object_part_text_cursor_end_set(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets the text for an object part, but converts HTML escapes to UTF8
+ *
+ * This converts the given string @p text to UTF8 assuming it contains HTML
+ * style escapes like "&amp;" and "&copy;" etc. IF the part is of type TEXT,
+ * as opposed to TEXTBLOCK.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE otherwise
+ *
+ * @since 1.2
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ */
+EAPI Eina_Bool edje_object_part_text_escaped_set(Edje_Object *obj, const char *part, const char *text);
+
+/**
+ *
+ * @brief Set the function that provides item objects for named items in an edje entry text
+ *
+ * Item objects may be deleted any time by Edje, and will be deleted when the
+ * Edje object is deleted (or file is set to a new file).
+ *
+ * @param[in] func The function to call (or NULL to disable) to get item objects
+ * @param[in] data The data pointer to pass to the @p func callback
+ */
+EAPI void edje_object_item_provider_set(Edje_Object *obj, Edje_Item_Provider_Cb func, void *data);
+
+/**
+ *
+ * @brief Move the cursor to the beginning of the line.
+ * @see evas_textblock_cursor_line_char_first
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ */
+EAPI void edje_object_part_text_cursor_line_begin_set(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Set an Edje message handler function for a given Edje object.
+ *
+ * For scriptable programs on an Edje object's defining EDC file which
+ * send messages with the @c send_message() primitive, one can attach
+ * <b>handler functions</b>, to be called in the code which creates
+ * that object (see @ref edcref "the syntax" for EDC files).
+ *
+ * This function associates a message handler function and the
+ * attached data pointer to the object @p obj.
+ *
+ * @see edje_object_message_send()
+ *
+ * @param[in] func The function to handle messages @b coming from @p obj
+ * @param[in] data Auxiliary data to be passed to @p func
+ */
+EAPI void edje_object_message_handler_set(Edje_Object *obj, Edje_Message_Handler_Cb func, void *data);
+
+/**
+ *
+ * @brief Get the minimum size specified -- as an EDC property -- for a
+ * given Edje object
+ *
+ * This function retrieves the @p obj object's minimum size values,
+ * <b>as declared in its EDC group definition</b>. Minimum size of
+ * groups have the following syntax
+ * @code
+ * collections {
+ * group {
+ * name: "a_group";
+ * min: 100 100;
+ * }
+ * }
+ * @endcode
+ *
+ * where one declares a minimum size of 100 pixels both for width and
+ * height. Those are (hint) values which should be respected when the
+ * given object/group is to be controlled by a given container object
+ * (e.g. an Edje object being "swallowed" into a given @c SWALLOW
+ * typed part, as in edje_object_part_swallow()). Check the complete
+ * @ref edcref "syntax reference" for EDC files.
+ *
+ * @note If the @c min EDC property was not declared for @p obj, this
+ * call will return the value 0, for each axis.
+ *
+ * @note On failure, this function will make all non-@c NULL size
+ * pointers' pointed variables be set to zero.
+ *
+ * @see edje_object_size_max_get()
+ *
+ * @param[out] minw Pointer to a variable where to store the minimum width
+ * @param[out] minh Pointer to a variable where to store the minimum height
+ */
+EAPI void edje_object_size_min_get(const Edje_Object *obj, Evas_Coord *minw, Evas_Coord *minh);
+
+/**
+ *
+ * @brief Retrieve a list all accessibility part names
+ *
+ * @return A list all accessibility part names on @p obj
+ * @since 1.7.0
+ *
+ */
+EAPI Eina_List *edje_object_access_part_list_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Gets the (last) file loading error for a given Edje object
+ *
+ * @return The Edje loading error, one of:
+ * - #EDJE_LOAD_ERROR_NONE
+ * - #EDJE_LOAD_ERROR_GENERIC
+ * - #EDJE_LOAD_ERROR_DOES_NOT_EXIST
+ * - #EDJE_LOAD_ERROR_PERMISSION_DENIED
+ * - #EDJE_LOAD_ERROR_RESOURCE_ALLOCATION_FAILED
+ * - #EDJE_LOAD_ERROR_CORRUPT_FILE
+ * - #EDJE_LOAD_ERROR_UNKNOWN_FORMAT
+ * - #EDJE_LOAD_ERROR_INCOMPATIBLE_FILE
+ * - #EDJE_LOAD_ERROR_UNKNOWN_COLLECTION
+ * - #EDJE_LOAD_ERROR_RECURSIVE_REFERENCE
+ *
+ * This function is meant to be used after an Edje EDJ <b>file
+ * loading</b>, what takes place with the edje_object_file_set()
+ * function. If that function does not return @c EINA_TRUE, one should
+ * check for the reason of failure with this one.
+ *
+ * @see edje_load_error_str()
+ *
+ */
+EAPI Edje_Load_Error edje_object_load_error_get(const Edje_Object *obj);
+
+/**
+ *
+ * @brief Get the maximum size specified -- as an EDC property -- for a
+ * given Edje object
+ *
+ * This function retrieves the @p obj object's maximum size values,
+ * <b>as declared in its EDC group definition</b>. Maximum size of
+ * groups have the following syntax
+ * @code
+ * collections {
+ * group {
+ * name: "a_group";
+ * max: 100 100;
+ * }
+ * }
+ * @endcode
+ *
+ * where one declares a maximum size of 100 pixels both for width and
+ * height. Those are (hint) values which should be respected when the
+ * given object/group is to be controlled by a given container object
+ * (e.g. an Edje object being "swallowed" into a given @c SWALLOW
+ * typed part, as in edje_object_part_swallow()). Check the complete
+ * @ref edcref "syntax reference" for EDC files.
+ *
+ * @note If the @c max EDC property was not declared for @p obj, this
+ * call will return the maximum size a given Edje object may have, for
+ * each axis.
+ *
+ * @note On failure, this function will make all non-@c NULL size
+ * pointers' pointed variables be set to zero.
+ *
+ * @see edje_object_size_min_get()
+ *
+ * @param[out] maxw Pointer to a variable where to store the maximum width
+ * @param[out] maxh Pointer to a variable where to store the maximum height
+ */
+EAPI void edje_object_size_max_get(const Edje_Object *obj, Evas_Coord *maxw, Evas_Coord *maxh);
+
+/**
+ *
+ * @brief Removes all object from the table.
+ *
+ * @return @c EINA_TRUE clear the table, @c EINA_FALSE on failure
+ *
+ * Removes all object from the table indicated by part, except the
+ * internal ones set from the theme.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] clear If set, will delete subobjs on remove
+ */
+EAPI Eina_Bool edje_object_part_table_clear(Edje_Object *obj, const char *part, Eina_Bool clear);
+
+/**
+ *
+ * Facility to query the type of the given parameter of the given part.
+ *
+ * @return @c EDJE_EXTERNAL_PARAM_TYPE_MAX on errors, or another value
+ * from #Edje_External_Param_Type on success.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] param the parameter name to use.
+ */
+EAPI Edje_External_Param_Type edje_object_part_external_param_type_get(const Edje_Object *obj, const char *part, const char *param);
+
+/**
+ *
+ * @brief Enables selection if the entry is an EXPLICIT selection mode
+ * type.
+ *
+ * The default is to @b not allow selection. This function only affects user
+ * selection, functions such as edje_object_part_text_select_all() and
+ * edje_object_part_text_select_none() are not affected.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] allow EINA_TRUE to enable, EINA_FALSE otherwise
+ */
+EAPI void edje_object_part_text_select_allow_set(const Edje_Object *obj, const char *part, Eina_Bool allow);
+
+/**
+ *
+ * @brief Returns the state of the Edje part.
+ *
+ * @return The part state:\n
+ * "default" for the default state\n
+ * "" for other states
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] val_ret No description supplied.
+ */
+EAPI const char *edje_object_part_state_get(const Edje_Object *obj, const char *part, double *val_ret);
+
+/**
+ *
+ * Delete a function and matching user data from the markup filter list.
+ *
+ * Delete the given @p func filter and @p data user data from the list
+ * in @p part.
+ * Returns the user data pointer given when added.
+ *
+ * @see edje_object_text_markup_filter_callback_add
+ * @see edje_object_text_markup_filter_callback_del
+ *
+ * @return The same data pointer if successful, or NULL otherwise
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ * @param[in] data The data passed to the callback function
+ */
+EAPI void *edje_object_text_markup_filter_callback_del_full(Edje_Object *obj, const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Sets the drag step increment.
+ *
+ * Sets the x,y step increments for a dragable object.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative size of the dragable area on that axis by which the
+ * part will be moved.
+ *
+ * @see edje_object_part_drag_step_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x step amount
+ * @param[in] dy The y step amount
+ */
+EAPI Eina_Bool edje_object_part_drag_step_set(Edje_Object *obj, const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Gets the drag step increment values.
+ *
+ * Gets the x and y step increments for the dragable object.
+ *
+ *
+ * @see edje_object_part_drag_step_set()
+ * 
+ *
+ * @param[in] part The part
+ * @param[out] dx The x step increment pointer
+ * @param[out] dy The y step increment pointer
+ */
+EAPI Eina_Bool edje_object_part_drag_step_get(const Edje_Object *obj, const char *part, double *dx, double *dy);
+
+/**
+ *
+ * @brief Get the input method context in entry.
+ *
+ * If ecore_imf was not available when edje was compiled, this function returns NULL
+ * otherwise, the returned pointer is an Ecore_IMF
+ *
+ * @return The input method context (Ecore_IMF_Context *) in entry
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void *edje_object_part_text_imf_context_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Starts selecting at current cursor position
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_select_begin(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Return the text of the object part.
+ *
+ * @return The text string
+ *
+ * This function returns the style associated with the textblock part.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI const char *edje_object_part_text_style_user_peek(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Advances the cursor to the next cursor position.
+ * @see evas_textblock_cursor_char_next
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The edje cursor to advance
+ */
+EAPI Eina_Bool edje_object_part_text_cursor_next(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Set the style of the
+ *
+ * This function sets the style associated with the textblock part.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] style The style to set (textblock conventions).
+ */
+EAPI void edje_object_part_text_style_user_push(Edje_Object *obj, const char *part, const char *style);
+
+/**
+ *
+ * @brief Insert text for an object part.
+ *
+ * This function inserts the text for an object part at the end; It does not
+ * move the cursor.
+ *
+ * @since 1.1
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ */
+EAPI void edje_object_part_text_append(Edje_Object *obj, const char *part, const char *text);
+
+/**
+ *
+ * @brief Retrieve the geometry of a given Edje part, in a given Edje
+ * object's group definition, <b>relative to the object's area</b>
+ *
+ * This function gets the geometry of an Edje part within its
+ * group. The @p x and @p y coordinates are relative to the top left
+ * corner of the whole @p obj object's area.
+ *
+ * @note Use @c NULL pointers on the geometry components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @note On failure, this function will make all non-@c NULL geometry
+ * pointers' pointed variables be set to zero.
+ * 
+ *
+ * @param[in] part The Edje part's name
+ * @param[out] x A pointer to a variable where to store the part's x
+coordinate
+ * @param[out] y A pointer to a variable where to store the part's y
+coordinate
+ * @param[out] w A pointer to a variable where to store the part's width
+ * @param[out] h A pointer to a variable where to store the part's height
+ */
+EAPI Eina_Bool edje_object_part_geometry_get(const Edje_Object *obj, const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * @brief Hide the input panel (virtual keyboard).
+ * @see edje_object_part_text_input_panel_show
+ *
+ * Note that input panel is shown or hidden automatically according to the focus state.
+ * This API can be used in the case of manually controlling by using edje_object_part_text_input_panel_enabled_set.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_input_panel_hide(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Return item geometry.
+ *
+ * @return 1 if item exists, 0 if not
+ *
+ * This function return a list of Evas_Textblock_Rectangle item
+ * rectangles.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] item The item name
+ * @param[out] cx Item x return (relative to entry part)
+ * @param[out] cy Item y return (relative to entry part)
+ * @param[out] cw Item width return
+ * @param[out] ch Item height return
+ */
+EAPI Eina_Bool edje_object_part_text_item_geometry_get(const Edje_Object *obj, const char *part, const char *item, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+/**
+ *
+ * @brief Removes an object from the table.
+ *
+ * @return @c EINA_TRUE object removed, @c EINA_FALSE on failure
+ *
+ * Removes an object from the table indicated by part.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child_obj The object to pack in
+ */
+EAPI Eina_Bool edje_object_part_table_unpack(Edje_Object *obj, const char *part, Evas_Object *child_obj);
+
+/**
+ *
+ * @brief Aborts any selection action on a part.
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_select_abort(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Delete a function and matching user data from the filter list.
+ *
+ * Delete the given @p func filter and @p data user data from the list
+ * in @p part.
+ * Returns the user data pointer given when added.
+ *
+ * @see edje_object_text_insert_filter_callback_add
+ * @see edje_object_text_insert_filter_callback_del
+ *
+ * @return The same data pointer if successful, or NULL otherwise
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ * @param[in] data The data passed to the callback function
+ */
+EAPI void *edje_object_text_insert_filter_callback_del_full(Edje_Object *obj, const char *part, Edje_Text_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Delete the top style form the user style stack.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_style_user_pop(Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Set the input panel-specific data to deliver to the input panel.
+ *
+ * This API is used by applications to deliver specific data to the input panel.
+ * The data format MUST be negotiated by both application and the input panel.
+ * The size and format of data are defined by the input panel.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] data The specific data to be set to the input panel.
+ * @param[in] len the length of data, in bytes, to send to the input panel
+ */
+EAPI void edje_object_part_text_input_panel_imdata_set(Edje_Object *obj, const char *part, const void *data, int len);
+
+/**
+ *
+ * Get the specific data of the current active input panel.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] data The specific data to be got from the input panel
+ * @param[in] len The length of data
+ */
+EAPI void edje_object_part_text_input_panel_imdata_get(const Edje_Object *obj, const char *part, void *data, int *len);
+
+/**
+ *
+ * @brief Insert text for an object part.
+ *
+ * This function inserts the text for an object part just before the
+ * cursor position.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ */
+EAPI void edje_object_part_text_insert(Edje_Object *obj, const char *part, const char *text);
+
+/**
+ *
+ * @brief Removes an object from the box.
+ *
+ * @return Pointer to the object removed, or @c NULL.
+ *
+ * Removes from the box indicated by part, the object in the position
+ * pos.
+ *
+ * @see edje_object_part_box_remove()
+ * @see edje_object_part_box_remove_all()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] pos The position index of the object (starts counting from 0)
+ */
+EAPI Evas_Object *edje_object_part_box_remove_at(Edje_Object *obj, const char *part, unsigned int pos);
+
+/**
+ *
+ * @brief Copy the cursor to another cursor.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] src the cursor to copy from
+ * @param[in] dst the cursor to copy to
+ */
+EAPI void edje_object_part_text_cursor_copy(Edje_Object *obj, const char *part, Edje_Cursor src, Edje_Cursor dst);
+
+/**
+ *
+ * Calculate the geometry of the region, relative to a given Edje
+ * object's area, <b>occupied by all parts in the object</b>
+ *
+ * This function gets the geometry of the rectangle equal to the area
+ * required to group all parts in @p obj's group/collection. The @p x
+ * and @p y coordinates are relative to the top left corner of the
+ * whole @p obj object's area. Parts placed out of the group's
+ * boundaries will also be taken in account, so that @p x and @p y
+ * <b>may be negative</b>.
+ *
+ * @note Use @c NULL pointers on the geometry components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @note On failure, this function will make all non-@c NULL geometry
+ * pointers' pointed variables be set to zero.
+ * 
+ *
+ * @param[out] x A pointer to a variable where to store the parts region's
+x coordinate
+ * @param[out] y A pointer to a variable where to store the parts region's
+y coordinate
+ * @param[out] w A pointer to a variable where to store the parts region's
+width
+ * @param[out] h A pointer to a variable where to store the parts region's
+height
+ */
+EAPI Eina_Bool edje_object_parts_extends_calc(Edje_Object *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * @brief Set the dragable object location.
+ *
+ * Places the dragable object at the given location.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative position to the dragable area on that axis.
+ *
+ * This value means, for the vertical axis, that 0.0 will be at the top if the
+ * first parameter of @c y in the dragable part theme is 1, and at bottom if it
+ * is -1.
+ *
+ * For the horizontal axis, 0.0 means left if the first parameter of @c x in the
+ * dragable part theme is 1, and right if it is -1.
+ *
+ * @see edje_object_part_drag_value_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x value
+ * @param[in] dy The y value
+ */
+EAPI Eina_Bool edje_object_part_drag_value_set(Edje_Object *obj, const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Get the dragable object location.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative position to the dragable area on that axis.
+ *
+ * @see edje_object_part_drag_value_set()
+ *
+ * Gets the drag location values.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] dx The X value pointer
+ * @param[out] dy The Y value pointer
+ */
+EAPI Eina_Bool edje_object_part_drag_value_get(const Edje_Object *obj, const char *part, double *dx, double *dy);
+
+/**
+ *
+ * @brief Force a Size/Geometry calculation.
+ *
+ * Forces the object @p obj to recalculation layout regardless of
+ * freeze/thaw.
+ * 
+ *
+ */
+EAPI void edje_object_calc_force(Edje_Object *obj);
+
+/**
+ *
+ * @brief Sets the cursor position to the given value
+ *
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to move
+ * @param[in] pos the position of the cursor
+ */
+EAPI void edje_object_part_text_cursor_pos_set(Edje_Object *obj, const char *part, Edje_Cursor cur, int pos);
+
+/**
+ *
+ * @brief Retrieves the current position of the cursor
+ *
+ * @return The cursor position
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to get the position
+ */
+EAPI int edje_object_part_text_cursor_pos_get(const Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Freezes the Edje object.
+ *
+ * @return The frozen state or 0 on Error
+ *
+ * This function puts all changes on hold. Successive freezes will
+ * nest, requiring an equal number of thaws.
+ *
+ * @see edje_object_thaw()
+ * 
+ *
+ */
+EAPI int edje_object_freeze(Edje_Object *obj);
+
+/**
+ *
+ * @brief Returns the content (char) at the cursor position.
+ * @see evas_textblock_cursor_content_get
+ *
+ * You must free the return (if not NULL) after you are done with it.
+ *
+ * @return The character string pointed to (may be a multi-byte utf8 sequence) terminated by a nul byte.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to use
+ */
+EAPI char *edje_object_part_text_cursor_content_get(const Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Set the layout of the input panel.
+ *
+ * The layout of the input panel or virtual keyboard can make it easier or
+ * harder to enter content. This allows you to hint what kind of input you
+ * are expecting to enter and thus have the input panel automatically
+ * come up with the right mode.
+ *
+ * @since 1.1
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] layout layout type
+ */
+EAPI void edje_object_part_text_input_panel_layout_set(Edje_Object *obj, const char *part, Edje_Input_Panel_Layout layout);
+
+/**
+ *
+ * @brief Get the layout of the input panel.
+ *
+ * @return Layout type of the input panel
+ *
+ * @see edje_object_part_text_input_panel_layout_set
+ * @since 1.1
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Edje_Input_Panel_Layout edje_object_part_text_input_panel_layout_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Packs an object into the table.
+ *
+ * @return @c EINA_TRUE object was added, @c EINA_FALSE on failure
+ *
+ * Packs an object into the table indicated by part.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child_obj The object to pack in
+ * @param[in] col The column to place it in
+ * @param[in] row The row to place it in
+ * @param[in] colspan Columns the child will take
+ * @param[in] rowspan Rows the child will take
+ */
+EAPI Eina_Bool edje_object_part_table_pack(Edje_Object *obj, const char *part, Evas_Object *child_obj, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan);
+
+/**
+ *
+ * Set the language mode of the input panel.
+ *
+ * This API can be used if you want to show the Alphabet keyboard.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] lang the language to be set to the input panel.
+ */
+EAPI void edje_object_part_text_input_panel_language_set(Edje_Object *obj, const char *part, Edje_Input_Panel_Lang lang);
+
+/**
+ *
+ * Get the language mode of the input panel.
+ *
+ * See @ref edje_object_part_text_input_panel_language_set for more details.
+ *
+ * @return input panel language type
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Edje_Input_Panel_Lang edje_object_part_text_input_panel_language_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Gets the number of columns and rows the table has.
+ *
+ * @return @c EINA_TRUE get some data, @c EINA_FALSE on failure
+ *
+ * Retrieves the size of the table in number of columns and rows.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] cols Pointer where to store number of columns (can be NULL)
+ * @param[out] rows Pointer where to store number of rows (can be NULL)
+ */
+EAPI Eina_Bool edje_object_part_table_col_row_size_get(const Edje_Object *obj, const char *part, int *cols, int *rows);
+
+/**
+ *
+ * @brief Get the object created by this external part.
+ *
+ * Parts of type external creates the part object using information
+ * provided by external plugins. It's somehow like "swallow"
+ * (edje_object_part_swallow()), but it's all set automatically.
+ *
+ * This function returns the part created by such external plugins and
+ * being currently managed by this Edje.
+ *
+ * @note Almost all swallow rules apply: you should not move, resize,
+ * hide, show, set the color or clipper of such part. It's a bit
+ * more restrictive as one must @b never delete this object!
+ *
+ * @return The externally created object, or NULL if there is none or
+ * part is not an external.
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Evas_Object *edje_object_part_external_object_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Get an object contained in an part of type EXTERNAL
+ *
+ * The @p content string must not be NULL. Its actual value depends on the
+ * code providing the EXTERNAL.
+ * 
+ *
+ * @param[in] part The name of the part holding the EXTERNAL
+ * @param[out] content A string identifying which content from the EXTERNAL to get
+ */
+EAPI Evas_Object *edje_object_part_external_content_get(const Edje_Object *obj, const char *part, const char *content);
+
+/**
+ *
+ * @brief Preload the images on the Edje Object in the background.
+ *
+ * @return @c EINA_FASLE if obj was not a valid Edje object
+ * otherwise @c EINA_TRUE
+ *
+ * This function requests the preload of all data images (on the given
+ * object) in the background. The work is queued before being processed
+ * (because there might be other pending requests of this type).
+ * It emits a signal "preload,done" when finished.
+ *
+ * @note Use @c EINA_TRUE on scenarios where you don't need
+ * the image data preloaded anymore.
+ * 
+ *
+ * @param[in] cancel @c EINA_FALSE will add it the preloading work queue,
+@c EINA_TRUE will remove it (if it was issued before).
+ */
+EAPI Eina_Bool edje_object_preload(Edje_Object *obj, Eina_Bool cancel);
+
+/**
+ *
+ * @brief Sets the attribute to show the input panel automatically.
+ *
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] enabled If true, the input panel is appeared when entry is clicked or has a focus
+ */
+EAPI void edje_object_part_text_input_panel_enabled_set(Edje_Object *obj, const char *part, Eina_Bool enabled);
+
+/**
+ *
+ * @brief Retrieve the attribute to show the input panel automatically.
+ * @see edje_object_part_text_input_panel_enabled_set
+ *
+ * @return EINA_TRUE if it supports or EINA_FALSE otherwise
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Eina_Bool edje_object_part_text_input_panel_enabled_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Extends the current selection to the current cursor position
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_select_extend(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Inserts an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Adds child to the box indicated by part, in the position given by
+ * pos.
+ *
+ * @see edje_object_part_box_append()
+ * @see edje_object_part_box_prepend()
+ * @see edje_object_part_box_insert_before()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to insert
+ * @param[in] pos The position where to insert child
+ */
+EAPI Eina_Bool edje_object_part_box_insert_at(Edje_Object *obj, const char *part, Evas_Object *child, unsigned int pos);
+
+/**
+ *
+ * @brief Return a list of Evas_Textblock_Rectangle anchor rectangles.
+ *
+ * @return The list of anchor rects (const Evas_Textblock_Rectangle
+ * *), do not modify! Geometry is relative to entry part.
+ *
+ * This function return a list of Evas_Textblock_Rectangle anchor
+ * rectangles.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] anchor The anchor name
+ */
+EAPI const Eina_List *edje_object_part_text_anchor_geometry_get(const Edje_Object *obj, const char *part, const char *anchor);
+
+/**
+ *
+ * @brief Moves the cursor to the char below the current cursor position.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ */
+EAPI Eina_Bool edje_object_part_text_cursor_down(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets the page step increments.
+ *
+ * Sets the x,y page step increment values.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1,
+ * representing the relative size of the dragable area on that axis by which the
+ * part will be moved.
+ *
+ * @see edje_object_part_drag_page_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x page step increment
+ * @param[in] dy The y page step increment
+ */
+EAPI Eina_Bool edje_object_part_drag_page_set(Edje_Object *obj, const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Gets the page step increments.
+ *
+ * Gets the x,y page step increments for the dragable object.
+ *
+ * @see edje_object_part_drag_page_set()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] dx The dx page increment pointer
+ * @param[out] dy The dy page increment pointer
+ */
+EAPI Eina_Bool edje_object_part_drag_page_get(const Edje_Object *obj, const char *part, double *dx, double *dy);
+
+/**
+ *
+ * @brief Prepends an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Prepends child to the box indicated by part.
+ *
+ * @see edje_object_part_box_append()
+ * @see edje_object_part_box_insert_before()
+ * @see edje_object_part_box_insert_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to prepend
+ */
+EAPI Eina_Bool edje_object_part_box_prepend(Edje_Object *obj, const char *part, Evas_Object *child);
+
+/**
+ *
+ * @brief Send/emit an Edje signal to a given Edje object
+ *
+ * This function sends a signal to the object @a obj. An Edje program,
+ * at @p obj's EDC specification level, can respond to a signal by
+ * having declared matching @c 'signal' and @c 'source' fields on its
+ * block (see @ref edcref "the syntax" for EDC files).
+ *
+ * As an example,
+ * @code
+ * edje_object_signal_emit(obj, "a_signal", "");
+ * @endcode
+ * would trigger a program which had an EDC declaration block like
+ * @code
+ * program {
+ * name: "a_program";
+ * signal: "a_signal";
+ * source: "";
+ * action: ...
+ * }
+ * @endcode
+ *
+ * @see edje_object_signal_callback_add() for more on Edje signals.
+ * 
+ *
+ * @param[in] emission The signal's "emission" string
+ * @param[in] source The signal's "source" string
+ */
+EAPI void edje_object_signal_emit(Edje_Object *obj, const char *emission, const char *source);
+
+/**
+ *
+ * @brief Set the layout variation of the input panel.
+ *
+ * The layout variation of the input panel or virtual keyboard can make it easier or
+ * harder to enter content. This allows you to hint what kind of input you
+ * are expecting to enter and thus have the input panel automatically
+ * come up with the right mode.
+ *
+ * @since 1.8
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] variation layout variation type
+ */
+EAPI void edje_object_part_text_input_panel_layout_variation_set(Edje_Object *obj, const char *part, int variation);
+
+/**
+ *
+ * @brief Get the layout variation of the input panel.
+ *
+ * @return Layout variation type of the input panel
+ *
+ * @see edje_object_part_text_input_panel_layout_variation_set
+ * @since 1.8
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI int edje_object_part_text_input_panel_layout_variation_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Send an (Edje) message to a given Edje object
+ *
+ * This function sends an Edje message to @p obj and to all of its
+ * child objects, if it has any (swallowed objects are one kind of
+ * child object). @p type and @p msg @b must be matched accordingly,
+ * as documented in #Edje_Message_Type.
+ *
+ * The @p id argument as a form of code and theme defining a common
+ * interface on message communication. One should define the same IDs
+ * on both code and EDC declaration (see @ref edcref "the syntax" for
+ * EDC files), to individualize messages (binding them to a given
+ * context).
+ *
+ * The function to handle messages arriving @b from @b obj is set with
+ * edje_object_message_handler_set().
+ * 
+ *
+ * @param[in] type The type of message to send to @p obj
+ * @param[in] id A identification number for the message to be sent
+ * @param[in] msg The message's body, a struct depending on @p type
+ */
+EAPI void edje_object_message_send(Edje_Object *obj, Edje_Message_Type type, int id, void *msg);
+
+/**
+ *
+ * @brief Set the selection to be none.
+ *
+ * This function sets the selection text to be none.
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_select_none(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Get a handle to the Evas object implementing a given Edje
+ * part, in an Edje object.
+ *
+ * @return A pointer to the Evas object implementing the given part,
+ * or @c NULL on failure (e.g. the given part doesn't exist)
+ *
+ * This function gets a pointer of the Evas object corresponding to a
+ * given part in the @p obj object's group.
+ *
+ * You should @b never modify the state of the returned object (with
+ * @c evas_object_move() or @c evas_object_hide() for example),
+ * because it's meant to be managed by Edje, solely. You are safe to
+ * query information about its current state (with @c
+ * evas_object_visible_get() or @c evas_object_color_get() for
+ * example), though.
+ * 
+ *
+ * @param[in] part The Edje part's name
+ */
+EAPI const Evas_Object *edje_object_part_object_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Set the dragable object size.
+ *
+ * Values for @p dw and @p dh are real numbers that range from 0 to 1,
+ * representing the relative size of the dragable area on that axis.
+ *
+ * Sets the size of the dragable object.
+ *
+ * @see edje_object_part_drag_size_get()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dw The drag width
+ * @param[in] dh The drag height
+ */
+EAPI Eina_Bool edje_object_part_drag_size_set(Edje_Object *obj, const char *part, double dw, double dh);
+
+/**
+ *
+ * @brief Get the dragable object size.
+ *
+ * Gets the dragable object size.
+ *
+ * @see edje_object_part_drag_size_set()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] dw The drag width pointer
+ * @param[out] dh The drag height pointer
+ */
+EAPI Eina_Bool edje_object_part_drag_size_get(const Edje_Object *obj, const char *part, double *dw, double *dh);
+
+/**
+ *
+ * Delete a function from the filter list.
+ *
+ * Delete the given @p func filter from the list in @p part. Returns
+ * the user data pointer given when added.
+ *
+ * @see edje_object_text_insert_filter_callback_add
+ * @see edje_object_text_insert_filter_callback_del_full
+ *
+ * @return The user data pointer if successful, or NULL otherwise
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ */
+EAPI void *edje_object_text_insert_filter_callback_del(Edje_Object *obj, const char *part, Edje_Text_Filter_Cb func);
+
+/**
+ *
+ * @brief Determine dragable directions.
+ *
+ * The dragable directions are defined in the EDC file, inside the @c dragable
+ * section, by the attributes @c x and @c y. See the @ref edcref for more
+ * information.
+ *
+ * @return #EDJE_DRAG_DIR_NONE: Not dragable\n
+ * #EDJE_DRAG_DIR_X: Dragable in X direction\n
+ * #EDJE_DRAG_DIR_Y: Dragable in Y direction\n
+ * #EDJE_DRAG_DIR_XY: Dragable in X & Y directions
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Edje_Drag_Dir edje_object_part_drag_dir_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Sets the raw (non escaped) text for an object part.
+ *
+ * This funciton will not do escape for you if it is a TEXTBLOCK part, that is,
+ * if text contain tags, these tags will not be interpreted/parsed by TEXTBLOCK.
+ *
+ * @see edje_object_part_text_unescaped_get().
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text_to_escape The text string
+ */
+EAPI Eina_Bool edje_object_part_text_unescaped_set(Edje_Object *obj, const char *part, const char *text_to_escape);
+
+/**
+ *
+ * @brief Returns the text of the object part, without escaping.
+ *
+ * @return The @b allocated text string without escaping, or NULL on
+ * problems.
+ *
+ * This function is the counterpart of
+ * edje_object_part_text_unescaped_set(). Please notice that the
+ * result is newly allocated memory and should be released with free()
+ * when done.
+ *
+ * @see edje_object_part_text_unescaped_set().
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI char *edje_object_part_text_unescaped_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Add a callback for an arriving Edje signal, emitted by
+ * a given Edje object.
+ *
+ * Edje signals are one of the communication interfaces between
+ * @b code and a given Edje object's @b theme. With signals, one can
+ * communicate two string values at a time, which are:
+ * - "emission" value: the name of the signal, in general
+ * - "source" value: a name for the signal's context, in general
+ *
+ * Though there are those common uses for the two strings, one is free
+ * to use them however they like.
+ *
+ * This function adds a callback function to a signal emitted by @a obj, to
+ * be issued every time an EDC program like the following
+ * @code
+ * program {
+ * name: "emit_example";
+ * action: SIGNAL_EMIT "a_signal" "a_source";
+ * }
+ * @endcode
+ * is run, if @p emission and @p source are given those same values,
+ * here.
+ *
+ * Signal callback registration is powerful, in the way that @b blobs
+ * may be used to match <b>multiple signals at once</b>. All the @c
+ * "*?[\" set of @c fnmatch() operators can be used, both for @p
+ * emission and @p source.
+ *
+ * Edje has @b internal signals it will emit, automatically, on
+ * various actions taking place on group parts. For example, the mouse
+ * cursor being moved, pressed, released, etc., over a given part's
+ * area, all generate individual signals.
+ *
+ * By using something like
+ * @code
+ * edje_object_signal_callback_add(obj, "mouse,down,*", "button.*",
+ * signal_cb, NULL);
+ * @endcode
+ * being @c "button.*" the pattern for the names of parts implementing
+ * buttons on an interface, you'd be registering for notifications on
+ * events of mouse buttons being pressed down on either of those parts
+ * (those events all have the @c "mouse,down," common prefix on their
+ * names, with a suffix giving the button number). The actual emission
+ * and source strings of an event will be passed in as the @a emission
+ * and @a source parameters of the callback function (e.g. @c
+ * "mouse,down,2" and @c "button.close"), for each of those events.
+ *
+ * @note See @ref edcref "the syntax" for EDC files
+ * @see edje_object_signal_emit() on how to emits Edje signals from
+ * code to a an object
+ * @see edje_object_signal_callback_del_full()
+ * 
+ *
+ * @param[in] emission The signal's "emission" string
+ * @param[in] source The signal's "source" string
+ * @param[in] func The callback function to be executed when the signal is
+emitted.
+ * @param[in] data A pointer to data to pass in to @p func.
+ */
+EAPI void edje_object_signal_callback_add(Edje_Object *obj, const char *emission, const char *source, Edje_Signal_Cb func, void *data);
+
+/**
+ *
+ * @brief Set the selection to be everything.
+ *
+ * This function selects all text of the object of the part.
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_select_all(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Set the return key on the input panel to be disabled.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] disabled The state
+ */
+EAPI void edje_object_part_text_input_panel_return_key_disabled_set(Edje_Object *obj, const char *part, Eina_Bool disabled);
+
+/**
+ *
+ * Get whether the return key on the input panel should be disabled or not.
+ *
+ * @return EINA_TRUE if it should be disabled
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Eina_Bool edje_object_part_text_input_panel_return_key_disabled_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Set the autocapitalization type on the immodule.
+ *
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] autocapital_type The type of autocapitalization
+ */
+EAPI void edje_object_part_text_autocapital_type_set(Edje_Object *obj, const char *part, Edje_Text_Autocapital_Type autocapital_type);
+
+/**
+ *
+ * @brief Retrieves the autocapitalization type
+ *
+ * @return The autocapitalization type
+ * @since 1.1.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Edje_Text_Autocapital_Type edje_object_part_text_autocapital_type_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Unswallow an object.
+ *
+ * Causes the edje to regurgitate a previously swallowed object. :)
+ *
+ * @note @p obj_swallow will @b not be deleted or hidden.
+ * @note @p obj_swallow may appear shown on the evas depending on its state when
+ * it got unswallowed. Make sure you delete it or hide it if you do not want it to.
+ * 
+ *
+ * @param[in] obj_swallow The swallowed object
+ */
+EAPI void edje_object_part_unswallow(Edje_Object *obj, Evas_Object *obj_swallow);
+
+/**
+ *
+ * @brief Set whether the prediction is allowed or not.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] prediction If true, the prediction feature is allowed.
+ */
+EAPI void edje_object_part_text_prediction_allow_set(Edje_Object *obj, const char *part, Eina_Bool prediction);
+
+/**
+ *
+ * @brief Get whether the prediction is allowed or not.
+ *
+ * @return EINA_TRUE if prediction feature is allowed.
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Eina_Bool edje_object_part_text_prediction_allow_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Retrive an <b>EDC data field's value</b> from a given Edje
+ * object's group.
+ *
+ * @return The data's value string. Must not be freed.
+ *
+ * This function fetches an EDC data field's value, which is declared
+ * on the objects building EDC file, <b>under its group</b>. EDC data
+ * blocks are most commonly used to pass arbitrary parameters from an
+ * application's theme to its code.
+ *
+ * They look like the following:
+ *
+ * @code
+ * collections {
+ * group {
+ * name: "a_group";
+ * data {
+ * item: "key1" "value1";
+ * item: "key2" "value2";
+ * }
+ * }
+ * }
+ * @endcode
+ *
+ * EDC data fields always hold @b strings as values, hence the return
+ * type of this function. Check the complete @ref edcref "syntax reference"
+ * for EDC files.
+ *
+ * @warning Do not confuse this call with edje_file_data_get(), which
+ * queries for a @b global EDC data field on an EDC declaration file.
+ *
+ * @see edje_object_file_set()
+ * 
+ *
+ * @param[in] key The data field's key string
+ */
+EAPI const char *edje_object_data_get(const Edje_Object *obj, const char *key);
+
+/**
+ *
+ * Add a markup filter function for newly inserted text.
+ *
+ * Whenever text is inserted (not the same as set) into the given @p part,
+ * the list of markup filter functions will be called to decide if and how
+ * the new text will be accepted.
+ * The text parameter in the @p func filter is always markup. It can be
+ * modified by the user and it's up to him to free the one passed if he's to
+ * change the pointer. If doing so, the newly set text should be malloc'ed,
+ * as once all the filters are called Edje will free it.
+ * If the text is to be rejected, freeing it and setting the pointer to NULL
+ * will make Edje break out of the filter cycle and reject the inserted
+ * text.
+ * This function is different from edje_object_text_insert_filter_callback_add()
+ * in that the text parameter in the @p fucn filter is always markup.
+ *
+ * @warning If you use this function with
+ * edje_object_text_insert_filter_callback_add() togehter, all
+ * Edje_Text_Filter_Cb functions and Edje_Markup_Filter_Cb functions
+ * will be executed, and then filtered text will be inserted.
+ *
+ * @see edje_object_text_markup_filter_callback_del
+ * @see edje_object_text_markup_filter_callback_del_full
+ * @see edje_object_text_insert_filter_callback_add
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The callback function that will act as markup filter
+ * @param[in] data User provided data to pass to the filter function
+ */
+EAPI void edje_object_text_markup_filter_callback_add(Edje_Object *obj, const char *part, Edje_Markup_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Process an object's message queue.
+ *
+ * This function goes through the object message queue processing the
+ * pending messages for @b this specific Edje object. Normally they'd
+ * be processed only at idle time.
+ * 
+ *
+ */
+EAPI void edje_object_message_signal_process(Edje_Object *obj);
+
+/**
+ *
+ * @brief Removes an object from the box.
+ *
+ * @return Pointer to the object removed, or @c NULL.
+ *
+ * Removes child from the box indicated by part.
+ *
+ * @see edje_object_part_box_remove_at()
+ * @see edje_object_part_box_remove_all()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to remove
+ */
+EAPI Evas_Object *edje_object_part_box_remove(Edje_Object *obj, const char *part, Evas_Object *child);
+
+/**
+ *
+ * @brief Thaws the Edje object.
+ *
+ * @return The frozen state or 0 if the object is not frozen or on error.
+ *
+ * This function thaws the given Edje object.
+ *
+ * @note: If sucessives freezes were done, an equal number of
+ * thaws will be required.
+ *
+ * @see edje_object_freeze()
+ * 
+ *
+ */
+EAPI int edje_object_thaw(Edje_Object *obj);
+
+/**
+ *
+ * @brief Get the object currently swallowed by a part.
+ *
+ * @return The swallowed object, or NULL if there is none.
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Evas_Object *edje_object_part_swallow_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Reset the input method context if needed.
+ *
+ * This can be necessary in the case where modifying the buffer would confuse on-going input method behavior
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_imf_context_reset(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Set the "return" key type. This type is used to set string or icon on the "return" key of the input panel.
+ *
+ * An input panel displays the string or icon associated with this type
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] return_key_type The type of "return" key on the input panel
+ */
+EAPI void edje_object_part_text_input_panel_return_key_type_set(Edje_Object *obj, const char *part, Edje_Input_Panel_Return_Key_Type return_key_type);
+
+/**
+ *
+ * Get the "return" key type.
+ *
+ * @see edje_object_part_text_input_panel_return_key_type_set() for more details
+ *
+ * @return The type of "return" key on the input panel
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Edje_Input_Panel_Return_Key_Type edje_object_part_text_input_panel_return_key_type_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Retrieve a child from a table
+ *
+ * @return The child Evas_Object
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] col The column of the child to get
+ * @param[in] row The row of the child to get
+ */
+EAPI Evas_Object *edje_object_part_table_child_get(const Edje_Object *obj, const char *part, unsigned int col, unsigned int row);
+
+/**
+ *
+ * @brief Adds an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Inserts child in the box given by part, in the position marked by
+ * reference.
+ *
+ * @see edje_object_part_box_append()
+ * @see edje_object_part_box_prepend()
+ * @see edje_object_part_box_insert_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to insert
+ * @param[in] reference The object to be used as reference
+ */
+EAPI Eina_Bool edje_object_part_box_insert_before(Edje_Object *obj, const char *part, Evas_Object *child, const Evas_Object *reference);
+
+/**
+ *
+ * @brief Set the parameter for the external part.
+ *
+ * Parts of type external may carry extra properties that have
+ * meanings defined by the external plugin. For instance, it may be a
+ * string that defines a button label and setting this property will
+ * change that label on the fly.
+ *
+ * @note external parts have parameters set when they change
+ * states. Those parameters will never be changed by this
+ * function. The interpretation of how state_set parameters and
+ * param_set will interact is up to the external plugin.
+ *
+ * @note this function will not check if parameter value is valid
+ * using #Edje_External_Param_Info minimum, maximum, valid
+ * choices and others. However these should be checked by the
+ * underlying implementation provided by the external
+ * plugin. This is done for performance reasons.
+ *
+ * @return @c EINA_TRUE if everything went fine, @c EINA_FALSE on errors.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] param the parameter details, including its name, type and
+actual value. This pointer should be valid, and the
+parameter must exist in
+#Edje_External_Type.parameters_info, with the exact type,
+otherwise the operation will fail and @c EINA_FALSE will be
+returned.
+ */
+EAPI Eina_Bool edje_object_part_external_param_set(Edje_Object *obj, const char *part, const Edje_External_Param *param);
+
+/**
+ *
+ * @brief Get the parameter for the external part.
+ *
+ * Parts of type external may carry extra properties that have
+ * meanings defined by the external plugin. For instance, it may be a
+ * string that defines a button label. This property can be modified by
+ * state parameters, by explicit calls to
+ * edje_object_part_external_param_set() or getting the actual object
+ * with edje_object_part_external_object_get() and calling native
+ * functions.
+ *
+ * This function asks the external plugin what is the current value,
+ * independent on how it was set.
+ *
+ * @return @c EINA_TRUE if everything went fine and @p param members
+ * are filled with information, @c EINA_FALSE on errors and @p
+ * param member values are not set or valid.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] param the parameter details. It is used as both input and
+output variable. This pointer should be valid, and the
+parameter must exist in
+#Edje_External_Type.parameters_info, with the exact type,
+otherwise the operation will fail and @c EINA_FALSE will be
+returned.
+ */
+EAPI Eina_Bool edje_object_part_external_param_get(const Edje_Object *obj, const char *part, Edje_External_Param *param);
+
+/**
+ *
+ * @brief Calculate the minimum required size for a given Edje object.
+ *
+ * This call works exactly as edje_object_size_min_restricted_calc(),
+ * with the last two arguments set to 0. Please refer to its
+ * documentation, then.
+ * 
+ *
+ * @param[out] minw Pointer to a variable where to store the minimum
+required width
+ * @param[out] minh Pointer to a variable where to store the minimum
+required height
+ */
+EAPI void edje_object_size_min_calc(Edje_Object *obj, Evas_Coord *minw, Evas_Coord *minh);
+
+/**
+ *
+ * @brief Appends an object to the box.
+ *
+ * @return @c EINA_TRUE: Successfully added.\n
+ * @c EINA_FALSE: An error occurred.
+ *
+ * Appends child to the box indicated by part.
+ *
+ * @see edje_object_part_box_prepend()
+ * @see edje_object_part_box_insert_before()
+ * @see edje_object_part_box_insert_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] child The object to append
+ */
+EAPI Eina_Bool edje_object_part_box_append(Edje_Object *obj, const char *part, Evas_Object *child);
+
+/**
+ *
+ * @brief Calculate the minimum required size for a given Edje object.
+ *
+ * This call will trigger an internal recalculation of all parts of
+ * the @p obj object, in order to return its minimum required
+ * dimensions for width and height. The user might choose to @b impose
+ * those minimum sizes, making the resulting calculation to get to values
+ * equal or bigger than @p restrictedw and @p restrictedh, for width and
+ * height, respectively.
+ *
+ * @note At the end of this call, @p obj @b won't be automatically
+ * resized to new dimensions, but just return the calculated
+ * sizes. The caller is the one up to change its geometry or not.
+ *
+ * @warning Be advised that invisible parts in @p obj @b will be taken
+ * into account in this calculation.
+ * 
+ *
+ * @param[out] minw Pointer to a variable where to store the minimum
+required width
+ * @param[out] minh Pointer to a variable where to store the minimum
+required height
+ * @param[in] restrictedw Do not allow object's calculated (minimum) width
+to be less than this value
+ * @param[in] restrictedh Do not allow object's calculated (minimum)
+height to be less than this value
+ */
+EAPI void edje_object_size_min_restricted_calc(Edje_Object *obj, Evas_Coord *minw, Evas_Coord *minh, Evas_Coord restrictedw, Evas_Coord restrictedh);
+
+/**
+ *
+ * @brief Removes all elements from the box.
+ *
+ * @return 1: Successfully cleared.\n
+ * 0: An error occurred.
+ *
+ * Removes all the external objects from the box indicated by part.
+ * Elements created from the theme will not be removed.
+ *
+ * @see edje_object_part_box_remove()
+ * @see edje_object_part_box_remove_at()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] clear Delete objects on removal
+ */
+EAPI Eina_Bool edje_object_part_box_remove_all(Edje_Object *obj, const char *part, Eina_Bool clear);
+
+/**
+ *
+ * @brief Pages x,y steps.
+ *
+ * Pages x,y where the increment is defined by
+ * edje_object_part_drag_page_set.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1.
+ *
+ * @warning Paging is bugged!
+ *
+ * @see edje_object_part_drag_step()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x step
+ * @param[in] dy The y step
+ */
+EAPI Eina_Bool edje_object_part_drag_page(Edje_Object *obj, const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Sets the text for an object part
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE otherwise
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ */
+EAPI Eina_Bool edje_object_part_text_set(Edje_Object *obj, const char *part, const char *text);
+
+/**
+ *
+ * @brief Return the text of the object part.
+ *
+ * @return The text string
+ *
+ * This function returns the text associated to the object part.
+ *
+ * @see edje_object_part_text_set().
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI const char *edje_object_part_text_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Set the attribute to show the input panel in case of only an user's explicit Mouse Up event.
+ * It doesn't request to show the input panel even though it has focus.
+ *
+ * @since 1.9.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] ondemand If true, the input panel will be shown in case of only Mouse up event. (Focus event will be ignored.)
+ */
+EAPI void edje_object_part_text_input_panel_show_on_demand_set(Edje_Object *obj, const char *part, Eina_Bool ondemand);
+
+/**
+ *
+ * Get the attribute to show the input panel in case of only an user's explicit Mouse Up event.
+ *
+ * @return @c EINA_TRUE if the input panel will be shown in case of only Mouse up event.
+ * @since 1.9.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Eina_Bool edje_object_part_text_input_panel_show_on_demand_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Sets the input hint which allows input methods to fine-tune their behavior.
+ *
+ * @since 1.12.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] input_hints input hints
+ */
+EAPI void edje_object_part_text_input_hint_set(Edje_Object *obj, const char *part, Edje_Input_Hints input_hints);
+
+/**
+ *
+ * Gets the value of input hint
+ *
+ * @return The value of input hint
+ * @since 1.12.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI Edje_Input_Hints edje_object_part_text_input_hint_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Return the selection text of the object part.
+ *
+ * @return The text string
+ *
+ * This function returns selection text of the object part.
+ *
+ * @see edje_object_part_text_select_all()
+ * @see edje_object_part_text_select_none()
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI const char *edje_object_part_text_selection_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Returns whether the cursor points to a format.
+ * @see evas_textblock_cursor_is_format
+ *
+ * @return EINA_TRUE if it's true, EINA_FALSE otherwise.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to adjust.
+ */
+EAPI Eina_Bool edje_object_part_text_cursor_is_format_get(const Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Sets the object color class.
+ *
+ * This function sets the color values for an object level color
+ * class. This will cause all edje parts in the specified object that
+ * have the specified color class to have their colors multiplied by
+ * these values.
+ *
+ * The first color is the object, the second is the text outline, and
+ * the third is the text shadow. (Note that the second two only apply
+ * to text parts).
+ *
+ * Setting color emits a signal "color_class,set" with source being
+ * the given color.
+ *
+ * @note unlike Evas, Edje colors are @b not pre-multiplied. That is,
+ * half-transparent white is 255 255 255 128.
+ * 
+ *
+ * @param[in] color_class No description supplied.
+ * @param[in] r Object Red value
+ * @param[in] g Object Green value
+ * @param[in] b Object Blue value
+ * @param[in] a Object Alpha value
+ * @param[in] r2 Outline Red value
+ * @param[in] g2 Outline Green value
+ * @param[in] b2 Outline Blue value
+ * @param[in] a2 Outline Alpha value
+ * @param[in] r3 Shadow Red value
+ * @param[in] g3 Shadow Green value
+ * @param[in] b3 Shadow Blue value
+ * @param[in] a3 Shadow Alpha value
+ */
+EAPI Eina_Bool edje_object_color_class_set(Edje_Object *obj, const char *color_class, int r, int g, int b, int a, int r2, int g2, int b2, int a2, int r3, int g3, int b3, int a3);
+
+/**
+ *
+ * @brief Gets the object color class.
+ *
+ * @return EINA_TRUE if found or EINA_FALSE if not found and all
+ * values are zeroed.
+ *
+ * This function gets the color values for an object level color
+ * class. If no explicit object color is set, then global values will
+ * be used.
+ *
+ * The first color is the object, the second is the text outline, and
+ * the third is the text shadow. (Note that the second two only apply
+ * to text parts).
+ *
+ * @note unlike Evas, Edje colors are @b not pre-multiplied. That is,
+ * half-transparent white is 255 255 255 128.
+ * 
+ *
+ * @param[in] color_class No description supplied.
+ * @param[out] r Object Red value
+ * @param[out] g Object Green value
+ * @param[out] b Object Blue value
+ * @param[out] a Object Alpha value
+ * @param[out] r2 Outline Red value
+ * @param[out] g2 Outline Green value
+ * @param[out] b2 Outline Blue value
+ * @param[out] a2 Outline Alpha value
+ * @param[out] r3 Shadow Red value
+ * @param[out] g3 Shadow Green value
+ * @param[out] b3 Shadow Blue value
+ * @param[out] a3 Shadow Alpha value
+ */
+EAPI Eina_Bool edje_object_color_class_get(const Edje_Object *obj, const char *color_class, int *r, int *g, int *b, int *a, int *r2, int *g2, int *b2, int *a2, int *r3, int *g3, int *b3, int *a3);
+
+/**
+ *
+ * @brief Steps the dragable x,y steps.
+ *
+ * Steps x,y where the step increment is the amount set by
+ * edje_object_part_drag_step_set.
+ *
+ * Values for @p dx and @p dy are real numbers that range from 0 to 1.
+ *
+ * @see edje_object_part_drag_page()
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] dx The x step
+ * @param[in] dy The y step
+ */
+EAPI Eina_Bool edje_object_part_drag_step(Edje_Object *obj, const char *part, double dx, double dy);
+
+/**
+ *
+ * @brief Move the cursor to the char above the current cursor position.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ */
+EAPI Eina_Bool edje_object_part_text_cursor_up(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Returns the cursor geometry of the part relative to the edje
+ * object.
+ * 
+ *
+ * @param[in] part The part name
+ * @param[out] x Cursor X position
+ * @param[out] y Cursor Y position
+ * @param[out] w Cursor width
+ * @param[out] h Cursor height
+ */
+EAPI void edje_object_part_text_cursor_geometry_get(const Edje_Object *obj, const char *part, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * @brief Return a list of char anchor names.
+ *
+ * @return The list of anchors (const char *), do not modify!
+ *
+ * This function returns a list of char anchor names.
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI const Eina_List *edje_object_part_text_anchor_list_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Add a filter function for newly inserted text.
+ *
+ * Whenever text is inserted (not the same as set) into the given @p part,
+ * the list of filter functions will be called to decide if and how the new
+ * text will be accepted.
+ * There are three types of filters, EDJE_TEXT_FILTER_TEXT,
+ * EDJE_TEXT_FILTER_FORMAT and EDJE_TEXT_FILTER_MARKUP.
+ * The text parameter in the @p func filter can be modified by the user and
+ * it's up to him to free the one passed if he's to change the pointer. If
+ * doing so, the newly set text should be malloc'ed, as once all the filters
+ * are called Edje will free it.
+ * If the text is to be rejected, freeing it and setting the pointer to NULL
+ * will make Edje break out of the filter cycle and reject the inserted
+ * text.
+ *
+ * @warning This function will be deprecated because of difficulty in use.
+ * The type(format, text, or markup) of text should be always
+ * checked in the filter function for correct filtering.
+ * Please use edje_object_text_markup_filter_callback_add() instead. There
+ * is no need to check the type of text in the filter function
+ * because the text is always markup.
+ * @warning If you use this function with
+ * edje_object_text_markup_filter_callback_add() together, all
+ * Edje_Text_Filter_Cb functions and Edje_Markup_Filter_Cb functions
+ * will be executed, and then filtered text will be inserted.
+ *
+ * @see edje_object_text_insert_filter_callback_del
+ * @see edje_object_text_insert_filter_callback_del_full
+ * @see edje_object_text_markup_filter_callback_add
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The callback function that will act as filter
+ * @param[in] data User provided data to pass to the filter function
+ */
+EAPI void edje_object_text_insert_filter_callback_add(Edje_Object *obj, const char *part, Edje_Text_Filter_Cb func, void *data);
+
+/**
+ *
+ * @brief Show the input panel (virtual keyboard) based on the input panel property such as layout, autocapital types, and so on.
+ *
+ * Note that input panel is shown or hidden automatically according to the focus state.
+ * This API can be used in the case of manually controlling by using edje_object_part_text_input_panel_enabled_set.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI void edje_object_part_text_input_panel_show(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief Check if an Edje part exists in a given Edje object's group
+ * definition.
+ *
+ * @return @c EINA_TRUE, if the Edje part exists in @p obj's group or
+ * @c EINA_FALSE, otherwise (and on errors)
+ *
+ * This function returns if a given part exists in the Edje group
+ * bound to object @p obj (with edje_object_file_set()).
+ *
+ * This call is useful, for example, when one could expect or not a
+ * given GUI element, depending on the @b theme applied to @p obj.
+ * 
+ *
+ * @param[in] part The part's name to check for existence in @p obj's
+group
+ */
+EAPI Eina_Bool edje_object_part_exists(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * Delete a function from the markup filter list.
+ *
+ * Delete the given @p func filter from the list in @p part. Returns
+ * the user data pointer given when added.
+ *
+ * @see edje_object_text_markup_filter_callback_add
+ * @see edje_object_text_markup_filter_callback_del_full
+ *
+ * @return The user data pointer if successful, or NULL otherwise
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] func The function callback to remove
+ */
+EAPI void *edje_object_text_markup_filter_callback_del(Edje_Object *obj, const char *part, Edje_Markup_Filter_Cb func);
+
+/**
+ *
+ * @brief Return true if the cursor points to a visible format
+ * For example \\t, \\n, item and etc.
+ * @see  evas_textblock_cursor_format_is_visible_get
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur The cursor to adjust.
+ */
+EAPI Eina_Bool edje_object_part_text_cursor_is_visible_format_get(const Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief This function inserts text as if the user has inserted it.
+ *
+ * This means it actually registers as a change and emits signals, triggers
+ * callbacks as appropriate.
+ *
+ * @since 1.2.0
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] text The text string
+ */
+EAPI void edje_object_part_text_user_insert(const Edje_Object *obj, const char *part, const char *text);
+
+/**
+ *
+ * @brief Moves the cursor to the previous char
+ * @see evas_textblock_cursor_char_prev
+ * 
+ *
+ * @param[in] part The part name
+ * @param[in] cur the edje cursor to work on
+ */
+EAPI Eina_Bool edje_object_part_text_cursor_prev(Edje_Object *obj, const char *part, Edje_Cursor cur);
+
+/**
+ *
+ * @brief Return a list of char item names.
+ *
+ * @return The list of items (const char *), do not modify!
+ *
+ * This function returns a list of char item names.
+ * 
+ *
+ * @param[in] part The part name
+ */
+EAPI const Eina_List *edje_object_part_text_item_list_get(const Edje_Object *obj, const char *part);
+
+/**
+ *
+ * @brief "Swallows" an object into one of the Edje object @c SWALLOW
+ * parts.
+ *
+ * Swallowing an object into an Edje object is, for a given part of
+ * type @c SWALLOW in the EDC group which gave life to @a obj, to set
+ * an external object to be controlled by @a obj, being displayed
+ * exactly over that part's region inside the whole Edje object's
+ * viewport.
+ *
+ * From this point on, @a obj will have total control over @a
+ * obj_swallow's geometry and visibility. For instance, if @a obj is
+ * visible, as in @c evas_object_show(), the swallowed object will be
+ * visible too -- if the given @c SWALLOW part it's in is also
+ * visible. Other actions on @a obj will also reflect on the swallowed
+ * object as well (e.g. resizing, moving, raising/lowering, etc.).
+ *
+ * Finally, all internal changes to @a part, specifically, will
+ * reflect on the displaying of @a obj_swallow, for example state
+ * changes leading to different visibility states, geometries,
+ * positions, etc.
+ *
+ * If an object has already been swallowed into this part, then it
+ * will first be unswallowed (as in edje_object_part_unswallow())
+ * before the new object is swallowed.
+ *
+ * @note @a obj @b won't delete the swallowed object once it is
+ * deleted -- @a obj_swallow will get to an unparented state again.
+ *
+ * For more details on EDC @c SWALLOW parts, see @ref edcref "syntax
+ * reference".
+ * 
+ *
+ * @param[in] part The swallow part's name
+ * @param[in] obj_swallow The object to occupy that part
+ */
+EAPI Eina_Bool edje_object_part_swallow(Edje_Object *obj, const char *part, Evas_Object *obj_swallow);
+
+#endif
diff -Naur a/src/lib/efl/Efl.hh b/src/lib/efl/Efl.hh
--- a/src/lib/efl/Efl.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/Efl.hh	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,14 @@
+#ifndef EFL_CXX_EDJE_HH
+#define EFL_CXX_EDJE_HH
+
+#ifdef EFL_BETA_API_SUPPORT
+#include <efl_control.eo.hh>
+#include <efl_file.eo.hh>
+#include <efl_image.eo.hh>
+#include <efl_player.eo.hh>
+#include <efl_text.eo.hh>
+#include <efl_text_properties.eo.hh>
+#endif
+
+#endif
+
diff -Naur a/src/lib/efl/interfaces/efl_control.eo.c b/src/lib/efl/interfaces/efl_control.eo.c
--- a/src/lib/efl/interfaces/efl_control.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_control.eo.c	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,25 @@
+EOAPI EO_VOID_FUNC_BODYV(efl_control_priority_set, EO_FUNC_CALL(priority), int priority);
+EOAPI EO_FUNC_BODY(efl_control_priority_get, int, 0);
+EOAPI EO_VOID_FUNC_BODYV(efl_control_suspend_set, EO_FUNC_CALL(suspend), Eina_Bool suspend);
+EOAPI EO_FUNC_BODY(efl_control_suspend_get, Eina_Bool, 0);
+
+static Eo_Op_Description _efl_control_op_desc[] = {
+     EO_OP_FUNC(efl_control_priority_set, NULL, ""),
+     EO_OP_FUNC(efl_control_priority_get, NULL, ""),
+     EO_OP_FUNC(efl_control_suspend_set, NULL, ""),
+     EO_OP_FUNC(efl_control_suspend_get, NULL, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _efl_control_class_desc = {
+     EO_VERSION,
+     "Efl_Control",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_OPS(_efl_control_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(efl_control_interface_get, &_efl_control_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/efl/interfaces/efl_control.eo.h b/src/lib/efl/interfaces/efl_control.eo.h
--- a/src/lib/efl/interfaces/efl_control.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_control.eo.h	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,59 @@
+#ifndef _EFL_CONTROL_EO_H_
+#define _EFL_CONTROL_EO_H_
+
+#ifndef _EFL_CONTROL_EO_CLASS_TYPE
+#define _EFL_CONTROL_EO_CLASS_TYPE
+
+typedef Eo Efl_Control;
+
+#endif
+
+#ifndef _EFL_CONTROL_EO_TYPES
+#define _EFL_CONTROL_EO_TYPES
+
+
+#endif
+#define EFL_CONTROL_INTERFACE efl_control_interface_get()
+
+const Eo_Class *efl_control_interface_get(void) EINA_CONST;
+
+/**
+ *
+ * Control the priority of the object.
+ * 
+ *
+ * @param[in] priority The priority of the object
+ *
+ */
+EOAPI void  efl_control_priority_set(int priority);
+
+/**
+ *
+ * Control the priority of the object.
+ * 
+ *
+ *
+ */
+EOAPI int  efl_control_priority_get(void);
+
+/**
+ *
+ * Controls whether the object is suspended or not.
+ * 
+ *
+ * @param[in] suspend Controls whether the object is suspended or not.
+ *
+ */
+EOAPI void  efl_control_suspend_set(Eina_Bool suspend);
+
+/**
+ *
+ * Controls whether the object is suspended or not.
+ * 
+ *
+ *
+ */
+EOAPI Eina_Bool  efl_control_suspend_get(void);
+
+
+#endif
diff -Naur a/src/lib/efl/interfaces/efl_control.eo.hh b/src/lib/efl/interfaces/efl_control.eo.hh
--- a/src/lib/efl/interfaces/efl_control.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_control.eo.hh	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,249 @@
+#ifndef EFL_GENERATED_EFL_CONTROL_HH
+#define EFL_GENERATED_EFL_CONTROL_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "efl_control.eo.h"
+}
+
+
+namespace efl {
+
+struct control
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit control(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit control(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   control(control const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~control() {}
+
+   /// @param priority The priority of the object
+   ///
+   int priority_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_control_priority_get());
+      return _tmp_ret;
+   }
+
+   /// @param priority The priority of the object
+   ///
+   void priority_set(int priority_) const
+   {
+      eo_do(_eo_ptr(), ::efl_control_priority_set(priority_));
+   }
+
+   /// @param suspend Controls whether the object is suspended or not.
+   ///
+   bool suspend_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_control_suspend_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param suspend Controls whether the object is suspended or not.
+   ///
+   void suspend_set(bool suspend_) const
+   {
+      eo_do(_eo_ptr(), ::efl_control_suspend_set(efl::eolian::to_c(suspend_)));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EFL_CONTROL_INTERFACE);
+   }
+
+private:
+};
+} 
+
+template <typename T>
+int efl_control_priority_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->priority_get();
+}
+
+template <typename T>
+void efl_control_priority_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int priority_)
+{
+   static_cast<T*>(self->this_)->priority_set(priority_);
+}
+
+template <typename T>
+bool efl_control_suspend_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->suspend_get();
+}
+
+template <typename T>
+void efl_control_suspend_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool suspend_)
+{
+   static_cast<T*>(self->this_)->suspend_set(efl::eolian::to_cxx<bool>(suspend_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< efl::control >
+{
+   template <typename T>
+   struct type
+   {
+      virtual int priority_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_control_priority_get());
+            return _tmp_ret;
+      }
+
+      virtual void priority_set(int priority_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_control_priority_set(priority_));
+      }
+
+      virtual bool suspend_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_control_suspend_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void suspend_set(bool suspend_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_control_suspend_set(efl::eolian::to_c(suspend_)));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< efl::control >
+{
+   static const int value = 4;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<efl::control>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::efl_control_priority_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::efl_control_priority_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::efl_control_priority_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_control_priority_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::efl_control_suspend_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_control_suspend_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::efl_control_suspend_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_control_suspend_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< efl::control >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<efl::control, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< efl::control>
+{
+   template <typename U>
+   struct type
+   {
+      operator efl::control() const
+      {
+         return efl::control(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      int priority_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_control_priority_get());
+            return _tmp_ret;
+      }
+
+      void priority_set(int priority_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_control_priority_set(priority_));
+      }
+
+      bool suspend_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_control_suspend_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void suspend_set(bool suspend_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_control_suspend_set(efl::eolian::to_c(suspend_)));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<efl::control>)
+{
+   return (EFL_CONTROL_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EFL_CONTROL_HH
+
diff -Naur a/src/lib/efl/interfaces/efl_file.eo.c b/src/lib/efl/interfaces/efl_file.eo.c
--- a/src/lib/efl/interfaces/efl_file.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_file.eo.c	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,25 @@
+EOAPI EO_FUNC_BODYV(efl_file_set, Eina_Bool, 0, EO_FUNC_CALL(file, key), const char *file, const char *key);
+EOAPI EO_VOID_FUNC_BODYV(efl_file_get, EO_FUNC_CALL(file, key), const char **file, const char **key);
+EOAPI EO_FUNC_BODYV(efl_file_save, Eina_Bool, 0, EO_FUNC_CALL(file, key, flags), const char *file, const char *key, const char *flags);
+EOAPI EO_VOID_FUNC_BODY(efl_file_eject);
+
+static Eo_Op_Description _efl_file_op_desc[] = {
+     EO_OP_FUNC(efl_file_set, NULL, "Set the source file from where an image object must fetch the real"),
+     EO_OP_FUNC(efl_file_get, NULL, "Retrieve the source file from where an image object is to fetch the"),
+     EO_OP_FUNC(efl_file_save, NULL, "Save the given image object's contents to an (image) file."),
+     EO_OP_FUNC(efl_file_eject, NULL, "Eject the represented object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _efl_file_class_desc = {
+     EO_VERSION,
+     "Efl_File",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_OPS(_efl_file_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(efl_file_interface_get, &_efl_file_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/efl/interfaces/efl_file.eo.h b/src/lib/efl/interfaces/efl_file.eo.h
--- a/src/lib/efl/interfaces/efl_file.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_file.eo.h	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,107 @@
+#ifndef _EFL_FILE_EO_H_
+#define _EFL_FILE_EO_H_
+
+#ifndef _EFL_FILE_EO_CLASS_TYPE
+#define _EFL_FILE_EO_CLASS_TYPE
+
+typedef Eo Efl_File;
+
+#endif
+
+#ifndef _EFL_FILE_EO_TYPES
+#define _EFL_FILE_EO_TYPES
+
+
+#endif
+#define EFL_FILE_INTERFACE efl_file_interface_get()
+
+const Eo_Class *efl_file_interface_get(void) EINA_CONST;
+
+/**
+ *
+ * Set the source file from where an image object must fetch the real
+ * image data (it may be an Eet file, besides pure image ones).
+ *
+ * If the file supports multiple data stored in it (as Eet files do),
+ * you can specify the key to be used as the index of the image in
+ * this file.
+ *
+ * Example:
+ * @code
+ * img = evas_object_image_add(canvas);
+ * evas_object_image_file_set(img, "/path/to/img", NULL);
+ * err = evas_object_image_load_error_get(img);
+ * if (err != EVAS_LOAD_ERROR_NONE)
+ * {
+ * fprintf(stderr, "could not load image '%s'. error string is \"%s\"\n",
+ * valid_path, evas_load_error_str(err));
+ * }
+ * else
+ * {
+ * evas_object_image_fill_set(img, 0, 0, w, h);
+ * evas_object_resize(img, w, h);
+ * evas_object_show(img);
+ * }
+ * @endcode
+ *
+ * @param[in] file The image file path.
+ * @param[in] key The image key in @p file (if its an Eet one), or @c
+NULL, otherwise.
+ *
+ */
+EOAPI Eina_Bool  efl_file_set(const char *file, const char *key);
+
+/**
+ *
+ * Retrieve the source file from where an image object is to fetch the
+ * real image data (it may be an Eet file, besides pure image ones).
+ *
+ * You must @b not modify the strings on the returned pointers.
+ *
+ * @note Use @c NULL pointers on the file components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @param[out] file The image file path.
+ * @param[out] key The image key in @p file (if its an Eet one), or @c
+NULL, otherwise.
+ *
+ */
+EOAPI void  efl_file_get(const char **file, const char **key);
+
+/**
+ *
+ * Save the given image object's contents to an (image) file.
+ *
+ * The extension suffix on @p file will determine which <b>saver
+ * module</b> Evas is to use when saving, thus the final file's
+ * format. If the file supports multiple data stored in it (Eet ones),
+ * you can specify the key to be used as the index of the image in it.
+ *
+ * You can specify some flags when saving the image.  Currently
+ * acceptable flags are @c quality and @c compress. Eg.: @c
+ * "quality=100 compress=9"
+ * 
+ *
+ * @param[in] file The filename to be used to save the image (extension
+obligatory).
+ * @param[in] key The image key in the file (if an Eet one), or @c NULL,
+otherwise.
+ * @param[in] flags String containing the flags to be used (@c NULL for
+none).
+ *
+ */
+EOAPI Eina_Bool  efl_file_save(const char *file, const char *key, const char *flags);
+
+/**
+ *
+ * Eject the represented object.
+ *
+ * Get rid of and clean the pointed resource.
+ * 
+ *
+ *
+ */
+EOAPI void  efl_file_eject(void);
+
+
+#endif
diff -Naur a/src/lib/efl/interfaces/efl_file.eo.hh b/src/lib/efl/interfaces/efl_file.eo.hh
--- a/src/lib/efl/interfaces/efl_file.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_file.eo.hh	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,305 @@
+#ifndef EFL_GENERATED_EFL_FILE_HH
+#define EFL_GENERATED_EFL_FILE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "efl_file.eo.h"
+}
+
+#include <string>
+
+namespace efl {
+
+struct file
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit file(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit file(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   file(file const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~file() {}
+
+   /// @brief Retrieve the source file from where an image object is to fetch the
+   /// real image data (it may be an Eet file, besides pure image ones).
+   ///
+   /// You must @b not modify the strings on the returned pointers.
+   ///
+   /// @note Use @c NULL pointers on the file components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @param file The image file path.
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   void file_get(const char ** file_, const char ** key_) const
+   {
+      eo_do(_eo_ptr(), ::efl_file_get(file_, key_));
+   }
+
+   /// @brief Set the source file from where an image object must fetch the real
+   /// image data (it may be an Eet file, besides pure image ones).
+   ///
+   /// If the file supports multiple data stored in it (as Eet files do),
+   /// you can specify the key to be used as the index of the image in
+   /// this file.
+   ///
+   /// Example:
+   /// @code
+   /// img = evas_object_image_add(canvas);
+   /// evas_object_image_file_set(img, "/path/to/img", NULL);
+   /// err = evas_object_image_load_error_get(img);
+   /// if (err != EVAS_LOAD_ERROR_NONE)
+   /// {
+   /// fprintf(stderr, "could not load image '%s'. error string is \"%s\"\n",
+   /// valid_path, evas_load_error_str(err));
+   /// }
+   /// else
+   /// {
+   /// evas_object_image_fill_set(img, 0, 0, w, h);
+   /// evas_object_resize(img, w, h);
+   /// evas_object_show(img);
+   /// }
+   /// @endcode
+   ///
+   /// @param file The image file path.
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   bool file_set(std::string file_, std::string key_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Save the given image object's contents to an (image) file.
+   ///
+   /// The extension suffix on @p file will determine which <b>saver
+   /// module</b> Evas is to use when saving, thus the final file's
+   /// format. If the file supports multiple data stored in it (Eet ones),
+   /// you can specify the key to be used as the index of the image in it.
+   ///
+   /// You can specify some flags when saving the image.  Currently
+   /// acceptable flags are @c quality and @c compress. Eg.: @c
+   /// "quality=100 compress=9"
+   ///
+   /// @param file The filename to be used to save the image (extension
+   /// obligatory).
+   /// @param key The image key in the file (if an Eet one), or @c NULL,
+   /// otherwise.
+   /// @param flags String containing the flags to be used (@c NULL for
+   /// none).
+   ///
+   bool save(std::string file_, std::string key_, std::string flags_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_file_save(efl::eolian::to_c(file_), efl::eolian::to_c(key_), efl::eolian::to_c(flags_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Eject the represented object.
+   ///
+   /// Get rid of and clean the pointed resource.
+   ///
+   void eject() const
+   {
+      eo_do(_eo_ptr(), ::efl_file_eject());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EFL_FILE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+template <typename T>
+void efl_file_file_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char ** file_, const char ** key_)
+{
+   static_cast<T*>(self->this_)->file_get(file_, key_);
+}
+
+template <typename T>
+bool efl_file_file_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * file_, const char * key_)
+{
+   return static_cast<T*>(self->this_)->file_set(efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool efl_file_save_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * file_, const char * key_, const char * flags_)
+{
+   return static_cast<T*>(self->this_)->save(efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(flags_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void efl_file_eject_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->eject();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< efl::file >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void file_get(const char ** file_, const char ** key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_file_get(file_, key_));
+      }
+
+      virtual bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool save(std::string file_, std::string key_, std::string flags_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_file_save(efl::eolian::to_c(file_), efl::eolian::to_c(key_), efl::eolian::to_c(flags_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void eject()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_file_eject());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< efl::file >
+{
+   static const int value = 4;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<efl::file>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::efl_file_file_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::efl_file_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::efl_file_file_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_file_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::efl_file_save_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_file_save);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::efl_file_eject_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_file_eject);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< efl::file >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<efl::file, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< efl::file>
+{
+   template <typename U>
+   struct type
+   {
+      operator efl::file() const
+      {
+         return efl::file(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void file_get(const char ** file_, const char ** key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_file_get(file_, key_));
+      }
+
+      bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool save(std::string file_, std::string key_, std::string flags_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_file_save(efl::eolian::to_c(file_), efl::eolian::to_c(key_), efl::eolian::to_c(flags_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void eject()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_file_eject());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<efl::file>)
+{
+   return (EFL_FILE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EFL_FILE_HH
+
diff -Naur a/src/lib/efl/interfaces/efl_image.eo.c b/src/lib/efl/interfaces/efl_image.eo.c
--- a/src/lib/efl/interfaces/efl_image.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_image.eo.c	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,29 @@
+EOAPI EO_FUNC_BODY(efl_image_animated_get, Eina_Bool, 0);
+EOAPI EO_VOID_FUNC_BODYV(efl_image_load_size_set, EO_FUNC_CALL(w, h), int w, int h);
+EOAPI EO_VOID_FUNC_BODYV(efl_image_load_size_get, EO_FUNC_CALL(w, h), int *w, int *h);
+EOAPI EO_VOID_FUNC_BODYV(efl_image_smooth_scale_set, EO_FUNC_CALL(smooth_scale), Eina_Bool smooth_scale);
+EOAPI EO_FUNC_BODY(efl_image_smooth_scale_get, Eina_Bool, 0);
+EOAPI EO_FUNC_BODY(efl_image_ratio_get, double, 0);
+
+static Eo_Op_Description _efl_image_op_desc[] = {
+     EO_OP_FUNC(efl_image_animated_get, NULL, "Check if an image  can be animated (have multiple frames)"),
+     EO_OP_FUNC(efl_image_load_size_set, NULL, "Set the loading size of an image. The image will be loaded into memory as if it was"),
+     EO_OP_FUNC(efl_image_load_size_get, NULL, ""),
+     EO_OP_FUNC(efl_image_smooth_scale_set, NULL, "Sets whether to use high-quality image scaling algorithm on the"),
+     EO_OP_FUNC(efl_image_smooth_scale_get, NULL, "Retrieves whether the given image is using high-quality"),
+     EO_OP_FUNC(efl_image_ratio_get, NULL, "The native ration of the image object"),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _efl_image_class_desc = {
+     EO_VERSION,
+     "Efl_Image",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_OPS(_efl_image_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(efl_image_interface_get, &_efl_image_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/efl/interfaces/efl_image.eo.h b/src/lib/efl/interfaces/efl_image.eo.h
--- a/src/lib/efl/interfaces/efl_image.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_image.eo.h	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,87 @@
+#ifndef _EFL_IMAGE_EO_H_
+#define _EFL_IMAGE_EO_H_
+
+#ifndef _EFL_IMAGE_EO_CLASS_TYPE
+#define _EFL_IMAGE_EO_CLASS_TYPE
+
+typedef Eo Efl_Image;
+
+#endif
+
+#ifndef _EFL_IMAGE_EO_TYPES
+#define _EFL_IMAGE_EO_TYPES
+
+
+#endif
+#define EFL_IMAGE_INTERFACE efl_image_interface_get()
+
+const Eo_Class *efl_image_interface_get(void) EINA_CONST;
+
+/**
+ *
+ * Check if an image  can be animated (have multiple frames)
+ *
+ * @return whether the image support animation
+ *
+ *
+ */
+EOAPI Eina_Bool  efl_image_animated_get(void);
+
+/**
+ *
+ * Set the loading size of an image. The image will be loaded into memory as if it was
+ * the set size instead of the original size. This can save a lot of memory, and is
+ * important for scalable types like svg.
+ *
+ * @param[in] w The new width of the image's load size.
+ * @param[in] h The new height of the image's load size.
+ *
+ */
+EOAPI void  efl_image_load_size_set(int w, int h);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[out] w The new width of the image's load size.
+ * @param[out] h The new height of the image's load size.
+ *
+ */
+EOAPI void  efl_image_load_size_get(int *w, int *h);
+
+/**
+ *
+ * Sets whether to use high-quality image scaling algorithm on the
+ * given image.
+ *
+ * When enabled, a higher quality image scaling algorithm is used when
+ * scaling images to sizes other than the source image's original
+ * one. This gives better results but is more computationally
+ * expensive.
+ *
+ * @param[in] smooth_scale Whether to use smooth scale or not.
+ *
+ */
+EOAPI void  efl_image_smooth_scale_set(Eina_Bool smooth_scale);
+
+/**
+ *
+ * Retrieves whether the given image is using high-quality
+ * image scaling algorithm.
+ *
+ * @return Whether smooth scale is being used.
+ *
+ *
+ */
+EOAPI Eina_Bool  efl_image_smooth_scale_get(void);
+
+/**
+ *
+ * The native ration of the image object
+ *
+ *
+ */
+EOAPI double  efl_image_ratio_get(void);
+
+
+#endif
diff -Naur a/src/lib/efl/interfaces/efl_image.eo.hh b/src/lib/efl/interfaces/efl_image.eo.hh
--- a/src/lib/efl/interfaces/efl_image.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_image.eo.hh	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,342 @@
+#ifndef EFL_GENERATED_EFL_IMAGE_HH
+#define EFL_GENERATED_EFL_IMAGE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "efl_image.eo.h"
+}
+
+
+namespace efl {
+
+struct image
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit image(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit image(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   image(image const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~image() {}
+
+   /// @brief Check if an image  can be animated (have multiple frames)
+   ///
+   /// @return whether the image support animation
+   ///
+   /// @param is_animated If it's animated or not.
+   ///
+   bool animated_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_image_animated_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param w The new width of the image's load size.
+   /// @param h The new height of the image's load size.
+   ///
+   void load_size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::efl_image_load_size_get(w_, h_));
+   }
+
+   /// @brief Set the loading size of an image. The image will be loaded into memory as if it was
+   /// the set size instead of the original size. This can save a lot of memory, and is
+   /// important for scalable types like svg.
+   ///
+   /// @param w The new width of the image's load size.
+   /// @param h The new height of the image's load size.
+   ///
+   void load_size_set(int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::efl_image_load_size_set(w_, h_));
+   }
+
+   /// @brief Retrieves whether the given image is using high-quality
+   /// image scaling algorithm.
+   ///
+   /// @return Whether smooth scale is being used.
+   ///
+   /// @param smooth_scale Whether to use smooth scale or not.
+   ///
+   bool smooth_scale_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_image_smooth_scale_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets whether to use high-quality image scaling algorithm on the
+   /// given image.
+   ///
+   /// When enabled, a higher quality image scaling algorithm is used when
+   /// scaling images to sizes other than the source image's original
+   /// one. This gives better results but is more computationally
+   /// expensive.
+   ///
+   /// @param smooth_scale Whether to use smooth scale or not.
+   ///
+   void smooth_scale_set(bool smooth_scale_) const
+   {
+      eo_do(_eo_ptr(), ::efl_image_smooth_scale_set(efl::eolian::to_c(smooth_scale_)));
+   }
+
+   /// @brief The native ration of the image object
+   ///
+   /// @param ratio The image's ratio
+   ///
+   double ratio_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_image_ratio_get());
+      return _tmp_ret;
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EFL_IMAGE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+template <typename T>
+bool efl_image_animated_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->animated_get();
+}
+
+template <typename T>
+void efl_image_load_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->load_size_get(w_, h_);
+}
+
+template <typename T>
+void efl_image_load_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->load_size_set(w_, h_);
+}
+
+template <typename T>
+bool efl_image_smooth_scale_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smooth_scale_get();
+}
+
+template <typename T>
+void efl_image_smooth_scale_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool smooth_scale_)
+{
+   static_cast<T*>(self->this_)->smooth_scale_set(efl::eolian::to_cxx<bool>(smooth_scale_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+double efl_image_ratio_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->ratio_get();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< efl::image >
+{
+   template <typename T>
+   struct type
+   {
+      virtual bool animated_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_image_animated_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void load_size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_image_load_size_get(w_, h_));
+      }
+
+      virtual void load_size_set(int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_image_load_size_set(w_, h_));
+      }
+
+      virtual bool smooth_scale_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_image_smooth_scale_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void smooth_scale_set(bool smooth_scale_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_image_smooth_scale_set(efl::eolian::to_c(smooth_scale_)));
+      }
+
+      virtual double ratio_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_image_ratio_get());
+            return _tmp_ret;
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< efl::image >
+{
+   static const int value = 6;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<efl::image>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::efl_image_animated_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::efl_image_animated_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::efl_image_load_size_get_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_image_load_size_get);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::efl_image_load_size_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_image_load_size_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::efl_image_smooth_scale_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_image_smooth_scale_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::efl_image_smooth_scale_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::efl_image_smooth_scale_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::efl_image_ratio_get_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::efl_image_ratio_get);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< efl::image >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<efl::image, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< efl::image>
+{
+   template <typename U>
+   struct type
+   {
+      operator efl::image() const
+      {
+         return efl::image(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      bool animated_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_image_animated_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void load_size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_image_load_size_get(w_, h_));
+      }
+
+      void load_size_set(int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_image_load_size_set(w_, h_));
+      }
+
+      bool smooth_scale_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_image_smooth_scale_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void smooth_scale_set(bool smooth_scale_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_image_smooth_scale_set(efl::eolian::to_c(smooth_scale_)));
+      }
+
+      double ratio_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_image_ratio_get());
+            return _tmp_ret;
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<efl::image>)
+{
+   return (EFL_IMAGE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EFL_IMAGE_HH
+
diff -Naur a/src/lib/efl/interfaces/efl_player.eo.c b/src/lib/efl/interfaces/efl_player.eo.c
--- a/src/lib/efl/interfaces/efl_player.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_player.eo.c	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,39 @@
+EOAPI EO_VOID_FUNC_BODYV(efl_player_play_set, EO_FUNC_CALL(play), Eina_Bool play);
+EOAPI EO_FUNC_BODY(efl_player_play_get, Eina_Bool, 0);
+EOAPI EO_VOID_FUNC_BODYV(efl_player_position_set, EO_FUNC_CALL(second), double second);
+EOAPI EO_FUNC_BODY(efl_player_position_get, double, 0);
+EOAPI EO_FUNC_BODY(efl_player_progress_get, double, 0);
+EOAPI EO_VOID_FUNC_BODYV(efl_player_play_speed_set, EO_FUNC_CALL(speed), double speed);
+EOAPI EO_FUNC_BODY(efl_player_play_speed_get, double, 0);
+EOAPI EO_VOID_FUNC_BODYV(efl_player_audio_volume_set, EO_FUNC_CALL(volume), double volume);
+EOAPI EO_FUNC_BODY(efl_player_audio_volume_get, double, 0);
+EOAPI EO_VOID_FUNC_BODYV(efl_player_audio_mute_set, EO_FUNC_CALL(mute), Eina_Bool mute);
+EOAPI EO_FUNC_BODY(efl_player_audio_mute_get, Eina_Bool, 0);
+
+static Eo_Op_Description _efl_player_op_desc[] = {
+     EO_OP_FUNC(efl_player_play_set, NULL, "* @brief Set play/pause state of the media file."),
+     EO_OP_FUNC(efl_player_play_get, NULL, "* @brief Get play/pause state of the media file."),
+     EO_OP_FUNC(efl_player_position_set, NULL, "* @brief Set the position in the media file."),
+     EO_OP_FUNC(efl_player_position_get, NULL, "* @brief Get the position in the media file."),
+     EO_OP_FUNC(efl_player_progress_get, NULL, "* @brief Get how much of the file has been played."),
+     EO_OP_FUNC(efl_player_play_speed_set, NULL, ""),
+     EO_OP_FUNC(efl_player_play_speed_get, NULL, ""),
+     EO_OP_FUNC(efl_player_audio_volume_set, NULL, ""),
+     EO_OP_FUNC(efl_player_audio_volume_get, NULL, ""),
+     EO_OP_FUNC(efl_player_audio_mute_set, NULL, ""),
+     EO_OP_FUNC(efl_player_audio_mute_get, NULL, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _efl_player_class_desc = {
+     EO_VERSION,
+     "Efl_Player",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_OPS(_efl_player_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(efl_player_interface_get, &_efl_player_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/efl/interfaces/efl_player.eo.h b/src/lib/efl/interfaces/efl_player.eo.h
--- a/src/lib/efl/interfaces/efl_player.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_player.eo.h	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,133 @@
+#ifndef _EFL_PLAYER_EO_H_
+#define _EFL_PLAYER_EO_H_
+
+#ifndef _EFL_PLAYER_EO_CLASS_TYPE
+#define _EFL_PLAYER_EO_CLASS_TYPE
+
+typedef Eo Efl_Player;
+
+#endif
+
+#ifndef _EFL_PLAYER_EO_TYPES
+#define _EFL_PLAYER_EO_TYPES
+
+
+#endif
+#define EFL_PLAYER_INTERFACE efl_player_interface_get()
+
+const Eo_Class *efl_player_interface_get(void) EINA_CONST;
+
+/**
+ *
+ * * @brief Set play/pause state of the media file.
+ * *
+ * * This functions sets the currently playing status of the video. Using this
+ * * function to play or pause the video doesn't alter it's current position.
+ *
+ * @param[in] play true if playing, false otherwise.
+ *
+ */
+EOAPI void  efl_player_play_set(Eina_Bool play);
+
+/**
+ *
+ * * @brief Get play/pause state of the media file.
+ *
+ *
+ */
+EOAPI Eina_Bool  efl_player_play_get(void);
+
+/**
+ *
+ * * @brief Set the position in the media file.
+ * *
+ * * @param obj The emotion object whose position will be changed.
+ * * @param sec The position(in seconds) to which the media file will be set.
+ * *
+ * * This functions sets the current position of the media file to @p sec, this
+ * * only works on seekable streams. Setting the position doesn't change the
+ * * playing state of the media file.
+ *
+ * @param[in] second The position (in seconds).
+ *
+ */
+EOAPI void  efl_player_position_set(double second);
+
+/**
+ *
+ * * @brief Get the position in the media file.
+ * *
+ * * @param obj The emotion object from which the position will be retrieved.
+ * * @return The position of the media file.
+ * *
+ * * The position is returned as the number of seconds since the beginning of the
+ * * media file.
+ *
+ *
+ */
+EOAPI double  efl_player_position_get(void);
+
+/**
+ *
+ * * @brief Get how much of the file has been played.
+ * *
+ * * This function gets the progress in playing the file, the return value is in
+ * * the [0, 1] range.
+ *
+ *
+ */
+EOAPI double  efl_player_progress_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] speed The play speed in the [0, infinity) range.
+ *
+ */
+EOAPI void  efl_player_play_speed_set(double speed);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI double  efl_player_play_speed_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] volume The volume level
+ *
+ */
+EOAPI void  efl_player_audio_volume_set(double volume);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI double  efl_player_audio_volume_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] mute The mute state. True or false.
+ *
+ */
+EOAPI void  efl_player_audio_mute_set(Eina_Bool mute);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  efl_player_audio_mute_get(void);
+
+
+#endif
diff -Naur a/src/lib/efl/interfaces/efl_player.eo.hh b/src/lib/efl/interfaces/efl_player.eo.hh
--- a/src/lib/efl/interfaces/efl_player.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_player.eo.hh	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,519 @@
+#ifndef EFL_GENERATED_EFL_PLAYER_HH
+#define EFL_GENERATED_EFL_PLAYER_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "efl_player.eo.h"
+}
+
+
+namespace efl {
+
+struct player
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit player(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit player(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   player(player const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~player() {}
+
+   /// @brief * @brief Get play/pause state of the media file.
+   ///
+   /// @param play true if playing, false otherwise.
+   ///
+   bool play_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_player_play_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief * @brief Set play/pause state of the media file.
+   /// *
+   /// * This functions sets the currently playing status of the video. Using this
+   /// * function to play or pause the video doesn't alter it's current position.
+   ///
+   /// @param play true if playing, false otherwise.
+   ///
+   void play_set(bool play_) const
+   {
+      eo_do(_eo_ptr(), ::efl_player_play_set(efl::eolian::to_c(play_)));
+   }
+
+   /// @brief * @brief Get the position in the media file.
+   /// *
+   /// * @param obj The emotion object from which the position will be retrieved.
+   /// * @return The position of the media file.
+   /// *
+   /// * The position is returned as the number of seconds since the beginning of the
+   /// * media file.
+   ///
+   /// @param second The position (in seconds).
+   ///
+   double position_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_player_position_get());
+      return _tmp_ret;
+   }
+
+   /// @brief * @brief Set the position in the media file.
+   /// *
+   /// * @param obj The emotion object whose position will be changed.
+   /// * @param sec The position(in seconds) to which the media file will be set.
+   /// *
+   /// * This functions sets the current position of the media file to @p sec, this
+   /// * only works on seekable streams. Setting the position doesn't change the
+   /// * playing state of the media file.
+   ///
+   /// @param second The position (in seconds).
+   ///
+   void position_set(double second_) const
+   {
+      eo_do(_eo_ptr(), ::efl_player_position_set(second_));
+   }
+
+   /// @brief * @brief Get how much of the file has been played.
+   /// *
+   /// * This function gets the progress in playing the file, the return value is in
+   /// * the [0, 1] range.
+   ///
+   /// @param progress The progress within the [0, 1] range.
+   ///
+   double progress_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_player_progress_get());
+      return _tmp_ret;
+   }
+
+   /// @param speed The play speed in the [0, infinity) range.
+   ///
+   double play_speed_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_player_play_speed_get());
+      return _tmp_ret;
+   }
+
+   /// @param speed The play speed in the [0, infinity) range.
+   ///
+   void play_speed_set(double speed_) const
+   {
+      eo_do(_eo_ptr(), ::efl_player_play_speed_set(speed_));
+   }
+
+   /// @param volume The volume level
+   ///
+   double audio_volume_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_player_audio_volume_get());
+      return _tmp_ret;
+   }
+
+   /// @param volume The volume level
+   ///
+   void audio_volume_set(double volume_) const
+   {
+      eo_do(_eo_ptr(), ::efl_player_audio_volume_set(volume_));
+   }
+
+   /// @param mute The mute state. True or false.
+   ///
+   bool audio_mute_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_player_audio_mute_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param mute The mute state. True or false.
+   ///
+   void audio_mute_set(bool mute_) const
+   {
+      eo_do(_eo_ptr(), ::efl_player_audio_mute_set(efl::eolian::to_c(mute_)));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EFL_PLAYER_INTERFACE);
+   }
+
+private:
+};
+} 
+
+template <typename T>
+bool efl_player_play_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->play_get();
+}
+
+template <typename T>
+void efl_player_play_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool play_)
+{
+   static_cast<T*>(self->this_)->play_set(efl::eolian::to_cxx<bool>(play_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+double efl_player_position_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->position_get();
+}
+
+template <typename T>
+void efl_player_position_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double second_)
+{
+   static_cast<T*>(self->this_)->position_set(second_);
+}
+
+template <typename T>
+double efl_player_progress_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->progress_get();
+}
+
+template <typename T>
+double efl_player_play_speed_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->play_speed_get();
+}
+
+template <typename T>
+void efl_player_play_speed_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double speed_)
+{
+   static_cast<T*>(self->this_)->play_speed_set(speed_);
+}
+
+template <typename T>
+double efl_player_audio_volume_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->audio_volume_get();
+}
+
+template <typename T>
+void efl_player_audio_volume_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double volume_)
+{
+   static_cast<T*>(self->this_)->audio_volume_set(volume_);
+}
+
+template <typename T>
+bool efl_player_audio_mute_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->audio_mute_get();
+}
+
+template <typename T>
+void efl_player_audio_mute_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool mute_)
+{
+   static_cast<T*>(self->this_)->audio_mute_set(efl::eolian::to_cxx<bool>(mute_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< efl::player >
+{
+   template <typename T>
+   struct type
+   {
+      virtual bool play_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_player_play_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void play_set(bool play_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_player_play_set(efl::eolian::to_c(play_)));
+      }
+
+      virtual double position_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_player_position_get());
+            return _tmp_ret;
+      }
+
+      virtual void position_set(double second_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_player_position_set(second_));
+      }
+
+      virtual double progress_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_player_progress_get());
+            return _tmp_ret;
+      }
+
+      virtual double play_speed_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_player_play_speed_get());
+            return _tmp_ret;
+      }
+
+      virtual void play_speed_set(double speed_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_player_play_speed_set(speed_));
+      }
+
+      virtual double audio_volume_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_player_audio_volume_get());
+            return _tmp_ret;
+      }
+
+      virtual void audio_volume_set(double volume_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_player_audio_volume_set(volume_));
+      }
+
+      virtual bool audio_mute_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_player_audio_mute_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void audio_mute_set(bool mute_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_player_audio_mute_set(efl::eolian::to_c(mute_)));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< efl::player >
+{
+   static const int value = 11;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<efl::player>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::efl_player_play_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::efl_player_play_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::efl_player_play_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_player_play_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::efl_player_position_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_player_position_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::efl_player_position_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_player_position_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::efl_player_progress_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::efl_player_progress_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::efl_player_play_speed_get_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::efl_player_play_speed_get);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::efl_player_play_speed_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::efl_player_play_speed_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::efl_player_audio_volume_get_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::efl_player_audio_volume_get);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::efl_player_audio_volume_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::efl_player_audio_volume_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::efl_player_audio_mute_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::efl_player_audio_mute_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::efl_player_audio_mute_set_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::efl_player_audio_mute_set);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< efl::player >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<efl::player, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< efl::player>
+{
+   template <typename U>
+   struct type
+   {
+      operator efl::player() const
+      {
+         return efl::player(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      bool play_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_player_play_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void play_set(bool play_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_player_play_set(efl::eolian::to_c(play_)));
+      }
+
+      double position_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_player_position_get());
+            return _tmp_ret;
+      }
+
+      void position_set(double second_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_player_position_set(second_));
+      }
+
+      double progress_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_player_progress_get());
+            return _tmp_ret;
+      }
+
+      double play_speed_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_player_play_speed_get());
+            return _tmp_ret;
+      }
+
+      void play_speed_set(double speed_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_player_play_speed_set(speed_));
+      }
+
+      double audio_volume_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_player_audio_volume_get());
+            return _tmp_ret;
+      }
+
+      void audio_volume_set(double volume_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_player_audio_volume_set(volume_));
+      }
+
+      bool audio_mute_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_player_audio_mute_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void audio_mute_set(bool mute_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_player_audio_mute_set(efl::eolian::to_c(mute_)));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<efl::player>)
+{
+   return (EFL_PLAYER_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EFL_PLAYER_HH
+
diff -Naur a/src/lib/efl/interfaces/efl_text.eo.c b/src/lib/efl/interfaces/efl_text.eo.c
--- a/src/lib/efl/interfaces/efl_text.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_text.eo.c	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,21 @@
+EOAPI EO_VOID_FUNC_BODYV(efl_text_set, EO_FUNC_CALL(text), const char *text);
+EOAPI EO_FUNC_BODY(efl_text_get, const char *, 0);
+
+static Eo_Op_Description _efl_text_op_desc[] = {
+     EO_OP_FUNC(efl_text_set, NULL, "Sets the text string to be displayed by the given text object."),
+     EO_OP_FUNC(efl_text_get, NULL, "Retrieves the text string currently being displayed by the given"),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _efl_text_class_desc = {
+     EO_VERSION,
+     "Efl_Text",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_OPS(_efl_text_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(efl_text_interface_get, &_efl_text_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/efl/interfaces/efl_text.eo.h b/src/lib/efl/interfaces/efl_text.eo.h
--- a/src/lib/efl/interfaces/efl_text.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_text.eo.h	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,47 @@
+#ifndef _EFL_TEXT_EO_H_
+#define _EFL_TEXT_EO_H_
+
+#ifndef _EFL_TEXT_EO_CLASS_TYPE
+#define _EFL_TEXT_EO_CLASS_TYPE
+
+typedef Eo Efl_Text;
+
+#endif
+
+#ifndef _EFL_TEXT_EO_TYPES
+#define _EFL_TEXT_EO_TYPES
+
+
+#endif
+#define EFL_TEXT_INTERFACE efl_text_interface_get()
+
+const Eo_Class *efl_text_interface_get(void) EINA_CONST;
+
+/**
+ *
+ * Sets the text string to be displayed by the given text object.
+ *
+ * @see evas_object_text_text_get()
+ *
+ * @param[in] text Text string to display on it.
+ *
+ */
+EOAPI void  efl_text_set(const char *text);
+
+/**
+ *
+ * Retrieves the text string currently being displayed by the given
+ * text object.
+ *
+ * @return The text string currently being displayed on it.
+ *
+ * @note Do not free() the return value.
+ *
+ * @see evas_object_text_text_set()
+ *
+ *
+ */
+EOAPI const char * efl_text_get(void);
+
+
+#endif
diff -Naur a/src/lib/efl/interfaces/efl_text.eo.hh b/src/lib/efl/interfaces/efl_text.eo.hh
--- a/src/lib/efl/interfaces/efl_text.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_text.eo.hh	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,195 @@
+#ifndef EFL_GENERATED_EFL_TEXT_HH
+#define EFL_GENERATED_EFL_TEXT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "efl_text.eo.h"
+}
+
+#include <string>
+
+namespace efl {
+
+struct text
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit text(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit text(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   text(text const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~text() {}
+
+   /// @brief Retrieves the text string currently being displayed by the given
+   /// text object.
+   ///
+   /// @return The text string currently being displayed on it.
+   ///
+   /// @note Do not free() the return value.
+   ///
+   /// @see evas_object_text_text_set()
+   ///
+   /// @param text Text string to display on it.
+   ///
+   std::string text_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_text_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets the text string to be displayed by the given text object.
+   ///
+   /// @see evas_object_text_text_get()
+   ///
+   /// @param text Text string to display on it.
+   ///
+   void text_set(std::string text_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_set(efl::eolian::to_c(text_)));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EFL_TEXT_INTERFACE);
+   }
+
+private:
+};
+} 
+
+template <typename T>
+std::string efl_text_text_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->text_get();
+}
+
+template <typename T>
+void efl_text_text_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * text_)
+{
+   static_cast<T*>(self->this_)->text_set(efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< efl::text >
+{
+   template <typename T>
+   struct type
+   {
+      virtual std::string text_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_text_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void text_set(std::string text_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_set(efl::eolian::to_c(text_)));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< efl::text >
+{
+   static const int value = 2;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<efl::text>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::efl_text_text_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::efl_text_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::efl_text_text_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_text_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< efl::text >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<efl::text, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< efl::text>
+{
+   template <typename U>
+   struct type
+   {
+      operator efl::text() const
+      {
+         return efl::text(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      std::string text_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_text_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void text_set(std::string text_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_set(efl::eolian::to_c(text_)));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<efl::text>)
+{
+   return (EFL_TEXT_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EFL_TEXT_HH
+
diff -Naur a/src/lib/efl/interfaces/efl_text_properties.eo.c b/src/lib/efl/interfaces/efl_text_properties.eo.c
--- a/src/lib/efl/interfaces/efl_text_properties.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_text_properties.eo.c	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,25 @@
+EOAPI EO_VOID_FUNC_BODYV(efl_text_properties_font_set, EO_FUNC_CALL(font, size), const char *font, Efl_Font_Size size);
+EOAPI EO_VOID_FUNC_BODYV(efl_text_properties_font_get, EO_FUNC_CALL(font, size), const char **font, Efl_Font_Size *size);
+EOAPI EO_VOID_FUNC_BODYV(efl_text_properties_font_source_set, EO_FUNC_CALL(font_source), const char *font_source);
+EOAPI EO_FUNC_BODY(efl_text_properties_font_source_get, const char *, 0);
+
+static Eo_Op_Description _efl_text_properties_op_desc[] = {
+     EO_OP_FUNC(efl_text_properties_font_set, NULL, "Set the font family or filename, and size on a given text object."),
+     EO_OP_FUNC(efl_text_properties_font_get, NULL, "Retrieve the font family and size in use on a given text object."),
+     EO_OP_FUNC(efl_text_properties_font_source_set, NULL, "Set the font (source) file to be used on a given text object."),
+     EO_OP_FUNC(efl_text_properties_font_source_get, NULL, "Get the font file's path which is being used on a given text"),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _efl_text_properties_class_desc = {
+     EO_VERSION,
+     "Efl_Text_Properties",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_OPS(_efl_text_properties_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(efl_text_properties_interface_get, &_efl_text_properties_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/efl/interfaces/efl_text_properties.eo.h b/src/lib/efl/interfaces/efl_text_properties.eo.h
--- a/src/lib/efl/interfaces/efl_text_properties.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_text_properties.eo.h	2014-11-27 00:57:33.403712301 +0200
@@ -0,0 +1,87 @@
+#ifndef _EFL_TEXT_PROPERTIES_EO_H_
+#define _EFL_TEXT_PROPERTIES_EO_H_
+
+#ifndef _EFL_TEXT_PROPERTIES_EO_CLASS_TYPE
+#define _EFL_TEXT_PROPERTIES_EO_CLASS_TYPE
+
+typedef Eo Efl_Text_Properties;
+
+#endif
+
+#ifndef _EFL_TEXT_PROPERTIES_EO_TYPES
+#define _EFL_TEXT_PROPERTIES_EO_TYPES
+
+typedef int Efl_Font_Size;
+
+
+#endif
+#define EFL_TEXT_PROPERTIES_INTERFACE efl_text_properties_interface_get()
+
+const Eo_Class *efl_text_properties_interface_get(void) EINA_CONST;
+
+/**
+ *
+ * Set the font family or filename, and size on a given text object.
+ *
+ * This function allows the font name and size of a text object to be
+ * set. The @p font string has to follow fontconfig's convention on
+ * naming fonts, as it's the underlying library used to query system
+ * fonts by Evas (see the @c fc-list command's output, on your system,
+ * to get an idea). Alternatively, one can use a full path to a font file.
+ *
+ * @see evas_object_text_font_get()
+ * @see evas_object_text_font_source_set()
+ *
+ * @param[in] font The font family name or filename.
+ * @param[in] size The font size, in points.
+ *
+ */
+EOAPI void  efl_text_properties_font_set(const char *font, Efl_Font_Size size);
+
+/**
+ *
+ * Retrieve the font family and size in use on a given text object.
+ *
+ * This function allows the font name and size of a text object to be
+ * queried. Be aware that the font name string is still owned by Evas
+ * and should @b not have free() called on it by the caller of the
+ * function.
+ *
+ * @see evas_object_text_font_set()
+ *
+ * @param[out] font The font family name or filename.
+ * @param[out] size The font size, in points.
+ *
+ */
+EOAPI void  efl_text_properties_font_get(const char **font, Efl_Font_Size *size);
+
+/**
+ *
+ * Set the font (source) file to be used on a given text object.
+ *
+ * This function allows the font file to be explicitly set for a given
+ * text object, overriding system lookup, which will first occur in
+ * the given file's contents.
+ *
+ * @see evas_object_text_font_get()
+ *
+ * @param[in] font_source The font file's path.
+ *
+ */
+EOAPI void  efl_text_properties_font_source_set(const char *font_source);
+
+/**
+ *
+ * Get the font file's path which is being used on a given text
+ * object.
+ *
+ * @return The font file's path.
+ *
+ * @see evas_object_text_font_get() for more details
+ *
+ *
+ */
+EOAPI const char * efl_text_properties_font_source_get(void);
+
+
+#endif
diff -Naur a/src/lib/efl/interfaces/efl_text_properties.eo.hh b/src/lib/efl/interfaces/efl_text_properties.eo.hh
--- a/src/lib/efl/interfaces/efl_text_properties.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/efl/interfaces/efl_text_properties.eo.hh	2014-11-27 00:57:33.407045708 +0200
@@ -0,0 +1,281 @@
+#ifndef EFL_GENERATED_EFL_TEXT_PROPERTIES_HH
+#define EFL_GENERATED_EFL_TEXT_PROPERTIES_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "efl_text_properties.eo.h"
+}
+
+#include <string>
+
+namespace efl {
+
+struct text_properties
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit text_properties(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit text_properties(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   text_properties(text_properties const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~text_properties() {}
+
+   /// @brief Retrieve the font family and size in use on a given text object.
+   ///
+   /// This function allows the font name and size of a text object to be
+   /// queried. Be aware that the font name string is still owned by Evas
+   /// and should @b not have free() called on it by the caller of the
+   /// function.
+   ///
+   /// @see evas_object_text_font_set()
+   ///
+   /// @param font The font family name or filename.
+   /// @param size The font size, in points.
+   ///
+   void font_get(const char ** font_, Efl_Font_Size* size_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_get(font_, size_));
+   }
+
+   /// @brief Set the font family or filename, and size on a given text object.
+   ///
+   /// This function allows the font name and size of a text object to be
+   /// set. The @p font string has to follow fontconfig's convention on
+   /// naming fonts, as it's the underlying library used to query system
+   /// fonts by Evas (see the @c fc-list command's output, on your system,
+   /// to get an idea). Alternatively, one can use a full path to a font file.
+   ///
+   /// @see evas_object_text_font_get()
+   /// @see evas_object_text_font_source_set()
+   ///
+   /// @param font The font family name or filename.
+   /// @param size The font size, in points.
+   ///
+   void font_set(std::string font_, Efl_Font_Size size_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+   }
+
+   /// @brief Get the font file's path which is being used on a given text
+   /// object.
+   ///
+   /// @return The font file's path.
+   ///
+   /// @see evas_object_text_font_get() for more details
+   ///
+   /// @param font_source The font file's path.
+   ///
+   std::string font_source_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_text_properties_font_source_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the font (source) file to be used on a given text object.
+   ///
+   /// This function allows the font file to be explicitly set for a given
+   /// text object, overriding system lookup, which will first occur in
+   /// the given file's contents.
+   ///
+   /// @see evas_object_text_font_get()
+   ///
+   /// @param font_source The font file's path.
+   ///
+   void font_source_set(std::string font_source_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EFL_TEXT_PROPERTIES_INTERFACE);
+   }
+
+private:
+};
+} 
+
+template <typename T>
+void efl_text_properties_font_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char ** font_, Efl_Font_Size* size_)
+{
+   static_cast<T*>(self->this_)->font_get(font_, size_);
+}
+
+template <typename T>
+void efl_text_properties_font_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * font_, Efl_Font_Size size_)
+{
+   static_cast<T*>(self->this_)->font_set(efl::eolian::to_cxx<std::string>(font_, std::tuple<std::false_type>()), size_);
+}
+
+template <typename T>
+std::string efl_text_properties_font_source_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->font_source_get();
+}
+
+template <typename T>
+void efl_text_properties_font_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * font_source_)
+{
+   static_cast<T*>(self->this_)->font_source_set(efl::eolian::to_cxx<std::string>(font_source_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< efl::text_properties >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void font_get(const char ** font_, Efl_Font_Size* size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_get(font_, size_));
+      }
+
+      virtual void font_set(std::string font_, Efl_Font_Size size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+      }
+
+      virtual std::string font_source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_text_properties_font_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void font_source_set(std::string font_source_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< efl::text_properties >
+{
+   static const int value = 4;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<efl::text_properties>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::efl_text_properties_font_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::efl_text_properties_font_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< efl::text_properties >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<efl::text_properties, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< efl::text_properties>
+{
+   template <typename U>
+   struct type
+   {
+      operator efl::text_properties() const
+      {
+         return efl::text_properties(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void font_get(const char ** font_, Efl_Font_Size* size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_get(font_, size_));
+      }
+
+      void font_set(std::string font_, Efl_Font_Size size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+      }
+
+      std::string font_source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_text_properties_font_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void font_source_set(std::string font_source_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<efl::text_properties>)
+{
+   return (EFL_TEXT_PROPERTIES_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EFL_TEXT_PROPERTIES_HH
+
diff -Naur a/src/lib/emotion/emotion_object.eo.c b/src/lib/emotion/emotion_object.eo.c
--- a/src/lib/emotion/emotion_object.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/emotion/emotion_object.eo.c	2014-11-27 00:57:33.520380796 +0200
@@ -0,0 +1,199 @@
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_FRAME_DECODE =
+   EO_EVENT_DESCRIPTION("frame_decode", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_UPDATE =
+   EO_EVENT_DESCRIPTION("position_update", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_LENGTH_CHANGE =
+   EO_EVENT_DESCRIPTION("length_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_FRAME_RESIZE =
+   EO_EVENT_DESCRIPTION("frame_resize", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_DECODE_STOP =
+   EO_EVENT_DESCRIPTION("decode_stop", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_PLAYBACK_STARTED =
+   EO_EVENT_DESCRIPTION("playback_started", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_PLAYBACK_FINISHED =
+   EO_EVENT_DESCRIPTION("playback_finished", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_AUDIO_LEVEL_CHANGE =
+   EO_EVENT_DESCRIPTION("audio_level_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_CHANNELS_CHANGE =
+   EO_EVENT_DESCRIPTION("channels_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_TITLE_CHANGE =
+   EO_EVENT_DESCRIPTION("title_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_PROGRESS_CHANGE =
+   EO_EVENT_DESCRIPTION("progress_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_REF_CHANGE =
+   EO_EVENT_DESCRIPTION("ref_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_BUTTON_NUM_CHANGE =
+   EO_EVENT_DESCRIPTION("button_num_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_BUTTON_CHANGE =
+   EO_EVENT_DESCRIPTION("button_change", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_OPEN_DONE =
+   EO_EVENT_DESCRIPTION("open_done", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_SAVE_SUCCEED =
+   EO_EVENT_DESCRIPTION("position_save,succeed", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_SAVE_FAILED =
+   EO_EVENT_DESCRIPTION("position_save,failed", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_LOAD_SUCCEED =
+   EO_EVENT_DESCRIPTION("position_load,succeed", "");
+EOAPI const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_LOAD_FAILED =
+   EO_EVENT_DESCRIPTION("position_load,failed", "");
+
+void _emotion_object_option_set(Eo *obj, Emotion_Object_Data *pd, const char *opt, const char *val);
+
+EOAPI EO_VOID_FUNC_BODYV(emotion_obj_option_set, EO_FUNC_CALL(opt, val), const char *opt, const char *val);
+
+Eina_Bool _emotion_object_engine_set(Eo *obj, Emotion_Object_Data *pd, const char *module_filename);
+
+EOAPI EO_FUNC_BODYV(emotion_obj_engine_set, Eina_Bool, 0, EO_FUNC_CALL(module_filename), const char *module_filename);
+
+void _emotion_object_eo_base_constructor(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_evas_object_smart_add(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_evas_object_smart_del(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_evas_object_smart_move(Eo *obj, Emotion_Object_Data *pd, Evas_Coord x, Evas_Coord y);
+
+
+void _emotion_object_evas_object_smart_resize(Eo *obj, Emotion_Object_Data *pd, Evas_Coord w, Evas_Coord h);
+
+
+void _emotion_object_evas_object_smart_show(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_evas_object_smart_hide(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_evas_object_smart_color_set(Eo *obj, Emotion_Object_Data *pd, int r, int g, int b, int a);
+
+
+void _emotion_object_evas_object_smart_clip_set(Eo *obj, Emotion_Object_Data *pd, Evas_Object *clip);
+
+
+void _emotion_object_evas_object_smart_clip_unset(Eo *obj, Emotion_Object_Data *pd);
+
+
+Eina_Bool _emotion_object_efl_file_file_set(Eo *obj, Emotion_Object_Data *pd, const char *file, const char *key);
+
+
+void _emotion_object_efl_file_file_get(Eo *obj, Emotion_Object_Data *pd, const char **file, const char **key);
+
+
+void _emotion_object_efl_player_play_set(Eo *obj, Emotion_Object_Data *pd, Eina_Bool play);
+
+
+Eina_Bool _emotion_object_efl_player_play_get(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_efl_player_position_set(Eo *obj, Emotion_Object_Data *pd, double second);
+
+
+double _emotion_object_efl_player_position_get(Eo *obj, Emotion_Object_Data *pd);
+
+
+double _emotion_object_efl_player_progress_get(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_efl_player_audio_volume_set(Eo *obj, Emotion_Object_Data *pd, double volume);
+
+
+double _emotion_object_efl_player_audio_volume_get(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_efl_player_audio_mute_set(Eo *obj, Emotion_Object_Data *pd, Eina_Bool mute);
+
+
+Eina_Bool _emotion_object_efl_player_audio_mute_get(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_efl_image_load_size_get(Eo *obj, Emotion_Object_Data *pd, int *w, int *h);
+
+
+double _emotion_object_efl_image_ratio_get(Eo *obj, Emotion_Object_Data *pd);
+
+
+void _emotion_object_efl_image_smooth_scale_set(Eo *obj, Emotion_Object_Data *pd, Eina_Bool smooth_scale);
+
+
+Eina_Bool _emotion_object_efl_image_smooth_scale_get(Eo *obj, Emotion_Object_Data *pd);
+
+
+static Eo_Op_Description _emotion_object_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _emotion_object_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_add, _emotion_object_evas_object_smart_add),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_del, _emotion_object_evas_object_smart_del),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_move, _emotion_object_evas_object_smart_move),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_resize, _emotion_object_evas_object_smart_resize),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_show, _emotion_object_evas_object_smart_show),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_hide, _emotion_object_evas_object_smart_hide),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_color_set, _emotion_object_evas_object_smart_color_set),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_clip_set, _emotion_object_evas_object_smart_clip_set),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_clip_unset, _emotion_object_evas_object_smart_clip_unset),
+     EO_OP_FUNC_OVERRIDE(efl_file_set, _emotion_object_efl_file_file_set),
+     EO_OP_FUNC_OVERRIDE(efl_file_get, _emotion_object_efl_file_file_get),
+     EO_OP_FUNC_OVERRIDE(efl_player_play_set, _emotion_object_efl_player_play_set),
+     EO_OP_FUNC_OVERRIDE(efl_player_play_get, _emotion_object_efl_player_play_get),
+     EO_OP_FUNC_OVERRIDE(efl_player_position_set, _emotion_object_efl_player_position_set),
+     EO_OP_FUNC_OVERRIDE(efl_player_position_get, _emotion_object_efl_player_position_get),
+     EO_OP_FUNC_OVERRIDE(efl_player_progress_get, _emotion_object_efl_player_progress_get),
+     EO_OP_FUNC_OVERRIDE(efl_player_audio_volume_set, _emotion_object_efl_player_audio_volume_set),
+     EO_OP_FUNC_OVERRIDE(efl_player_audio_volume_get, _emotion_object_efl_player_audio_volume_get),
+     EO_OP_FUNC_OVERRIDE(efl_player_audio_mute_set, _emotion_object_efl_player_audio_mute_set),
+     EO_OP_FUNC_OVERRIDE(efl_player_audio_mute_get, _emotion_object_efl_player_audio_mute_get),
+     EO_OP_FUNC_OVERRIDE(efl_image_load_size_get, _emotion_object_efl_image_load_size_get),
+     EO_OP_FUNC_OVERRIDE(efl_image_ratio_get, _emotion_object_efl_image_ratio_get),
+     EO_OP_FUNC_OVERRIDE(efl_image_smooth_scale_set, _emotion_object_efl_image_smooth_scale_set),
+     EO_OP_FUNC_OVERRIDE(efl_image_smooth_scale_get, _emotion_object_efl_image_smooth_scale_get),
+     EO_OP_FUNC(emotion_obj_option_set, _emotion_object_option_set, ""),
+     EO_OP_FUNC(emotion_obj_engine_set, _emotion_object_engine_set, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Event_Description *_emotion_object_event_desc[] = {
+     EMOTION_OBJECT_EVENT_FRAME_DECODE,
+     EMOTION_OBJECT_EVENT_POSITION_UPDATE,
+     EMOTION_OBJECT_EVENT_LENGTH_CHANGE,
+     EMOTION_OBJECT_EVENT_FRAME_RESIZE,
+     EMOTION_OBJECT_EVENT_DECODE_STOP,
+     EMOTION_OBJECT_EVENT_PLAYBACK_STARTED,
+     EMOTION_OBJECT_EVENT_PLAYBACK_FINISHED,
+     EMOTION_OBJECT_EVENT_AUDIO_LEVEL_CHANGE,
+     EMOTION_OBJECT_EVENT_CHANNELS_CHANGE,
+     EMOTION_OBJECT_EVENT_TITLE_CHANGE,
+     EMOTION_OBJECT_EVENT_PROGRESS_CHANGE,
+     EMOTION_OBJECT_EVENT_REF_CHANGE,
+     EMOTION_OBJECT_EVENT_BUTTON_NUM_CHANGE,
+     EMOTION_OBJECT_EVENT_BUTTON_CHANGE,
+     EMOTION_OBJECT_EVENT_OPEN_DONE,
+     EMOTION_OBJECT_EVENT_POSITION_SAVE_SUCCEED,
+     EMOTION_OBJECT_EVENT_POSITION_SAVE_FAILED,
+     EMOTION_OBJECT_EVENT_POSITION_LOAD_SUCCEED,
+     EMOTION_OBJECT_EVENT_POSITION_LOAD_FAILED,
+     NULL
+};
+
+static const Eo_Class_Description _emotion_object_class_desc = {
+     EO_VERSION,
+     "Emotion_Object",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_emotion_object_op_desc),
+     _emotion_object_event_desc,
+     sizeof(Emotion_Object_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(emotion_object_class_get, &_emotion_object_class_desc, EVAS_OBJECT_SMART_CLASS, EFL_FILE_INTERFACE, EFL_PLAYER_INTERFACE, EFL_IMAGE_INTERFACE, NULL);
+EAPI void
+emotion_object_module_option_set(Emotion_Object *obj, const char *opt, const char *val)
+{
+   eo_do((Emotion_Object *)obj, emotion_obj_option_set(opt, val));
+}
+
+EAPI Eina_Bool
+emotion_object_init(Emotion_Object *obj, const char *module_filename)
+{
+   return eo_do((Emotion_Object *)obj, emotion_obj_engine_set(module_filename));
+}
diff -Naur a/src/lib/emotion/emotion_object.eo.h b/src/lib/emotion/emotion_object.eo.h
--- a/src/lib/emotion/emotion_object.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/emotion/emotion_object.eo.h	2014-11-27 00:57:33.520380796 +0200
@@ -0,0 +1,154 @@
+#ifndef _EMOTION_OBJECT_EO_H_
+#define _EMOTION_OBJECT_EO_H_
+
+#ifndef _EMOTION_OBJECT_EO_CLASS_TYPE
+#define _EMOTION_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Emotion_Object;
+
+#endif
+
+#ifndef _EMOTION_OBJECT_EO_TYPES
+#define _EMOTION_OBJECT_EO_TYPES
+
+
+#endif
+#define EMOTION_OBJECT_CLASS emotion_object_class_get()
+
+const Eo_Class *emotion_object_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] opt The option that is being set. Currently supported optiosn: "video" and "audio".
+ * @param[in] val The value of the option. Currently only supports "off" (?!?!?!)
+ *
+ */
+EOAPI void  emotion_obj_option_set(const char *opt, const char *val);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] module_filename The name of the module to be used (gstreamer or xine).
+ *
+ */
+EOAPI Eina_Bool  emotion_obj_engine_set(const char *module_filename);
+
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_FRAME_DECODE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_UPDATE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_LENGTH_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_FRAME_RESIZE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_DECODE_STOP;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_PLAYBACK_STARTED;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_PLAYBACK_FINISHED;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_AUDIO_LEVEL_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_CHANNELS_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_TITLE_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_PROGRESS_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_REF_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_BUTTON_NUM_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_BUTTON_CHANGE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_OPEN_DONE;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_SAVE_SUCCEED;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_SAVE_FAILED;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_LOAD_SUCCEED;
+EOAPI extern const Eo_Event_Description _EMOTION_OBJECT_EVENT_POSITION_LOAD_FAILED;
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_FRAME_DECODE (&(_EMOTION_OBJECT_EVENT_FRAME_DECODE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_POSITION_UPDATE (&(_EMOTION_OBJECT_EVENT_POSITION_UPDATE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_LENGTH_CHANGE (&(_EMOTION_OBJECT_EVENT_LENGTH_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_FRAME_RESIZE (&(_EMOTION_OBJECT_EVENT_FRAME_RESIZE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_DECODE_STOP (&(_EMOTION_OBJECT_EVENT_DECODE_STOP))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_PLAYBACK_STARTED (&(_EMOTION_OBJECT_EVENT_PLAYBACK_STARTED))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_PLAYBACK_FINISHED (&(_EMOTION_OBJECT_EVENT_PLAYBACK_FINISHED))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_AUDIO_LEVEL_CHANGE (&(_EMOTION_OBJECT_EVENT_AUDIO_LEVEL_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_CHANNELS_CHANGE (&(_EMOTION_OBJECT_EVENT_CHANNELS_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_TITLE_CHANGE (&(_EMOTION_OBJECT_EVENT_TITLE_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_PROGRESS_CHANGE (&(_EMOTION_OBJECT_EVENT_PROGRESS_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_REF_CHANGE (&(_EMOTION_OBJECT_EVENT_REF_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_BUTTON_NUM_CHANGE (&(_EMOTION_OBJECT_EVENT_BUTTON_NUM_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_BUTTON_CHANGE (&(_EMOTION_OBJECT_EVENT_BUTTON_CHANGE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_OPEN_DONE (&(_EMOTION_OBJECT_EVENT_OPEN_DONE))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_POSITION_SAVE_SUCCEED (&(_EMOTION_OBJECT_EVENT_POSITION_SAVE_SUCCEED))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_POSITION_SAVE_FAILED (&(_EMOTION_OBJECT_EVENT_POSITION_SAVE_FAILED))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_POSITION_LOAD_SUCCEED (&(_EMOTION_OBJECT_EVENT_POSITION_LOAD_SUCCEED))
+
+/**
+ * No description
+ */
+#define EMOTION_OBJECT_EVENT_POSITION_LOAD_FAILED (&(_EMOTION_OBJECT_EVENT_POSITION_LOAD_FAILED))
+
+#endif
diff -Naur a/src/lib/emotion/emotion_object.eo.legacy.h b/src/lib/emotion/emotion_object.eo.legacy.h
--- a/src/lib/emotion/emotion_object.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/emotion/emotion_object.eo.legacy.h	2014-11-27 00:57:33.520380796 +0200
@@ -0,0 +1,34 @@
+#ifndef _EMOTION_OBJECT_EO_LEGACY_H_
+#define _EMOTION_OBJECT_EO_LEGACY_H_
+
+#ifndef _EMOTION_OBJECT_EO_CLASS_TYPE
+#define _EMOTION_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Emotion_Object;
+
+#endif
+
+#ifndef _EMOTION_OBJECT_EO_TYPES
+#define _EMOTION_OBJECT_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] opt The option that is being set. Currently supported optiosn: "video" and "audio".
+ * @param[in] val The value of the option. Currently only supports "off" (?!?!?!)
+ */
+EAPI void emotion_object_module_option_set(Emotion_Object *obj, const char *opt, const char *val);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] module_filename The name of the module to be used (gstreamer or xine).
+ */
+EAPI Eina_Bool emotion_object_init(Emotion_Object *obj, const char *module_filename);
+
+#endif
diff -Naur a/src/lib/eo/eo_abstract_class.eo.c b/src/lib/eo/eo_abstract_class.eo.c
--- a/src/lib/eo/eo_abstract_class.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/eo/eo_abstract_class.eo.c	2014-11-27 00:57:33.393712147 +0200
@@ -0,0 +1,13 @@
+
+static const Eo_Class_Description _eo_abstract_class_class_desc = {
+     EO_VERSION,
+     "Eo_Abstract_Class",
+     EO_CLASS_TYPE_REGULAR_NO_INSTANT,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(eo_abstract_class_class_get, &_eo_abstract_class_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/eo/eo_abstract_class.eo.h b/src/lib/eo/eo_abstract_class.eo.h
--- a/src/lib/eo/eo_abstract_class.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/eo/eo_abstract_class.eo.h	2014-11-27 00:57:33.397045554 +0200
@@ -0,0 +1,21 @@
+#ifndef _EO_ABSTRACT_CLASS_EO_H_
+#define _EO_ABSTRACT_CLASS_EO_H_
+
+#ifndef _EO_ABSTRACT_CLASS_EO_CLASS_TYPE
+#define _EO_ABSTRACT_CLASS_EO_CLASS_TYPE
+
+typedef Eo Eo_Abstract_Class;
+
+#endif
+
+#ifndef _EO_ABSTRACT_CLASS_EO_TYPES
+#define _EO_ABSTRACT_CLASS_EO_TYPES
+
+
+#endif
+#define EO_ABSTRACT_CLASS_CLASS eo_abstract_class_class_get()
+
+const Eo_Class *eo_abstract_class_class_get(void) EINA_CONST;
+
+
+#endif
diff -Naur a/src/lib/eo/eo_base.eo.c b/src/lib/eo/eo_base.eo.c
--- a/src/lib/eo/eo_base.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/eo/eo_base.eo.c	2014-11-27 00:57:33.397045554 +0200
@@ -0,0 +1,175 @@
+EOAPI const Eo_Event_Description _EO_BASE_EVENT_CALLBACK_ADD =
+   EO_EVENT_DESCRIPTION("callback,add", "A callback was added.");
+EOAPI const Eo_Event_Description _EO_BASE_EVENT_CALLBACK_DEL =
+   EO_EVENT_DESCRIPTION("callback,del", "A callback was deleted.");
+EOAPI const Eo_Event_Description _EO_BASE_EVENT_DEL =
+   EO_EVENT_DESCRIPTION("del", "Obj is being deleted.");
+
+void _eo_base_parent_set(Eo *obj, Eo_Base_Data *pd, Eo *parent);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_parent_set, EO_FUNC_CALL(parent), Eo *parent);
+
+Eo * _eo_base_parent_get(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_FUNC_BODY(eo_parent_get, Eo *, 0);
+
+int _eo_base_event_global_freeze_count_get(Eo *obj, void *pd);
+
+EOAPI EO_FUNC_BODY(eo_event_global_freeze_count_get, int, 0);
+
+int _eo_base_event_freeze_count_get(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_FUNC_BODY(eo_event_freeze_count_get, int, 0);
+
+Eina_Bool _eo_base_finalized_get(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_FUNC_BODY(eo_finalized_get, Eina_Bool, 0);
+
+void _eo_base_constructor(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(eo_constructor);
+
+void _eo_base_event_callback_forwarder_del(Eo *obj, Eo_Base_Data *pd, const Eo_Event_Description *desc, Eo *new_obj);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_event_callback_forwarder_del, EO_FUNC_CALL(desc, new_obj), const Eo_Event_Description *desc, Eo *new_obj);
+
+void _eo_base_event_thaw(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(eo_event_thaw);
+
+void _eo_base_event_freeze(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(eo_event_freeze);
+
+void _eo_base_event_global_freeze(Eo *obj, void *pd);
+
+EOAPI EO_VOID_FUNC_BODY(eo_event_global_freeze);
+
+void _eo_base_event_callback_array_del(Eo *obj, Eo_Base_Data *pd, const Eo_Callback_Array_Item *array, const void *user_data);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_event_callback_array_del, EO_FUNC_CALL(array, user_data), const Eo_Callback_Array_Item *array, const void *user_data);
+
+void _eo_base_wref_del(Eo *obj, Eo_Base_Data *pd, Eo **wref);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_wref_del, EO_FUNC_CALL(wref), Eo **wref);
+
+void _eo_base_destructor(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(eo_destructor);
+
+Eo * _eo_base_finalize(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_FUNC_BODY(eo_finalize, Eo *, 0);
+
+void _eo_base_key_data_set(Eo *obj, Eo_Base_Data *pd, const char *key, const void *data, eo_key_data_free_func free_func);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_key_data_set, EO_FUNC_CALL(key, data, free_func), const char *key, const void *data, eo_key_data_free_func free_func);
+
+void * _eo_base_key_data_get(Eo *obj, Eo_Base_Data *pd, const char *key);
+
+EOAPI EO_FUNC_BODYV(eo_key_data_get, void *, 0, EO_FUNC_CALL(key), const char *key);
+
+void _eo_base_event_callback_del(Eo *obj, Eo_Base_Data *pd, const Eo_Event_Description *desc, Eo_Event_Cb func, const void *user_data);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_event_callback_del, EO_FUNC_CALL(desc, func, user_data), const Eo_Event_Description *desc, Eo_Event_Cb func, const void *user_data);
+
+void _eo_base_event_global_thaw(Eo *obj, void *pd);
+
+EOAPI EO_VOID_FUNC_BODY(eo_event_global_thaw);
+
+void _eo_base_key_data_del(Eo *obj, Eo_Base_Data *pd, const char *key);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_key_data_del, EO_FUNC_CALL(key), const char *key);
+
+void _eo_base_event_callback_array_priority_add(Eo *obj, Eo_Base_Data *pd, const Eo_Callback_Array_Item *array, Eo_Callback_Priority priority, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_event_callback_array_priority_add, EO_FUNC_CALL(array, priority, data), const Eo_Callback_Array_Item *array, Eo_Callback_Priority priority, const void *data);
+
+void _eo_base_wref_add(Eo *obj, Eo_Base_Data *pd, Eo **wref);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_wref_add, EO_FUNC_CALL(wref), Eo **wref);
+
+void _eo_base_dbg_info_get(Eo *obj, Eo_Base_Data *pd, Eo_Dbg_Info *root_node);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_dbg_info_get, EO_FUNC_CALL(root_node), Eo_Dbg_Info *root_node);
+
+void _eo_base_event_callback_forwarder_add(Eo *obj, Eo_Base_Data *pd, const Eo_Event_Description *desc, Eo *new_obj);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_event_callback_forwarder_add, EO_FUNC_CALL(desc, new_obj), const Eo_Event_Description *desc, Eo *new_obj);
+
+Eina_Bool _eo_base_event_callback_call(Eo *obj, Eo_Base_Data *pd, const Eo_Event_Description *desc, void *event_info);
+
+EOAPI EO_FUNC_BODYV(eo_event_callback_call, Eina_Bool, 0, EO_FUNC_CALL(desc, event_info), const Eo_Event_Description *desc, void *event_info);
+
+void _eo_base_event_callback_priority_add(Eo *obj, Eo_Base_Data *pd, const Eo_Event_Description *desc, Eo_Callback_Priority priority, Eo_Event_Cb cb, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(eo_event_callback_priority_add, EO_FUNC_CALL(desc, priority, cb, data), const Eo_Event_Description *desc, Eo_Callback_Priority priority, Eo_Event_Cb cb, const void *data);
+
+Eina_Iterator * _eo_base_children_iterator_new(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_FUNC_BODY(eo_children_iterator_new, Eina_Iterator *, 0);
+
+Eina_Bool _eo_base_composite_attach(Eo *obj, Eo_Base_Data *pd, Eo *comp_obj);
+
+EOAPI EO_FUNC_BODYV(eo_composite_attach, Eina_Bool, 0, EO_FUNC_CALL(comp_obj), Eo *comp_obj);
+
+Eina_Bool _eo_base_composite_detach(Eo *obj, Eo_Base_Data *pd, Eo *comp_obj);
+
+EOAPI EO_FUNC_BODYV(eo_composite_detach, Eina_Bool, 0, EO_FUNC_CALL(comp_obj), Eo *comp_obj);
+
+Eina_Bool _eo_base_composite_part_is(Eo *obj, Eo_Base_Data *pd);
+
+EOAPI EO_FUNC_BODY(eo_composite_part_is, Eina_Bool, 0);
+
+static Eo_Op_Description _eo_base_op_desc[] = {
+     EO_OP_FUNC(eo_parent_set, _eo_base_parent_set, "Set the parent of an object"),
+     EO_OP_FUNC(eo_parent_get, _eo_base_parent_get, "Get the parent of an object"),
+     EO_OP_CLASS_FUNC(eo_event_global_freeze_count_get, _eo_base_event_global_freeze_count_get, "return freeze events of object."),
+     EO_OP_FUNC(eo_event_freeze_count_get, _eo_base_event_freeze_count_get, "return freeze events of object."),
+     EO_OP_FUNC(eo_finalized_get, _eo_base_finalized_get, ""),
+     EO_OP_FUNC(eo_constructor, _eo_base_constructor, "Call the object's constructor."),
+     EO_OP_FUNC(eo_event_callback_forwarder_del, _eo_base_event_callback_forwarder_del, "Remove an event callback forwarder for an event and an object."),
+     EO_OP_FUNC(eo_event_thaw, _eo_base_event_thaw, "thaw events of object."),
+     EO_OP_FUNC(eo_event_freeze, _eo_base_event_freeze, "freeze events of object."),
+     EO_OP_CLASS_FUNC(eo_event_global_freeze, _eo_base_event_global_freeze, "freeze events of object."),
+     EO_OP_FUNC(eo_event_callback_array_del, _eo_base_event_callback_array_del, "Del a callback array with a specific data associated to it for an event."),
+     EO_OP_FUNC(eo_wref_del, _eo_base_wref_del, "Delete the weak reference passed."),
+     EO_OP_FUNC(eo_destructor, _eo_base_destructor, "Call the object's destructor."),
+     EO_OP_FUNC(eo_finalize, _eo_base_finalize, "Called at the end of #eo_add. Should not be called, just overridden."),
+     EO_OP_FUNC(eo_key_data_set, _eo_base_key_data_set, "Set generic data to object."),
+     EO_OP_FUNC(eo_key_data_get, _eo_base_key_data_get, "Get generic data from object."),
+     EO_OP_FUNC(eo_event_callback_del, _eo_base_event_callback_del, "Del a callback with a specific data associated to it for an event."),
+     EO_OP_CLASS_FUNC(eo_event_global_thaw, _eo_base_event_global_thaw, "thaw events of object."),
+     EO_OP_FUNC(eo_key_data_del, _eo_base_key_data_del, "Del generic data from object."),
+     EO_OP_FUNC(eo_event_callback_array_priority_add, _eo_base_event_callback_array_priority_add, "Add a callback array for an event with a specific priority."),
+     EO_OP_FUNC(eo_wref_add, _eo_base_wref_add, "Add a new weak reference to obj."),
+     EO_OP_FUNC(eo_dbg_info_get, _eo_base_dbg_info_get, "Get dbg information from the object."),
+     EO_OP_FUNC(eo_event_callback_forwarder_add, _eo_base_event_callback_forwarder_add, "Add an event callback forwarder for an event and an object."),
+     EO_OP_FUNC(eo_event_callback_call, _eo_base_event_callback_call, "Call the callbacks for an event of an object."),
+     EO_OP_FUNC(eo_event_callback_priority_add, _eo_base_event_callback_priority_add, "Add a callback for an event with a specific priority."),
+     EO_OP_FUNC(eo_children_iterator_new, _eo_base_children_iterator_new, "Get an iterator on all childrens"),
+     EO_OP_FUNC(eo_composite_attach, _eo_base_composite_attach, ""),
+     EO_OP_FUNC(eo_composite_detach, _eo_base_composite_detach, ""),
+     EO_OP_FUNC(eo_composite_part_is, _eo_base_composite_part_is, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Event_Description *_eo_base_event_desc[] = {
+     EO_BASE_EVENT_CALLBACK_ADD,
+     EO_BASE_EVENT_CALLBACK_DEL,
+     EO_BASE_EVENT_DEL,
+     NULL
+};
+
+static const Eo_Class_Description _eo_base_class_desc = {
+     EO_VERSION,
+     "Eo_Base",
+     EO_CLASS_TYPE_REGULAR_NO_INSTANT,
+     EO_CLASS_DESCRIPTION_OPS(_eo_base_op_desc),
+     _eo_base_event_desc,
+     sizeof(Eo_Base_Data),
+     _eo_base_class_constructor,
+     _eo_base_class_destructor
+};
+
+EO_DEFINE_CLASS(eo_base_class_get, &_eo_base_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/eo/eo_base.eo.h b/src/lib/eo/eo_base.eo.h
--- a/src/lib/eo/eo_base.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/eo/eo_base.eo.h	2014-11-27 00:57:33.397045554 +0200
@@ -0,0 +1,334 @@
+#ifndef _EO_BASE_EO_H_
+#define _EO_BASE_EO_H_
+
+#ifndef _EO_BASE_EO_CLASS_TYPE
+#define _EO_BASE_EO_CLASS_TYPE
+
+typedef Eo Eo_Base;
+
+#endif
+
+#ifndef _EO_BASE_EO_TYPES
+#define _EO_BASE_EO_TYPES
+
+
+#endif
+#define EO_BASE_CLASS eo_base_class_get()
+
+const Eo_Class *eo_base_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Set the parent of an object
+ * Parents keep references to their children so in order to delete objects that have parents you need to set parent to NULL or use eo_del() that does that for you (and also unrefs the object).
+ *
+ * @param[in] parent the new parent
+ *
+ */
+EOAPI void  eo_parent_set(Eo *parent);
+
+/**
+ *
+ * Get the parent of an object
+ *
+ *
+ */
+EOAPI Eo * eo_parent_get(void);
+
+/**
+ *
+ * return freeze events of object.
+ * Return event freeze count.
+ *
+ *
+ */
+EOAPI int  eo_event_global_freeze_count_get(void);
+
+/**
+ *
+ * return freeze events of object.
+ * Return event freeze count.
+ *
+ *
+ */
+EOAPI int  eo_event_freeze_count_get(void);
+
+/**
+ *
+ * True if the object is already finalized, false otherwise.
+ * 
+ *
+ *
+ */
+EOAPI Eina_Bool  eo_finalized_get(void);
+
+/**
+ *
+ * Call the object's constructor.
+ * Should not be used with #eo_do. Only use it with #eo_do_super.
+ * 
+ *
+ *
+ */
+EOAPI void  eo_constructor(void);
+
+/**
+ *
+ * Remove an event callback forwarder for an event and an object.
+ * 
+ *
+ * @param[in] desc The description of the event to listen to
+ * @param[in] new_obj The object to emit events from
+ *
+ */
+EOAPI void  eo_event_callback_forwarder_del(const Eo_Event_Description *desc, Eo *new_obj);
+
+/**
+ *
+ * thaw events of object.
+ * Lets event callbacks be called for the object.
+ * 
+ *
+ *
+ */
+EOAPI void  eo_event_thaw(void);
+
+/**
+ *
+ * freeze events of object.
+ * Prevents event callbacks from being called for the object.
+ * 
+ *
+ *
+ */
+EOAPI void  eo_event_freeze(void);
+
+/**
+ *
+ * freeze events of object.
+ * Prevents event callbacks from being called for the object.
+ * 
+ *
+ *
+ */
+EOAPI void  eo_event_global_freeze(void);
+
+/**
+ *
+ * Del a callback array with a specific data associated to it for an event.
+ * 
+ *
+ * @param[in] array an #Eo_Callback_Array_Item of events to listen to
+ * @param[in] user_data The data to compare
+ *
+ */
+EOAPI void  eo_event_callback_array_del(const Eo_Callback_Array_Item *array, const void *user_data);
+
+/**
+ *
+ * Delete the weak reference passed.
+ * 
+ *
+ * @param[inout] wref No description supplied.
+ *
+ */
+EOAPI void  eo_wref_del(Eo **wref);
+
+/**
+ *
+ * Call the object's destructor.
+ * Should not be used with #eo_do. Only use it with #eo_do_super.
+ * 
+ *
+ *
+ */
+EOAPI void  eo_destructor(void);
+
+/**
+ *
+ * Called at the end of #eo_add. Should not be called, just overridden.
+ * 
+ *
+ *
+ */
+EOAPI Eo * eo_finalize(void);
+
+/**
+ *
+ * Set generic data to object.
+ * 
+ *
+ * @param[in] key the key associated with the data
+ * @param[in] data the data to set
+ * @param[in] free_func the func to free data with (NULL means
+ *
+ */
+EOAPI void  eo_key_data_set(const char *key, const void *data, eo_key_data_free_func free_func);
+
+/**
+ *
+ * Get generic data from object.
+ * 
+ *
+ * @param[in] key the key associated with the data
+ *
+ */
+EOAPI void * eo_key_data_get(const char *key);
+
+/**
+ *
+ * Del a callback with a specific data associated to it for an event.
+ * 
+ *
+ * @param[in] desc The description of the event to listen to
+ * @param[in] func the callback to delete
+ * @param[in] user_data The data to compare
+ *
+ */
+EOAPI void  eo_event_callback_del(const Eo_Event_Description *desc, Eo_Event_Cb func, const void *user_data);
+
+/**
+ *
+ * thaw events of object.
+ * Lets event callbacks be called for the object.
+ * 
+ *
+ *
+ */
+EOAPI void  eo_event_global_thaw(void);
+
+/**
+ *
+ * Del generic data from object.
+ * 
+ *
+ * @param[in] key the key associated with the data
+ *
+ */
+EOAPI void  eo_key_data_del(const char *key);
+
+/**
+ *
+ * Add a callback array for an event with a specific priority.
+ * callbacks of the same priority are called in reverse order of creation.
+ * 
+ *
+ * @param[in] array an #Eo_Callback_Array_Item of events to listen to
+ * @param[in] priority The priority of the callback
+ * @param[in] data additional data to pass to the callback
+ *
+ */
+EOAPI void  eo_event_callback_array_priority_add(const Eo_Callback_Array_Item *array, Eo_Callback_Priority priority, const void *data);
+
+/**
+ *
+ * Add a new weak reference to obj.
+ * This function registers the object handle pointed by wref to obj so when obj is deleted it'll be updated to NULL. This functions should be used when you want to keep track of an object in a safe way, but you don't want to prevent it from being freed.
+ * 
+ *
+ * @param[inout] wref No description supplied.
+ *
+ */
+EOAPI void  eo_wref_add(Eo **wref);
+
+/**
+ *
+ * Get dbg information from the object.
+ * 
+ *
+ * @param[in] root_node node of the tree
+ *
+ */
+EOAPI void  eo_dbg_info_get(Eo_Dbg_Info *root_node);
+
+/**
+ *
+ * Add an event callback forwarder for an event and an object.
+ * 
+ *
+ * @param[in] desc The description of the event to listen to
+ * @param[in] new_obj The object to emit events from
+ *
+ */
+EOAPI void  eo_event_callback_forwarder_add(const Eo_Event_Description *desc, Eo *new_obj);
+
+/**
+ *
+ * Call the callbacks for an event of an object.
+ * 
+ *
+ * @param[in] desc The description of the event to call
+ * @param[in] event_info Extra event info to pass to the callbacks
+ *
+ */
+EOAPI Eina_Bool  eo_event_callback_call(const Eo_Event_Description *desc, void *event_info);
+
+/**
+ *
+ * Add a callback for an event with a specific priority.
+ * callbacks of the same priority are called in reverse order of creation.
+ * 
+ *
+ * @param[in] desc The description of the event to listen to
+ * @param[in] priority The priority of the callback
+ * @param[in] cb the callback to call
+ * @param[in] data additional data to pass to the callback
+ *
+ */
+EOAPI void  eo_event_callback_priority_add(const Eo_Event_Description *desc, Eo_Callback_Priority priority, Eo_Event_Cb cb, const void *data);
+
+/**
+ *
+ * Get an iterator on all childrens
+ * 
+ *
+ *
+ */
+EOAPI Eina_Iterator * eo_children_iterator_new(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] comp_obj the object that will be used to composite the parent.
+ *
+ */
+EOAPI Eina_Bool  eo_composite_attach(Eo *comp_obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] comp_obj the object that will be removed from the parent.
+ *
+ */
+EOAPI Eina_Bool  eo_composite_detach(Eo *comp_obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  eo_composite_part_is(void);
+
+EOAPI extern const Eo_Event_Description _EO_BASE_EVENT_CALLBACK_ADD;
+EOAPI extern const Eo_Event_Description _EO_BASE_EVENT_CALLBACK_DEL;
+EOAPI extern const Eo_Event_Description _EO_BASE_EVENT_DEL;
+
+/**
+ * A callback was added.
+ */
+#define EO_BASE_EVENT_CALLBACK_ADD (&(_EO_BASE_EVENT_CALLBACK_ADD))
+
+/**
+ * A callback was deleted.
+ */
+#define EO_BASE_EVENT_CALLBACK_DEL (&(_EO_BASE_EVENT_CALLBACK_DEL))
+
+/**
+ * Obj is being deleted.
+ */
+#define EO_BASE_EVENT_DEL (&(_EO_BASE_EVENT_DEL))
+
+#endif
diff -Naur a/src/lib/evas/Evas.hh b/src/lib/evas/Evas.hh
--- a/src/lib/evas/Evas.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/Evas.hh	2014-11-27 00:57:33.490380314 +0200
@@ -0,0 +1,38 @@
+#ifndef EFL_CXX_EVAS_HH
+#define EFL_CXX_EVAS_HH
+
+#ifdef EFL_BETA_API_SUPPORT
+#include <canvas/evas_line.eo.hh>
+#include <canvas/evas_polygon.eo.hh>
+#include <canvas/evas_rectangle.eo.hh>
+#include <canvas/evas_text.eo.hh>
+#include <canvas/evas_textblock.eo.hh>
+#include <canvas/evas_textgrid.eo.hh>
+#include <canvas/evas_signal_interface.eo.hh>
+#include <canvas/evas_object_smart.eo.hh>
+#include <canvas/evas_smart_clipped.eo.hh>
+#include <canvas/evas_table.eo.hh>
+#include <canvas/evas_common_interface.eo.hh>
+#include <canvas/evas_object.eo.hh>
+#include <canvas/evas_canvas.eo.hh>
+#include <canvas/evas_grid.eo.hh>
+#include <canvas/evas_image.eo.hh>
+#include <canvas/evas_out.eo.hh>
+#include <canvas/evas_draggable_interface.eo.hh>
+#include <canvas/evas_clickable_interface.eo.hh>
+#include <canvas/evas_scrollable_interface.eo.hh>
+#include <canvas/evas_selectable_interface.eo.hh>
+#include <canvas/evas_zoomable_interface.eo.hh>
+#include <canvas/evas_box.eo.hh>
+#include <canvas/evas_3d_camera.eo.hh>
+#include <canvas/evas_3d_light.eo.hh>
+#include <canvas/evas_3d_material.eo.hh>
+#include <canvas/evas_3d_mesh.eo.hh>
+#include <canvas/evas_3d_node.eo.hh>
+#include <canvas/evas_3d_object.eo.hh>
+#include <canvas/evas_3d_scene.eo.hh>
+#include <canvas/evas_3d_texture.eo.hh>
+#endif
+
+#endif
+
diff -Naur a/src/lib/evas/canvas/evas_3d_camera.eo.c b/src/lib/evas/canvas/evas_3d_camera.eo.c
--- a/src/lib/evas/canvas/evas_3d_camera.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_camera.eo.c	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,58 @@
+
+void _evas_3d_camera_projection_matrix_set(Eo *obj, Evas_3D_Camera_Data *pd, const Evas_Real *matrix);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_camera_projection_matrix_set, EO_FUNC_CALL(matrix), const Evas_Real *matrix);
+
+void _evas_3d_camera_projection_matrix_get(Eo *obj, Evas_3D_Camera_Data *pd, Evas_Real *matrix);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_camera_projection_matrix_get, EO_FUNC_CALL(matrix), Evas_Real *matrix);
+
+void _evas_3d_camera_projection_perspective_set(Eo *obj, Evas_3D_Camera_Data *pd, Evas_Real fovy, Evas_Real aspect, Evas_Real dnear, Evas_Real dfar);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_camera_projection_perspective_set, EO_FUNC_CALL(fovy, aspect, dnear, dfar), Evas_Real fovy, Evas_Real aspect, Evas_Real dnear, Evas_Real dfar);
+
+void _evas_3d_camera_projection_frustum_set(Eo *obj, Evas_3D_Camera_Data *pd, Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_camera_projection_frustum_set, EO_FUNC_CALL(left, right, bottom, top, dnear, dfar), Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+void _evas_3d_camera_projection_ortho_set(Eo *obj, Evas_3D_Camera_Data *pd, Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_camera_projection_ortho_set, EO_FUNC_CALL(left, right, bottom, top, dnear, dfar), Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+void _evas_3d_camera_eo_base_constructor(Eo *obj, Evas_3D_Camera_Data *pd);
+
+
+void _evas_3d_camera_eo_base_destructor(Eo *obj, Evas_3D_Camera_Data *pd);
+
+
+void _evas_3d_camera_evas_3d_object_update_notify(Eo *obj, Evas_3D_Camera_Data *pd);
+
+
+void _evas_3d_camera_evas_3d_object_change_notify(Eo *obj, Evas_3D_Camera_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+
+static Eo_Op_Description _evas_3d_camera_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_3d_camera_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_3d_camera_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_update_notify, _evas_3d_camera_evas_3d_object_update_notify),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_change_notify, _evas_3d_camera_evas_3d_object_change_notify),
+     EO_OP_FUNC(evas_3d_camera_projection_matrix_set, _evas_3d_camera_projection_matrix_set, "Set the projection matrix of the given camera."),
+     EO_OP_FUNC(evas_3d_camera_projection_matrix_get, _evas_3d_camera_projection_matrix_get, "Get the projection matrix of the given camera."),
+     EO_OP_FUNC(evas_3d_camera_projection_perspective_set, _evas_3d_camera_projection_perspective_set, "Set the projection matrix of the given camera with perspective projection."),
+     EO_OP_FUNC(evas_3d_camera_projection_frustum_set, _evas_3d_camera_projection_frustum_set, "Set the projection matrix of the given camera with frustum projection."),
+     EO_OP_FUNC(evas_3d_camera_projection_ortho_set, _evas_3d_camera_projection_ortho_set, "Set the projection matrix of the given camera with orthogonal projection."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_camera_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Camera",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_camera_op_desc),
+     NULL,
+     sizeof(Evas_3D_Camera_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_camera_class_get, &_evas_3d_camera_class_desc, EVAS_3D_OBJECT_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_camera.eo.h b/src/lib/evas/canvas/evas_3d_camera.eo.h
--- a/src/lib/evas/canvas/evas_3d_camera.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_camera.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,120 @@
+#ifndef _EVAS_3D_CAMERA_EO_H_
+#define _EVAS_3D_CAMERA_EO_H_
+
+#ifndef _EVAS_3D_CAMERA_EO_CLASS_TYPE
+#define _EVAS_3D_CAMERA_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Camera;
+
+#endif
+
+#ifndef _EVAS_3D_CAMERA_EO_TYPES
+#define _EVAS_3D_CAMERA_EO_TYPES
+
+
+#endif
+#define EVAS_3D_CAMERA_CLASS evas_3d_camera_class_get()
+
+const Eo_Class *evas_3d_camera_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Set the projection matrix of the given camera.
+ *
+ * @param camera     The given camera.
+ * @param matrix     Pointer to the array of 16 Evas_Real values in column major order.
+ *
+ * Default projection matrix is identity matrix.
+ *
+ * @see evas_3d_camera_projection_perspective_set()
+ * @see evas_3d_camera_projection_ortho_set()
+ * @see evas_3d_camera_projection_frustum_set()
+ *
+ * @ingroup Evas_3D_Camera
+ * 
+ *
+ * @param[in] matrix Projection Matrix
+ *
+ */
+EOAPI void  evas_3d_camera_projection_matrix_set(const Evas_Real *matrix);
+
+/**
+ *
+ * Get the projection matrix of the given camera.
+ *
+ * @param camera     The given camera.
+ * @param matrix     Pointer to receive the 16 Evas_Real values in column major order.
+ *
+ * @see evas_3d_camera_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Camera
+ * 
+ *
+ * @param[out] matrix Projection Matrix
+ *
+ */
+EOAPI void  evas_3d_camera_projection_matrix_get(Evas_Real *matrix);
+
+/**
+ *
+ * Set the projection matrix of the given camera with perspective projection.
+ *
+ * @param camera     The given camera.
+ * @param fovy       Field of view angle in Y direction.
+ * @param aspect     Aspect ratio.
+ * @param dnear      Distance to near clipping plane.
+ * @param dfar       Distance to far clipping plane.
+ *
+ * @see evas_3d_camera_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Camera
+ * 
+ *
+ * @param[in] fovy Field of view angle in Y direction.
+ * @param[in] aspect Aspect ratio.
+ * @param[in] dnear Distance to near clipping plane.
+ * @param[in] dfar Distance to far clipping plane.
+ *
+ */
+EOAPI void  evas_3d_camera_projection_perspective_set(Evas_Real fovy, Evas_Real aspect, Evas_Real dnear, Evas_Real dfar);
+
+/**
+ *
+ * Set the projection matrix of the given camera with frustum projection.
+ *
+ * @see evas_3d_camera_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Camera
+ * 
+ *
+ * @param[in] left Left X coordinate of the near clipping plane.
+ * @param[in] right Right X coordinate of the near clipping plane..
+ * @param[in] bottom Bottom Y coordinate of the near clipping plane.
+ * @param[in] top Top Y coordinate of the near clipping plane
+ * @param[in] dnear Distance to near clipping plane.
+ * @param[in] dfar Distance to far clipping plane.
+ *
+ */
+EOAPI void  evas_3d_camera_projection_frustum_set(Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+/**
+ *
+ * Set the projection matrix of the given camera with orthogonal projection.
+ *
+ * @see evas_3d_camera_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Camera
+ * 
+ *
+ * @param[in] left Left X coordinate of the near clipping plane.
+ * @param[in] right Right X coordinate of the near clipping plane..
+ * @param[in] bottom Bottom Y coordinate of the near clipping plane.
+ * @param[in] top Top Y coordinate of the near clipping plane
+ * @param[in] dnear Distance to near clipping plane.
+ * @param[in] dfar Distance to far clipping plane.
+ *
+ */
+EOAPI void  evas_3d_camera_projection_ortho_set(Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_camera.eo.hh b/src/lib/evas/canvas/evas_3d_camera.eo.hh
--- a/src/lib/evas/canvas/evas_3d_camera.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_camera.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,415 @@
+#ifndef EFL_GENERATED_EVAS_3D_CAMERA_HH
+#define EFL_GENERATED_EVAS_3D_CAMERA_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_camera.eo.h"
+}
+
+#include "evas_3d_object.eo.hh"
+#include "evas_common_interface.eo.hh"
+
+struct evas_3d_camera
+      : evas_3d_object,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_camera>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_camera(Eo* eo)
+      : evas_3d_object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_camera(std::nullptr_t)
+      : evas_3d_object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   evas_3d_camera(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_camera(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_camera(evas_3d_camera const& other)
+      : evas_3d_object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_camera() {}
+
+   /// @brief Pure virtual update_notify function..
+   /// Update request for the object.
+   ///
+   void update_notify() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update_notify());
+   }
+
+   /// @brief Pure virtual change_notify function..
+   /// Update request for the object.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+   }
+
+   /// @brief Set the projection matrix of the given camera.
+   ///
+   /// @param camera     The given camera.
+   /// @param matrix     Pointer to the array of 16 Evas_Real values in column major order.
+   ///
+   /// Default projection matrix is identity matrix.
+   ///
+   /// @see evas_3d_camera_projection_perspective_set()
+   /// @see evas_3d_camera_projection_ortho_set()
+   /// @see evas_3d_camera_projection_frustum_set()
+   ///
+   /// @ingroup Evas_3D_Camera
+   ///
+   /// @param matrix Projection Matrix
+   ///
+   void projection_matrix_set(const Evas_Real * matrix_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_camera_projection_matrix_set(matrix_));
+   }
+
+   /// @brief Get the projection matrix of the given camera.
+   ///
+   /// @param camera     The given camera.
+   /// @param matrix     Pointer to receive the 16 Evas_Real values in column major order.
+   ///
+   /// @see evas_3d_camera_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Camera
+   ///
+   /// @param[out] matrix Projection Matrix
+   ///
+   void projection_matrix_get(Evas_Real* matrix_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_camera_projection_matrix_get(matrix_));
+   }
+
+   /// @brief Set the projection matrix of the given camera with perspective projection.
+   ///
+   /// @param camera     The given camera.
+   /// @param fovy       Field of view angle in Y direction.
+   /// @param aspect     Aspect ratio.
+   /// @param dnear      Distance to near clipping plane.
+   /// @param dfar       Distance to far clipping plane.
+   ///
+   /// @see evas_3d_camera_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Camera
+   ///
+   /// @param fovy Field of view angle in Y direction.
+   /// @param aspect Aspect ratio.
+   /// @param dnear Distance to near clipping plane.
+   /// @param dfar Distance to far clipping plane.
+   ///
+   void projection_perspective_set(Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_camera_projection_perspective_set(fovy_, aspect_, dnear_, dfar_));
+   }
+
+   /// @brief Set the projection matrix of the given camera with frustum projection.
+   ///
+   /// @see evas_3d_camera_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Camera
+   ///
+   /// @param left Left X coordinate of the near clipping plane.
+   /// @param right Right X coordinate of the near clipping plane..
+   /// @param bottom Bottom Y coordinate of the near clipping plane.
+   /// @param top Top Y coordinate of the near clipping plane
+   /// @param dnear Distance to near clipping plane.
+   /// @param dfar Distance to far clipping plane.
+   ///
+   void projection_frustum_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_camera_projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_));
+   }
+
+   /// @brief Set the projection matrix of the given camera with orthogonal projection.
+   ///
+   /// @see evas_3d_camera_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Camera
+   ///
+   /// @param left Left X coordinate of the near clipping plane.
+   /// @param right Right X coordinate of the near clipping plane..
+   /// @param bottom Bottom Y coordinate of the near clipping plane.
+   /// @param top Top Y coordinate of the near clipping plane
+   /// @param dnear Distance to near clipping plane.
+   /// @param dfar Distance to far clipping plane.
+   ///
+   void projection_ortho_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_camera_projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_CAMERA_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_CAMERA_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _evas_3d_camera_update_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update_notify();
+}
+
+template <typename T>
+void _evas_3d_camera_change_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change_notify(state_, ref_);
+}
+
+template <typename T>
+void _evas_3d_camera_projection_matrix_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Evas_Real * matrix_)
+{
+   static_cast<T*>(self->this_)->projection_matrix_set(matrix_);
+}
+
+template <typename T>
+void _evas_3d_camera_projection_matrix_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* matrix_)
+{
+   static_cast<T*>(self->this_)->projection_matrix_get(matrix_);
+}
+
+template <typename T>
+void _evas_3d_camera_projection_perspective_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_)
+{
+   static_cast<T*>(self->this_)->projection_perspective_set(fovy_, aspect_, dnear_, dfar_);
+}
+
+template <typename T>
+void _evas_3d_camera_projection_frustum_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+{
+   static_cast<T*>(self->this_)->projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_);
+}
+
+template <typename T>
+void _evas_3d_camera_projection_ortho_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+{
+   static_cast<T*>(self->this_)->projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_camera >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void update_notify()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update_notify());
+      }
+
+      virtual void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      virtual void projection_matrix_set(const Evas_Real * matrix_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_camera_projection_matrix_set(matrix_));
+      }
+
+      virtual void projection_matrix_get(Evas_Real* matrix_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_camera_projection_matrix_get(matrix_));
+      }
+
+      virtual void projection_perspective_set(Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_camera_projection_perspective_set(fovy_, aspect_, dnear_, dfar_));
+      }
+
+      virtual void projection_frustum_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_camera_projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+      virtual void projection_ortho_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_camera_projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_camera >
+{
+   static const int value = 7;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_camera>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_camera_update_notify_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update_notify);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_camera_change_notify_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change_notify);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_camera_projection_matrix_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_camera_projection_matrix_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_camera_projection_matrix_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_camera_projection_matrix_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_camera_projection_perspective_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_camera_projection_perspective_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_camera_projection_frustum_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_camera_projection_frustum_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_evas_3d_camera_projection_ortho_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_3d_camera_projection_ortho_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_camera >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_camera, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::evas_3d_camera >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_camera, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_camera>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_camera() const
+      {
+         return ::evas_3d_camera(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void update_notify()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update_notify());
+      }
+
+      void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      void projection_matrix_set(const Evas_Real * matrix_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_camera_projection_matrix_set(matrix_));
+      }
+
+      void projection_matrix_get(Evas_Real* matrix_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_camera_projection_matrix_get(matrix_));
+      }
+
+      void projection_perspective_set(Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_camera_projection_perspective_set(fovy_, aspect_, dnear_, dfar_));
+      }
+
+      void projection_frustum_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_camera_projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+      void projection_ortho_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_camera_projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_camera>)
+{
+   return (EVAS_3D_CAMERA_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_CAMERA_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_camera.eo.legacy.h b/src/lib/evas/canvas/evas_3d_camera.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_camera.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_camera.eo.legacy.h	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_CAMERA_EO_LEGACY_H_
+#define _EVAS_3D_CAMERA_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_CAMERA_EO_CLASS_TYPE
+#define _EVAS_3D_CAMERA_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Camera;
+
+#endif
+
+#ifndef _EVAS_3D_CAMERA_EO_TYPES
+#define _EVAS_3D_CAMERA_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_light.eo.c b/src/lib/evas/canvas/evas_3d_light.eo.c
--- a/src/lib/evas/canvas/evas_3d_light.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_light.eo.c	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,138 @@
+
+void _evas_3d_light_directional_set(Eo *obj, Evas_3D_Light_Data *pd, Eina_Bool directional);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_directional_set, EO_FUNC_CALL(directional), Eina_Bool directional);
+
+Eina_Bool _evas_3d_light_directional_get(Eo *obj, Evas_3D_Light_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_light_directional_get, Eina_Bool, 0);
+
+void _evas_3d_light_spot_exponent_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real exponent);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_spot_exponent_set, EO_FUNC_CALL(exponent), Evas_Real exponent);
+
+Evas_Real _evas_3d_light_spot_exponent_get(Eo *obj, Evas_3D_Light_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_light_spot_exponent_get, Evas_Real, 0);
+
+void _evas_3d_light_spot_cutoff_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real cutoff);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_spot_cutoff_set, EO_FUNC_CALL(cutoff), Evas_Real cutoff);
+
+Evas_Real _evas_3d_light_spot_cutoff_get(Eo *obj, Evas_3D_Light_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_light_spot_cutoff_get, Evas_Real, 0);
+
+void _evas_3d_light_attenuation_enable_set(Eo *obj, Evas_3D_Light_Data *pd, Eina_Bool enable);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_attenuation_enable_set, EO_FUNC_CALL(enable), Eina_Bool enable);
+
+Eina_Bool _evas_3d_light_attenuation_enable_get(Eo *obj, Evas_3D_Light_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_light_attenuation_enable_get, Eina_Bool, 0);
+
+void _evas_3d_light_ambient_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_ambient_set, EO_FUNC_CALL(r, g, b, a), Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+void _evas_3d_light_ambient_get(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_ambient_get, EO_FUNC_CALL(r, g, b, a), Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+void _evas_3d_light_diffuse_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_diffuse_set, EO_FUNC_CALL(r, g, b, a), Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+void _evas_3d_light_diffuse_get(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_diffuse_get, EO_FUNC_CALL(r, g, b, a), Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+void _evas_3d_light_specular_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_specular_set, EO_FUNC_CALL(r, g, b, a), Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+void _evas_3d_light_specular_get(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_specular_get, EO_FUNC_CALL(r, g, b, a), Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+void _evas_3d_light_attenuation_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real constant, Evas_Real linear, Evas_Real quadratic);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_attenuation_set, EO_FUNC_CALL(constant, linear, quadratic), Evas_Real constant, Evas_Real linear, Evas_Real quadratic);
+
+void _evas_3d_light_attenuation_get(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real *constant, Evas_Real *linear, Evas_Real *quadratic);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_attenuation_get, EO_FUNC_CALL(constant, linear, quadratic), Evas_Real *constant, Evas_Real *linear, Evas_Real *quadratic);
+
+void _evas_3d_light_projection_matrix_set(Eo *obj, Evas_3D_Light_Data *pd, const Evas_Real *matrix);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_projection_matrix_set, EO_FUNC_CALL(matrix), const Evas_Real *matrix);
+
+void _evas_3d_light_projection_matrix_get(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real *matrix);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_projection_matrix_get, EO_FUNC_CALL(matrix), Evas_Real *matrix);
+
+void _evas_3d_light_projection_perspective_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real fovy, Evas_Real aspect, Evas_Real dnear, Evas_Real dfar);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_projection_perspective_set, EO_FUNC_CALL(fovy, aspect, dnear, dfar), Evas_Real fovy, Evas_Real aspect, Evas_Real dnear, Evas_Real dfar);
+
+void _evas_3d_light_projection_frustum_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_projection_frustum_set, EO_FUNC_CALL(left, right, bottom, top, dnear, dfar), Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+void _evas_3d_light_projection_ortho_set(Eo *obj, Evas_3D_Light_Data *pd, Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_light_projection_ortho_set, EO_FUNC_CALL(left, right, bottom, top, dnear, dfar), Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+void _evas_3d_light_eo_base_constructor(Eo *obj, Evas_3D_Light_Data *pd);
+
+
+void _evas_3d_light_eo_base_destructor(Eo *obj, Evas_3D_Light_Data *pd);
+
+
+void _evas_3d_light_evas_3d_object_update_notify(Eo *obj, Evas_3D_Light_Data *pd);
+
+
+void _evas_3d_light_evas_3d_object_change_notify(Eo *obj, Evas_3D_Light_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+
+static Eo_Op_Description _evas_3d_light_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_3d_light_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_3d_light_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_update_notify, _evas_3d_light_evas_3d_object_update_notify),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_change_notify, _evas_3d_light_evas_3d_object_change_notify),
+     EO_OP_FUNC(evas_3d_light_directional_set, _evas_3d_light_directional_set, "Set the directional flag of the given light."),
+     EO_OP_FUNC(evas_3d_light_directional_get, _evas_3d_light_directional_get, "Get the directional flag of the given light."),
+     EO_OP_FUNC(evas_3d_light_spot_exponent_set, _evas_3d_light_spot_exponent_set, "Set the spot exponent of the given light."),
+     EO_OP_FUNC(evas_3d_light_spot_exponent_get, _evas_3d_light_spot_exponent_get, "Get the spot exponent of the given light."),
+     EO_OP_FUNC(evas_3d_light_spot_cutoff_set, _evas_3d_light_spot_cutoff_set, "Set the spot cutoff angle of the given light."),
+     EO_OP_FUNC(evas_3d_light_spot_cutoff_get, _evas_3d_light_spot_cutoff_get, "Get the spot cutoff angle of the given light."),
+     EO_OP_FUNC(evas_3d_light_attenuation_enable_set, _evas_3d_light_attenuation_enable_set, "Set the attenuation enable flag of the given light."),
+     EO_OP_FUNC(evas_3d_light_attenuation_enable_get, _evas_3d_light_attenuation_enable_get, "Get the attenuation enable flag of the given light."),
+     EO_OP_FUNC(evas_3d_light_ambient_set, _evas_3d_light_ambient_set, "Set the ambient color of the given light."),
+     EO_OP_FUNC(evas_3d_light_ambient_get, _evas_3d_light_ambient_get, "Get the ambient color of the given light."),
+     EO_OP_FUNC(evas_3d_light_diffuse_set, _evas_3d_light_diffuse_set, "Set the diffuse color of the given light."),
+     EO_OP_FUNC(evas_3d_light_diffuse_get, _evas_3d_light_diffuse_get, "Get the diffuse color of the given light."),
+     EO_OP_FUNC(evas_3d_light_specular_set, _evas_3d_light_specular_set, "Set the specular color of the given light."),
+     EO_OP_FUNC(evas_3d_light_specular_get, _evas_3d_light_specular_get, "Get the specular color of the given light."),
+     EO_OP_FUNC(evas_3d_light_attenuation_set, _evas_3d_light_attenuation_set, "Set the attenuation of the given light."),
+     EO_OP_FUNC(evas_3d_light_attenuation_get, _evas_3d_light_attenuation_get, "Get the attenuation of the given light."),
+     EO_OP_FUNC(evas_3d_light_projection_matrix_set, _evas_3d_light_projection_matrix_set, "Set the projection matrix of the given light source."),
+     EO_OP_FUNC(evas_3d_light_projection_matrix_get, _evas_3d_light_projection_matrix_get, "Get the projection matrix of the given light source."),
+     EO_OP_FUNC(evas_3d_light_projection_perspective_set, _evas_3d_light_projection_perspective_set, "Set the projection matrix of the given light source with perspective projection."),
+     EO_OP_FUNC(evas_3d_light_projection_frustum_set, _evas_3d_light_projection_frustum_set, "Set the projection matrix of the given light source with frustum projection."),
+     EO_OP_FUNC(evas_3d_light_projection_ortho_set, _evas_3d_light_projection_ortho_set, "Set the projection matrix of the given light source with orthogonal projection."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_light_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Light",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_light_op_desc),
+     NULL,
+     sizeof(Evas_3D_Light_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_light_class_get, &_evas_3d_light_class_desc, EVAS_3D_OBJECT_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_light.eo.h b/src/lib/evas/canvas/evas_3d_light.eo.h
--- a/src/lib/evas/canvas/evas_3d_light.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_light.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,380 @@
+#ifndef _EVAS_3D_LIGHT_EO_H_
+#define _EVAS_3D_LIGHT_EO_H_
+
+#ifndef _EVAS_3D_LIGHT_EO_CLASS_TYPE
+#define _EVAS_3D_LIGHT_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Light;
+
+#endif
+
+#ifndef _EVAS_3D_LIGHT_EO_TYPES
+#define _EVAS_3D_LIGHT_EO_TYPES
+
+
+#endif
+#define EVAS_3D_LIGHT_CLASS evas_3d_light_class_get()
+
+const Eo_Class *evas_3d_light_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Set the directional flag of the given light.
+ *
+ * Directional light is a type of light which is infinitely far away with no
+ * attenuation. The light direction is determined by the containing node's
+ * forward vector (negative Z-axis).
+ *
+ * By default, directional is not enabled.
+ *
+ * @see evas_3d_node_look_at_set()
+ *
+ * @ingroup Evas_3D_Light
+ *
+ * @param[in] directional Whether the light is directional (@c EINA_TRUE), or not (@c EINA_FALSE).
+ *
+ */
+EOAPI void  evas_3d_light_directional_set(Eina_Bool directional);
+
+/**
+ *
+ * Get the directional flag of the given light.
+ *
+ * @see evas_3d_light_directional_set()
+ *
+ * @ingroup Evas_3D_Light
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_light_directional_get(void);
+
+/**
+ *
+ * Set the spot exponent of the given light.
+ *
+ * Higher spot exponent means intensity at the center of the cone is relatively
+ * stronger. Zero exponent means the light intensity is evenly distibuted. The
+ * spot exponent has no effect when the light is not spot light (spot cutoff
+ * angle is less than 180 degree).
+ *
+ * Default spot exponent is 0.
+ *
+ * @see evas_3d_light_spot_cutoff_set()
+ *
+ * @ingroup Evas_3D_Light
+ *
+ * @param[in] exponent Spot exponent value..
+ *
+ */
+EOAPI void  evas_3d_light_spot_exponent_set(Evas_Real exponent);
+
+/**
+ *
+ * Get the spot exponent of the given light.
+ *
+ * @see evas_3d_light_spot_exponent_set()
+ *
+ * @ingroup Evas_3D_Light
+ *
+ *
+ */
+EOAPI Evas_Real  evas_3d_light_spot_exponent_get(void);
+
+/**
+ *
+ * Set the spot cutoff angle of the given light.
+ *
+ * Only angle less than 180 degree will make it spot light, so that other spot
+ * light attribute will take effect.
+ *
+ * Default spot cutoff angle is 180.
+ *
+ * @ingroup Evas_3D_Light
+ *
+ * @param[in] cutoff Cutoff angle in degree..
+ *
+ */
+EOAPI void  evas_3d_light_spot_cutoff_set(Evas_Real cutoff);
+
+/**
+ *
+ * Get the spot cutoff angle of the given light.
+ *
+ * @see evas_3d_light_spot_cutoff_set()
+ *
+ * @ingroup Evas_3D_Light
+ *
+ *
+ */
+EOAPI Evas_Real  evas_3d_light_spot_cutoff_get(void);
+
+/**
+ *
+ * Set the attenuation enable flag of the given light.
+ *
+ * By default, light attenuation is not enabled.
+ *
+ * @see evas_3d_light_attenuation_set()
+ *
+ * @ingroup Evas_3D_Light
+ *
+ * @param[in] enable Whether to enable attenuation (@c EINA_TRUE), or not (@c EINA_FALSE)..
+ *
+ */
+EOAPI void  evas_3d_light_attenuation_enable_set(Eina_Bool enable);
+
+/**
+ *
+ * Get the attenuation enable flag of the given light.
+ *
+ * @see evas_3d_light_attenuation_enable_set()
+ *
+ * @ingroup Evas_3D_Light
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_light_attenuation_enable_get(void);
+
+/**
+ *
+ * Set the ambient color of the given light.
+ *
+ * Default ambient color is (0.0, 0.0, 0.0, 1.0).
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] r Red component of the ambient color between [0.0, 1.0].
+ * @param[in] g Green component of the ambient color between [0.0, 1.0].
+ * @param[in] b Blue component of the ambient color between [0.0, 1.0].
+ * @param[in] a Alpha component of the ambient color between [0.0, 1.0].
+ *
+ */
+EOAPI void  evas_3d_light_ambient_set(Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+/**
+ *
+ * Get the ambient color of the given light.
+ *
+ * @see evas_3d_light_ambient_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[out] r Red component of the ambient color between [0.0, 1.0].
+ * @param[out] g Green component of the ambient color between [0.0, 1.0].
+ * @param[out] b Blue component of the ambient color between [0.0, 1.0].
+ * @param[out] a Alpha component of the ambient color between [0.0, 1.0].
+ *
+ */
+EOAPI void  evas_3d_light_ambient_get(Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+/**
+ *
+ * Set the diffuse color of the given light.
+ *
+ * Default diffuse color is (1.0, 1.0, 1.0, 1.0).
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] r Red component of the diffuse color between [0.0, 1.0].
+ * @param[in] g Green component of the diffuse color between [0.0, 1.0].
+ * @param[in] b Blue component of the diffuse color between [0.0, 1.0].
+ * @param[in] a Alpha component of the diffuse color between [0.0, 1.0].
+ *
+ */
+EOAPI void  evas_3d_light_diffuse_set(Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+/**
+ *
+ * Get the diffuse color of the given light.
+ *
+ * @see evas_3d_light_diffuse_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[out] r Red component of the diffuse color between [0.0, 1.0].
+ * @param[out] g Green component of the diffuse color between [0.0, 1.0].
+ * @param[out] b Blue component of the diffuse color between [0.0, 1.0].
+ * @param[out] a Alpha component of the diffuse color between [0.0, 1.0].
+ *
+ */
+EOAPI void  evas_3d_light_diffuse_get(Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+/**
+ *
+ * Set the specular color of the given light.
+ *
+ * Default specular color is (1.0, 1.0, 1.0, 1.0).
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] r Red component of the specular color between [0.0, 1.0].
+ * @param[in] g Green component of the specular color between [0.0, 1.0].
+ * @param[in] b Blue component of the specular color between [0.0, 1.0].
+ * @param[in] a Alpha component of the specular color between [0.0, 1.0].
+ *
+ */
+EOAPI void  evas_3d_light_specular_set(Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+/**
+ *
+ * Get the specular color of the given light.
+ *
+ * @see evas_3d_light_specular_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[out] r Red component of the specular color between [0.0, 1.0].
+ * @param[out] g Green component of the specular color between [0.0, 1.0].
+ * @param[out] b Blue component of the specular color between [0.0, 1.0].
+ * @param[out] a Alpha component of the specular color between [0.0, 1.0].
+ *
+ */
+EOAPI void  evas_3d_light_specular_get(Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+/**
+ *
+ * Set the attenuation of the given light.
+ *
+ * Light attenuation has no effect with directional light. And the attenuation
+ * should be enabled first to take effect. The attenuation factor is calculated
+ * as follows.
+ *
+ * atten = 1.0 / constant + linear * distance + quadratic * distance * distance
+ *
+ * Default attenuation is constant = 1.0, linear = 0.0, quadratic = 0.0.
+ *
+ * @see evas_3d_light_attenuation_enable_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] constant Constant attenuation term..
+ * @param[in] linear Linear attenuation term..
+ * @param[in] quadratic Quadratic attenuation term..
+ *
+ */
+EOAPI void  evas_3d_light_attenuation_set(Evas_Real constant, Evas_Real linear, Evas_Real quadratic);
+
+/**
+ *
+ * Get the attenuation of the given light.
+ *
+ * @see evas_3d_light_attenuation_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[out] constant Constant attenuation term..
+ * @param[out] linear Linear attenuation term..
+ * @param[out] quadratic Quadratic attenuation term..
+ *
+ */
+EOAPI void  evas_3d_light_attenuation_get(Evas_Real *constant, Evas_Real *linear, Evas_Real *quadratic);
+
+/**
+ *
+ * Set the projection matrix of the given light source.
+ *
+ * @param light The given light source.
+ * @param matrix Pointer to the array of 16 Evas_Real values in column major order.
+ *
+ * Default projection matrix is identity matrix.
+ *
+ * @see evas_3d_light_projection_perspective_set()
+ * @see evas_3d_light_projection_ortho_set()
+ * @see evas_3d_light_projection_frustum_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] matrix Projection Matrix
+ *
+ */
+EOAPI void  evas_3d_light_projection_matrix_set(const Evas_Real *matrix);
+
+/**
+ *
+ * Get the projection matrix of the given light source.
+ *
+ * @param light The given light source.
+ * @param matrix Pointer to receive the 16 Evas_Real values in column major order.
+ *
+ * @see evas_3d_light_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[out] matrix Projection Matrix
+ *
+ */
+EOAPI void  evas_3d_light_projection_matrix_get(Evas_Real *matrix);
+
+/**
+ *
+ * Set the projection matrix of the given light source with perspective projection.
+ *
+ * @param light The given light source.
+ * @param fovy Field of view angle in Y direction.
+ * @param aspect Aspect ratio.
+ * @param dnear Distance to near clipping plane.
+ * @param dfar Distance to far clipping plane.
+ *
+ * @see evas_3d_light_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] fovy Field of view angle in Y direction.
+ * @param[in] aspect Aspect ratio.
+ * @param[in] dnear Distance to near clipping plane.
+ * @param[in] dfar Distance to far clipping plane.
+ *
+ */
+EOAPI void  evas_3d_light_projection_perspective_set(Evas_Real fovy, Evas_Real aspect, Evas_Real dnear, Evas_Real dfar);
+
+/**
+ *
+ * Set the projection matrix of the given light source with frustum projection.
+ *
+ * @see evas_3d_Light_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] left Left X coordinate of the near clipping plane.
+ * @param[in] right Right X coordinate of the near clipping plane..
+ * @param[in] bottom Bottom Y coordinate of the near clipping plane.
+ * @param[in] top Top Y coordinate of the near clipping plane
+ * @param[in] dnear Distance to near clipping plane.
+ * @param[in] dfar Distance to far clipping plane.
+ *
+ */
+EOAPI void  evas_3d_light_projection_frustum_set(Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+/**
+ *
+ * Set the projection matrix of the given light source with orthogonal projection.
+ *
+ * @see evas_3d_light_projection_matrix_set()
+ *
+ * @ingroup Evas_3D_Light
+ * 
+ *
+ * @param[in] left Left X coordinate of the near clipping plane.
+ * @param[in] right Right X coordinate of the near clipping plane..
+ * @param[in] bottom Bottom Y coordinate of the near clipping plane.
+ * @param[in] top Top Y coordinate of the near clipping plane
+ * @param[in] dnear Distance to near clipping plane.
+ * @param[in] dfar Distance to far clipping plane.
+ *
+ */
+EOAPI void  evas_3d_light_projection_ortho_set(Evas_Real left, Evas_Real right, Evas_Real bottom, Evas_Real top, Evas_Real dnear, Evas_Real dfar);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_light.eo.hh b/src/lib/evas/canvas/evas_3d_light.eo.hh
--- a/src/lib/evas/canvas/evas_3d_light.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_light.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,1079 @@
+#ifndef EFL_GENERATED_EVAS_3D_LIGHT_HH
+#define EFL_GENERATED_EVAS_3D_LIGHT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_light.eo.h"
+}
+
+#include "evas_3d_object.eo.hh"
+#include "evas_common_interface.eo.hh"
+
+struct evas_3d_light
+      : evas_3d_object,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_light>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_light(Eo* eo)
+      : evas_3d_object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_light(std::nullptr_t)
+      : evas_3d_object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   evas_3d_light(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_light(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_light(evas_3d_light const& other)
+      : evas_3d_object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_light() {}
+
+   /// @brief Pure virtual update_notify function..
+   /// Update request for the object.
+   ///
+   void update_notify() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update_notify());
+   }
+
+   /// @brief Pure virtual change_notify function..
+   /// Update request for the object.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+   }
+
+   /// @brief Get the directional flag of the given light.
+   ///
+   /// @see evas_3d_light_directional_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param directional Whether the light is directional (@c EINA_TRUE), or not (@c EINA_FALSE).
+   ///
+   bool directional_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_light_directional_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the directional flag of the given light.
+   ///
+   /// Directional light is a type of light which is infinitely far away with no
+   /// attenuation. The light direction is determined by the containing node's
+   /// forward vector (negative Z-axis).
+   ///
+   /// By default, directional is not enabled.
+   ///
+   /// @see evas_3d_node_look_at_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param directional Whether the light is directional (@c EINA_TRUE), or not (@c EINA_FALSE).
+   ///
+   void directional_set(bool directional_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_directional_set(efl::eolian::to_c(directional_)));
+   }
+
+   /// @brief Get the spot exponent of the given light.
+   ///
+   /// @see evas_3d_light_spot_exponent_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param exponent Spot exponent value..
+   ///
+   Evas_Real spot_exponent_get() const
+   {
+      Evas_Real _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_light_spot_exponent_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the spot exponent of the given light.
+   ///
+   /// Higher spot exponent means intensity at the center of the cone is relatively
+   /// stronger. Zero exponent means the light intensity is evenly distibuted. The
+   /// spot exponent has no effect when the light is not spot light (spot cutoff
+   /// angle is less than 180 degree).
+   ///
+   /// Default spot exponent is 0.
+   ///
+   /// @see evas_3d_light_spot_cutoff_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param exponent Spot exponent value..
+   ///
+   void spot_exponent_set(Evas_Real exponent_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_spot_exponent_set(exponent_));
+   }
+
+   /// @brief Get the spot cutoff angle of the given light.
+   ///
+   /// @see evas_3d_light_spot_cutoff_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param cutoff Cutoff angle in degree..
+   ///
+   Evas_Real spot_cutoff_get() const
+   {
+      Evas_Real _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_light_spot_cutoff_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the spot cutoff angle of the given light.
+   ///
+   /// Only angle less than 180 degree will make it spot light, so that other spot
+   /// light attribute will take effect.
+   ///
+   /// Default spot cutoff angle is 180.
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param cutoff Cutoff angle in degree..
+   ///
+   void spot_cutoff_set(Evas_Real cutoff_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_spot_cutoff_set(cutoff_));
+   }
+
+   /// @brief Get the attenuation enable flag of the given light.
+   ///
+   /// @see evas_3d_light_attenuation_enable_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param enable Whether to enable attenuation (@c EINA_TRUE), or not (@c EINA_FALSE)..
+   ///
+   bool attenuation_enable_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_light_attenuation_enable_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the attenuation enable flag of the given light.
+   ///
+   /// By default, light attenuation is not enabled.
+   ///
+   /// @see evas_3d_light_attenuation_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param enable Whether to enable attenuation (@c EINA_TRUE), or not (@c EINA_FALSE)..
+   ///
+   void attenuation_enable_set(bool enable_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_attenuation_enable_set(efl::eolian::to_c(enable_)));
+   }
+
+   /// @brief Set the ambient color of the given light.
+   ///
+   /// Default ambient color is (0.0, 0.0, 0.0, 1.0).
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param r Red component of the ambient color between [0.0, 1.0].
+   /// @param g Green component of the ambient color between [0.0, 1.0].
+   /// @param b Blue component of the ambient color between [0.0, 1.0].
+   /// @param a Alpha component of the ambient color between [0.0, 1.0].
+   ///
+   void ambient_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_ambient_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Get the ambient color of the given light.
+   ///
+   /// @see evas_3d_light_ambient_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param[out] r Red component of the ambient color between [0.0, 1.0].
+   /// @param[out] g Green component of the ambient color between [0.0, 1.0].
+   /// @param[out] b Blue component of the ambient color between [0.0, 1.0].
+   /// @param[out] a Alpha component of the ambient color between [0.0, 1.0].
+   ///
+   void ambient_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_ambient_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Set the diffuse color of the given light.
+   ///
+   /// Default diffuse color is (1.0, 1.0, 1.0, 1.0).
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param r Red component of the diffuse color between [0.0, 1.0].
+   /// @param g Green component of the diffuse color between [0.0, 1.0].
+   /// @param b Blue component of the diffuse color between [0.0, 1.0].
+   /// @param a Alpha component of the diffuse color between [0.0, 1.0].
+   ///
+   void diffuse_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_diffuse_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Get the diffuse color of the given light.
+   ///
+   /// @see evas_3d_light_diffuse_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param[out] r Red component of the diffuse color between [0.0, 1.0].
+   /// @param[out] g Green component of the diffuse color between [0.0, 1.0].
+   /// @param[out] b Blue component of the diffuse color between [0.0, 1.0].
+   /// @param[out] a Alpha component of the diffuse color between [0.0, 1.0].
+   ///
+   void diffuse_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_diffuse_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Set the specular color of the given light.
+   ///
+   /// Default specular color is (1.0, 1.0, 1.0, 1.0).
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param r Red component of the specular color between [0.0, 1.0].
+   /// @param g Green component of the specular color between [0.0, 1.0].
+   /// @param b Blue component of the specular color between [0.0, 1.0].
+   /// @param a Alpha component of the specular color between [0.0, 1.0].
+   ///
+   void specular_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_specular_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Get the specular color of the given light.
+   ///
+   /// @see evas_3d_light_specular_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param[out] r Red component of the specular color between [0.0, 1.0].
+   /// @param[out] g Green component of the specular color between [0.0, 1.0].
+   /// @param[out] b Blue component of the specular color between [0.0, 1.0].
+   /// @param[out] a Alpha component of the specular color between [0.0, 1.0].
+   ///
+   void specular_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_specular_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Set the attenuation of the given light.
+   ///
+   /// Light attenuation has no effect with directional light. And the attenuation
+   /// should be enabled first to take effect. The attenuation factor is calculated
+   /// as follows.
+   ///
+   /// atten = 1.0 / constant + linear * distance + quadratic * distance * distance
+   ///
+   /// Default attenuation is constant = 1.0, linear = 0.0, quadratic = 0.0.
+   ///
+   /// @see evas_3d_light_attenuation_enable_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param constant Constant attenuation term..
+   /// @param linear Linear attenuation term..
+   /// @param quadratic Quadratic attenuation term..
+   ///
+   void attenuation_set(Evas_Real constant_, Evas_Real linear_, Evas_Real quadratic_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_attenuation_set(constant_, linear_, quadratic_));
+   }
+
+   /// @brief Get the attenuation of the given light.
+   ///
+   /// @see evas_3d_light_attenuation_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param[out] constant Constant attenuation term..
+   /// @param[out] linear Linear attenuation term..
+   /// @param[out] quadratic Quadratic attenuation term..
+   ///
+   void attenuation_get(Evas_Real* constant_, Evas_Real* linear_, Evas_Real* quadratic_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_attenuation_get(constant_, linear_, quadratic_));
+   }
+
+   /// @brief Set the projection matrix of the given light source.
+   ///
+   /// @param light The given light source.
+   /// @param matrix Pointer to the array of 16 Evas_Real values in column major order.
+   ///
+   /// Default projection matrix is identity matrix.
+   ///
+   /// @see evas_3d_light_projection_perspective_set()
+   /// @see evas_3d_light_projection_ortho_set()
+   /// @see evas_3d_light_projection_frustum_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param matrix Projection Matrix
+   ///
+   void projection_matrix_set(const Evas_Real * matrix_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_projection_matrix_set(matrix_));
+   }
+
+   /// @brief Get the projection matrix of the given light source.
+   ///
+   /// @param light The given light source.
+   /// @param matrix Pointer to receive the 16 Evas_Real values in column major order.
+   ///
+   /// @see evas_3d_light_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param[out] matrix Projection Matrix
+   ///
+   void projection_matrix_get(Evas_Real* matrix_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_projection_matrix_get(matrix_));
+   }
+
+   /// @brief Set the projection matrix of the given light source with perspective projection.
+   ///
+   /// @param light The given light source.
+   /// @param fovy Field of view angle in Y direction.
+   /// @param aspect Aspect ratio.
+   /// @param dnear Distance to near clipping plane.
+   /// @param dfar Distance to far clipping plane.
+   ///
+   /// @see evas_3d_light_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param fovy Field of view angle in Y direction.
+   /// @param aspect Aspect ratio.
+   /// @param dnear Distance to near clipping plane.
+   /// @param dfar Distance to far clipping plane.
+   ///
+   void projection_perspective_set(Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_projection_perspective_set(fovy_, aspect_, dnear_, dfar_));
+   }
+
+   /// @brief Set the projection matrix of the given light source with frustum projection.
+   ///
+   /// @see evas_3d_Light_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param left Left X coordinate of the near clipping plane.
+   /// @param right Right X coordinate of the near clipping plane..
+   /// @param bottom Bottom Y coordinate of the near clipping plane.
+   /// @param top Top Y coordinate of the near clipping plane
+   /// @param dnear Distance to near clipping plane.
+   /// @param dfar Distance to far clipping plane.
+   ///
+   void projection_frustum_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_));
+   }
+
+   /// @brief Set the projection matrix of the given light source with orthogonal projection.
+   ///
+   /// @see evas_3d_light_projection_matrix_set()
+   ///
+   /// @ingroup Evas_3D_Light
+   ///
+   /// @param left Left X coordinate of the near clipping plane.
+   /// @param right Right X coordinate of the near clipping plane..
+   /// @param bottom Bottom Y coordinate of the near clipping plane.
+   /// @param top Top Y coordinate of the near clipping plane
+   /// @param dnear Distance to near clipping plane.
+   /// @param dfar Distance to far clipping plane.
+   ///
+   void projection_ortho_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_light_projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_LIGHT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_LIGHT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _evas_3d_light_update_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update_notify();
+}
+
+template <typename T>
+void _evas_3d_light_change_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change_notify(state_, ref_);
+}
+
+template <typename T>
+bool _evas_3d_light_directional_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->directional_get();
+}
+
+template <typename T>
+void _evas_3d_light_directional_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool directional_)
+{
+   static_cast<T*>(self->this_)->directional_set(efl::eolian::to_cxx<bool>(directional_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Real _evas_3d_light_spot_exponent_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->spot_exponent_get();
+}
+
+template <typename T>
+void _evas_3d_light_spot_exponent_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real exponent_)
+{
+   static_cast<T*>(self->this_)->spot_exponent_set(exponent_);
+}
+
+template <typename T>
+Evas_Real _evas_3d_light_spot_cutoff_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->spot_cutoff_get();
+}
+
+template <typename T>
+void _evas_3d_light_spot_cutoff_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real cutoff_)
+{
+   static_cast<T*>(self->this_)->spot_cutoff_set(cutoff_);
+}
+
+template <typename T>
+bool _evas_3d_light_attenuation_enable_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->attenuation_enable_get();
+}
+
+template <typename T>
+void _evas_3d_light_attenuation_enable_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool enable_)
+{
+   static_cast<T*>(self->this_)->attenuation_enable_set(efl::eolian::to_cxx<bool>(enable_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void _evas_3d_light_ambient_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+{
+   static_cast<T*>(self->this_)->ambient_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_light_ambient_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+{
+   static_cast<T*>(self->this_)->ambient_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_light_diffuse_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+{
+   static_cast<T*>(self->this_)->diffuse_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_light_diffuse_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+{
+   static_cast<T*>(self->this_)->diffuse_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_light_specular_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+{
+   static_cast<T*>(self->this_)->specular_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_light_specular_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+{
+   static_cast<T*>(self->this_)->specular_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_light_attenuation_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real constant_, Evas_Real linear_, Evas_Real quadratic_)
+{
+   static_cast<T*>(self->this_)->attenuation_set(constant_, linear_, quadratic_);
+}
+
+template <typename T>
+void _evas_3d_light_attenuation_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* constant_, Evas_Real* linear_, Evas_Real* quadratic_)
+{
+   static_cast<T*>(self->this_)->attenuation_get(constant_, linear_, quadratic_);
+}
+
+template <typename T>
+void _evas_3d_light_projection_matrix_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Evas_Real * matrix_)
+{
+   static_cast<T*>(self->this_)->projection_matrix_set(matrix_);
+}
+
+template <typename T>
+void _evas_3d_light_projection_matrix_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* matrix_)
+{
+   static_cast<T*>(self->this_)->projection_matrix_get(matrix_);
+}
+
+template <typename T>
+void _evas_3d_light_projection_perspective_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_)
+{
+   static_cast<T*>(self->this_)->projection_perspective_set(fovy_, aspect_, dnear_, dfar_);
+}
+
+template <typename T>
+void _evas_3d_light_projection_frustum_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+{
+   static_cast<T*>(self->this_)->projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_);
+}
+
+template <typename T>
+void _evas_3d_light_projection_ortho_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+{
+   static_cast<T*>(self->this_)->projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_light >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void update_notify()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update_notify());
+      }
+
+      virtual void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      virtual bool directional_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_light_directional_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void directional_set(bool directional_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_directional_set(efl::eolian::to_c(directional_)));
+      }
+
+      virtual Evas_Real spot_exponent_get()
+      {
+         Evas_Real _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_light_spot_exponent_get());
+            return _tmp_ret;
+      }
+
+      virtual void spot_exponent_set(Evas_Real exponent_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_spot_exponent_set(exponent_));
+      }
+
+      virtual Evas_Real spot_cutoff_get()
+      {
+         Evas_Real _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_light_spot_cutoff_get());
+            return _tmp_ret;
+      }
+
+      virtual void spot_cutoff_set(Evas_Real cutoff_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_spot_cutoff_set(cutoff_));
+      }
+
+      virtual bool attenuation_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_light_attenuation_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void attenuation_enable_set(bool enable_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_attenuation_enable_set(efl::eolian::to_c(enable_)));
+      }
+
+      virtual void ambient_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_ambient_set(r_, g_, b_, a_));
+      }
+
+      virtual void ambient_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_ambient_get(r_, g_, b_, a_));
+      }
+
+      virtual void diffuse_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_diffuse_set(r_, g_, b_, a_));
+      }
+
+      virtual void diffuse_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_diffuse_get(r_, g_, b_, a_));
+      }
+
+      virtual void specular_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_specular_set(r_, g_, b_, a_));
+      }
+
+      virtual void specular_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_specular_get(r_, g_, b_, a_));
+      }
+
+      virtual void attenuation_set(Evas_Real constant_, Evas_Real linear_, Evas_Real quadratic_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_attenuation_set(constant_, linear_, quadratic_));
+      }
+
+      virtual void attenuation_get(Evas_Real* constant_, Evas_Real* linear_, Evas_Real* quadratic_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_attenuation_get(constant_, linear_, quadratic_));
+      }
+
+      virtual void projection_matrix_set(const Evas_Real * matrix_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_projection_matrix_set(matrix_));
+      }
+
+      virtual void projection_matrix_get(Evas_Real* matrix_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_projection_matrix_get(matrix_));
+      }
+
+      virtual void projection_perspective_set(Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_projection_perspective_set(fovy_, aspect_, dnear_, dfar_));
+      }
+
+      virtual void projection_frustum_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+      virtual void projection_ortho_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_light_projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_light >
+{
+   static const int value = 23;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_light>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_light_update_notify_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update_notify);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_light_change_notify_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change_notify);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_light_directional_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_light_directional_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_light_directional_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_light_directional_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_light_spot_exponent_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_light_spot_exponent_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_light_spot_exponent_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_light_spot_exponent_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_evas_3d_light_spot_cutoff_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_3d_light_spot_cutoff_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_evas_3d_light_spot_cutoff_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_3d_light_spot_cutoff_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_evas_3d_light_attenuation_enable_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_3d_light_attenuation_enable_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_evas_3d_light_attenuation_enable_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_3d_light_attenuation_enable_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::_evas_3d_light_ambient_set_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_3d_light_ambient_set);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::_evas_3d_light_ambient_get_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_3d_light_ambient_get);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::_evas_3d_light_diffuse_set_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_3d_light_diffuse_set);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::_evas_3d_light_diffuse_get_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_3d_light_diffuse_get);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::_evas_3d_light_specular_set_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_3d_light_specular_set);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::_evas_3d_light_specular_get_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_3d_light_specular_get);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::_evas_3d_light_attenuation_set_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_3d_light_attenuation_set);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::_evas_3d_light_attenuation_get_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_3d_light_attenuation_get);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::_evas_3d_light_projection_matrix_set_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_3d_light_projection_matrix_set);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::_evas_3d_light_projection_matrix_get_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_3d_light_projection_matrix_get);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::_evas_3d_light_projection_perspective_set_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_3d_light_projection_perspective_set);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::_evas_3d_light_projection_frustum_set_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_3d_light_projection_frustum_set);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::_evas_3d_light_projection_ortho_set_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_3d_light_projection_ortho_set);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_light >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_light, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::evas_3d_light >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_light, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_light>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_light() const
+      {
+         return ::evas_3d_light(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void update_notify()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update_notify());
+      }
+
+      void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      bool directional_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_light_directional_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void directional_set(bool directional_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_directional_set(efl::eolian::to_c(directional_)));
+      }
+
+      Evas_Real spot_exponent_get()
+      {
+         Evas_Real _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_light_spot_exponent_get());
+            return _tmp_ret;
+      }
+
+      void spot_exponent_set(Evas_Real exponent_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_spot_exponent_set(exponent_));
+      }
+
+      Evas_Real spot_cutoff_get()
+      {
+         Evas_Real _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_light_spot_cutoff_get());
+            return _tmp_ret;
+      }
+
+      void spot_cutoff_set(Evas_Real cutoff_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_spot_cutoff_set(cutoff_));
+      }
+
+      bool attenuation_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_light_attenuation_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void attenuation_enable_set(bool enable_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_attenuation_enable_set(efl::eolian::to_c(enable_)));
+      }
+
+      void ambient_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_ambient_set(r_, g_, b_, a_));
+      }
+
+      void ambient_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_ambient_get(r_, g_, b_, a_));
+      }
+
+      void diffuse_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_diffuse_set(r_, g_, b_, a_));
+      }
+
+      void diffuse_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_diffuse_get(r_, g_, b_, a_));
+      }
+
+      void specular_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_specular_set(r_, g_, b_, a_));
+      }
+
+      void specular_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_specular_get(r_, g_, b_, a_));
+      }
+
+      void attenuation_set(Evas_Real constant_, Evas_Real linear_, Evas_Real quadratic_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_attenuation_set(constant_, linear_, quadratic_));
+      }
+
+      void attenuation_get(Evas_Real* constant_, Evas_Real* linear_, Evas_Real* quadratic_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_attenuation_get(constant_, linear_, quadratic_));
+      }
+
+      void projection_matrix_set(const Evas_Real * matrix_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_projection_matrix_set(matrix_));
+      }
+
+      void projection_matrix_get(Evas_Real* matrix_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_projection_matrix_get(matrix_));
+      }
+
+      void projection_perspective_set(Evas_Real fovy_, Evas_Real aspect_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_projection_perspective_set(fovy_, aspect_, dnear_, dfar_));
+      }
+
+      void projection_frustum_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_projection_frustum_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+      void projection_ortho_set(Evas_Real left_, Evas_Real right_, Evas_Real bottom_, Evas_Real top_, Evas_Real dnear_, Evas_Real dfar_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_light_projection_ortho_set(left_, right_, bottom_, top_, dnear_, dfar_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_light>)
+{
+   return (EVAS_3D_LIGHT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_LIGHT_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_light.eo.legacy.h b/src/lib/evas/canvas/evas_3d_light.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_light.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_light.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_LIGHT_EO_LEGACY_H_
+#define _EVAS_3D_LIGHT_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_LIGHT_EO_CLASS_TYPE
+#define _EVAS_3D_LIGHT_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Light;
+
+#endif
+
+#ifndef _EVAS_3D_LIGHT_EO_TYPES
+#define _EVAS_3D_LIGHT_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_material.eo.c b/src/lib/evas/canvas/evas_3d_material.eo.c
--- a/src/lib/evas/canvas/evas_3d_material.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_material.eo.c	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,73 @@
+
+void _evas_3d_material_enable_set(Eo *obj, Evas_3D_Material_Data *pd, Evas_3D_Material_Attrib attrib, Eina_Bool enable);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_material_enable_set, EO_FUNC_CALL(attrib, enable), Evas_3D_Material_Attrib attrib, Eina_Bool enable);
+
+Eina_Bool _evas_3d_material_enable_get(Eo *obj, Evas_3D_Material_Data *pd, Evas_3D_Material_Attrib attrib);
+
+EOAPI EO_FUNC_BODYV(evas_3d_material_enable_get, Eina_Bool, 0, EO_FUNC_CALL(attrib), Evas_3D_Material_Attrib attrib);
+
+void _evas_3d_material_shininess_set(Eo *obj, Evas_3D_Material_Data *pd, Evas_Real shininess);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_material_shininess_set, EO_FUNC_CALL(shininess), Evas_Real shininess);
+
+Evas_Real _evas_3d_material_shininess_get(Eo *obj, Evas_3D_Material_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_material_shininess_get, Evas_Real, 0);
+
+void _evas_3d_material_texture_set(Eo *obj, Evas_3D_Material_Data *pd, Evas_3D_Material_Attrib attrib, Evas_3D_Texture *texture);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_material_texture_set, EO_FUNC_CALL(attrib, texture), Evas_3D_Material_Attrib attrib, Evas_3D_Texture *texture);
+
+Evas_3D_Texture * _evas_3d_material_texture_get(Eo *obj, Evas_3D_Material_Data *pd, Evas_3D_Material_Attrib attrib);
+
+EOAPI EO_FUNC_BODYV(evas_3d_material_texture_get, Evas_3D_Texture *, 0, EO_FUNC_CALL(attrib), Evas_3D_Material_Attrib attrib);
+
+void _evas_3d_material_color_set(Eo *obj, Evas_3D_Material_Data *pd, Evas_3D_Material_Attrib attrib, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_material_color_set, EO_FUNC_CALL(attrib, r, g, b, a), Evas_3D_Material_Attrib attrib, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+void _evas_3d_material_color_get(Eo *obj, Evas_3D_Material_Data *pd, Evas_3D_Material_Attrib attrib, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_material_color_get, EO_FUNC_CALL(attrib, r, g, b, a), Evas_3D_Material_Attrib attrib, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+void _evas_3d_material_eo_base_constructor(Eo *obj, Evas_3D_Material_Data *pd);
+
+
+void _evas_3d_material_eo_base_destructor(Eo *obj, Evas_3D_Material_Data *pd);
+
+
+void _evas_3d_material_evas_3d_object_update_notify(Eo *obj, Evas_3D_Material_Data *pd);
+
+
+void _evas_3d_material_evas_3d_object_change_notify(Eo *obj, Evas_3D_Material_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+
+static Eo_Op_Description _evas_3d_material_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_3d_material_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_3d_material_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_update_notify, _evas_3d_material_evas_3d_object_update_notify),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_change_notify, _evas_3d_material_evas_3d_object_change_notify),
+     EO_OP_FUNC(evas_3d_material_enable_set, _evas_3d_material_enable_set, ""),
+     EO_OP_FUNC(evas_3d_material_enable_get, _evas_3d_material_enable_get, ""),
+     EO_OP_FUNC(evas_3d_material_shininess_set, _evas_3d_material_shininess_set, ""),
+     EO_OP_FUNC(evas_3d_material_shininess_get, _evas_3d_material_shininess_get, ""),
+     EO_OP_FUNC(evas_3d_material_texture_set, _evas_3d_material_texture_set, "Set the texture of the given material."),
+     EO_OP_FUNC(evas_3d_material_texture_get, _evas_3d_material_texture_get, ""),
+     EO_OP_FUNC(evas_3d_material_color_set, _evas_3d_material_color_set, ""),
+     EO_OP_FUNC(evas_3d_material_color_get, _evas_3d_material_color_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_material_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Material",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_material_op_desc),
+     NULL,
+     sizeof(Evas_3D_Material_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_material_class_get, &_evas_3d_material_class_desc, EVAS_3D_OBJECT_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_material.eo.h b/src/lib/evas/canvas/evas_3d_material.eo.h
--- a/src/lib/evas/canvas/evas_3d_material.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_material.eo.h	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,108 @@
+#ifndef _EVAS_3D_MATERIAL_EO_H_
+#define _EVAS_3D_MATERIAL_EO_H_
+
+#ifndef _EVAS_3D_MATERIAL_EO_CLASS_TYPE
+#define _EVAS_3D_MATERIAL_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Material;
+
+#endif
+
+#ifndef _EVAS_3D_MATERIAL_EO_TYPES
+#define _EVAS_3D_MATERIAL_EO_TYPES
+
+
+#endif
+#define EVAS_3D_MATERIAL_CLASS evas_3d_material_class_get()
+
+const Eo_Class *evas_3d_material_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] attrib Material attribute ID.
+ * @param[in] enable Whether to enable the attribute (@c EINA_TRUE), or not (@c EINA_FALSE).
+ *
+ */
+EOAPI void  evas_3d_material_enable_set(Evas_3D_Material_Attrib attrib, Eina_Bool enable);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] attrib Material attribute ID.
+ *
+ */
+EOAPI Eina_Bool  evas_3d_material_enable_get(Evas_3D_Material_Attrib attrib);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] shininess Shininess value.
+ *
+ */
+EOAPI void  evas_3d_material_shininess_set(Evas_Real shininess);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Real  evas_3d_material_shininess_get(void);
+
+/**
+ *
+ * Set the texture of the given material.
+ *
+ * You have to enable the desired attribute first.
+ *
+ * @see evas_3d_material_enable_set()
+ *
+ * @ingroup Evas_3D_Material
+ *
+ * @param[in] attrib Material attribute ID.
+ * @param[in] texture No description supplied.
+ *
+ */
+EOAPI void  evas_3d_material_texture_set(Evas_3D_Material_Attrib attrib, Evas_3D_Texture *texture);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] attrib Material attribute ID.
+ *
+ */
+EOAPI Evas_3D_Texture * evas_3d_material_texture_get(Evas_3D_Material_Attrib attrib);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] attrib Material attribute ID.
+ * @param[in] r Red component of the color.
+ * @param[in] g Green component of the color.
+ * @param[in] b Blue component of the color.
+ * @param[in] a Alpha component of the color.
+ *
+ */
+EOAPI void  evas_3d_material_color_set(Evas_3D_Material_Attrib attrib, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] attrib Material attribute ID.
+ * @param[out] r Pointer to receive red component of the color.
+ * @param[out] g Pointer to receive green component of the color.
+ * @param[out] b Pointer to receive blue component of the color.
+ * @param[out] a Pointer to receive alpha component of the color.
+ *
+ */
+EOAPI void  evas_3d_material_color_get(Evas_3D_Material_Attrib attrib, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_material.eo.hh b/src/lib/evas/canvas/evas_3d_material.eo.hh
--- a/src/lib/evas/canvas/evas_3d_material.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_material.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,483 @@
+#ifndef EFL_GENERATED_EVAS_3D_MATERIAL_HH
+#define EFL_GENERATED_EVAS_3D_MATERIAL_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_material.eo.h"
+}
+
+#include "evas_3d_object.eo.hh"
+#include "evas_common_interface.eo.hh"
+
+struct evas_3d_material
+      : evas_3d_object,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_material>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_material(Eo* eo)
+      : evas_3d_object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_material(std::nullptr_t)
+      : evas_3d_object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   evas_3d_material(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_material(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_material(evas_3d_material const& other)
+      : evas_3d_object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_material() {}
+
+   /// @brief Pure virtual update_notify function..
+   /// Update request for the object.
+   ///
+   void update_notify() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update_notify());
+   }
+
+   /// @brief Pure virtual change_notify function..
+   /// Update request for the object.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+   }
+
+   /// @param enable Whether to enable the attribute (@c EINA_TRUE), or not (@c EINA_FALSE).
+   ///
+   bool enable_get(Evas_3D_Material_Attrib attrib_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_material_enable_get(attrib_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param enable Whether to enable the attribute (@c EINA_TRUE), or not (@c EINA_FALSE).
+   ///
+   void enable_set(Evas_3D_Material_Attrib attrib_, bool enable_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_material_enable_set(attrib_, efl::eolian::to_c(enable_)));
+   }
+
+   /// @param shininess Shininess value.
+   ///
+   Evas_Real shininess_get() const
+   {
+      Evas_Real _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_material_shininess_get());
+      return _tmp_ret;
+   }
+
+   /// @param shininess Shininess value.
+   ///
+   void shininess_set(Evas_Real shininess_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_material_shininess_set(shininess_));
+   }
+
+   /// @param texture 
+   ///
+   Evas_3D_Texture * texture_get(Evas_3D_Material_Attrib attrib_) const
+   {
+      Evas_3D_Texture * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_material_texture_get(attrib_));
+      return _tmp_ret;
+   }
+
+   /// @brief Set the texture of the given material.
+   ///
+   /// You have to enable the desired attribute first.
+   ///
+   /// @see evas_3d_material_enable_set()
+   ///
+   /// @ingroup Evas_3D_Material
+   ///
+   /// @param texture 
+   ///
+   void texture_set(Evas_3D_Material_Attrib attrib_, Evas_3D_Texture * texture_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_material_texture_set(attrib_, texture_));
+   }
+
+   /// @param attrib Material attribute ID.
+   /// @param r Red component of the color.
+   /// @param g Green component of the color.
+   /// @param b Blue component of the color.
+   /// @param a Alpha component of the color.
+   ///
+   void color_set(Evas_3D_Material_Attrib attrib_, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_material_color_set(attrib_, r_, g_, b_, a_));
+   }
+
+   /// @param attrib Material attribute ID.
+   /// @param[out] r Pointer to receive red component of the color.
+   /// @param[out] g Pointer to receive green component of the color.
+   /// @param[out] b Pointer to receive blue component of the color.
+   /// @param[out] a Pointer to receive alpha component of the color.
+   ///
+   void color_get(Evas_3D_Material_Attrib attrib_, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_material_color_get(attrib_, r_, g_, b_, a_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_MATERIAL_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_MATERIAL_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _evas_3d_material_update_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update_notify();
+}
+
+template <typename T>
+void _evas_3d_material_change_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change_notify(state_, ref_);
+}
+
+template <typename T>
+bool _evas_3d_material_enable_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Material_Attrib attrib_)
+{
+   return static_cast<T*>(self->this_)->enable_get(attrib_);
+}
+
+template <typename T>
+void _evas_3d_material_enable_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Material_Attrib attrib_, Eina_Bool enable_)
+{
+   static_cast<T*>(self->this_)->enable_set(attrib_, efl::eolian::to_cxx<bool>(enable_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Real _evas_3d_material_shininess_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->shininess_get();
+}
+
+template <typename T>
+void _evas_3d_material_shininess_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real shininess_)
+{
+   static_cast<T*>(self->this_)->shininess_set(shininess_);
+}
+
+template <typename T>
+Evas_3D_Texture * _evas_3d_material_texture_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Material_Attrib attrib_)
+{
+   return static_cast<T*>(self->this_)->texture_get(attrib_);
+}
+
+template <typename T>
+void _evas_3d_material_texture_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Material_Attrib attrib_, Evas_3D_Texture * texture_)
+{
+   static_cast<T*>(self->this_)->texture_set(attrib_, texture_);
+}
+
+template <typename T>
+void _evas_3d_material_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Material_Attrib attrib_, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+{
+   static_cast<T*>(self->this_)->color_set(attrib_, r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_material_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Material_Attrib attrib_, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+{
+   static_cast<T*>(self->this_)->color_get(attrib_, r_, g_, b_, a_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_material >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void update_notify()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update_notify());
+      }
+
+      virtual void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      virtual bool enable_get(Evas_3D_Material_Attrib attrib_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_material_enable_get(attrib_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void enable_set(Evas_3D_Material_Attrib attrib_, bool enable_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_material_enable_set(attrib_, efl::eolian::to_c(enable_)));
+      }
+
+      virtual Evas_Real shininess_get()
+      {
+         Evas_Real _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_material_shininess_get());
+            return _tmp_ret;
+      }
+
+      virtual void shininess_set(Evas_Real shininess_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_material_shininess_set(shininess_));
+      }
+
+      virtual Evas_3D_Texture * texture_get(Evas_3D_Material_Attrib attrib_)
+      {
+         Evas_3D_Texture * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_material_texture_get(attrib_));
+            return _tmp_ret;
+      }
+
+      virtual void texture_set(Evas_3D_Material_Attrib attrib_, Evas_3D_Texture * texture_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_material_texture_set(attrib_, texture_));
+      }
+
+      virtual void color_set(Evas_3D_Material_Attrib attrib_, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_material_color_set(attrib_, r_, g_, b_, a_));
+      }
+
+      virtual void color_get(Evas_3D_Material_Attrib attrib_, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_material_color_get(attrib_, r_, g_, b_, a_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_material >
+{
+   static const int value = 10;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_material>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_material_update_notify_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update_notify);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_material_change_notify_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change_notify);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_material_enable_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_material_enable_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_material_enable_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_material_enable_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_material_shininess_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_material_shininess_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_material_shininess_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_material_shininess_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_evas_3d_material_texture_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_3d_material_texture_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_evas_3d_material_texture_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_3d_material_texture_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_evas_3d_material_color_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_3d_material_color_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_evas_3d_material_color_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_3d_material_color_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_material >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_material, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::evas_3d_material >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_material, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_material>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_material() const
+      {
+         return ::evas_3d_material(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void update_notify()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update_notify());
+      }
+
+      void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      bool enable_get(Evas_3D_Material_Attrib attrib_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_material_enable_get(attrib_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void enable_set(Evas_3D_Material_Attrib attrib_, bool enable_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_material_enable_set(attrib_, efl::eolian::to_c(enable_)));
+      }
+
+      Evas_Real shininess_get()
+      {
+         Evas_Real _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_material_shininess_get());
+            return _tmp_ret;
+      }
+
+      void shininess_set(Evas_Real shininess_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_material_shininess_set(shininess_));
+      }
+
+      Evas_3D_Texture * texture_get(Evas_3D_Material_Attrib attrib_)
+      {
+         Evas_3D_Texture * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_material_texture_get(attrib_));
+            return _tmp_ret;
+      }
+
+      void texture_set(Evas_3D_Material_Attrib attrib_, Evas_3D_Texture * texture_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_material_texture_set(attrib_, texture_));
+      }
+
+      void color_set(Evas_3D_Material_Attrib attrib_, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_material_color_set(attrib_, r_, g_, b_, a_));
+      }
+
+      void color_get(Evas_3D_Material_Attrib attrib_, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_material_color_get(attrib_, r_, g_, b_, a_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_material>)
+{
+   return (EVAS_3D_MATERIAL_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_MATERIAL_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_material.eo.legacy.h b/src/lib/evas/canvas/evas_3d_material.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_material.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_material.eo.legacy.h	2014-11-27 00:57:33.490380314 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_MATERIAL_EO_LEGACY_H_
+#define _EVAS_3D_MATERIAL_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_MATERIAL_EO_CLASS_TYPE
+#define _EVAS_3D_MATERIAL_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Material;
+
+#endif
+
+#ifndef _EVAS_3D_MATERIAL_EO_TYPES
+#define _EVAS_3D_MATERIAL_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_mesh.eo.c b/src/lib/evas/canvas/evas_3d_mesh.eo.c
--- a/src/lib/evas/canvas/evas_3d_mesh.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_mesh.eo.c	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,168 @@
+
+void _evas_3d_mesh_shade_mode_set(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_3D_Shade_Mode mode);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_shade_mode_set, EO_FUNC_CALL(mode), Evas_3D_Shade_Mode mode);
+
+Evas_3D_Shade_Mode _evas_3d_mesh_shade_mode_get(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_mesh_shade_mode_get, Evas_3D_Shade_Mode, 0);
+
+void _evas_3d_mesh_frame_material_set(Eo *obj, Evas_3D_Mesh_Data *pd, int frame, Evas_3D_Material *material);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_frame_material_set, EO_FUNC_CALL(frame, material), int frame, Evas_3D_Material *material);
+
+Evas_3D_Material * _evas_3d_mesh_frame_material_get(Eo *obj, Evas_3D_Mesh_Data *pd, int frame);
+
+EOAPI EO_FUNC_BODYV(evas_3d_mesh_frame_material_get, Evas_3D_Material *, 0, EO_FUNC_CALL(frame), int frame);
+
+void _evas_3d_mesh_vertex_assembly_set(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_3D_Vertex_Assembly assembly);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_vertex_assembly_set, EO_FUNC_CALL(assembly), Evas_3D_Vertex_Assembly assembly);
+
+Evas_3D_Vertex_Assembly _evas_3d_mesh_vertex_assembly_get(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_mesh_vertex_assembly_get, Evas_3D_Vertex_Assembly, 0);
+
+void _evas_3d_mesh_file_set(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_3D_Mesh_File_Type type, const char *file, const char *key);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_file_set, EO_FUNC_CALL(type, file, key), Evas_3D_Mesh_File_Type type, const char *file, const char *key);
+
+void _evas_3d_mesh_save(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_3D_Mesh_File_Type type, const char *file, const char *key);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_save, EO_FUNC_CALL(type, file, key), Evas_3D_Mesh_File_Type type, const char *file, const char *key);
+
+void _evas_3d_mesh_frame_vertex_data_set(Eo *obj, Evas_3D_Mesh_Data *pd, int frame, Evas_3D_Vertex_Attrib attrib, int stride, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_frame_vertex_data_set, EO_FUNC_CALL(frame, attrib, stride, data), int frame, Evas_3D_Vertex_Attrib attrib, int stride, const void *data);
+
+void _evas_3d_mesh_frame_vertex_data_copy_set(Eo *obj, Evas_3D_Mesh_Data *pd, int frame, Evas_3D_Vertex_Attrib attrib, int stride, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_frame_vertex_data_copy_set, EO_FUNC_CALL(frame, attrib, stride, data), int frame, Evas_3D_Vertex_Attrib attrib, int stride, const void *data);
+
+void * _evas_3d_mesh_frame_vertex_data_map(Eo *obj, Evas_3D_Mesh_Data *pd, int frame, Evas_3D_Vertex_Attrib attrib);
+
+EOAPI EO_FUNC_BODYV(evas_3d_mesh_frame_vertex_data_map, void *, 0, EO_FUNC_CALL(frame, attrib), int frame, Evas_3D_Vertex_Attrib attrib);
+
+void _evas_3d_mesh_frame_vertex_data_unmap(Eo *obj, Evas_3D_Mesh_Data *pd, int frame, Evas_3D_Vertex_Attrib attrib);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_frame_vertex_data_unmap, EO_FUNC_CALL(frame, attrib), int frame, Evas_3D_Vertex_Attrib attrib);
+
+int _evas_3d_mesh_frame_vertex_stride_get(Eo *obj, Evas_3D_Mesh_Data *pd, int frame, Evas_3D_Vertex_Attrib attrib);
+
+EOAPI EO_FUNC_BODYV(evas_3d_mesh_frame_vertex_stride_get, int, 0, EO_FUNC_CALL(frame, attrib), int frame, Evas_3D_Vertex_Attrib attrib);
+
+void _evas_3d_mesh_index_data_set(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_3D_Index_Format format, int count, const void *indices);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_index_data_set, EO_FUNC_CALL(format, count, indices), Evas_3D_Index_Format format, int count, const void *indices);
+
+void _evas_3d_mesh_index_data_copy_set(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_3D_Index_Format format, int count, const void *indices);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_index_data_copy_set, EO_FUNC_CALL(format, count, indices), Evas_3D_Index_Format format, int count, const void *indices);
+
+Evas_3D_Index_Format _evas_3d_mesh_index_format_get(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_mesh_index_format_get, Evas_3D_Index_Format, 0);
+
+int _evas_3d_mesh_index_count_get(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_mesh_index_count_get, int, 0);
+
+void * _evas_3d_mesh_index_data_map(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_mesh_index_data_map, void *, 0);
+
+void _evas_3d_mesh_index_data_unmap(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_3d_mesh_index_data_unmap);
+
+void _evas_3d_mesh_frame_add(Eo *obj, Evas_3D_Mesh_Data *pd, int frame);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_frame_add, EO_FUNC_CALL(frame), int frame);
+
+void _evas_3d_mesh_frame_del(Eo *obj, Evas_3D_Mesh_Data *pd, int frame);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_frame_del, EO_FUNC_CALL(frame), int frame);
+
+void _evas_3d_mesh_vertex_count_set(Eo *obj, Evas_3D_Mesh_Data *pd, unsigned int count);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_vertex_count_set, EO_FUNC_CALL(count), unsigned int count);
+
+int _evas_3d_mesh_vertex_count_get(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_mesh_vertex_count_get, int, 0);
+
+void _evas_3d_mesh_fog_color_set(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_fog_color_set, EO_FUNC_CALL(r, g, b, a), Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+void _evas_3d_mesh_fog_color_get(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_fog_color_get, EO_FUNC_CALL(r, g, b, a), Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+void _evas_3d_mesh_fog_enable_set(Eo *obj, Evas_3D_Mesh_Data *pd, Eina_Bool enabled);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_mesh_fog_enable_set, EO_FUNC_CALL(enabled), Eina_Bool enabled);
+
+Eina_Bool _evas_3d_mesh_fog_enable_get(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_mesh_fog_enable_get, Eina_Bool, 0);
+
+void _evas_3d_mesh_eo_base_constructor(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+
+void _evas_3d_mesh_eo_base_destructor(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+
+void _evas_3d_mesh_evas_3d_object_update_notify(Eo *obj, Evas_3D_Mesh_Data *pd);
+
+
+void _evas_3d_mesh_evas_3d_object_change_notify(Eo *obj, Evas_3D_Mesh_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+
+static Eo_Op_Description _evas_3d_mesh_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_3d_mesh_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_3d_mesh_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_update_notify, _evas_3d_mesh_evas_3d_object_update_notify),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_change_notify, _evas_3d_mesh_evas_3d_object_change_notify),
+     EO_OP_FUNC(evas_3d_mesh_shade_mode_set, _evas_3d_mesh_shade_mode_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_shade_mode_get, _evas_3d_mesh_shade_mode_get, ""),
+     EO_OP_FUNC(evas_3d_mesh_frame_material_set, _evas_3d_mesh_frame_material_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_frame_material_get, _evas_3d_mesh_frame_material_get, ""),
+     EO_OP_FUNC(evas_3d_mesh_vertex_assembly_set, _evas_3d_mesh_vertex_assembly_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_vertex_assembly_get, _evas_3d_mesh_vertex_assembly_get, ""),
+     EO_OP_FUNC(evas_3d_mesh_file_set, _evas_3d_mesh_file_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_save, _evas_3d_mesh_save, ""),
+     EO_OP_FUNC(evas_3d_mesh_frame_vertex_data_set, _evas_3d_mesh_frame_vertex_data_set, "Set the vertex data of the key frame of the given mesh."),
+     EO_OP_FUNC(evas_3d_mesh_frame_vertex_data_copy_set, _evas_3d_mesh_frame_vertex_data_copy_set, "Set the vertex data of the key frame of the given mesh by copying from a buffer."),
+     EO_OP_FUNC(evas_3d_mesh_frame_vertex_data_map, _evas_3d_mesh_frame_vertex_data_map, "Map the vertex buffer of the key frame of the given mesh."),
+     EO_OP_FUNC(evas_3d_mesh_frame_vertex_data_unmap, _evas_3d_mesh_frame_vertex_data_unmap, ""),
+     EO_OP_FUNC(evas_3d_mesh_frame_vertex_stride_get, _evas_3d_mesh_frame_vertex_stride_get, ""),
+     EO_OP_FUNC(evas_3d_mesh_index_data_set, _evas_3d_mesh_index_data_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_index_data_copy_set, _evas_3d_mesh_index_data_copy_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_index_format_get, _evas_3d_mesh_index_format_get, ""),
+     EO_OP_FUNC(evas_3d_mesh_index_count_get, _evas_3d_mesh_index_count_get, ""),
+     EO_OP_FUNC(evas_3d_mesh_index_data_map, _evas_3d_mesh_index_data_map, ""),
+     EO_OP_FUNC(evas_3d_mesh_index_data_unmap, _evas_3d_mesh_index_data_unmap, ""),
+     EO_OP_FUNC(evas_3d_mesh_frame_add, _evas_3d_mesh_frame_add, ""),
+     EO_OP_FUNC(evas_3d_mesh_frame_del, _evas_3d_mesh_frame_del, ""),
+     EO_OP_FUNC(evas_3d_mesh_vertex_count_set, _evas_3d_mesh_vertex_count_set, "Set the vertex count of the given mesh."),
+     EO_OP_FUNC(evas_3d_mesh_vertex_count_get, _evas_3d_mesh_vertex_count_get, "Get the vertex count of the given mesh."),
+     EO_OP_FUNC(evas_3d_mesh_fog_color_set, _evas_3d_mesh_fog_color_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_fog_color_get, _evas_3d_mesh_fog_color_get, ""),
+     EO_OP_FUNC(evas_3d_mesh_fog_enable_set, _evas_3d_mesh_fog_enable_set, ""),
+     EO_OP_FUNC(evas_3d_mesh_fog_enable_get, _evas_3d_mesh_fog_enable_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_mesh_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Mesh",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_mesh_op_desc),
+     NULL,
+     sizeof(Evas_3D_Mesh_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_mesh_class_get, &_evas_3d_mesh_class_desc, EVAS_3D_OBJECT_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_mesh.eo.h b/src/lib/evas/canvas/evas_3d_mesh.eo.h
--- a/src/lib/evas/canvas/evas_3d_mesh.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_mesh.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,331 @@
+#ifndef _EVAS_3D_MESH_EO_H_
+#define _EVAS_3D_MESH_EO_H_
+
+#ifndef _EVAS_3D_MESH_EO_CLASS_TYPE
+#define _EVAS_3D_MESH_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Mesh;
+
+#endif
+
+#ifndef _EVAS_3D_MESH_EO_TYPES
+#define _EVAS_3D_MESH_EO_TYPES
+
+
+#endif
+#define EVAS_3D_MESH_CLASS evas_3d_mesh_class_get()
+
+const Eo_Class *evas_3d_mesh_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] mode The shade mode.
+ *
+ */
+EOAPI void  evas_3d_mesh_shade_mode_set(Evas_3D_Shade_Mode mode);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Shade_Mode  evas_3d_mesh_shade_mode_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] frame The number of the key frame.
+ * @param[in] material The material to be set to the key frame.
+ *
+ */
+EOAPI void  evas_3d_mesh_frame_material_set(int frame, Evas_3D_Material *material);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] frame The number of the key frame.
+ *
+ */
+EOAPI Evas_3D_Material * evas_3d_mesh_frame_material_get(int frame);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] assembly Vertex assembly.
+ *
+ */
+EOAPI void  evas_3d_mesh_vertex_assembly_set(Evas_3D_Vertex_Assembly assembly);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Vertex_Assembly  evas_3d_mesh_vertex_assembly_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] type The type of the mesh file.
+ * @param[in] file Path to the mesh file.
+ * @param[in] key Key in the mesh file.
+ *
+ */
+EOAPI void  evas_3d_mesh_file_set(Evas_3D_Mesh_File_Type type, const char *file, const char *key);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] type The type of the mesh file.
+ * @param[in] file Path to the mesh file.
+ * @param[in] key Key in the mesh file.
+ *
+ */
+EOAPI void  evas_3d_mesh_save(Evas_3D_Mesh_File_Type type, const char *file, const char *key);
+
+/**
+ *
+ * Set the vertex data of the key frame of the given mesh.
+ *
+ * This function make evas read from the given buffer whenever it requires.
+ * If you want to release the buffer after calling this functions, use
+ * evas_3d_mesh_frame_vertex_data_copy_set() instead.
+ *
+ * After setting the vertex data, further modifications should be protected
+ * by map/unmap pair.
+ *
+ * @see evas_3d_mesh_frame_vertex_data_copy_set()
+ * @see evas_3d_mesh_frame_vertex_data_map()
+ * @see evas_3d_mesh_frame_vertex_data_unmap()
+ *
+ * @ingroup Evas_3D_Mesh
+ * 
+ *
+ * @param[in] frame The number of the key frame.
+ * @param[in] attrib Vertex attribute ID.
+ * @param[in] stride Stride to go to the next vertex (in bytes).
+ * @param[in] data Pointer to the vertex data buffer.
+ *
+ */
+EOAPI void  evas_3d_mesh_frame_vertex_data_set(int frame, Evas_3D_Vertex_Attrib attrib, int stride, const void *data);
+
+/**
+ *
+ * Set the vertex data of the key frame of the given mesh by copying from a buffer.
+ * This function allocates internal vertex buffer and copy from the given
+ * buffer. So you can release the buffer. If you want to modify the vertex data
+ * use evas_3d_mesh_frame_vertex_data_map(). After finishing the modifications,
+ * you should call evas_3d_mesh_frame_vertex_data_unmap().
+ *
+ * @see evas_3d_mesh_frame_vertex_data_set()
+ * @see evas_3d_mesh_frame_vertex_data_map()
+ * @see evas_3d_mesh_frame_vertex_data_unmap()
+ *
+ * @ingroup Evas_3D_Mesh
+ * 
+ *
+ * @param[in] frame The number of the key frame.
+ * @param[in] attrib Vertex attribute ID.
+ * @param[in] stride Stride to go to the next vertex (in bytes).
+ * @param[in] data Pointer to the vertex data buffer.
+ *
+ */
+EOAPI void  evas_3d_mesh_frame_vertex_data_copy_set(int frame, Evas_3D_Vertex_Attrib attrib, int stride, const void *data);
+
+/**
+ *
+ * Map the vertex buffer of the key frame of the given mesh.
+ *
+ * After manipulating the mapped buffer, evas_3d_mesh_frame_vertex_data_unmap()
+ * should be called to properly download the data to the engine. If the data
+ * was set using evas_3d_mesh_frame_vertex_data_set(), pointer to the original
+ * buffer will be returned. Otherwise, the returned pointer can differ every
+ * time calling this function.
+ *
+ * @see evas_3d_mesh_frame_vertex_data_unmap()
+ * @return Starting address of the mapped vertex buffer.
+ *
+ * @ingroup Evas_3D_Mesh
+ * 
+ *
+ * @param[in] frame The number of the key frame.
+ * @param[in] attrib Vertex attribute ID.
+ *
+ */
+EOAPI void * evas_3d_mesh_frame_vertex_data_map(int frame, Evas_3D_Vertex_Attrib attrib);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] frame The number of the key frame.
+ * @param[in] attrib Vertex attribute ID.
+ *
+ */
+EOAPI void  evas_3d_mesh_frame_vertex_data_unmap(int frame, Evas_3D_Vertex_Attrib attrib);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] frame The number of the key frame.
+ * @param[in] attrib Vertex attribute ID.
+ *
+ */
+EOAPI int  evas_3d_mesh_frame_vertex_stride_get(int frame, Evas_3D_Vertex_Attrib attrib);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] format Vertex index data format.
+ * @param[in] count Vertex index count.
+ * @param[in] indices Pointer to the index data.
+ *
+ */
+EOAPI void  evas_3d_mesh_index_data_set(Evas_3D_Index_Format format, int count, const void *indices);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] format Vertex index data format.
+ * @param[in] count Vertex index count.
+ * @param[in] indices Pointer to the index data.
+ *
+ */
+EOAPI void  evas_3d_mesh_index_data_copy_set(Evas_3D_Index_Format format, int count, const void *indices);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Index_Format  evas_3d_mesh_index_format_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI int  evas_3d_mesh_index_count_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI void * evas_3d_mesh_index_data_map(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI void  evas_3d_mesh_index_data_unmap(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] frame The number of the key frame to be added.
+ *
+ */
+EOAPI void  evas_3d_mesh_frame_add(int frame);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] frame The number of the key frame to be added.
+ *
+ */
+EOAPI void  evas_3d_mesh_frame_del(int frame);
+
+/**
+ *
+ * Set the vertex count of the given mesh.
+ *
+ * Each key frame should have same vertex count to be properly interpolated.
+ * Key frames have their own vertex data and the data should have more vertices
+ * than the mesh's vertex count.
+ *
+ * Default vertex count is 0.
+ *
+ * @ingroup Evas_3D_Mesh
+ * 
+ *
+ * @param[in] count Vertex count.
+ *
+ */
+EOAPI void  evas_3d_mesh_vertex_count_set(unsigned int count);
+
+/**
+ *
+ * Get the vertex count of the given mesh.
+ *
+ * @see evas_3d_mesh_vertex_count_set()
+ *
+ * @ingroup Evas_3D_Mesh
+ * 
+ *
+ *
+ */
+EOAPI int  evas_3d_mesh_vertex_count_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] r The red component of the fog color.
+ * @param[in] g The green component of the fog color.
+ * @param[in] b The blue component of the fog color.
+ * @param[in] a The transparency of fog.
+ *
+ */
+EOAPI void  evas_3d_mesh_fog_color_set(Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[out] r Pointer to receive red component of the fog color.
+ * @param[out] g Pointer to receive green component of the fog color.
+ * @param[out] b Pointer to receive blue component of the fog color.
+ * @param[out] a Pointer to receive transparency of fog.
+ *
+ */
+EOAPI void  evas_3d_mesh_fog_color_get(Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] enabled The red component of the fog color.
+ *
+ */
+EOAPI void  evas_3d_mesh_fog_enable_set(Eina_Bool enabled);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_mesh_fog_enable_get(void);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_mesh.eo.hh b/src/lib/evas/canvas/evas_3d_mesh.eo.hh
--- a/src/lib/evas/canvas/evas_3d_mesh.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_mesh.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,1166 @@
+#ifndef EFL_GENERATED_EVAS_3D_MESH_HH
+#define EFL_GENERATED_EVAS_3D_MESH_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_mesh.eo.h"
+}
+
+#include "evas_3d_object.eo.hh"
+#include "evas_common_interface.eo.hh"
+#include <string>
+
+struct evas_3d_mesh
+      : evas_3d_object,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_mesh>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_mesh(Eo* eo)
+      : evas_3d_object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_mesh(std::nullptr_t)
+      : evas_3d_object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   evas_3d_mesh(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_mesh(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_mesh(evas_3d_mesh const& other)
+      : evas_3d_object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_mesh() {}
+
+   /// @brief Pure virtual update_notify function..
+   /// Update request for the object.
+   ///
+   void update_notify() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update_notify());
+   }
+
+   /// @brief Pure virtual change_notify function..
+   /// Update request for the object.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+   }
+
+   /// @param mode The shade mode.
+   ///
+   Evas_3D_Shade_Mode shade_mode_get() const
+   {
+      Evas_3D_Shade_Mode _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_shade_mode_get());
+      return _tmp_ret;
+   }
+
+   /// @param mode The shade mode.
+   ///
+   void shade_mode_set(Evas_3D_Shade_Mode mode_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_shade_mode_set(mode_));
+   }
+
+   /// @param material The material to be set to the key frame.
+   ///
+   Evas_3D_Material * frame_material_get(int frame_) const
+   {
+      Evas_3D_Material * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_frame_material_get(frame_));
+      return _tmp_ret;
+   }
+
+   /// @param material The material to be set to the key frame.
+   ///
+   void frame_material_set(int frame_, Evas_3D_Material * material_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_frame_material_set(frame_, material_));
+   }
+
+   /// @param assembly Vertex assembly.
+   ///
+   Evas_3D_Vertex_Assembly vertex_assembly_get() const
+   {
+      Evas_3D_Vertex_Assembly _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_vertex_assembly_get());
+      return _tmp_ret;
+   }
+
+   /// @param assembly Vertex assembly.
+   ///
+   void vertex_assembly_set(Evas_3D_Vertex_Assembly assembly_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_vertex_assembly_set(assembly_));
+   }
+
+   /// @param type The type of the mesh file.
+   /// @param file Path to the mesh file.
+   /// @param key Key in the mesh file.
+   ///
+   void file_set(Evas_3D_Mesh_File_Type type_, std::string file_, std::string key_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_file_set(type_, efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+   }
+
+   /// @param type The type of the mesh file.
+   /// @param file Path to the mesh file.
+   /// @param key Key in the mesh file.
+   ///
+   void save(Evas_3D_Mesh_File_Type type_, std::string file_, std::string key_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_save(type_, efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+   }
+
+   /// @brief Set the vertex data of the key frame of the given mesh.
+   ///
+   /// This function make evas read from the given buffer whenever it requires.
+   /// If you want to release the buffer after calling this functions, use
+   /// evas_3d_mesh_frame_vertex_data_copy_set() instead.
+   ///
+   /// After setting the vertex data, further modifications should be protected
+   /// by map/unmap pair.
+   ///
+   /// @see evas_3d_mesh_frame_vertex_data_copy_set()
+   /// @see evas_3d_mesh_frame_vertex_data_map()
+   /// @see evas_3d_mesh_frame_vertex_data_unmap()
+   ///
+   /// @ingroup Evas_3D_Mesh
+   ///
+   /// @param frame The number of the key frame.
+   /// @param attrib Vertex attribute ID.
+   /// @param stride Stride to go to the next vertex (in bytes).
+   /// @param data Pointer to the vertex data buffer.
+   ///
+   void frame_vertex_data_set(int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_frame_vertex_data_set(frame_, attrib_, stride_, data_));
+   }
+
+   /// @brief Set the vertex data of the key frame of the given mesh by copying from a buffer.
+   /// This function allocates internal vertex buffer and copy from the given
+   /// buffer. So you can release the buffer. If you want to modify the vertex data
+   /// use evas_3d_mesh_frame_vertex_data_map(). After finishing the modifications,
+   /// you should call evas_3d_mesh_frame_vertex_data_unmap().
+   ///
+   /// @see evas_3d_mesh_frame_vertex_data_set()
+   /// @see evas_3d_mesh_frame_vertex_data_map()
+   /// @see evas_3d_mesh_frame_vertex_data_unmap()
+   ///
+   /// @ingroup Evas_3D_Mesh
+   ///
+   /// @param frame The number of the key frame.
+   /// @param attrib Vertex attribute ID.
+   /// @param stride Stride to go to the next vertex (in bytes).
+   /// @param data Pointer to the vertex data buffer.
+   ///
+   void frame_vertex_data_copy_set(int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_frame_vertex_data_copy_set(frame_, attrib_, stride_, data_));
+   }
+
+   /// @brief Map the vertex buffer of the key frame of the given mesh.
+   ///
+   /// After manipulating the mapped buffer, evas_3d_mesh_frame_vertex_data_unmap()
+   /// should be called to properly download the data to the engine. If the data
+   /// was set using evas_3d_mesh_frame_vertex_data_set(), pointer to the original
+   /// buffer will be returned. Otherwise, the returned pointer can differ every
+   /// time calling this function.
+   ///
+   /// @see evas_3d_mesh_frame_vertex_data_unmap()
+   /// @return Starting address of the mapped vertex buffer.
+   ///
+   /// @ingroup Evas_3D_Mesh
+   ///
+   /// @param frame The number of the key frame.
+   /// @param attrib Vertex attribute ID.
+   ///
+   void * frame_vertex_data_map(int frame_, Evas_3D_Vertex_Attrib attrib_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_frame_vertex_data_map(frame_, attrib_));
+      return _tmp_ret;
+   }
+
+   /// @param frame The number of the key frame.
+   /// @param attrib Vertex attribute ID.
+   ///
+   void frame_vertex_data_unmap(int frame_, Evas_3D_Vertex_Attrib attrib_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_frame_vertex_data_unmap(frame_, attrib_));
+   }
+
+   /// @param frame The number of the key frame.
+   /// @param attrib Vertex attribute ID.
+   ///
+   int frame_vertex_stride_get(int frame_, Evas_3D_Vertex_Attrib attrib_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_frame_vertex_stride_get(frame_, attrib_));
+      return _tmp_ret;
+   }
+
+   /// @param format Vertex index data format.
+   /// @param count Vertex index count.
+   /// @param indices Pointer to the index data.
+   ///
+   void index_data_set(Evas_3D_Index_Format format_, int count_, const void * indices_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_index_data_set(format_, count_, indices_));
+   }
+
+   /// @param format Vertex index data format.
+   /// @param count Vertex index count.
+   /// @param indices Pointer to the index data.
+   ///
+   void index_data_copy_set(Evas_3D_Index_Format format_, int count_, const void * indices_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_index_data_copy_set(format_, count_, indices_));
+   }
+
+   Evas_3D_Index_Format index_format_get() const
+   {
+      Evas_3D_Index_Format _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_index_format_get());
+      return _tmp_ret;
+   }
+
+   int index_count_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_index_count_get());
+      return _tmp_ret;
+   }
+
+   void * index_data_map() const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_index_data_map());
+      return _tmp_ret;
+   }
+
+   void index_data_unmap() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_index_data_unmap());
+   }
+
+   /// @param frame The number of the key frame to be added.
+   ///
+   void frame_add(int frame_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_frame_add(frame_));
+   }
+
+   /// @param frame The number of the key frame to be added.
+   ///
+   void frame_del(int frame_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_frame_del(frame_));
+   }
+
+   /// @brief Set the vertex count of the given mesh.
+   ///
+   /// Each key frame should have same vertex count to be properly interpolated.
+   /// Key frames have their own vertex data and the data should have more vertices
+   /// than the mesh's vertex count.
+   ///
+   /// Default vertex count is 0.
+   ///
+   /// @ingroup Evas_3D_Mesh
+   ///
+   /// @param count Vertex count.
+   ///
+   void vertex_count_set(unsigned int count_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_vertex_count_set(count_));
+   }
+
+   /// @brief Get the vertex count of the given mesh.
+   ///
+   /// @see evas_3d_mesh_vertex_count_set()
+   ///
+   /// @ingroup Evas_3D_Mesh
+   ///
+   int vertex_count_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_vertex_count_get());
+      return _tmp_ret;
+   }
+
+   /// @param r The red component of the fog color.
+   /// @param g The green component of the fog color.
+   /// @param b The blue component of the fog color.
+   /// @param a The transparency of fog.
+   ///
+   void fog_color_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_fog_color_set(r_, g_, b_, a_));
+   }
+
+   /// @param[out] r Pointer to receive red component of the fog color.
+   /// @param[out] g Pointer to receive green component of the fog color.
+   /// @param[out] b Pointer to receive blue component of the fog color.
+   /// @param[out] a Pointer to receive transparency of fog.
+   ///
+   void fog_color_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_fog_color_get(r_, g_, b_, a_));
+   }
+
+   /// @param enabled The red component of the fog color.
+   ///
+   void fog_enable_set(bool enabled_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_mesh_fog_enable_set(efl::eolian::to_c(enabled_)));
+   }
+
+   bool fog_enable_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_mesh_fog_enable_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_MESH_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_MESH_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _evas_3d_mesh_update_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update_notify();
+}
+
+template <typename T>
+void _evas_3d_mesh_change_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change_notify(state_, ref_);
+}
+
+template <typename T>
+Evas_3D_Shade_Mode _evas_3d_mesh_shade_mode_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->shade_mode_get();
+}
+
+template <typename T>
+void _evas_3d_mesh_shade_mode_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Shade_Mode mode_)
+{
+   static_cast<T*>(self->this_)->shade_mode_set(mode_);
+}
+
+template <typename T>
+Evas_3D_Material * _evas_3d_mesh_frame_material_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_)
+{
+   return static_cast<T*>(self->this_)->frame_material_get(frame_);
+}
+
+template <typename T>
+void _evas_3d_mesh_frame_material_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_, Evas_3D_Material * material_)
+{
+   static_cast<T*>(self->this_)->frame_material_set(frame_, material_);
+}
+
+template <typename T>
+Evas_3D_Vertex_Assembly _evas_3d_mesh_vertex_assembly_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->vertex_assembly_get();
+}
+
+template <typename T>
+void _evas_3d_mesh_vertex_assembly_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Vertex_Assembly assembly_)
+{
+   static_cast<T*>(self->this_)->vertex_assembly_set(assembly_);
+}
+
+template <typename T>
+void _evas_3d_mesh_file_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Mesh_File_Type type_, const char * file_, const char * key_)
+{
+   static_cast<T*>(self->this_)->file_set(type_, efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void _evas_3d_mesh_save_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Mesh_File_Type type_, const char * file_, const char * key_)
+{
+   static_cast<T*>(self->this_)->save(type_, efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void _evas_3d_mesh_frame_vertex_data_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_)
+{
+   static_cast<T*>(self->this_)->frame_vertex_data_set(frame_, attrib_, stride_, data_);
+}
+
+template <typename T>
+void _evas_3d_mesh_frame_vertex_data_copy_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_)
+{
+   static_cast<T*>(self->this_)->frame_vertex_data_copy_set(frame_, attrib_, stride_, data_);
+}
+
+template <typename T>
+void * _evas_3d_mesh_frame_vertex_data_map_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_, Evas_3D_Vertex_Attrib attrib_)
+{
+   return static_cast<T*>(self->this_)->frame_vertex_data_map(frame_, attrib_);
+}
+
+template <typename T>
+void _evas_3d_mesh_frame_vertex_data_unmap_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_, Evas_3D_Vertex_Attrib attrib_)
+{
+   static_cast<T*>(self->this_)->frame_vertex_data_unmap(frame_, attrib_);
+}
+
+template <typename T>
+int _evas_3d_mesh_frame_vertex_stride_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_, Evas_3D_Vertex_Attrib attrib_)
+{
+   return static_cast<T*>(self->this_)->frame_vertex_stride_get(frame_, attrib_);
+}
+
+template <typename T>
+void _evas_3d_mesh_index_data_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Index_Format format_, int count_, const void * indices_)
+{
+   static_cast<T*>(self->this_)->index_data_set(format_, count_, indices_);
+}
+
+template <typename T>
+void _evas_3d_mesh_index_data_copy_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Index_Format format_, int count_, const void * indices_)
+{
+   static_cast<T*>(self->this_)->index_data_copy_set(format_, count_, indices_);
+}
+
+template <typename T>
+Evas_3D_Index_Format _evas_3d_mesh_index_format_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->index_format_get();
+}
+
+template <typename T>
+int _evas_3d_mesh_index_count_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->index_count_get();
+}
+
+template <typename T>
+void * _evas_3d_mesh_index_data_map_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->index_data_map();
+}
+
+template <typename T>
+void _evas_3d_mesh_index_data_unmap_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->index_data_unmap();
+}
+
+template <typename T>
+void _evas_3d_mesh_frame_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_)
+{
+   static_cast<T*>(self->this_)->frame_add(frame_);
+}
+
+template <typename T>
+void _evas_3d_mesh_frame_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_)
+{
+   static_cast<T*>(self->this_)->frame_del(frame_);
+}
+
+template <typename T>
+void _evas_3d_mesh_vertex_count_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int count_)
+{
+   static_cast<T*>(self->this_)->vertex_count_set(count_);
+}
+
+template <typename T>
+int _evas_3d_mesh_vertex_count_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->vertex_count_get();
+}
+
+template <typename T>
+void _evas_3d_mesh_fog_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+{
+   static_cast<T*>(self->this_)->fog_color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_mesh_fog_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+{
+   static_cast<T*>(self->this_)->fog_color_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_mesh_fog_enable_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool enabled_)
+{
+   static_cast<T*>(self->this_)->fog_enable_set(efl::eolian::to_cxx<bool>(enabled_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool _evas_3d_mesh_fog_enable_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->fog_enable_get();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_mesh >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void update_notify()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update_notify());
+      }
+
+      virtual void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      virtual Evas_3D_Shade_Mode shade_mode_get()
+      {
+         Evas_3D_Shade_Mode _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_shade_mode_get());
+            return _tmp_ret;
+      }
+
+      virtual void shade_mode_set(Evas_3D_Shade_Mode mode_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_shade_mode_set(mode_));
+      }
+
+      virtual Evas_3D_Material * frame_material_get(int frame_)
+      {
+         Evas_3D_Material * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_frame_material_get(frame_));
+            return _tmp_ret;
+      }
+
+      virtual void frame_material_set(int frame_, Evas_3D_Material * material_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_frame_material_set(frame_, material_));
+      }
+
+      virtual Evas_3D_Vertex_Assembly vertex_assembly_get()
+      {
+         Evas_3D_Vertex_Assembly _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_vertex_assembly_get());
+            return _tmp_ret;
+      }
+
+      virtual void vertex_assembly_set(Evas_3D_Vertex_Assembly assembly_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_vertex_assembly_set(assembly_));
+      }
+
+      virtual void file_set(Evas_3D_Mesh_File_Type type_, std::string file_, std::string key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_file_set(type_, efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      }
+
+      virtual void save(Evas_3D_Mesh_File_Type type_, std::string file_, std::string key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_save(type_, efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      }
+
+      virtual void frame_vertex_data_set(int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_frame_vertex_data_set(frame_, attrib_, stride_, data_));
+      }
+
+      virtual void frame_vertex_data_copy_set(int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_frame_vertex_data_copy_set(frame_, attrib_, stride_, data_));
+      }
+
+      virtual void * frame_vertex_data_map(int frame_, Evas_3D_Vertex_Attrib attrib_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_frame_vertex_data_map(frame_, attrib_));
+            return _tmp_ret;
+      }
+
+      virtual void frame_vertex_data_unmap(int frame_, Evas_3D_Vertex_Attrib attrib_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_frame_vertex_data_unmap(frame_, attrib_));
+      }
+
+      virtual int frame_vertex_stride_get(int frame_, Evas_3D_Vertex_Attrib attrib_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_frame_vertex_stride_get(frame_, attrib_));
+            return _tmp_ret;
+      }
+
+      virtual void index_data_set(Evas_3D_Index_Format format_, int count_, const void * indices_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_index_data_set(format_, count_, indices_));
+      }
+
+      virtual void index_data_copy_set(Evas_3D_Index_Format format_, int count_, const void * indices_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_index_data_copy_set(format_, count_, indices_));
+      }
+
+      virtual Evas_3D_Index_Format index_format_get()
+      {
+         Evas_3D_Index_Format _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_index_format_get());
+            return _tmp_ret;
+      }
+
+      virtual int index_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_index_count_get());
+            return _tmp_ret;
+      }
+
+      virtual void * index_data_map()
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_index_data_map());
+            return _tmp_ret;
+      }
+
+      virtual void index_data_unmap()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_index_data_unmap());
+      }
+
+      virtual void frame_add(int frame_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_frame_add(frame_));
+      }
+
+      virtual void frame_del(int frame_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_frame_del(frame_));
+      }
+
+      virtual void vertex_count_set(unsigned int count_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_vertex_count_set(count_));
+      }
+
+      virtual int vertex_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_vertex_count_get());
+            return _tmp_ret;
+      }
+
+      virtual void fog_color_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_fog_color_set(r_, g_, b_, a_));
+      }
+
+      virtual void fog_color_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_fog_color_get(r_, g_, b_, a_));
+      }
+
+      virtual void fog_enable_set(bool enabled_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_mesh_fog_enable_set(efl::eolian::to_c(enabled_)));
+      }
+
+      virtual bool fog_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_mesh_fog_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_mesh >
+{
+   static const int value = 29;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_mesh>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_update_notify_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update_notify);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_change_notify_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change_notify);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_shade_mode_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_shade_mode_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_shade_mode_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_shade_mode_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_material_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_material_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_material_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_material_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_vertex_assembly_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_vertex_assembly_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_vertex_assembly_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_vertex_assembly_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_file_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_file_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_save_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_save);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_vertex_data_set_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_vertex_data_set);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_vertex_data_copy_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_vertex_data_copy_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_vertex_data_map_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_vertex_data_map);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_vertex_data_unmap_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_vertex_data_unmap);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_vertex_stride_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_vertex_stride_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_index_data_set_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_index_data_set);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_index_data_copy_set_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_index_data_copy_set);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_index_format_get_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_index_format_get);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_index_count_get_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_index_count_get);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_index_data_map_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_index_data_map);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_index_data_unmap_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_index_data_unmap);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_add_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_add);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_frame_del_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_frame_del);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_vertex_count_set_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_vertex_count_set);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_vertex_count_get_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_vertex_count_get);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_fog_color_set_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_fog_color_set);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_fog_color_get_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_fog_color_get);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_fog_enable_set_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_fog_enable_set);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::_evas_3d_mesh_fog_enable_get_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::evas_3d_mesh_fog_enable_get);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_mesh >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_mesh, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::evas_3d_mesh >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_mesh, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_mesh>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_mesh() const
+      {
+         return ::evas_3d_mesh(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void update_notify()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update_notify());
+      }
+
+      void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      Evas_3D_Shade_Mode shade_mode_get()
+      {
+         Evas_3D_Shade_Mode _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_shade_mode_get());
+            return _tmp_ret;
+      }
+
+      void shade_mode_set(Evas_3D_Shade_Mode mode_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_shade_mode_set(mode_));
+      }
+
+      Evas_3D_Material * frame_material_get(int frame_)
+      {
+         Evas_3D_Material * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_frame_material_get(frame_));
+            return _tmp_ret;
+      }
+
+      void frame_material_set(int frame_, Evas_3D_Material * material_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_frame_material_set(frame_, material_));
+      }
+
+      Evas_3D_Vertex_Assembly vertex_assembly_get()
+      {
+         Evas_3D_Vertex_Assembly _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_vertex_assembly_get());
+            return _tmp_ret;
+      }
+
+      void vertex_assembly_set(Evas_3D_Vertex_Assembly assembly_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_vertex_assembly_set(assembly_));
+      }
+
+      void file_set(Evas_3D_Mesh_File_Type type_, std::string file_, std::string key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_file_set(type_, efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      }
+
+      void save(Evas_3D_Mesh_File_Type type_, std::string file_, std::string key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_save(type_, efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      }
+
+      void frame_vertex_data_set(int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_frame_vertex_data_set(frame_, attrib_, stride_, data_));
+      }
+
+      void frame_vertex_data_copy_set(int frame_, Evas_3D_Vertex_Attrib attrib_, int stride_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_frame_vertex_data_copy_set(frame_, attrib_, stride_, data_));
+      }
+
+      void * frame_vertex_data_map(int frame_, Evas_3D_Vertex_Attrib attrib_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_frame_vertex_data_map(frame_, attrib_));
+            return _tmp_ret;
+      }
+
+      void frame_vertex_data_unmap(int frame_, Evas_3D_Vertex_Attrib attrib_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_frame_vertex_data_unmap(frame_, attrib_));
+      }
+
+      int frame_vertex_stride_get(int frame_, Evas_3D_Vertex_Attrib attrib_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_frame_vertex_stride_get(frame_, attrib_));
+            return _tmp_ret;
+      }
+
+      void index_data_set(Evas_3D_Index_Format format_, int count_, const void * indices_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_index_data_set(format_, count_, indices_));
+      }
+
+      void index_data_copy_set(Evas_3D_Index_Format format_, int count_, const void * indices_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_index_data_copy_set(format_, count_, indices_));
+      }
+
+      Evas_3D_Index_Format index_format_get()
+      {
+         Evas_3D_Index_Format _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_index_format_get());
+            return _tmp_ret;
+      }
+
+      int index_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_index_count_get());
+            return _tmp_ret;
+      }
+
+      void * index_data_map()
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_index_data_map());
+            return _tmp_ret;
+      }
+
+      void index_data_unmap()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_index_data_unmap());
+      }
+
+      void frame_add(int frame_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_frame_add(frame_));
+      }
+
+      void frame_del(int frame_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_frame_del(frame_));
+      }
+
+      void vertex_count_set(unsigned int count_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_vertex_count_set(count_));
+      }
+
+      int vertex_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_vertex_count_get());
+            return _tmp_ret;
+      }
+
+      void fog_color_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_fog_color_set(r_, g_, b_, a_));
+      }
+
+      void fog_color_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_fog_color_get(r_, g_, b_, a_));
+      }
+
+      void fog_enable_set(bool enabled_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_mesh_fog_enable_set(efl::eolian::to_c(enabled_)));
+      }
+
+      bool fog_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_mesh_fog_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_mesh>)
+{
+   return (EVAS_3D_MESH_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_MESH_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_mesh.eo.legacy.h b/src/lib/evas/canvas/evas_3d_mesh.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_mesh.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_mesh.eo.legacy.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_MESH_EO_LEGACY_H_
+#define _EVAS_3D_MESH_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_MESH_EO_CLASS_TYPE
+#define _EVAS_3D_MESH_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Mesh;
+
+#endif
+
+#ifndef _EVAS_3D_MESH_EO_TYPES
+#define _EVAS_3D_MESH_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_node.eo.c b/src/lib/evas/canvas/evas_3d_node.eo.c
--- a/src/lib/evas/canvas/evas_3d_node.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_node.eo.c	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,180 @@
+
+void _evas_3d_node_position_inherit_set(Eo *obj, Evas_3D_Node_Data *pd, Eina_Bool inherit);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_position_inherit_set, EO_FUNC_CALL(inherit), Eina_Bool inherit);
+
+Eina_Bool _evas_3d_node_position_inherit_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_position_inherit_get, Eina_Bool, 0);
+
+void _evas_3d_node_orientation_inherit_set(Eo *obj, Evas_3D_Node_Data *pd, Eina_Bool inherit);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_orientation_inherit_set, EO_FUNC_CALL(inherit), Eina_Bool inherit);
+
+Eina_Bool _evas_3d_node_orientation_inherit_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_orientation_inherit_get, Eina_Bool, 0);
+
+void _evas_3d_node_scale_inherit_set(Eo *obj, Evas_3D_Node_Data *pd, Eina_Bool inherit);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_scale_inherit_set, EO_FUNC_CALL(inherit), Eina_Bool inherit);
+
+Eina_Bool _evas_3d_node_scale_inherit_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_scale_inherit_get, Eina_Bool, 0);
+
+void _evas_3d_node_camera_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Camera *camera);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_camera_set, EO_FUNC_CALL(camera), Evas_3D_Camera *camera);
+
+Evas_3D_Camera * _evas_3d_node_camera_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_camera_get, Evas_3D_Camera *, 0);
+
+void _evas_3d_node_light_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Light *light);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_light_set, EO_FUNC_CALL(light), Evas_3D_Light *light);
+
+Evas_3D_Light * _evas_3d_node_light_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_light_get, Evas_3D_Light *, 0);
+
+void _evas_3d_node_mesh_frame_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Mesh * mesh, int frame);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_mesh_frame_set, EO_FUNC_CALL(mesh, frame), Evas_3D_Mesh * mesh, int frame);
+
+int _evas_3d_node_mesh_frame_get(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Mesh * mesh);
+
+EOAPI EO_FUNC_BODYV(evas_3d_node_mesh_frame_get, int, 0, EO_FUNC_CALL(mesh), Evas_3D_Mesh * mesh);
+
+void _evas_3d_node_constructor(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Node_Type type);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_constructor, EO_FUNC_CALL(type), Evas_3D_Node_Type type);
+
+Evas_3D_Node_Type _evas_3d_node_type_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_type_get, Evas_3D_Node_Type, 0);
+
+void _evas_3d_node_member_add(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Node *member);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_member_add, EO_FUNC_CALL(member), Evas_3D_Node *member);
+
+void _evas_3d_node_member_del(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Node *member);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_member_del, EO_FUNC_CALL(member), Evas_3D_Node *member);
+
+Evas_3D_Node * _evas_3d_node_parent_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_parent_get, Evas_3D_Node *, 0);
+
+const Eina_List * _evas_3d_node_member_list_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_member_list_get, const Eina_List *, 0);
+
+void _evas_3d_node_position_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_Real x, Evas_Real y, Evas_Real z);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_position_set, EO_FUNC_CALL(x, y, z), Evas_Real x, Evas_Real y, Evas_Real z);
+
+void _evas_3d_node_orientation_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_Real x, Evas_Real y, Evas_Real z, Evas_Real w);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_orientation_set, EO_FUNC_CALL(x, y, z, w), Evas_Real x, Evas_Real y, Evas_Real z, Evas_Real w);
+
+void _evas_3d_node_orientation_angle_axis_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_Real angle, Evas_Real x, Evas_Real y, Evas_Real z);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_orientation_angle_axis_set, EO_FUNC_CALL(angle, x, y, z), Evas_Real angle, Evas_Real x, Evas_Real y, Evas_Real z);
+
+void _evas_3d_node_scale_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_Real x, Evas_Real y, Evas_Real z);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_scale_set, EO_FUNC_CALL(x, y, z), Evas_Real x, Evas_Real y, Evas_Real z);
+
+void _evas_3d_node_position_get(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_position_get, EO_FUNC_CALL(space, x, y, z), Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z);
+
+void _evas_3d_node_orientation_get(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z, Evas_Real *w);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_orientation_get, EO_FUNC_CALL(space, x, y, z, w), Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z, Evas_Real *w);
+
+void _evas_3d_node_scale_get(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_scale_get, EO_FUNC_CALL(space, x, y, z), Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z);
+
+void _evas_3d_node_look_at_set(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Space target_space, Evas_Real x, Evas_Real y, Evas_Real z, Evas_3D_Space up_space, Evas_Real ux, Evas_Real uy, Evas_Real uz);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_look_at_set, EO_FUNC_CALL(target_space, x, y, z, up_space, ux, uy, uz), Evas_3D_Space target_space, Evas_Real x, Evas_Real y, Evas_Real z, Evas_3D_Space up_space, Evas_Real ux, Evas_Real uy, Evas_Real uz);
+
+void _evas_3d_node_mesh_add(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Mesh *mesh);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_mesh_add, EO_FUNC_CALL(mesh), Evas_3D_Mesh *mesh);
+
+void _evas_3d_node_mesh_del(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Mesh *mesh);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_mesh_del, EO_FUNC_CALL(mesh), Evas_3D_Mesh *mesh);
+
+const Eina_List * _evas_3d_node_mesh_list_get(Eo *obj, Evas_3D_Node_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_node_mesh_list_get, const Eina_List *, 0);
+
+void _evas_3d_node_bounding_box_get(Eo *obj, Evas_3D_Node_Data *pd, Evas_Real *x, Evas_Real *y, Evas_Real *z, Evas_Real *x2, Evas_Real *y2, Evas_Real *z2);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_node_bounding_box_get, EO_FUNC_CALL(x, y, z, x2, y2, z2), Evas_Real *x, Evas_Real *y, Evas_Real *z, Evas_Real *x2, Evas_Real *y2, Evas_Real *z2);
+
+int _evas_3d_node_obb_frustum_check(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_Node *camera_node);
+
+EOAPI EO_FUNC_BODYV(evas_3d_node_obb_frustum_check, int, 0, EO_FUNC_CALL(camera_node), Evas_3D_Node *camera_node);
+
+void _evas_3d_node_evas_3d_object_update_notify(Eo *obj, Evas_3D_Node_Data *pd);
+
+
+void _evas_3d_node_evas_3d_object_change_notify(Eo *obj, Evas_3D_Node_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+
+static Eo_Op_Description _evas_3d_node_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_update_notify, _evas_3d_node_evas_3d_object_update_notify),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_change_notify, _evas_3d_node_evas_3d_object_change_notify),
+     EO_OP_FUNC(evas_3d_node_position_inherit_set, _evas_3d_node_position_inherit_set, ""),
+     EO_OP_FUNC(evas_3d_node_position_inherit_get, _evas_3d_node_position_inherit_get, ""),
+     EO_OP_FUNC(evas_3d_node_orientation_inherit_set, _evas_3d_node_orientation_inherit_set, ""),
+     EO_OP_FUNC(evas_3d_node_orientation_inherit_get, _evas_3d_node_orientation_inherit_get, ""),
+     EO_OP_FUNC(evas_3d_node_scale_inherit_set, _evas_3d_node_scale_inherit_set, ""),
+     EO_OP_FUNC(evas_3d_node_scale_inherit_get, _evas_3d_node_scale_inherit_get, ""),
+     EO_OP_FUNC(evas_3d_node_camera_set, _evas_3d_node_camera_set, ""),
+     EO_OP_FUNC(evas_3d_node_camera_get, _evas_3d_node_camera_get, ""),
+     EO_OP_FUNC(evas_3d_node_light_set, _evas_3d_node_light_set, ""),
+     EO_OP_FUNC(evas_3d_node_light_get, _evas_3d_node_light_get, ""),
+     EO_OP_FUNC(evas_3d_node_mesh_frame_set, _evas_3d_node_mesh_frame_set, ""),
+     EO_OP_FUNC(evas_3d_node_mesh_frame_get, _evas_3d_node_mesh_frame_get, ""),
+     EO_OP_FUNC(evas_3d_node_constructor, _evas_3d_node_constructor, "Constructor."),
+     EO_OP_FUNC(evas_3d_node_type_get, _evas_3d_node_type_get, ""),
+     EO_OP_FUNC(evas_3d_node_member_add, _evas_3d_node_member_add, ""),
+     EO_OP_FUNC(evas_3d_node_member_del, _evas_3d_node_member_del, ""),
+     EO_OP_FUNC(evas_3d_node_parent_get, _evas_3d_node_parent_get, ""),
+     EO_OP_FUNC(evas_3d_node_member_list_get, _evas_3d_node_member_list_get, ""),
+     EO_OP_FUNC(evas_3d_node_position_set, _evas_3d_node_position_set, ""),
+     EO_OP_FUNC(evas_3d_node_orientation_set, _evas_3d_node_orientation_set, ""),
+     EO_OP_FUNC(evas_3d_node_orientation_angle_axis_set, _evas_3d_node_orientation_angle_axis_set, ""),
+     EO_OP_FUNC(evas_3d_node_scale_set, _evas_3d_node_scale_set, ""),
+     EO_OP_FUNC(evas_3d_node_position_get, _evas_3d_node_position_get, ""),
+     EO_OP_FUNC(evas_3d_node_orientation_get, _evas_3d_node_orientation_get, ""),
+     EO_OP_FUNC(evas_3d_node_scale_get, _evas_3d_node_scale_get, ""),
+     EO_OP_FUNC(evas_3d_node_look_at_set, _evas_3d_node_look_at_set, ""),
+     EO_OP_FUNC(evas_3d_node_mesh_add, _evas_3d_node_mesh_add, ""),
+     EO_OP_FUNC(evas_3d_node_mesh_del, _evas_3d_node_mesh_del, ""),
+     EO_OP_FUNC(evas_3d_node_mesh_list_get, _evas_3d_node_mesh_list_get, ""),
+     EO_OP_FUNC(evas_3d_node_bounding_box_get, _evas_3d_node_bounding_box_get, ""),
+     EO_OP_FUNC(evas_3d_node_obb_frustum_check, _evas_3d_node_obb_frustum_check, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_node_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Node",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_node_op_desc),
+     NULL,
+     sizeof(Evas_3D_Node_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_node_class_get, &_evas_3d_node_class_desc, EVAS_3D_OBJECT_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_node.eo.h b/src/lib/evas/canvas/evas_3d_node.eo.h
--- a/src/lib/evas/canvas/evas_3d_node.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_node.eo.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,325 @@
+#ifndef _EVAS_3D_NODE_EO_H_
+#define _EVAS_3D_NODE_EO_H_
+
+#ifndef _EVAS_3D_NODE_EO_CLASS_TYPE
+#define _EVAS_3D_NODE_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Node;
+
+#endif
+
+#ifndef _EVAS_3D_NODE_EO_TYPES
+#define _EVAS_3D_NODE_EO_TYPES
+
+
+#endif
+#define EVAS_3D_NODE_CLASS evas_3d_node_class_get()
+
+const Eo_Class *evas_3d_node_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] inherit Whether to inherit parent position
+ *
+ */
+EOAPI void  evas_3d_node_position_inherit_set(Eina_Bool inherit);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_node_position_inherit_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] inherit Whether to inherit parent orientation
+ *
+ */
+EOAPI void  evas_3d_node_orientation_inherit_set(Eina_Bool inherit);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_node_orientation_inherit_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] inherit Whether to inherit parent scale
+ *
+ */
+EOAPI void  evas_3d_node_scale_inherit_set(Eina_Bool inherit);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_node_scale_inherit_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] camera The camera
+ *
+ */
+EOAPI void  evas_3d_node_camera_set(Evas_3D_Camera *camera);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Camera * evas_3d_node_camera_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] light The light
+ *
+ */
+EOAPI void  evas_3d_node_light_set(Evas_3D_Light *light);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Light * evas_3d_node_light_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] mesh The given mesh.
+ * @param[in] frame The animation frame number.
+ *
+ */
+EOAPI void  evas_3d_node_mesh_frame_set(Evas_3D_Mesh * mesh, int frame);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] mesh The given mesh.
+ *
+ */
+EOAPI int  evas_3d_node_mesh_frame_get(Evas_3D_Mesh * mesh);
+
+/**
+ *
+ * Constructor.
+ * 
+ *
+ * @param[in] type No description supplied.
+ *
+ */
+EOAPI void  evas_3d_node_constructor(Evas_3D_Node_Type type);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Node_Type  evas_3d_node_type_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] member Node object to be added.
+ *
+ */
+EOAPI void  evas_3d_node_member_add(Evas_3D_Node *member);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] member Member node to be deleted from the given node.
+ *
+ */
+EOAPI void  evas_3d_node_member_del(Evas_3D_Node *member);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Node * evas_3d_node_parent_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI const Eina_List * evas_3d_node_member_list_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x X coordinate of the position.
+ * @param[in] y Y coordinate of the position.
+ * @param[in] z Z coordinate of the position.
+ *
+ */
+EOAPI void  evas_3d_node_position_set(Evas_Real x, Evas_Real y, Evas_Real z);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x X term of the orientation quaternion (w, x, y, z)
+ * @param[in] y Y term of the orientation quaternion (w, x, y, z)
+ * @param[in] z Z term of the orientation quaternion (w, x, y, z)
+ * @param[in] w W term of the orientation quaternion (w, x, y, z)
+ *
+ */
+EOAPI void  evas_3d_node_orientation_set(Evas_Real x, Evas_Real y, Evas_Real z, Evas_Real w);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] angle Rotation angle.
+ * @param[in] x X term of the rotation axis.
+ * @param[in] y Y term of the rotation axis.
+ * @param[in] z Z term of the rotation axis.
+ *
+ */
+EOAPI void  evas_3d_node_orientation_angle_axis_set(Evas_Real angle, Evas_Real x, Evas_Real y, Evas_Real z);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x Scale factor along X-axis.
+ * @param[in] y Scale factor along Y-axis.
+ * @param[in] z Scale factor along Z-axis.
+ *
+ */
+EOAPI void  evas_3d_node_scale_set(Evas_Real x, Evas_Real y, Evas_Real z);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] space 
+ * @param[out] x Pointer to receive X coordinate of the position.
+ * @param[out] y Pointer to receive Y coordinate of the position.
+ * @param[out] z Pointer to receive Z coordinate of the position.
+ *
+ */
+EOAPI void  evas_3d_node_position_get(Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] space 
+ * @param[out] x Pointer to receive X term of the orientation quaternion.
+ * @param[out] y Pointer to receive Y term of the orientation quaternion.
+ * @param[out] z Pointer to receive Z term of the orientation quaternion.
+ * @param[out] w Pointer to receive W term of the orientation quaternion.
+ *
+ */
+EOAPI void  evas_3d_node_orientation_get(Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z, Evas_Real *w);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] space 
+ * @param[out] x Pointer to receive Scale factor along X-axis.
+ * @param[out] y Pointer to receive Scale factor along X-axis.
+ * @param[out] z Pointer to receive Scale factor along X-axis.
+ *
+ */
+EOAPI void  evas_3d_node_scale_get(Evas_3D_Space space, Evas_Real *x, Evas_Real *y, Evas_Real *z);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] target_space Space where the target position belongs to.
+ * @param[in] x X coordinate of the target position.
+ * @param[in] y Y coordinate of the target position.
+ * @param[in] z Z coordinate of the target position.
+ * @param[in] up_space Space where the up vector belongs to.
+ * @param[in] ux X term of the up vector.
+ * @param[in] uy Y term of the up vector.
+ * @param[in] uz Z term of the up vector.
+ *
+ */
+EOAPI void  evas_3d_node_look_at_set(Evas_3D_Space target_space, Evas_Real x, Evas_Real y, Evas_Real z, Evas_3D_Space up_space, Evas_Real ux, Evas_Real uy, Evas_Real uz);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] mesh The mesh to be added.
+ *
+ */
+EOAPI void  evas_3d_node_mesh_add(Evas_3D_Mesh *mesh);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] mesh The mesh to be deleted.
+ *
+ */
+EOAPI void  evas_3d_node_mesh_del(Evas_3D_Mesh *mesh);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI const Eina_List * evas_3d_node_mesh_list_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x Coordinates of vector.
+ * @param[in] y No description supplied.
+ * @param[in] z No description supplied.
+ * @param[in] x2 No description supplied.
+ * @param[in] y2 No description supplied.
+ * @param[in] z2 No description supplied.
+ *
+ */
+EOAPI void  evas_3d_node_bounding_box_get(Evas_Real *x, Evas_Real *y, Evas_Real *z, Evas_Real *x2, Evas_Real *y2, Evas_Real *z2);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] camera_node No description supplied.
+ *
+ */
+EOAPI int  evas_3d_node_obb_frustum_check(Evas_3D_Node *camera_node);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_node.eo.hh b/src/lib/evas/canvas/evas_3d_node.eo.hh
--- a/src/lib/evas/canvas/evas_3d_node.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_node.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,1222 @@
+#ifndef EFL_GENERATED_EVAS_3D_NODE_HH
+#define EFL_GENERATED_EVAS_3D_NODE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_node.eo.h"
+}
+
+#include "evas_3d_object.eo.hh"
+#include "evas_common_interface.eo.hh"
+
+struct evas_3d_node
+      : evas_3d_object,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_node>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_node(Eo* eo)
+      : evas_3d_object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_node(std::nullptr_t)
+      : evas_3d_object(nullptr)
+   {}
+
+   /// @brief Constructor.
+   ///
+   /// @param type 
+   ///
+   evas_3d_node(Evas_3D_Node_Type type_, efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_node(_c0(type_, _p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_node(evas_3d_node const& other)
+      : evas_3d_object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_node() {}
+
+   /// @brief Pure virtual update_notify function..
+   /// Update request for the object.
+   ///
+   void update_notify() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update_notify());
+   }
+
+   /// @brief Pure virtual change_notify function..
+   /// Update request for the object.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+   }
+
+   /// @param inherit Whether to inherit parent position
+   ///
+   bool position_inherit_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_position_inherit_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param inherit Whether to inherit parent position
+   ///
+   void position_inherit_set(bool inherit_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_position_inherit_set(efl::eolian::to_c(inherit_)));
+   }
+
+   /// @param inherit Whether to inherit parent orientation
+   ///
+   bool orientation_inherit_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_orientation_inherit_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param inherit Whether to inherit parent orientation
+   ///
+   void orientation_inherit_set(bool inherit_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_orientation_inherit_set(efl::eolian::to_c(inherit_)));
+   }
+
+   /// @param inherit Whether to inherit parent scale
+   ///
+   bool scale_inherit_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_scale_inherit_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param inherit Whether to inherit parent scale
+   ///
+   void scale_inherit_set(bool inherit_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_scale_inherit_set(efl::eolian::to_c(inherit_)));
+   }
+
+   /// @param camera The camera
+   ///
+   Evas_3D_Camera * camera_get() const
+   {
+      Evas_3D_Camera * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_camera_get());
+      return _tmp_ret;
+   }
+
+   /// @param camera The camera
+   ///
+   void camera_set(Evas_3D_Camera * camera_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_camera_set(camera_));
+   }
+
+   /// @param light The light
+   ///
+   Evas_3D_Light * light_get() const
+   {
+      Evas_3D_Light * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_light_get());
+      return _tmp_ret;
+   }
+
+   /// @param light The light
+   ///
+   void light_set(Evas_3D_Light * light_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_light_set(light_));
+   }
+
+   /// @param frame The animation frame number.
+   ///
+   int mesh_frame_get(Evas_3D_Mesh * mesh_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_mesh_frame_get(mesh_));
+      return _tmp_ret;
+   }
+
+   /// @param frame The animation frame number.
+   ///
+   void mesh_frame_set(Evas_3D_Mesh * mesh_, int frame_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_mesh_frame_set(mesh_, frame_));
+   }
+
+   Evas_3D_Node_Type type_get() const
+   {
+      Evas_3D_Node_Type _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_type_get());
+      return _tmp_ret;
+   }
+
+   /// @param member Node object to be added.
+   ///
+   void member_add(Evas_3D_Node * member_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_member_add(member_));
+   }
+
+   /// @param member Member node to be deleted from the given node.
+   ///
+   void member_del(Evas_3D_Node * member_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_member_del(member_));
+   }
+
+   Evas_3D_Node * parent_get() const
+   {
+      Evas_3D_Node * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_parent_get());
+      return _tmp_ret;
+   }
+
+   efl::eina::crange_list< Evas_3D_Node * > member_list_get() const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_member_list_get());
+      return efl::eolian::to_cxx<efl::eina::crange_list< Evas_3D_Node * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @param x X coordinate of the position.
+   /// @param y Y coordinate of the position.
+   /// @param z Z coordinate of the position.
+   ///
+   void position_set(Evas_Real x_, Evas_Real y_, Evas_Real z_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_position_set(x_, y_, z_));
+   }
+
+   /// @param x X term of the orientation quaternion (w, x, y, z)
+   /// @param y Y term of the orientation quaternion (w, x, y, z)
+   /// @param z Z term of the orientation quaternion (w, x, y, z)
+   /// @param w W term of the orientation quaternion (w, x, y, z)
+   ///
+   void orientation_set(Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_Real w_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_orientation_set(x_, y_, z_, w_));
+   }
+
+   /// @param angle Rotation angle.
+   /// @param x X term of the rotation axis.
+   /// @param y Y term of the rotation axis.
+   /// @param z Z term of the rotation axis.
+   ///
+   void orientation_angle_axis_set(Evas_Real angle_, Evas_Real x_, Evas_Real y_, Evas_Real z_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_orientation_angle_axis_set(angle_, x_, y_, z_));
+   }
+
+   /// @param x Scale factor along X-axis.
+   /// @param y Scale factor along Y-axis.
+   /// @param z Scale factor along Z-axis.
+   ///
+   void scale_set(Evas_Real x_, Evas_Real y_, Evas_Real z_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_scale_set(x_, y_, z_));
+   }
+
+   /// @param space 
+   /// @param[out] x Pointer to receive X coordinate of the position.
+   /// @param[out] y Pointer to receive Y coordinate of the position.
+   /// @param[out] z Pointer to receive Z coordinate of the position.
+   ///
+   void position_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_position_get(space_, x_, y_, z_));
+   }
+
+   /// @param space 
+   /// @param[out] x Pointer to receive X term of the orientation quaternion.
+   /// @param[out] y Pointer to receive Y term of the orientation quaternion.
+   /// @param[out] z Pointer to receive Z term of the orientation quaternion.
+   /// @param[out] w Pointer to receive W term of the orientation quaternion.
+   ///
+   void orientation_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_, Evas_Real* w_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_orientation_get(space_, x_, y_, z_, w_));
+   }
+
+   /// @param space 
+   /// @param[out] x Pointer to receive Scale factor along X-axis.
+   /// @param[out] y Pointer to receive Scale factor along X-axis.
+   /// @param[out] z Pointer to receive Scale factor along X-axis.
+   ///
+   void scale_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_scale_get(space_, x_, y_, z_));
+   }
+
+   /// @param target_space Space where the target position belongs to.
+   /// @param x X coordinate of the target position.
+   /// @param y Y coordinate of the target position.
+   /// @param z Z coordinate of the target position.
+   /// @param up_space Space where the up vector belongs to.
+   /// @param ux X term of the up vector.
+   /// @param uy Y term of the up vector.
+   /// @param uz Z term of the up vector.
+   ///
+   void look_at_set(Evas_3D_Space target_space_, Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_3D_Space up_space_, Evas_Real ux_, Evas_Real uy_, Evas_Real uz_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_look_at_set(target_space_, x_, y_, z_, up_space_, ux_, uy_, uz_));
+   }
+
+   /// @param mesh The mesh to be added.
+   ///
+   void mesh_add(Evas_3D_Mesh * mesh_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_mesh_add(mesh_));
+   }
+
+   /// @param mesh The mesh to be deleted.
+   ///
+   void mesh_del(Evas_3D_Mesh * mesh_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_mesh_del(mesh_));
+   }
+
+   efl::eina::crange_list< Evas_3D_Mesh * > mesh_list_get() const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_mesh_list_get());
+      return efl::eolian::to_cxx<efl::eina::crange_list< Evas_3D_Mesh * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @param x Coordinates of vector.
+   /// @param y 
+   /// @param z 
+   /// @param x2 
+   /// @param y2 
+   /// @param z2 
+   ///
+   void bounding_box_get(Evas_Real * x_, Evas_Real * y_, Evas_Real * z_, Evas_Real * x2_, Evas_Real * y2_, Evas_Real * z2_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_node_bounding_box_get(x_, y_, z_, x2_, y2_, z2_));
+   }
+
+   /// @param camera_node 
+   ///
+   int obb_frustum_check(Evas_3D_Node * camera_node_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_node_obb_frustum_check(camera_node_));
+      return _tmp_ret;
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_NODE_CLASS);
+   }
+
+private:
+   static Eo* _c0(Evas_3D_Node_Type type_, efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_NODE_CLASS, _p._eo_raw, evas_3d_node_constructor(type_));
+   }
+
+};
+template <typename T>
+void _evas_3d_node_update_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update_notify();
+}
+
+template <typename T>
+void _evas_3d_node_change_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change_notify(state_, ref_);
+}
+
+template <typename T>
+bool _evas_3d_node_position_inherit_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->position_inherit_get();
+}
+
+template <typename T>
+void _evas_3d_node_position_inherit_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool inherit_)
+{
+   static_cast<T*>(self->this_)->position_inherit_set(efl::eolian::to_cxx<bool>(inherit_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool _evas_3d_node_orientation_inherit_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->orientation_inherit_get();
+}
+
+template <typename T>
+void _evas_3d_node_orientation_inherit_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool inherit_)
+{
+   static_cast<T*>(self->this_)->orientation_inherit_set(efl::eolian::to_cxx<bool>(inherit_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool _evas_3d_node_scale_inherit_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->scale_inherit_get();
+}
+
+template <typename T>
+void _evas_3d_node_scale_inherit_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool inherit_)
+{
+   static_cast<T*>(self->this_)->scale_inherit_set(efl::eolian::to_cxx<bool>(inherit_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_3D_Camera * _evas_3d_node_camera_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->camera_get();
+}
+
+template <typename T>
+void _evas_3d_node_camera_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Camera * camera_)
+{
+   static_cast<T*>(self->this_)->camera_set(camera_);
+}
+
+template <typename T>
+Evas_3D_Light * _evas_3d_node_light_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->light_get();
+}
+
+template <typename T>
+void _evas_3d_node_light_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Light * light_)
+{
+   static_cast<T*>(self->this_)->light_set(light_);
+}
+
+template <typename T>
+int _evas_3d_node_mesh_frame_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Mesh * mesh_)
+{
+   return static_cast<T*>(self->this_)->mesh_frame_get(mesh_);
+}
+
+template <typename T>
+void _evas_3d_node_mesh_frame_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Mesh * mesh_, int frame_)
+{
+   static_cast<T*>(self->this_)->mesh_frame_set(mesh_, frame_);
+}
+
+template <typename T>
+Evas_3D_Node_Type _evas_3d_node_type_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->type_get();
+}
+
+template <typename T>
+void _evas_3d_node_member_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Node * member_)
+{
+   static_cast<T*>(self->this_)->member_add(member_);
+}
+
+template <typename T>
+void _evas_3d_node_member_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Node * member_)
+{
+   static_cast<T*>(self->this_)->member_del(member_);
+}
+
+template <typename T>
+Evas_3D_Node * _evas_3d_node_parent_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->parent_get();
+}
+
+template <typename T>
+efl::eina::crange_list< Evas_3D_Node * > _evas_3d_node_member_list_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->member_list_get();
+}
+
+template <typename T>
+void _evas_3d_node_position_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real x_, Evas_Real y_, Evas_Real z_)
+{
+   static_cast<T*>(self->this_)->position_set(x_, y_, z_);
+}
+
+template <typename T>
+void _evas_3d_node_orientation_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_Real w_)
+{
+   static_cast<T*>(self->this_)->orientation_set(x_, y_, z_, w_);
+}
+
+template <typename T>
+void _evas_3d_node_orientation_angle_axis_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real angle_, Evas_Real x_, Evas_Real y_, Evas_Real z_)
+{
+   static_cast<T*>(self->this_)->orientation_angle_axis_set(angle_, x_, y_, z_);
+}
+
+template <typename T>
+void _evas_3d_node_scale_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real x_, Evas_Real y_, Evas_Real z_)
+{
+   static_cast<T*>(self->this_)->scale_set(x_, y_, z_);
+}
+
+template <typename T>
+void _evas_3d_node_position_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_)
+{
+   static_cast<T*>(self->this_)->position_get(space_, x_, y_, z_);
+}
+
+template <typename T>
+void _evas_3d_node_orientation_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_, Evas_Real* w_)
+{
+   static_cast<T*>(self->this_)->orientation_get(space_, x_, y_, z_, w_);
+}
+
+template <typename T>
+void _evas_3d_node_scale_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_)
+{
+   static_cast<T*>(self->this_)->scale_get(space_, x_, y_, z_);
+}
+
+template <typename T>
+void _evas_3d_node_look_at_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Space target_space_, Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_3D_Space up_space_, Evas_Real ux_, Evas_Real uy_, Evas_Real uz_)
+{
+   static_cast<T*>(self->this_)->look_at_set(target_space_, x_, y_, z_, up_space_, ux_, uy_, uz_);
+}
+
+template <typename T>
+void _evas_3d_node_mesh_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Mesh * mesh_)
+{
+   static_cast<T*>(self->this_)->mesh_add(mesh_);
+}
+
+template <typename T>
+void _evas_3d_node_mesh_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Mesh * mesh_)
+{
+   static_cast<T*>(self->this_)->mesh_del(mesh_);
+}
+
+template <typename T>
+efl::eina::crange_list< Evas_3D_Mesh * > _evas_3d_node_mesh_list_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->mesh_list_get();
+}
+
+template <typename T>
+void _evas_3d_node_bounding_box_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real * x_, Evas_Real * y_, Evas_Real * z_, Evas_Real * x2_, Evas_Real * y2_, Evas_Real * z2_)
+{
+   static_cast<T*>(self->this_)->bounding_box_get(x_, y_, z_, x2_, y2_, z2_);
+}
+
+template <typename T>
+int _evas_3d_node_obb_frustum_check_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Node * camera_node_)
+{
+   return static_cast<T*>(self->this_)->obb_frustum_check(camera_node_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_node >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void update_notify()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update_notify());
+      }
+
+      virtual void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      virtual bool position_inherit_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_position_inherit_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void position_inherit_set(bool inherit_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_position_inherit_set(efl::eolian::to_c(inherit_)));
+      }
+
+      virtual bool orientation_inherit_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_orientation_inherit_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void orientation_inherit_set(bool inherit_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_orientation_inherit_set(efl::eolian::to_c(inherit_)));
+      }
+
+      virtual bool scale_inherit_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_scale_inherit_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void scale_inherit_set(bool inherit_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_scale_inherit_set(efl::eolian::to_c(inherit_)));
+      }
+
+      virtual Evas_3D_Camera * camera_get()
+      {
+         Evas_3D_Camera * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_camera_get());
+            return _tmp_ret;
+      }
+
+      virtual void camera_set(Evas_3D_Camera * camera_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_camera_set(camera_));
+      }
+
+      virtual Evas_3D_Light * light_get()
+      {
+         Evas_3D_Light * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_light_get());
+            return _tmp_ret;
+      }
+
+      virtual void light_set(Evas_3D_Light * light_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_light_set(light_));
+      }
+
+      virtual int mesh_frame_get(Evas_3D_Mesh * mesh_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_mesh_frame_get(mesh_));
+            return _tmp_ret;
+      }
+
+      virtual void mesh_frame_set(Evas_3D_Mesh * mesh_, int frame_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_mesh_frame_set(mesh_, frame_));
+      }
+
+      virtual Evas_3D_Node_Type type_get()
+      {
+         Evas_3D_Node_Type _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_type_get());
+            return _tmp_ret;
+      }
+
+      virtual void member_add(Evas_3D_Node * member_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_member_add(member_));
+      }
+
+      virtual void member_del(Evas_3D_Node * member_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_member_del(member_));
+      }
+
+      virtual Evas_3D_Node * parent_get()
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_parent_get());
+            return _tmp_ret;
+      }
+
+      virtual efl::eina::crange_list< Evas_3D_Node * > member_list_get()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_member_list_get());
+            return efl::eolian::to_cxx<efl::eina::crange_list< Evas_3D_Node * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual void position_set(Evas_Real x_, Evas_Real y_, Evas_Real z_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_position_set(x_, y_, z_));
+      }
+
+      virtual void orientation_set(Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_Real w_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_orientation_set(x_, y_, z_, w_));
+      }
+
+      virtual void orientation_angle_axis_set(Evas_Real angle_, Evas_Real x_, Evas_Real y_, Evas_Real z_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_orientation_angle_axis_set(angle_, x_, y_, z_));
+      }
+
+      virtual void scale_set(Evas_Real x_, Evas_Real y_, Evas_Real z_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_scale_set(x_, y_, z_));
+      }
+
+      virtual void position_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_position_get(space_, x_, y_, z_));
+      }
+
+      virtual void orientation_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_, Evas_Real* w_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_orientation_get(space_, x_, y_, z_, w_));
+      }
+
+      virtual void scale_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_scale_get(space_, x_, y_, z_));
+      }
+
+      virtual void look_at_set(Evas_3D_Space target_space_, Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_3D_Space up_space_, Evas_Real ux_, Evas_Real uy_, Evas_Real uz_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_look_at_set(target_space_, x_, y_, z_, up_space_, ux_, uy_, uz_));
+      }
+
+      virtual void mesh_add(Evas_3D_Mesh * mesh_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_mesh_add(mesh_));
+      }
+
+      virtual void mesh_del(Evas_3D_Mesh * mesh_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_mesh_del(mesh_));
+      }
+
+      virtual efl::eina::crange_list< Evas_3D_Mesh * > mesh_list_get()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_mesh_list_get());
+            return efl::eolian::to_cxx<efl::eina::crange_list< Evas_3D_Mesh * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual void bounding_box_get(Evas_Real * x_, Evas_Real * y_, Evas_Real * z_, Evas_Real * x2_, Evas_Real * y2_, Evas_Real * z2_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_node_bounding_box_get(x_, y_, z_, x2_, y2_, z2_));
+      }
+
+      virtual int obb_frustum_check(Evas_3D_Node * camera_node_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_node_obb_frustum_check(camera_node_));
+            return _tmp_ret;
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_node >
+{
+   static const int value = 32;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_node>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_node_update_notify_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update_notify);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_node_change_notify_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change_notify);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_node_position_inherit_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_node_position_inherit_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_node_position_inherit_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_node_position_inherit_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_node_orientation_inherit_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_node_orientation_inherit_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_node_orientation_inherit_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_node_orientation_inherit_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_evas_3d_node_scale_inherit_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_3d_node_scale_inherit_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_evas_3d_node_scale_inherit_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_3d_node_scale_inherit_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_evas_3d_node_camera_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_3d_node_camera_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_evas_3d_node_camera_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_3d_node_camera_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::_evas_3d_node_light_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_3d_node_light_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::_evas_3d_node_light_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_3d_node_light_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::_evas_3d_node_mesh_frame_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_3d_node_mesh_frame_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::_evas_3d_node_mesh_frame_set_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_3d_node_mesh_frame_set);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::_evas_3d_node_type_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_3d_node_type_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::_evas_3d_node_member_add_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_3d_node_member_add);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::_evas_3d_node_member_del_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_3d_node_member_del);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::_evas_3d_node_parent_get_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_3d_node_parent_get);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::_evas_3d_node_member_list_get_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_3d_node_member_list_get);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::_evas_3d_node_position_set_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_3d_node_position_set);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::_evas_3d_node_orientation_set_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_3d_node_orientation_set);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::_evas_3d_node_orientation_angle_axis_set_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_3d_node_orientation_angle_axis_set);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::_evas_3d_node_scale_set_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_3d_node_scale_set);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::_evas_3d_node_position_get_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_3d_node_position_get);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::_evas_3d_node_orientation_get_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_3d_node_orientation_get);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::_evas_3d_node_scale_get_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_3d_node_scale_get);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::_evas_3d_node_look_at_set_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_3d_node_look_at_set);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::_evas_3d_node_mesh_add_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::evas_3d_node_mesh_add);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::_evas_3d_node_mesh_del_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::evas_3d_node_mesh_del);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   ops[29].func = reinterpret_cast<void*>(& ::_evas_3d_node_mesh_list_get_wrapper<T>);
+   ops[29].api_func = reinterpret_cast<void*>(& ::evas_3d_node_mesh_list_get);
+   ops[29].op = EO_OP_OVERRIDE;
+   ops[29].op_type = EO_OP_TYPE_REGULAR;
+   ops[29].doc = NULL;
+
+   ops[30].func = reinterpret_cast<void*>(& ::_evas_3d_node_bounding_box_get_wrapper<T>);
+   ops[30].api_func = reinterpret_cast<void*>(& ::evas_3d_node_bounding_box_get);
+   ops[30].op = EO_OP_OVERRIDE;
+   ops[30].op_type = EO_OP_TYPE_REGULAR;
+   ops[30].doc = NULL;
+
+   ops[31].func = reinterpret_cast<void*>(& ::_evas_3d_node_obb_frustum_check_wrapper<T>);
+   ops[31].api_func = reinterpret_cast<void*>(& ::evas_3d_node_obb_frustum_check);
+   ops[31].op = EO_OP_OVERRIDE;
+   ops[31].op_type = EO_OP_TYPE_REGULAR;
+   ops[31].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_node >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_node, ::std::tuple<Evas_3D_Node_Type> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::evas_3d_node_constructor(::efl::eolian::to_c(args.get<0>())));
+}
+
+inline void
+call_constructor(tag< ::evas_3d_node >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_node, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_node>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_node() const
+      {
+         return ::evas_3d_node(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void update_notify()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update_notify());
+      }
+
+      void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      bool position_inherit_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_position_inherit_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void position_inherit_set(bool inherit_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_position_inherit_set(efl::eolian::to_c(inherit_)));
+      }
+
+      bool orientation_inherit_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_orientation_inherit_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void orientation_inherit_set(bool inherit_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_orientation_inherit_set(efl::eolian::to_c(inherit_)));
+      }
+
+      bool scale_inherit_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_scale_inherit_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void scale_inherit_set(bool inherit_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_scale_inherit_set(efl::eolian::to_c(inherit_)));
+      }
+
+      Evas_3D_Camera * camera_get()
+      {
+         Evas_3D_Camera * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_camera_get());
+            return _tmp_ret;
+      }
+
+      void camera_set(Evas_3D_Camera * camera_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_camera_set(camera_));
+      }
+
+      Evas_3D_Light * light_get()
+      {
+         Evas_3D_Light * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_light_get());
+            return _tmp_ret;
+      }
+
+      void light_set(Evas_3D_Light * light_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_light_set(light_));
+      }
+
+      int mesh_frame_get(Evas_3D_Mesh * mesh_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_mesh_frame_get(mesh_));
+            return _tmp_ret;
+      }
+
+      void mesh_frame_set(Evas_3D_Mesh * mesh_, int frame_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_mesh_frame_set(mesh_, frame_));
+      }
+
+      Evas_3D_Node_Type type_get()
+      {
+         Evas_3D_Node_Type _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_type_get());
+            return _tmp_ret;
+      }
+
+      void member_add(Evas_3D_Node * member_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_member_add(member_));
+      }
+
+      void member_del(Evas_3D_Node * member_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_member_del(member_));
+      }
+
+      Evas_3D_Node * parent_get()
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_parent_get());
+            return _tmp_ret;
+      }
+
+      efl::eina::crange_list< Evas_3D_Node * > member_list_get()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_member_list_get());
+            return efl::eolian::to_cxx<efl::eina::crange_list< Evas_3D_Node * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      void position_set(Evas_Real x_, Evas_Real y_, Evas_Real z_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_position_set(x_, y_, z_));
+      }
+
+      void orientation_set(Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_Real w_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_orientation_set(x_, y_, z_, w_));
+      }
+
+      void orientation_angle_axis_set(Evas_Real angle_, Evas_Real x_, Evas_Real y_, Evas_Real z_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_orientation_angle_axis_set(angle_, x_, y_, z_));
+      }
+
+      void scale_set(Evas_Real x_, Evas_Real y_, Evas_Real z_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_scale_set(x_, y_, z_));
+      }
+
+      void position_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_position_get(space_, x_, y_, z_));
+      }
+
+      void orientation_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_, Evas_Real* w_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_orientation_get(space_, x_, y_, z_, w_));
+      }
+
+      void scale_get(Evas_3D_Space space_, Evas_Real* x_, Evas_Real* y_, Evas_Real* z_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_scale_get(space_, x_, y_, z_));
+      }
+
+      void look_at_set(Evas_3D_Space target_space_, Evas_Real x_, Evas_Real y_, Evas_Real z_, Evas_3D_Space up_space_, Evas_Real ux_, Evas_Real uy_, Evas_Real uz_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_look_at_set(target_space_, x_, y_, z_, up_space_, ux_, uy_, uz_));
+      }
+
+      void mesh_add(Evas_3D_Mesh * mesh_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_mesh_add(mesh_));
+      }
+
+      void mesh_del(Evas_3D_Mesh * mesh_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_mesh_del(mesh_));
+      }
+
+      efl::eina::crange_list< Evas_3D_Mesh * > mesh_list_get()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_mesh_list_get());
+            return efl::eolian::to_cxx<efl::eina::crange_list< Evas_3D_Mesh * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      void bounding_box_get(Evas_Real * x_, Evas_Real * y_, Evas_Real * z_, Evas_Real * x2_, Evas_Real * y2_, Evas_Real * z2_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_node_bounding_box_get(x_, y_, z_, x2_, y2_, z2_));
+      }
+
+      int obb_frustum_check(Evas_3D_Node * camera_node_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_node_obb_frustum_check(camera_node_));
+            return _tmp_ret;
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_node>)
+{
+   return (EVAS_3D_NODE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_NODE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_node.eo.legacy.h b/src/lib/evas/canvas/evas_3d_node.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_node.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_node.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_NODE_EO_LEGACY_H_
+#define _EVAS_3D_NODE_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_NODE_EO_CLASS_TYPE
+#define _EVAS_3D_NODE_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Node;
+
+#endif
+
+#ifndef _EVAS_3D_NODE_EO_TYPES
+#define _EVAS_3D_NODE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_object.eo.c b/src/lib/evas/canvas/evas_3d_object.eo.c
--- a/src/lib/evas/canvas/evas_3d_object.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_object.eo.c	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,54 @@
+EOAPI EO_VOID_FUNC_BODY(evas_3d_object_update_notify);
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_object_change_notify, EO_FUNC_CALL(state, ref), Evas_3D_State state, Evas_3D_Object *ref);
+
+void _evas_3d_object_change(Eo *obj, Evas_3D_Object_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_object_change, EO_FUNC_CALL(state, ref), Evas_3D_State state, Evas_3D_Object *ref);
+
+Evas_3D_Object_Type _evas_3d_object_type_get(Eo *obj, Evas_3D_Object_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_object_type_get, Evas_3D_Object_Type, 0);
+
+void _evas_3d_object_type_set(Eo *obj, Evas_3D_Object_Data *pd, Evas_3D_Object_Type type);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_object_type_set, EO_FUNC_CALL(type), Evas_3D_Object_Type type);
+
+Eina_Bool _evas_3d_object_dirty_get(Eo *obj, Evas_3D_Object_Data *pd, Evas_3D_State state);
+
+EOAPI EO_FUNC_BODYV(evas_3d_object_dirty_get, Eina_Bool, 0, EO_FUNC_CALL(state), Evas_3D_State state);
+
+void _evas_3d_object_update(Eo *obj, Evas_3D_Object_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_3d_object_update);
+
+void _evas_3d_object_eo_base_constructor(Eo *obj, Evas_3D_Object_Data *pd);
+
+
+Evas * _evas_3d_object_evas_common_interface_evas_get(Eo *obj, Evas_3D_Object_Data *pd);
+
+
+static Eo_Op_Description _evas_3d_object_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_3d_object_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(evas_common_evas_get, _evas_3d_object_evas_common_interface_evas_get),
+     EO_OP_FUNC(evas_3d_object_update_notify, NULL, "Pure virtual update_notify function.."),
+     EO_OP_FUNC(evas_3d_object_change_notify, NULL, "Pure virtual change_notify function.."),
+     EO_OP_FUNC(evas_3d_object_change, _evas_3d_object_change, "Notify the object regarding its  state change."),
+     EO_OP_FUNC(evas_3d_object_type_get, _evas_3d_object_type_get, "Returns the type of the object."),
+     EO_OP_FUNC(evas_3d_object_type_set, _evas_3d_object_type_set, "Returns the type of the object."),
+     EO_OP_FUNC(evas_3d_object_dirty_get, _evas_3d_object_dirty_get, "Returns the status of a particular state of the object."),
+     EO_OP_FUNC(evas_3d_object_update, _evas_3d_object_update, "Update request for the object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_object_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Object",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_object_op_desc),
+     NULL,
+     sizeof(Evas_3D_Object_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_object_class_get, &_evas_3d_object_class_desc, EO_BASE_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_object.eo.h b/src/lib/evas/canvas/evas_3d_object.eo.h
--- a/src/lib/evas/canvas/evas_3d_object.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_object.eo.h	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,92 @@
+#ifndef _EVAS_3D_OBJECT_EO_H_
+#define _EVAS_3D_OBJECT_EO_H_
+
+#ifndef _EVAS_3D_OBJECT_EO_CLASS_TYPE
+#define _EVAS_3D_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Object;
+
+#endif
+
+#ifndef _EVAS_3D_OBJECT_EO_TYPES
+#define _EVAS_3D_OBJECT_EO_TYPES
+
+
+#endif
+#define EVAS_3D_OBJECT_CLASS evas_3d_object_class_get()
+
+const Eo_Class *evas_3d_object_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Pure virtual update_notify function..
+ * Update request for the object.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_3d_object_update_notify(void);
+
+/**
+ *
+ * Pure virtual change_notify function..
+ * Update request for the object.
+ * 
+ *
+ * @param[in] state State that is changed
+ * @param[in] ref The Object that caused the change
+ *
+ */
+EOAPI void  evas_3d_object_change_notify(Evas_3D_State state, Evas_3D_Object *ref);
+
+/**
+ *
+ * Notify the object regarding its  state change.
+ * 
+ *
+ * @param[in] state State that is changed
+ * @param[in] ref The Object that caused the change
+ *
+ */
+EOAPI void  evas_3d_object_change(Evas_3D_State state, Evas_3D_Object *ref);
+
+/**
+ *
+ * Returns the type of the object.
+ * 
+ *
+ *
+ */
+EOAPI Evas_3D_Object_Type  evas_3d_object_type_get(void);
+
+/**
+ *
+ * Returns the type of the object.
+ * 
+ *
+ * @param[in] type No description supplied.
+ *
+ */
+EOAPI void  evas_3d_object_type_set(Evas_3D_Object_Type type);
+
+/**
+ *
+ * Returns the status of a particular state of the object.
+ * 
+ *
+ * @param[in] state State whose status is being asked
+ *
+ */
+EOAPI Eina_Bool  evas_3d_object_dirty_get(Evas_3D_State state);
+
+/**
+ *
+ * Update request for the object.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_3d_object_update(void);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_object.eo.hh b/src/lib/evas/canvas/evas_3d_object.eo.hh
--- a/src/lib/evas/canvas/evas_3d_object.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_object.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,346 @@
+#ifndef EFL_GENERATED_EVAS_3D_OBJECT_HH
+#define EFL_GENERATED_EVAS_3D_OBJECT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_object.eo.h"
+}
+
+#include "evas_common_interface.eo.hh"
+
+struct evas_3d_object
+      : efl::eo::base,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_object>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_object(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_object(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   evas_3d_object(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_object(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_object(evas_3d_object const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_object() {}
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param ret 
+   ///
+   Evas * evas_get() const
+   {
+      Evas * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Notify the object regarding its  state change.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change(state_, ref_));
+   }
+
+   /// @brief Returns the type of the object.
+   ///
+   Evas_3D_Object_Type type_get() const
+   {
+      Evas_3D_Object_Type _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_object_type_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Returns the type of the object.
+   ///
+   /// @param type 
+   ///
+   void type_set(Evas_3D_Object_Type type_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_type_set(type_));
+   }
+
+   /// @brief Returns the status of a particular state of the object.
+   ///
+   /// @param state State whose status is being asked
+   ///
+   bool dirty_get(Evas_3D_State state_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_object_dirty_get(state_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Update request for the object.
+   ///
+   void update() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_OBJECT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_OBJECT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+Evas * _evas_3d_object_evas_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->evas_get();
+}
+
+template <typename T>
+void _evas_3d_object_change_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change(state_, ref_);
+}
+
+template <typename T>
+Evas_3D_Object_Type _evas_3d_object_type_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->type_get();
+}
+
+template <typename T>
+void _evas_3d_object_type_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Object_Type type_)
+{
+   static_cast<T*>(self->this_)->type_set(type_);
+}
+
+template <typename T>
+bool _evas_3d_object_dirty_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_)
+{
+   return static_cast<T*>(self->this_)->dirty_get(state_);
+}
+
+template <typename T>
+void _evas_3d_object_update_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_object >
+{
+   template <typename T>
+   struct type
+   {
+      virtual Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+      virtual void change(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change(state_, ref_));
+      }
+
+      virtual Evas_3D_Object_Type type_get()
+      {
+         Evas_3D_Object_Type _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_object_type_get());
+            return _tmp_ret;
+      }
+
+      virtual void type_set(Evas_3D_Object_Type type_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_type_set(type_));
+      }
+
+      virtual bool dirty_get(Evas_3D_State state_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_object_dirty_get(state_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void update()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_object >
+{
+   static const int value = 6;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_object>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_object_evas_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_common_evas_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_object_change_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_object_type_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_object_type_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_object_type_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_object_type_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_object_dirty_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_object_dirty_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_object_update_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_object >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_object, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::evas_3d_object >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_object, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_object>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_object() const
+      {
+         return ::evas_3d_object(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+      void change(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change(state_, ref_));
+      }
+
+      Evas_3D_Object_Type type_get()
+      {
+         Evas_3D_Object_Type _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_object_type_get());
+            return _tmp_ret;
+      }
+
+      void type_set(Evas_3D_Object_Type type_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_type_set(type_));
+      }
+
+      bool dirty_get(Evas_3D_State state_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_object_dirty_get(state_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void update()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_object>)
+{
+   return (EVAS_3D_OBJECT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_OBJECT_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_object.eo.legacy.h b/src/lib/evas/canvas/evas_3d_object.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_object.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_object.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_OBJECT_EO_LEGACY_H_
+#define _EVAS_3D_OBJECT_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_OBJECT_EO_CLASS_TYPE
+#define _EVAS_3D_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Object;
+
+#endif
+
+#ifndef _EVAS_3D_OBJECT_EO_TYPES
+#define _EVAS_3D_OBJECT_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_scene.eo.c b/src/lib/evas/canvas/evas_3d_scene.eo.c
--- a/src/lib/evas/canvas/evas_3d_scene.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_scene.eo.c	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,94 @@
+
+void _evas_3d_scene_root_node_set(Eo *obj, Evas_3D_Scene_Data *pd, Evas_3D_Node *node);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_scene_root_node_set, EO_FUNC_CALL(node), Evas_3D_Node *node);
+
+Evas_3D_Node * _evas_3d_scene_root_node_get(Eo *obj, Evas_3D_Scene_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_scene_root_node_get, Evas_3D_Node *, 0);
+
+void _evas_3d_scene_camera_node_set(Eo *obj, Evas_3D_Scene_Data *pd, Evas_3D_Node *node);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_scene_camera_node_set, EO_FUNC_CALL(node), Evas_3D_Node *node);
+
+Evas_3D_Node * _evas_3d_scene_camera_node_get(Eo *obj, Evas_3D_Scene_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_scene_camera_node_get, Evas_3D_Node *, 0);
+
+void _evas_3d_scene_size_set(Eo *obj, Evas_3D_Scene_Data *pd, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_scene_size_set, EO_FUNC_CALL(w, h), int w, int h);
+
+void _evas_3d_scene_size_get(Eo *obj, Evas_3D_Scene_Data *pd, int *w, int *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_scene_size_get, EO_FUNC_CALL(w, h), int *w, int *h);
+
+void _evas_3d_scene_background_color_set(Eo *obj, Evas_3D_Scene_Data *pd, Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_scene_background_color_set, EO_FUNC_CALL(r, g, b, a), Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+void _evas_3d_scene_background_color_get(Eo *obj, Evas_3D_Scene_Data *pd, Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_scene_background_color_get, EO_FUNC_CALL(r, g, b, a), Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+Eina_Bool _evas_3d_scene_pick(Eo *obj, Evas_3D_Scene_Data *pd, Evas_Real x, Evas_Real y, Evas_3D_Node **node, Evas_3D_Mesh **mesh, Evas_Real *s, Evas_Real *t);
+
+EOAPI EO_FUNC_BODYV(evas_3d_scene_pick, Eina_Bool, 0, EO_FUNC_CALL(x, y, node, mesh, s, t), Evas_Real x, Evas_Real y, Evas_3D_Node **node, Evas_3D_Mesh **mesh, Evas_Real *s, Evas_Real *t);
+
+Evas_3D_Node * _evas_3d_scene_exist(Eo *obj, Evas_3D_Scene_Data *pd, Evas_Real x, Evas_Real y, Evas_3D_Node *node);
+
+EOAPI EO_FUNC_BODYV(evas_3d_scene_exist, Evas_3D_Node *, 0, EO_FUNC_CALL(x, y, node), Evas_Real x, Evas_Real y, Evas_3D_Node *node);
+
+Eina_List * _evas_3d_scene_pick_member_list_get(Eo *obj, Evas_3D_Scene_Data *pd, Evas_Real x, Evas_Real y);
+
+EOAPI EO_FUNC_BODYV(evas_3d_scene_pick_member_list_get, Eina_List *, 0, EO_FUNC_CALL(x, y), Evas_Real x, Evas_Real y);
+
+void _evas_3d_scene_shadows_enable_set(Eo *obj, Evas_3D_Scene_Data *pd, Eina_Bool shadows_enabled);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_scene_shadows_enable_set, EO_FUNC_CALL(shadows_enabled), Eina_Bool shadows_enabled);
+
+Eina_Bool _evas_3d_scene_shadows_enable_get(Eo *obj, Evas_3D_Scene_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_scene_shadows_enable_get, Eina_Bool, 0);
+
+void _evas_3d_scene_eo_base_constructor(Eo *obj, Evas_3D_Scene_Data *pd);
+
+
+void _evas_3d_scene_evas_3d_object_update_notify(Eo *obj, Evas_3D_Scene_Data *pd);
+
+
+void _evas_3d_scene_evas_3d_object_change_notify(Eo *obj, Evas_3D_Scene_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+
+static Eo_Op_Description _evas_3d_scene_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_3d_scene_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_update_notify, _evas_3d_scene_evas_3d_object_update_notify),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_change_notify, _evas_3d_scene_evas_3d_object_change_notify),
+     EO_OP_FUNC(evas_3d_scene_root_node_set, _evas_3d_scene_root_node_set, ""),
+     EO_OP_FUNC(evas_3d_scene_root_node_get, _evas_3d_scene_root_node_get, ""),
+     EO_OP_FUNC(evas_3d_scene_camera_node_set, _evas_3d_scene_camera_node_set, ""),
+     EO_OP_FUNC(evas_3d_scene_camera_node_get, _evas_3d_scene_camera_node_get, ""),
+     EO_OP_FUNC(evas_3d_scene_size_set, _evas_3d_scene_size_set, ""),
+     EO_OP_FUNC(evas_3d_scene_size_get, _evas_3d_scene_size_get, ""),
+     EO_OP_FUNC(evas_3d_scene_background_color_set, _evas_3d_scene_background_color_set, ""),
+     EO_OP_FUNC(evas_3d_scene_background_color_get, _evas_3d_scene_background_color_get, ""),
+     EO_OP_FUNC(evas_3d_scene_pick, _evas_3d_scene_pick, ""),
+     EO_OP_FUNC(evas_3d_scene_exist, _evas_3d_scene_exist, ""),
+     EO_OP_FUNC(evas_3d_scene_pick_member_list_get, _evas_3d_scene_pick_member_list_get, ""),
+     EO_OP_FUNC(evas_3d_scene_shadows_enable_set, _evas_3d_scene_shadows_enable_set, ""),
+     EO_OP_FUNC(evas_3d_scene_shadows_enable_get, _evas_3d_scene_shadows_enable_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_scene_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Scene",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_scene_op_desc),
+     NULL,
+     sizeof(Evas_3D_Scene_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_scene_class_get, &_evas_3d_scene_class_desc, EVAS_3D_OBJECT_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_scene.eo.h b/src/lib/evas/canvas/evas_3d_scene.eo.h
--- a/src/lib/evas/canvas/evas_3d_scene.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_scene.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,151 @@
+#ifndef _EVAS_3D_SCENE_EO_H_
+#define _EVAS_3D_SCENE_EO_H_
+
+#ifndef _EVAS_3D_SCENE_EO_CLASS_TYPE
+#define _EVAS_3D_SCENE_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Scene;
+
+#endif
+
+#ifndef _EVAS_3D_SCENE_EO_TYPES
+#define _EVAS_3D_SCENE_EO_TYPES
+
+
+#endif
+#define EVAS_3D_SCENE_CLASS evas_3d_scene_class_get()
+
+const Eo_Class *evas_3d_scene_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] node A node which will be used as a root node for the scene.
+ *
+ */
+EOAPI void  evas_3d_scene_root_node_set(Evas_3D_Node *node);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Node * evas_3d_scene_root_node_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] node A node which will be used as a camera node for the scene.
+ *
+ */
+EOAPI void  evas_3d_scene_camera_node_set(Evas_3D_Node *node);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Node * evas_3d_scene_camera_node_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] w Width of the resolution.
+ * @param[in] h Height of the resolution.
+ *
+ */
+EOAPI void  evas_3d_scene_size_set(int w, int h);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[out] w Pointer to receive width of the resolution.
+ * @param[out] h Pointer to receive height of the resolution.
+ *
+ */
+EOAPI void  evas_3d_scene_size_get(int *w, int *h);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] r Red component of the background color.
+ * @param[in] g Green component of the background color.
+ * @param[in] b Blue component of the background color.
+ * @param[in] a Alpha component of the background color.
+ *
+ */
+EOAPI void  evas_3d_scene_background_color_set(Evas_Real r, Evas_Real g, Evas_Real b, Evas_Real a);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[out] r Pointer to receive red component of the background color.
+ * @param[out] g Pointer to receive green component of the background color.
+ * @param[out] b Pointer to receive blue component of the background color.
+ * @param[out] a Pointer to receive alpha component of the background color.
+ *
+ */
+EOAPI void  evas_3d_scene_background_color_get(Evas_Real *r, Evas_Real *g, Evas_Real *b, Evas_Real *a);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x X coordinate of the picking position.
+ * @param[in] y Y coordinate of the picking position.
+ * @param[out] node Pointer to receive the node contains the picked mesh.
+ * @param[out] mesh Pointer to receive the picked mesh.
+ * @param[out] s Pointer to receive the texture "s" coordinate.
+ * @param[out] t Pointer to receive the texture "t" coordinate.
+ *
+ */
+EOAPI Eina_Bool  evas_3d_scene_pick(Evas_Real x, Evas_Real y, Evas_3D_Node **node, Evas_3D_Mesh **mesh, Evas_Real *s, Evas_Real *t);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x X coordinate of the picking position.
+ * @param[in] y Y coordinate of the picking position.
+ * @param[in] node Node for search.
+ *
+ */
+EOAPI Evas_3D_Node * evas_3d_scene_exist(Evas_Real x, Evas_Real y, Evas_3D_Node *node);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x X coordinate of the picking position.
+ * @param[in] y Y coordinate of the picking position.
+ *
+ */
+EOAPI Eina_List * evas_3d_scene_pick_member_list_get(Evas_Real x, Evas_Real y);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] shadows_enabled shadows enabled status.
+ *
+ */
+EOAPI void  evas_3d_scene_shadows_enable_set(Eina_Bool shadows_enabled);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_scene_shadows_enable_get(void);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_scene.eo.hh b/src/lib/evas/canvas/evas_3d_scene.eo.hh
--- a/src/lib/evas/canvas/evas_3d_scene.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_scene.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,654 @@
+#ifndef EFL_GENERATED_EVAS_3D_SCENE_HH
+#define EFL_GENERATED_EVAS_3D_SCENE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_scene.eo.h"
+}
+
+#include "evas_3d_object.eo.hh"
+#include "evas_common_interface.eo.hh"
+
+struct evas_3d_scene
+      : evas_3d_object,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_scene>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_scene(Eo* eo)
+      : evas_3d_object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_scene(std::nullptr_t)
+      : evas_3d_object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   evas_3d_scene(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_scene(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_scene(evas_3d_scene const& other)
+      : evas_3d_object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_scene() {}
+
+   /// @brief Pure virtual update_notify function..
+   /// Update request for the object.
+   ///
+   void update_notify() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update_notify());
+   }
+
+   /// @brief Pure virtual change_notify function..
+   /// Update request for the object.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+   }
+
+   /// @param node A node which will be used as a root node for the scene.
+   ///
+   Evas_3D_Node * root_node_get() const
+   {
+      Evas_3D_Node * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_scene_root_node_get());
+      return _tmp_ret;
+   }
+
+   /// @param node A node which will be used as a root node for the scene.
+   ///
+   void root_node_set(Evas_3D_Node * node_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_scene_root_node_set(node_));
+   }
+
+   /// @param node A node which will be used as a camera node for the scene.
+   ///
+   Evas_3D_Node * camera_node_get() const
+   {
+      Evas_3D_Node * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_scene_camera_node_get());
+      return _tmp_ret;
+   }
+
+   /// @param node A node which will be used as a camera node for the scene.
+   ///
+   void camera_node_set(Evas_3D_Node * node_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_scene_camera_node_set(node_));
+   }
+
+   /// @param w Width of the resolution.
+   /// @param h Height of the resolution.
+   ///
+   void size_set(int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_scene_size_set(w_, h_));
+   }
+
+   /// @param[out] w Pointer to receive width of the resolution.
+   /// @param[out] h Pointer to receive height of the resolution.
+   ///
+   void size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_scene_size_get(w_, h_));
+   }
+
+   /// @param r Red component of the background color.
+   /// @param g Green component of the background color.
+   /// @param b Blue component of the background color.
+   /// @param a Alpha component of the background color.
+   ///
+   void background_color_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_scene_background_color_set(r_, g_, b_, a_));
+   }
+
+   /// @param[out] r Pointer to receive red component of the background color.
+   /// @param[out] g Pointer to receive green component of the background color.
+   /// @param[out] b Pointer to receive blue component of the background color.
+   /// @param[out] a Pointer to receive alpha component of the background color.
+   ///
+   void background_color_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_scene_background_color_get(r_, g_, b_, a_));
+   }
+
+   /// @param x X coordinate of the picking position.
+   /// @param y Y coordinate of the picking position.
+   /// @param[out] node Pointer to receive the node contains the picked mesh.
+   /// @param[out] mesh Pointer to receive the picked mesh.
+   /// @param[out] s Pointer to receive the texture "s" coordinate.
+   /// @param[out] t Pointer to receive the texture "t" coordinate.
+   ///
+   bool pick(Evas_Real x_, Evas_Real y_, Evas_3D_Node ** node_, Evas_3D_Mesh ** mesh_, Evas_Real* s_, Evas_Real* t_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_scene_pick(x_, y_, node_, mesh_, s_, t_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param x X coordinate of the picking position.
+   /// @param y Y coordinate of the picking position.
+   /// @param node Node for search.
+   ///
+   Evas_3D_Node * exist(Evas_Real x_, Evas_Real y_, Evas_3D_Node * node_) const
+   {
+      Evas_3D_Node * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_scene_exist(x_, y_, node_));
+      return _tmp_ret;
+   }
+
+   /// @param x X coordinate of the picking position.
+   /// @param y Y coordinate of the picking position.
+   ///
+   efl::eina::range_list< Evas_3D_Node * > pick_member_list_get(Evas_Real x_, Evas_Real y_) const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_scene_pick_member_list_get(x_, y_));
+      return efl::eolian::to_cxx<efl::eina::range_list< Evas_3D_Node * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @param shadows_enabled shadows enabled status.
+   ///
+   void shadows_enable_set(bool shadows_enabled_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_scene_shadows_enable_set(efl::eolian::to_c(shadows_enabled_)));
+   }
+
+   bool shadows_enable_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_scene_shadows_enable_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_SCENE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_SCENE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _evas_3d_scene_update_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update_notify();
+}
+
+template <typename T>
+void _evas_3d_scene_change_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change_notify(state_, ref_);
+}
+
+template <typename T>
+Evas_3D_Node * _evas_3d_scene_root_node_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->root_node_get();
+}
+
+template <typename T>
+void _evas_3d_scene_root_node_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Node * node_)
+{
+   static_cast<T*>(self->this_)->root_node_set(node_);
+}
+
+template <typename T>
+Evas_3D_Node * _evas_3d_scene_camera_node_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->camera_node_get();
+}
+
+template <typename T>
+void _evas_3d_scene_camera_node_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Node * node_)
+{
+   static_cast<T*>(self->this_)->camera_node_set(node_);
+}
+
+template <typename T>
+void _evas_3d_scene_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->size_set(w_, h_);
+}
+
+template <typename T>
+void _evas_3d_scene_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->size_get(w_, h_);
+}
+
+template <typename T>
+void _evas_3d_scene_background_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+{
+   static_cast<T*>(self->this_)->background_color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void _evas_3d_scene_background_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+{
+   static_cast<T*>(self->this_)->background_color_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+bool _evas_3d_scene_pick_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real x_, Evas_Real y_, Evas_3D_Node ** node_, Evas_3D_Mesh ** mesh_, Evas_Real* s_, Evas_Real* t_)
+{
+   return static_cast<T*>(self->this_)->pick(x_, y_, node_, mesh_, s_, t_);
+}
+
+template <typename T>
+Evas_3D_Node * _evas_3d_scene_exist_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real x_, Evas_Real y_, Evas_3D_Node * node_)
+{
+   return static_cast<T*>(self->this_)->exist(x_, y_, node_);
+}
+
+template <typename T>
+efl::eina::range_list< Evas_3D_Node * > _evas_3d_scene_pick_member_list_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Real x_, Evas_Real y_)
+{
+   return static_cast<T*>(self->this_)->pick_member_list_get(x_, y_);
+}
+
+template <typename T>
+void _evas_3d_scene_shadows_enable_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool shadows_enabled_)
+{
+   static_cast<T*>(self->this_)->shadows_enable_set(efl::eolian::to_cxx<bool>(shadows_enabled_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool _evas_3d_scene_shadows_enable_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->shadows_enable_get();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_scene >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void update_notify()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update_notify());
+      }
+
+      virtual void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      virtual Evas_3D_Node * root_node_get()
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_scene_root_node_get());
+            return _tmp_ret;
+      }
+
+      virtual void root_node_set(Evas_3D_Node * node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_scene_root_node_set(node_));
+      }
+
+      virtual Evas_3D_Node * camera_node_get()
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_scene_camera_node_get());
+            return _tmp_ret;
+      }
+
+      virtual void camera_node_set(Evas_3D_Node * node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_scene_camera_node_set(node_));
+      }
+
+      virtual void size_set(int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_scene_size_set(w_, h_));
+      }
+
+      virtual void size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_scene_size_get(w_, h_));
+      }
+
+      virtual void background_color_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_scene_background_color_set(r_, g_, b_, a_));
+      }
+
+      virtual void background_color_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_scene_background_color_get(r_, g_, b_, a_));
+      }
+
+      virtual bool pick(Evas_Real x_, Evas_Real y_, Evas_3D_Node ** node_, Evas_3D_Mesh ** mesh_, Evas_Real* s_, Evas_Real* t_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_scene_pick(x_, y_, node_, mesh_, s_, t_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Evas_3D_Node * exist(Evas_Real x_, Evas_Real y_, Evas_3D_Node * node_)
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_scene_exist(x_, y_, node_));
+            return _tmp_ret;
+      }
+
+      virtual efl::eina::range_list< Evas_3D_Node * > pick_member_list_get(Evas_Real x_, Evas_Real y_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_scene_pick_member_list_get(x_, y_));
+            return efl::eolian::to_cxx<efl::eina::range_list< Evas_3D_Node * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual void shadows_enable_set(bool shadows_enabled_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_scene_shadows_enable_set(efl::eolian::to_c(shadows_enabled_)));
+      }
+
+      virtual bool shadows_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_scene_shadows_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_scene >
+{
+   static const int value = 15;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_scene>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_scene_update_notify_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update_notify);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_scene_change_notify_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change_notify);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_scene_root_node_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_root_node_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_scene_root_node_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_root_node_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_scene_camera_node_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_camera_node_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_scene_camera_node_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_camera_node_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_evas_3d_scene_size_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_size_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_evas_3d_scene_size_get_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_size_get);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_evas_3d_scene_background_color_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_background_color_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_evas_3d_scene_background_color_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_background_color_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::_evas_3d_scene_pick_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_pick);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::_evas_3d_scene_exist_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_exist);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::_evas_3d_scene_pick_member_list_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_pick_member_list_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::_evas_3d_scene_shadows_enable_set_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_shadows_enable_set);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::_evas_3d_scene_shadows_enable_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_3d_scene_shadows_enable_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_scene >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_scene, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::evas_3d_scene >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_scene, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_scene>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_scene() const
+      {
+         return ::evas_3d_scene(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void update_notify()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update_notify());
+      }
+
+      void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      Evas_3D_Node * root_node_get()
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_scene_root_node_get());
+            return _tmp_ret;
+      }
+
+      void root_node_set(Evas_3D_Node * node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_scene_root_node_set(node_));
+      }
+
+      Evas_3D_Node * camera_node_get()
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_scene_camera_node_get());
+            return _tmp_ret;
+      }
+
+      void camera_node_set(Evas_3D_Node * node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_scene_camera_node_set(node_));
+      }
+
+      void size_set(int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_scene_size_set(w_, h_));
+      }
+
+      void size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_scene_size_get(w_, h_));
+      }
+
+      void background_color_set(Evas_Real r_, Evas_Real g_, Evas_Real b_, Evas_Real a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_scene_background_color_set(r_, g_, b_, a_));
+      }
+
+      void background_color_get(Evas_Real* r_, Evas_Real* g_, Evas_Real* b_, Evas_Real* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_scene_background_color_get(r_, g_, b_, a_));
+      }
+
+      bool pick(Evas_Real x_, Evas_Real y_, Evas_3D_Node ** node_, Evas_3D_Mesh ** mesh_, Evas_Real* s_, Evas_Real* t_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_scene_pick(x_, y_, node_, mesh_, s_, t_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Evas_3D_Node * exist(Evas_Real x_, Evas_Real y_, Evas_3D_Node * node_)
+      {
+         Evas_3D_Node * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_scene_exist(x_, y_, node_));
+            return _tmp_ret;
+      }
+
+      efl::eina::range_list< Evas_3D_Node * > pick_member_list_get(Evas_Real x_, Evas_Real y_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_scene_pick_member_list_get(x_, y_));
+            return efl::eolian::to_cxx<efl::eina::range_list< Evas_3D_Node * >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      void shadows_enable_set(bool shadows_enabled_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_scene_shadows_enable_set(efl::eolian::to_c(shadows_enabled_)));
+      }
+
+      bool shadows_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_scene_shadows_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_scene>)
+{
+   return (EVAS_3D_SCENE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_SCENE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_scene.eo.legacy.h b/src/lib/evas/canvas/evas_3d_scene.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_scene.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_scene.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_SCENE_EO_LEGACY_H_
+#define _EVAS_3D_SCENE_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_SCENE_EO_CLASS_TYPE
+#define _EVAS_3D_SCENE_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Scene;
+
+#endif
+
+#ifndef _EVAS_3D_SCENE_EO_TYPES
+#define _EVAS_3D_SCENE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_texture.eo.c b/src/lib/evas/canvas/evas_3d_texture.eo.c
--- a/src/lib/evas/canvas/evas_3d_texture.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_texture.eo.c	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,88 @@
+
+void _evas_3d_texture_source_visible_set(Eo *obj, Evas_3D_Texture_Data *pd, Eina_Bool visible);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_source_visible_set, EO_FUNC_CALL(visible), Eina_Bool visible);
+
+Eina_Bool _evas_3d_texture_source_visible_get(Eo *obj, Evas_3D_Texture_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_texture_source_visible_get, Eina_Bool, 0);
+
+void _evas_3d_texture_data_set(Eo *obj, Evas_3D_Texture_Data *pd, Evas_3D_Color_Format color_format, Evas_3D_Pixel_Format pixel_format, int w, int h, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_data_set, EO_FUNC_CALL(color_format, pixel_format, w, h, data), Evas_3D_Color_Format color_format, Evas_3D_Pixel_Format pixel_format, int w, int h, const void *data);
+
+void _evas_3d_texture_file_set(Eo *obj, Evas_3D_Texture_Data *pd, const char *file, const char *key);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_file_set, EO_FUNC_CALL(file, key), const char *file, const char *key);
+
+void _evas_3d_texture_source_set(Eo *obj, Evas_3D_Texture_Data *pd, Evas_Object *source);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_source_set, EO_FUNC_CALL(source), Evas_Object *source);
+
+Evas_3D_Color_Format _evas_3d_texture_color_format_get(Eo *obj, Evas_3D_Texture_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_3d_texture_color_format_get, Evas_3D_Color_Format, 0);
+
+void _evas_3d_texture_size_get(Eo *obj, Evas_3D_Texture_Data *pd, int *w, int *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_size_get, EO_FUNC_CALL(w, h), int *w, int *h);
+
+void _evas_3d_texture_wrap_set(Eo *obj, Evas_3D_Texture_Data *pd, Evas_3D_Wrap_Mode s, Evas_3D_Wrap_Mode t);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_wrap_set, EO_FUNC_CALL(s, t), Evas_3D_Wrap_Mode s, Evas_3D_Wrap_Mode t);
+
+void _evas_3d_texture_wrap_get(Eo *obj, Evas_3D_Texture_Data *pd, Evas_3D_Wrap_Mode *s, Evas_3D_Wrap_Mode *t);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_wrap_get, EO_FUNC_CALL(s, t), Evas_3D_Wrap_Mode *s, Evas_3D_Wrap_Mode *t);
+
+void _evas_3d_texture_filter_set(Eo *obj, Evas_3D_Texture_Data *pd, Evas_3D_Texture_Filter min, Evas_3D_Texture_Filter mag);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_filter_set, EO_FUNC_CALL(min, mag), Evas_3D_Texture_Filter min, Evas_3D_Texture_Filter mag);
+
+void _evas_3d_texture_filter_get(Eo *obj, Evas_3D_Texture_Data *pd, Evas_3D_Texture_Filter *min, Evas_3D_Texture_Filter *mag);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_3d_texture_filter_get, EO_FUNC_CALL(min, mag), Evas_3D_Texture_Filter *min, Evas_3D_Texture_Filter *mag);
+
+void _evas_3d_texture_eo_base_constructor(Eo *obj, Evas_3D_Texture_Data *pd);
+
+
+void _evas_3d_texture_eo_base_destructor(Eo *obj, Evas_3D_Texture_Data *pd);
+
+
+void _evas_3d_texture_evas_3d_object_update_notify(Eo *obj, Evas_3D_Texture_Data *pd);
+
+
+void _evas_3d_texture_evas_3d_object_change_notify(Eo *obj, Evas_3D_Texture_Data *pd, Evas_3D_State state, Evas_3D_Object *ref);
+
+
+static Eo_Op_Description _evas_3d_texture_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_3d_texture_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_3d_texture_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_update_notify, _evas_3d_texture_evas_3d_object_update_notify),
+     EO_OP_FUNC_OVERRIDE(evas_3d_object_change_notify, _evas_3d_texture_evas_3d_object_change_notify),
+     EO_OP_FUNC(evas_3d_texture_source_visible_set, _evas_3d_texture_source_visible_set, ""),
+     EO_OP_FUNC(evas_3d_texture_source_visible_get, _evas_3d_texture_source_visible_get, ""),
+     EO_OP_FUNC(evas_3d_texture_data_set, _evas_3d_texture_data_set, ""),
+     EO_OP_FUNC(evas_3d_texture_file_set, _evas_3d_texture_file_set, ""),
+     EO_OP_FUNC(evas_3d_texture_source_set, _evas_3d_texture_source_set, ""),
+     EO_OP_FUNC(evas_3d_texture_color_format_get, _evas_3d_texture_color_format_get, ""),
+     EO_OP_FUNC(evas_3d_texture_size_get, _evas_3d_texture_size_get, ""),
+     EO_OP_FUNC(evas_3d_texture_wrap_set, _evas_3d_texture_wrap_set, ""),
+     EO_OP_FUNC(evas_3d_texture_wrap_get, _evas_3d_texture_wrap_get, ""),
+     EO_OP_FUNC(evas_3d_texture_filter_set, _evas_3d_texture_filter_set, ""),
+     EO_OP_FUNC(evas_3d_texture_filter_get, _evas_3d_texture_filter_get, ""),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_3d_texture_class_desc = {
+     EO_VERSION,
+     "Evas_3D_Texture",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_3d_texture_op_desc),
+     NULL,
+     sizeof(Evas_3D_Texture_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_3d_texture_class_get, &_evas_3d_texture_class_desc, EVAS_3D_OBJECT_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_3d_texture.eo.h b/src/lib/evas/canvas/evas_3d_texture.eo.h
--- a/src/lib/evas/canvas/evas_3d_texture.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_texture.eo.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,128 @@
+#ifndef _EVAS_3D_TEXTURE_EO_H_
+#define _EVAS_3D_TEXTURE_EO_H_
+
+#ifndef _EVAS_3D_TEXTURE_EO_CLASS_TYPE
+#define _EVAS_3D_TEXTURE_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Texture;
+
+#endif
+
+#ifndef _EVAS_3D_TEXTURE_EO_TYPES
+#define _EVAS_3D_TEXTURE_EO_TYPES
+
+
+#endif
+#define EVAS_3D_TEXTURE_CLASS evas_3d_texture_class_get()
+
+const Eo_Class *evas_3d_texture_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] visible @c EINA_TRUE for visible, @c EINA_FALSE for invisible.
+ *
+ */
+EOAPI void  evas_3d_texture_source_visible_set(Eina_Bool visible);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_3d_texture_source_visible_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] color_format Color format of the texture.
+ * @param[in] pixel_format Pixel format of the data.
+ * @param[in] w Width of the data.
+ * @param[in] h Height of the data.
+ * @param[in] data Pointer to the data.
+ *
+ */
+EOAPI void  evas_3d_texture_data_set(Evas_3D_Color_Format color_format, Evas_3D_Pixel_Format pixel_format, int w, int h, const void *data);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] file Path to the image file.
+ * @param[in] key Key in the image file.
+ *
+ */
+EOAPI void  evas_3d_texture_file_set(const char *file, const char *key);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] source Source evas object to be used as the texture data.
+ *
+ */
+EOAPI void  evas_3d_texture_source_set(Evas_Object *source);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_3D_Color_Format  evas_3d_texture_color_format_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[out] w Pointer to receive the width of the texture size.
+ * @param[out] h Pointer to receive the height of the texture size.
+ *
+ */
+EOAPI void  evas_3d_texture_size_get(int *w, int *h);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] s Wrap mode for S-axis.
+ * @param[in] t Wrap mode for T-axis.
+ *
+ */
+EOAPI void  evas_3d_texture_wrap_set(Evas_3D_Wrap_Mode s, Evas_3D_Wrap_Mode t);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[out] s Pointer to receive S-axis wrap mode.
+ * @param[out] t Pointer to receive T-axis wrap mode.
+ *
+ */
+EOAPI void  evas_3d_texture_wrap_get(Evas_3D_Wrap_Mode *s, Evas_3D_Wrap_Mode *t);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] min Minification filter used when down-scaling.
+ * @param[in] mag Magnification filter used when up-scaling.
+ *
+ */
+EOAPI void  evas_3d_texture_filter_set(Evas_3D_Texture_Filter min, Evas_3D_Texture_Filter mag);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[out] min Pointer to receive the minification filter.
+ * @param[out] mag Pointer to receive the magnification filter.
+ *
+ */
+EOAPI void  evas_3d_texture_filter_get(Evas_3D_Texture_Filter *min, Evas_3D_Texture_Filter *mag);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_3d_texture.eo.hh b/src/lib/evas/canvas/evas_3d_texture.eo.hh
--- a/src/lib/evas/canvas/evas_3d_texture.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_texture.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,564 @@
+#ifndef EFL_GENERATED_EVAS_3D_TEXTURE_HH
+#define EFL_GENERATED_EVAS_3D_TEXTURE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_3d_texture.eo.h"
+}
+
+#include "evas_3d_object.eo.hh"
+#include "evas_common_interface.eo.hh"
+#include <canvas/evas_object.eo.hh>
+#include <string>
+
+struct evas_3d_texture
+      : evas_3d_object,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas_3d_texture>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit evas_3d_texture(Eo* eo)
+      : evas_3d_object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit evas_3d_texture(std::nullptr_t)
+      : evas_3d_object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   evas_3d_texture(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : evas_3d_texture(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   evas_3d_texture(evas_3d_texture const& other)
+      : evas_3d_object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~evas_3d_texture() {}
+
+   /// @brief Pure virtual update_notify function..
+   /// Update request for the object.
+   ///
+   void update_notify() const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_update_notify());
+   }
+
+   /// @brief Pure virtual change_notify function..
+   /// Update request for the object.
+   ///
+   /// @param state State that is changed
+   /// @param ref The Object that caused the change
+   ///
+   void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+   }
+
+   /// @param visible @c EINA_TRUE for visible, @c EINA_FALSE for invisible.
+   ///
+   bool source_visible_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_texture_source_visible_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @param visible @c EINA_TRUE for visible, @c EINA_FALSE for invisible.
+   ///
+   void source_visible_set(bool visible_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_source_visible_set(efl::eolian::to_c(visible_)));
+   }
+
+   /// @param color_format Color format of the texture.
+   /// @param pixel_format Pixel format of the data.
+   /// @param w Width of the data.
+   /// @param h Height of the data.
+   /// @param data Pointer to the data.
+   ///
+   void data_set(Evas_3D_Color_Format color_format_, Evas_3D_Pixel_Format pixel_format_, int w_, int h_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_data_set(color_format_, pixel_format_, w_, h_, data_));
+   }
+
+   /// @param file Path to the image file.
+   /// @param key Key in the image file.
+   ///
+   void file_set(std::string file_, std::string key_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+   }
+
+   /// @param source Source evas object to be used as the texture data.
+   ///
+   void source_set(evas::object source_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_source_set(efl::eolian::to_c(source_)));
+   }
+
+   Evas_3D_Color_Format color_format_get() const
+   {
+      Evas_3D_Color_Format _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_3d_texture_color_format_get());
+      return _tmp_ret;
+   }
+
+   /// @param[out] w Pointer to receive the width of the texture size.
+   /// @param[out] h Pointer to receive the height of the texture size.
+   ///
+   void size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_size_get(w_, h_));
+   }
+
+   /// @param s Wrap mode for S-axis.
+   /// @param t Wrap mode for T-axis.
+   ///
+   void wrap_set(Evas_3D_Wrap_Mode s_, Evas_3D_Wrap_Mode t_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_wrap_set(s_, t_));
+   }
+
+   /// @param[out] s Pointer to receive S-axis wrap mode.
+   /// @param[out] t Pointer to receive T-axis wrap mode.
+   ///
+   void wrap_get(Evas_3D_Wrap_Mode* s_, Evas_3D_Wrap_Mode* t_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_wrap_get(s_, t_));
+   }
+
+   /// @param min Minification filter used when down-scaling.
+   /// @param mag Magnification filter used when up-scaling.
+   ///
+   void filter_set(Evas_3D_Texture_Filter min_, Evas_3D_Texture_Filter mag_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_filter_set(min_, mag_));
+   }
+
+   /// @param[out] min Pointer to receive the minification filter.
+   /// @param[out] mag Pointer to receive the magnification filter.
+   ///
+   void filter_get(Evas_3D_Texture_Filter* min_, Evas_3D_Texture_Filter* mag_) const
+   {
+      eo_do(_eo_ptr(), ::evas_3d_texture_filter_get(min_, mag_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_3D_TEXTURE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_3D_TEXTURE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+template <typename T>
+void _evas_3d_texture_update_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->update_notify();
+}
+
+template <typename T>
+void _evas_3d_texture_change_notify_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_State state_, Evas_3D_Object * ref_)
+{
+   static_cast<T*>(self->this_)->change_notify(state_, ref_);
+}
+
+template <typename T>
+bool _evas_3d_texture_source_visible_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_visible_get();
+}
+
+template <typename T>
+void _evas_3d_texture_source_visible_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool visible_)
+{
+   static_cast<T*>(self->this_)->source_visible_set(efl::eolian::to_cxx<bool>(visible_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void _evas_3d_texture_data_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Color_Format color_format_, Evas_3D_Pixel_Format pixel_format_, int w_, int h_, const void * data_)
+{
+   static_cast<T*>(self->this_)->data_set(color_format_, pixel_format_, w_, h_, data_);
+}
+
+template <typename T>
+void _evas_3d_texture_file_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * file_, const char * key_)
+{
+   static_cast<T*>(self->this_)->file_set(efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void _evas_3d_texture_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * source_)
+{
+   static_cast<T*>(self->this_)->source_set(efl::eolian::to_cxx<evas::object>(source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_3D_Color_Format _evas_3d_texture_color_format_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->color_format_get();
+}
+
+template <typename T>
+void _evas_3d_texture_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->size_get(w_, h_);
+}
+
+template <typename T>
+void _evas_3d_texture_wrap_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Wrap_Mode s_, Evas_3D_Wrap_Mode t_)
+{
+   static_cast<T*>(self->this_)->wrap_set(s_, t_);
+}
+
+template <typename T>
+void _evas_3d_texture_wrap_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Wrap_Mode* s_, Evas_3D_Wrap_Mode* t_)
+{
+   static_cast<T*>(self->this_)->wrap_get(s_, t_);
+}
+
+template <typename T>
+void _evas_3d_texture_filter_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Texture_Filter min_, Evas_3D_Texture_Filter mag_)
+{
+   static_cast<T*>(self->this_)->filter_set(min_, mag_);
+}
+
+template <typename T>
+void _evas_3d_texture_filter_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Texture_Filter* min_, Evas_3D_Texture_Filter* mag_)
+{
+   static_cast<T*>(self->this_)->filter_get(min_, mag_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< ::evas_3d_texture >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void update_notify()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_update_notify());
+      }
+
+      virtual void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      virtual bool source_visible_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_texture_source_visible_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void source_visible_set(bool visible_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_source_visible_set(efl::eolian::to_c(visible_)));
+      }
+
+      virtual void data_set(Evas_3D_Color_Format color_format_, Evas_3D_Pixel_Format pixel_format_, int w_, int h_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_data_set(color_format_, pixel_format_, w_, h_, data_));
+      }
+
+      virtual void file_set(std::string file_, std::string key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      }
+
+      virtual void source_set(evas::object source_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_source_set(efl::eolian::to_c(source_)));
+      }
+
+      virtual Evas_3D_Color_Format color_format_get()
+      {
+         Evas_3D_Color_Format _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_3d_texture_color_format_get());
+            return _tmp_ret;
+      }
+
+      virtual void size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_size_get(w_, h_));
+      }
+
+      virtual void wrap_set(Evas_3D_Wrap_Mode s_, Evas_3D_Wrap_Mode t_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_wrap_set(s_, t_));
+      }
+
+      virtual void wrap_get(Evas_3D_Wrap_Mode* s_, Evas_3D_Wrap_Mode* t_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_wrap_get(s_, t_));
+      }
+
+      virtual void filter_set(Evas_3D_Texture_Filter min_, Evas_3D_Texture_Filter mag_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_filter_set(min_, mag_));
+      }
+
+      virtual void filter_get(Evas_3D_Texture_Filter* min_, Evas_3D_Texture_Filter* mag_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_3d_texture_filter_get(min_, mag_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< ::evas_3d_texture >
+{
+   static const int value = 13;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<::evas_3d_texture>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::_evas_3d_texture_update_notify_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_3d_object_update_notify);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::_evas_3d_texture_change_notify_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_3d_object_change_notify);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::_evas_3d_texture_source_visible_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_source_visible_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::_evas_3d_texture_source_visible_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_source_visible_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::_evas_3d_texture_data_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_data_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::_evas_3d_texture_file_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_file_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::_evas_3d_texture_source_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_source_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::_evas_3d_texture_color_format_get_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_color_format_get);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::_evas_3d_texture_size_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_size_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::_evas_3d_texture_wrap_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_wrap_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::_evas_3d_texture_wrap_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_wrap_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::_evas_3d_texture_filter_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_filter_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::_evas_3d_texture_filter_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_3d_texture_filter_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< ::evas_3d_texture >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_texture, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< ::evas_3d_texture >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<::evas_3d_texture, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< ::evas_3d_texture>
+{
+   template <typename U>
+   struct type
+   {
+      operator ::evas_3d_texture() const
+      {
+         return ::evas_3d_texture(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void update_notify()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_update_notify());
+      }
+
+      void change_notify(Evas_3D_State state_, Evas_3D_Object * ref_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_object_change_notify(state_, ref_));
+      }
+
+      bool source_visible_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_texture_source_visible_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void source_visible_set(bool visible_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_source_visible_set(efl::eolian::to_c(visible_)));
+      }
+
+      void data_set(Evas_3D_Color_Format color_format_, Evas_3D_Pixel_Format pixel_format_, int w_, int h_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_data_set(color_format_, pixel_format_, w_, h_, data_));
+      }
+
+      void file_set(std::string file_, std::string key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      }
+
+      void source_set(evas::object source_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_source_set(efl::eolian::to_c(source_)));
+      }
+
+      Evas_3D_Color_Format color_format_get()
+      {
+         Evas_3D_Color_Format _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_3d_texture_color_format_get());
+            return _tmp_ret;
+      }
+
+      void size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_size_get(w_, h_));
+      }
+
+      void wrap_set(Evas_3D_Wrap_Mode s_, Evas_3D_Wrap_Mode t_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_wrap_set(s_, t_));
+      }
+
+      void wrap_get(Evas_3D_Wrap_Mode* s_, Evas_3D_Wrap_Mode* t_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_wrap_get(s_, t_));
+      }
+
+      void filter_set(Evas_3D_Texture_Filter min_, Evas_3D_Texture_Filter mag_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_filter_set(min_, mag_));
+      }
+
+      void filter_get(Evas_3D_Texture_Filter* min_, Evas_3D_Texture_Filter* mag_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_3d_texture_filter_get(min_, mag_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<::evas_3d_texture>)
+{
+   return (EVAS_3D_TEXTURE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_3D_TEXTURE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_3d_texture.eo.legacy.h b/src/lib/evas/canvas/evas_3d_texture.eo.legacy.h
--- a/src/lib/evas/canvas/evas_3d_texture.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_3d_texture.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_3D_TEXTURE_EO_LEGACY_H_
+#define _EVAS_3D_TEXTURE_EO_LEGACY_H_
+
+#ifndef _EVAS_3D_TEXTURE_EO_CLASS_TYPE
+#define _EVAS_3D_TEXTURE_EO_CLASS_TYPE
+
+typedef Eo Evas_3D_Texture;
+
+#endif
+
+#ifndef _EVAS_3D_TEXTURE_EO_TYPES
+#define _EVAS_3D_TEXTURE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_box.eo.c b/src/lib/evas/canvas/evas_box.eo.c
--- a/src/lib/evas/canvas/evas_box.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_box.eo.c	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,402 @@
+EOAPI const Eo_Event_Description _EVAS_BOX_EVENT_CHILD_ADDED =
+   EO_EVENT_DESCRIPTION("child,added", "");
+EOAPI const Eo_Event_Description _EVAS_BOX_EVENT_CHILD_REMOVED =
+   EO_EVENT_DESCRIPTION("child,removed", "");
+
+void _evas_box_align_set(Eo *obj, Evas_Object_Box_Data *pd, double horizontal, double vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_align_set, EO_FUNC_CALL(horizontal, vertical), double horizontal, double vertical);
+
+void _evas_box_align_get(Eo *obj, Evas_Object_Box_Data *pd, double *horizontal, double *vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_align_get, EO_FUNC_CALL(horizontal, vertical), double *horizontal, double *vertical);
+
+void _evas_box_padding_set(Eo *obj, Evas_Object_Box_Data *pd, Evas_Coord horizontal, Evas_Coord vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_padding_set, EO_FUNC_CALL(horizontal, vertical), Evas_Coord horizontal, Evas_Coord vertical);
+
+void _evas_box_padding_get(Eo *obj, Evas_Object_Box_Data *pd, Evas_Coord *horizontal, Evas_Coord *vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_padding_get, EO_FUNC_CALL(horizontal, vertical), Evas_Coord *horizontal, Evas_Coord *vertical);
+
+void _evas_box_layout_set(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Layout cb, const void *data, Eina_Free_Cb free_data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_set, EO_FUNC_CALL(cb, data, free_data), Evas_Object_Box_Layout cb, const void *data, Eina_Free_Cb free_data);
+
+void _evas_box_layout_horizontal(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_horizontal, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+void _evas_box_layout_vertical(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_vertical, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+void _evas_box_layout_homogeneous_max_size_horizontal(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_homogeneous_max_size_horizontal, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+Evas_Object * _evas_box_internal_remove(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_remove, Evas_Object *, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+void _evas_box_layout_flow_vertical(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_flow_vertical, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+void _evas_box_internal_option_free(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Option *opt);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_internal_option_free, EO_FUNC_CALL(opt), Evas_Object_Box_Option *opt);
+
+Evas_Object_Box_Option * _evas_box_insert_after(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child, const Evas_Object *reference);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_insert_after, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child, reference), Evas_Object *child, const Evas_Object *reference);
+
+Eina_Bool _evas_box_remove_all(Eo *obj, Evas_Object_Box_Data *pd, Eina_Bool clear);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_remove_all, Eina_Bool, 0, EO_FUNC_CALL(clear), Eina_Bool clear);
+
+Eina_Iterator * _evas_box_iterator_new(Eo *obj, Evas_Object_Box_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_box_iterator_new, Eina_Iterator *, 0);
+
+Evas_Object * _evas_box_add_to(Eo *obj, Evas_Object_Box_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_box_add_to, Evas_Object *, 0);
+
+Evas_Object_Box_Option * _evas_box_append(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_append, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+int _evas_box_option_property_id_get(Eo *obj, Evas_Object_Box_Data *pd, const char *name);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_option_property_id_get, int, 0, EO_FUNC_CALL(name), const char *name);
+
+Evas_Object_Box_Option * _evas_box_prepend(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_prepend, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+Eina_Accessor * _evas_box_accessor_new(Eo *obj, Evas_Object_Box_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_box_accessor_new, Eina_Accessor *, 0);
+
+Evas_Object_Box_Option * _evas_box_internal_append(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_append, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+Eina_Bool _evas_box_option_property_vset(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Option *opt, int property, va_list *args);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_option_property_vset, Eina_Bool, 0, EO_FUNC_CALL(opt, property, args), Evas_Object_Box_Option *opt, int property, va_list *args);
+
+Evas_Object * _evas_box_internal_remove_at(Eo *obj, Evas_Object_Box_Data *pd, unsigned int pos);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_remove_at, Evas_Object *, 0, EO_FUNC_CALL(pos), unsigned int pos);
+
+Eina_Bool _evas_box_remove_at(Eo *obj, Evas_Object_Box_Data *pd, unsigned int pos);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_remove_at, Eina_Bool, 0, EO_FUNC_CALL(pos), unsigned int pos);
+
+Eina_Bool _evas_box_option_property_vget(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Option *opt, int property, va_list *args);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_option_property_vget, Eina_Bool, 0, EO_FUNC_CALL(opt, property, args), Evas_Object_Box_Option *opt, int property, va_list *args);
+
+Evas_Object_Box_Option * _evas_box_internal_insert_at(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child, unsigned int pos);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_insert_at, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child, pos), Evas_Object *child, unsigned int pos);
+
+Evas_Object_Box_Option * _evas_box_insert_before(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child, const Evas_Object *reference);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_insert_before, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child, reference), Evas_Object *child, const Evas_Object *reference);
+
+const char * _evas_box_option_property_name_get(Eo *obj, Evas_Object_Box_Data *pd, int property);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_option_property_name_get, const char *, 0, EO_FUNC_CALL(property), int property);
+
+Evas_Object_Box_Option * _evas_box_internal_insert_before(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child, const Evas_Object *reference);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_insert_before, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child, reference), Evas_Object *child, const Evas_Object *reference);
+
+void _evas_box_layout_homogeneous_horizontal(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_homogeneous_horizontal, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+Evas_Object_Box_Option * _evas_box_internal_option_new(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_option_new, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+void _evas_box_layout_homogeneous_max_size_vertical(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_homogeneous_max_size_vertical, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+Evas_Object_Box_Option * _evas_box_internal_insert_after(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child, const Evas_Object *reference);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_insert_after, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child, reference), Evas_Object *child, const Evas_Object *reference);
+
+Evas_Object_Box_Option * _evas_box_insert_at(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child, unsigned int pos);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_insert_at, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child, pos), Evas_Object *child, unsigned int pos);
+
+Evas_Object_Box_Option * _evas_box_internal_prepend(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_internal_prepend, Evas_Object_Box_Option *, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+Eina_Bool _evas_box_remove(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_box_remove, Eina_Bool, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+void _evas_box_layout_stack(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_stack, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+void _evas_box_layout_homogeneous_vertical(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_homogeneous_vertical, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+void _evas_box_layout_flow_horizontal(Eo *obj, Evas_Object_Box_Data *pd, Evas_Object_Box_Data *priv, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_box_layout_flow_horizontal, EO_FUNC_CALL(priv, data), Evas_Object_Box_Data *priv, void *data);
+
+void _evas_box_eo_base_constructor(Eo *obj, Evas_Object_Box_Data *pd);
+
+
+void * _evas_box_evas_object_smart_data_get(Eo *obj, Evas_Object_Box_Data *pd);
+
+
+void _evas_box_evas_object_smart_calculate(Eo *obj, Evas_Object_Box_Data *pd);
+
+
+void _evas_box_evas_object_smart_add(Eo *obj, Evas_Object_Box_Data *pd);
+
+
+void _evas_box_evas_object_smart_del(Eo *obj, Evas_Object_Box_Data *pd);
+
+
+void _evas_box_evas_object_smart_resize(Eo *obj, Evas_Object_Box_Data *pd, Evas_Coord w, Evas_Coord h);
+
+
+static Eo_Op_Description _evas_box_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_box_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_data_get, _evas_box_evas_object_smart_data_get),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_calculate, _evas_box_evas_object_smart_calculate),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_add, _evas_box_evas_object_smart_add),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_del, _evas_box_evas_object_smart_del),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_resize, _evas_box_evas_object_smart_resize),
+     EO_OP_FUNC(evas_obj_box_align_set, _evas_box_align_set, "Set the alignment of the whole bounding box of contents, for a"),
+     EO_OP_FUNC(evas_obj_box_align_get, _evas_box_align_get, "Get the alignment of the whole bounding box of contents, for a"),
+     EO_OP_FUNC(evas_obj_box_padding_set, _evas_box_padding_set, "Set the (space) padding between cells set for a given box object."),
+     EO_OP_FUNC(evas_obj_box_padding_get, _evas_box_padding_get, "Get the (space) padding between cells set for a given box object."),
+     EO_OP_FUNC(evas_obj_box_layout_set, _evas_box_layout_set, "Set a new layouting function to a given box object"),
+     EO_OP_FUNC(evas_obj_box_layout_horizontal, _evas_box_layout_horizontal, "Layout function which sets the box @a o to a (basic) horizontal box"),
+     EO_OP_FUNC(evas_obj_box_layout_vertical, _evas_box_layout_vertical, "Layout function which sets the box @a o to a (basic) vertical box"),
+     EO_OP_FUNC(evas_obj_box_layout_homogeneous_max_size_horizontal, _evas_box_layout_homogeneous_max_size_horizontal, "Layout function which sets the box @a o to a <b>maximum size,"),
+     EO_OP_FUNC(evas_obj_box_internal_remove, _evas_box_internal_remove, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_layout_flow_vertical, _evas_box_layout_flow_vertical, "Layout function which sets the box @a o to a @b flow vertical box."),
+     EO_OP_FUNC(evas_obj_box_internal_option_free, _evas_box_internal_option_free, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_insert_after, _evas_box_insert_after, "Insert a new @a child object <b>after another existing one</b>, in"),
+     EO_OP_FUNC(evas_obj_box_remove_all, _evas_box_remove_all, "Remove @b all child objects from a box object, unparenting them"),
+     EO_OP_FUNC(evas_obj_box_iterator_new, _evas_box_iterator_new, "Get an iterator to walk the list of children of a given box object."),
+     EO_OP_FUNC(evas_obj_box_add_to, _evas_box_add_to, "Add a new box as a @b child of a given smart object."),
+     EO_OP_FUNC(evas_obj_box_append, _evas_box_append, "Append a new @a child object to the given box object @a o."),
+     EO_OP_FUNC(evas_obj_box_option_property_id_get, _evas_box_option_property_id_get, "Get the numerical identifier of the property of the child elements"),
+     EO_OP_FUNC(evas_obj_box_prepend, _evas_box_prepend, "Prepend a new @a child object to the given box object @a o."),
+     EO_OP_FUNC(evas_obj_box_accessor_new, _evas_box_accessor_new, "Get an accessor (a structure providing random items access) to the"),
+     EO_OP_FUNC(evas_obj_box_internal_append, _evas_box_internal_append, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_option_property_vset, _evas_box_option_property_vset, "Set a property value (by its given numerical identifier), on a"),
+     EO_OP_FUNC(evas_obj_box_internal_remove_at, _evas_box_internal_remove_at, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_remove_at, _evas_box_remove_at, "Remove an object, <b>bound to a given position</b> in a box object,"),
+     EO_OP_FUNC(evas_obj_box_option_property_vget, _evas_box_option_property_vget, "Get a property's value (by its given numerical identifier), on a"),
+     EO_OP_FUNC(evas_obj_box_internal_insert_at, _evas_box_internal_insert_at, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_insert_before, _evas_box_insert_before, "Insert a new @a child object <b>before another existing one</b>, in"),
+     EO_OP_FUNC(evas_obj_box_option_property_name_get, _evas_box_option_property_name_get, "Get the name of the property of the child elements of the box @a o"),
+     EO_OP_FUNC(evas_obj_box_internal_insert_before, _evas_box_internal_insert_before, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_layout_homogeneous_horizontal, _evas_box_layout_homogeneous_horizontal, "Layout function which sets the box @a o to a @b homogeneous"),
+     EO_OP_FUNC(evas_obj_box_internal_option_new, _evas_box_internal_option_new, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_layout_homogeneous_max_size_vertical, _evas_box_layout_homogeneous_max_size_vertical, "Layout function which sets the box @a o to a <b>maximum size,"),
+     EO_OP_FUNC(evas_obj_box_internal_insert_after, _evas_box_internal_insert_after, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_insert_at, _evas_box_insert_at, "Insert a new @a child object <b>at a given position</b>, in a given"),
+     EO_OP_FUNC(evas_obj_box_internal_prepend, _evas_box_internal_prepend, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_box_remove, _evas_box_remove, "Remove a given object from a box object, unparenting it again."),
+     EO_OP_FUNC(evas_obj_box_layout_stack, _evas_box_layout_stack, "Layout function which sets the box @a o to a @b stacking box"),
+     EO_OP_FUNC(evas_obj_box_layout_homogeneous_vertical, _evas_box_layout_homogeneous_vertical, "Layout function which sets the box @a o to a @b homogeneous"),
+     EO_OP_FUNC(evas_obj_box_layout_flow_horizontal, _evas_box_layout_flow_horizontal, "Layout function which sets the box @a o to a @b flow horizontal"),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Event_Description *_evas_box_event_desc[] = {
+     EVAS_BOX_EVENT_CHILD_ADDED,
+     EVAS_BOX_EVENT_CHILD_REMOVED,
+     NULL
+};
+
+static const Eo_Class_Description _evas_box_class_desc = {
+     EO_VERSION,
+     "Evas_Box",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_box_op_desc),
+     _evas_box_event_desc,
+     sizeof(Evas_Object_Box_Data),
+     _evas_box_class_constructor,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_box_class_get, &_evas_box_class_desc, EVAS_SMART_CLIPPED_CLASS, NULL);
+EAPI void
+evas_object_box_align_set(Evas_Box *obj, double horizontal, double vertical)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_align_set(horizontal, vertical));
+}
+
+EAPI void
+evas_object_box_align_get(const Evas_Box *obj, double *horizontal, double *vertical)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_align_get(horizontal, vertical));
+}
+
+EAPI void
+evas_object_box_padding_set(Evas_Box *obj, Evas_Coord horizontal, Evas_Coord vertical)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_padding_set(horizontal, vertical));
+}
+
+EAPI void
+evas_object_box_padding_get(const Evas_Box *obj, Evas_Coord *horizontal, Evas_Coord *vertical)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_padding_get(horizontal, vertical));
+}
+
+EAPI void
+evas_object_box_layout_set(Evas_Box *obj, Evas_Object_Box_Layout cb, const void *data, Eina_Free_Cb free_data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_set(cb, data, free_data));
+}
+
+EAPI void
+evas_object_box_layout_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_horizontal(priv, data));
+}
+
+EAPI void
+evas_object_box_layout_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_vertical(priv, data));
+}
+
+EAPI void
+evas_object_box_layout_homogeneous_max_size_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_homogeneous_max_size_horizontal(priv, data));
+}
+
+EAPI void
+evas_object_box_layout_flow_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_flow_vertical(priv, data));
+}
+
+EAPI Evas_Object_Box_Option *
+evas_object_box_insert_after(Evas_Box *obj, Evas_Object *child, const Evas_Object *reference)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_insert_after(child, reference));
+}
+
+EAPI Eina_Bool
+evas_object_box_remove_all(Evas_Box *obj, Eina_Bool clear)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_remove_all(clear));
+}
+
+EAPI Eina_Iterator *
+evas_object_box_iterator_new(const Evas_Box *obj)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_iterator_new());
+}
+
+EAPI Evas_Object *
+evas_object_box_add_to(Evas_Box *obj)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_add_to());
+}
+
+EAPI Evas_Object_Box_Option *
+evas_object_box_append(Evas_Box *obj, Evas_Object *child)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_append(child));
+}
+
+EAPI int
+evas_object_box_option_property_id_get(const Evas_Box *obj, const char *name)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_option_property_id_get(name));
+}
+
+EAPI Evas_Object_Box_Option *
+evas_object_box_prepend(Evas_Box *obj, Evas_Object *child)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_prepend(child));
+}
+
+EAPI Eina_Accessor *
+evas_object_box_accessor_new(const Evas_Box *obj)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_accessor_new());
+}
+
+EAPI Eina_Bool
+evas_object_box_remove_at(Evas_Box *obj, unsigned int pos)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_remove_at(pos));
+}
+
+EAPI Evas_Object_Box_Option *
+evas_object_box_insert_before(Evas_Box *obj, Evas_Object *child, const Evas_Object *reference)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_insert_before(child, reference));
+}
+
+EAPI const char *
+evas_object_box_option_property_name_get(const Evas_Box *obj, int property)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_option_property_name_get(property));
+}
+
+EAPI void
+evas_object_box_layout_homogeneous_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_homogeneous_horizontal(priv, data));
+}
+
+EAPI void
+evas_object_box_layout_homogeneous_max_size_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_homogeneous_max_size_vertical(priv, data));
+}
+
+EAPI Evas_Object_Box_Option *
+evas_object_box_insert_at(Evas_Box *obj, Evas_Object *child, unsigned int pos)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_insert_at(child, pos));
+}
+
+EAPI Eina_Bool
+evas_object_box_remove(Evas_Box *obj, Evas_Object *child)
+{
+   return eo_do((Evas_Box *)obj, evas_obj_box_remove(child));
+}
+
+EAPI void
+evas_object_box_layout_stack(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_stack(priv, data));
+}
+
+EAPI void
+evas_object_box_layout_homogeneous_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_homogeneous_vertical(priv, data));
+}
+
+EAPI void
+evas_object_box_layout_flow_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data)
+{
+   eo_do((Evas_Box *)obj, evas_obj_box_layout_flow_horizontal(priv, data));
+}
diff -Naur a/src/lib/evas/canvas/evas_box.eo.h b/src/lib/evas/canvas/evas_box.eo.h
--- a/src/lib/evas/canvas/evas_box.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_box.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,820 @@
+#ifndef _EVAS_BOX_EO_H_
+#define _EVAS_BOX_EO_H_
+
+#ifndef _EVAS_BOX_EO_CLASS_TYPE
+#define _EVAS_BOX_EO_CLASS_TYPE
+
+typedef Eo Evas_Box;
+
+#endif
+
+#ifndef _EVAS_BOX_EO_TYPES
+#define _EVAS_BOX_EO_TYPES
+
+
+#endif
+#define EVAS_BOX_CLASS evas_box_class_get()
+
+const Eo_Class *evas_box_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Set the alignment of the whole bounding box of contents, for a
+ * given box object.
+ *
+ * This will influence how a box object is to align its bounding box
+ * of contents within its own area. The values @b must be in the range
+ * @c 0.0 - @c 1.0, or undefined behavior is expected. For horizontal
+ * alignment, @c 0.0 means to the left, with @c 1.0 meaning to the
+ * right. For vertical alignment, @c 0.0 means to the top, with @c 1.0
+ * meaning to the bottom.
+ *
+ * @note The default values for both alignments is @c 0.5.
+ *
+ * @see evas_object_box_align_get()
+ *
+ * @param[in] horizontal The horizontal alignment, in pixels
+ * @param[in] vertical the vertical alignment, in pixels
+ *
+ */
+EOAPI void  evas_obj_box_align_set(double horizontal, double vertical);
+
+/**
+ *
+ * Get the alignment of the whole bounding box of contents, for a
+ * given box object.
+ *
+ * @see evas_object_box_align_set() for more information
+ *
+ * @param[out] horizontal The horizontal alignment, in pixels
+ * @param[out] vertical the vertical alignment, in pixels
+ *
+ */
+EOAPI void  evas_obj_box_align_get(double *horizontal, double *vertical);
+
+/**
+ *
+ * Set the (space) padding between cells set for a given box object.
+ *
+ * @note The default values for both padding components is @c 0.
+ *
+ * @see evas_object_box_padding_get()
+ *
+ * @param[in] horizontal The horizontal padding, in pixels
+ * @param[in] vertical the vertical padding, in pixels
+ *
+ */
+EOAPI void  evas_obj_box_padding_set(Evas_Coord horizontal, Evas_Coord vertical);
+
+/**
+ *
+ * Get the (space) padding between cells set for a given box object.
+ *
+ * @see evas_object_box_padding_set()
+ *
+ * @param[out] horizontal The horizontal padding, in pixels
+ * @param[out] vertical the vertical padding, in pixels
+ *
+ */
+EOAPI void  evas_obj_box_padding_get(Evas_Coord *horizontal, Evas_Coord *vertical);
+
+/**
+ *
+ * Set a new layouting function to a given box object
+ *
+ * A box layout function affects how a box object displays child
+ * elements within its area. The list of pre-defined box layouts
+ * available in Evas is:
+ * - evas_object_box_layout_horizontal()
+ * - evas_object_box_layout_vertical()
+ * - evas_object_box_layout_homogeneous_horizontal()
+ * - evas_object_box_layout_homogeneous_vertical()
+ * - evas_object_box_layout_homogeneous_max_size_horizontal()
+ * - evas_object_box_layout_homogeneous_max_size_vertical()
+ * - evas_object_box_layout_flow_horizontal()
+ * - evas_object_box_layout_flow_vertical()
+ * - evas_object_box_layout_stack()
+ *
+ * Refer to each of their documentation texts for details on them.
+ *
+ * @note A box layouting function will be triggered by the @c
+ * 'calculate' smart callback of the box's smart class.
+ *
+ * @param[in] cb The new layout function to set on @p o.
+ * @param[in] data Data pointer to be passed to @p cb.
+ * @param[in] free_data Function to free @p data, if need be.
+ *
+ */
+EOAPI void  evas_obj_box_layout_set(Evas_Object_Box_Layout cb, const void *data, Eina_Free_Cb free_data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a (basic) horizontal box
+ *
+ * In this layout, the box object's overall behavior is controlled by
+ * its padding/alignment properties, which are set by the
+ * <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions. The size hints of the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c align_h controls the horizontal alignment of the child objects
+ * relative to the containing box. When set to @c 0.0, children are
+ * aligned to the left. A value of @c 1.0 makes them aligned to the
+ * right border. Values in between align them proportionally. Note
+ * that if the size required by the children, which is given by their
+ * widths and the @c padding_h property of the box, is bigger than the
+ * their container's width, the children will be displayed out of the
+ * box's bounds. A negative value of @c align_h makes the box to
+ * @b justify its children. The padding between them, in this case, is
+ * corrected so that the leftmost one touches the left border and the
+ * rightmost one touches the right border (even if they must
+ * overlap). The @c align_v and @c padding_v properties of the box
+ * @b don't contribute to its behaviour when this layout is chosen.
+ *
+ * \par Child element's properties:
+ * @c align_x does @b not influence the box's behavior. @c padding_l
+ * and @c padding_r sum up to the container's horizontal padding
+ * between elements. The child's @c padding_t, @c padding_b and
+ * @c align_y properties apply for padding/alignment relative to the
+ * overall height of the box. Finally, there is the @c weight_x
+ * property, which, if set to a non-zero value, tells the container
+ * that the child width is @b not pre-defined. If the container can't
+ * accommodate all its children, it sets the widths of the ones
+ * <b>with weights</b> to sizes as small as they can all fit into
+ * it. If the size required by the children is less than the
+ * available, the box increases its childrens' (which have weights)
+ * widths as to fit the remaining space. The @c weight_x property,
+ * besides telling the element is resizable, gives a @b weight for the
+ * resizing process.  The parent box will try to distribute (or take
+ * off) widths accordingly to the @b normalized list of weights: most
+ * weighted children remain/get larger in this process than the least
+ * ones. @c weight_y does not influence the layout.
+ *
+ * If one desires that, besides having weights, child elements must be
+ * resized bounded to a minimum or maximum size, those size hints must
+ * be set, by the <c>evas_object_size_hint_{min,max}_set()</c>
+ * functions.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_horizontal(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a (basic) vertical box
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_horizontal(). The description of its
+ * behaviour can be derived from that function's documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_vertical(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a <b>maximum size,
+ * homogeneous</b> horizontal box
+ *
+ * In a maximum size, homogeneous horizontal box, besides having cells
+ * of <b>equal size</b> reserved for the child objects, this size will
+ * be defined by the size of the @b largest child in the box (in
+ * width). The box's overall behavior is controlled by its properties,
+ * which are set by the
+ * <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions.  The size hints of the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c padding_h tells the box to draw empty spaces of that size, in
+ * pixels, between the child objects' cells. @c align_h controls the
+ * horizontal alignment of the child objects, relative to the
+ * containing box. When set to @c 0.0, children are aligned to the
+ * left. A value of @c 1.0 lets them aligned to the right
+ * border. Values in between align them proportionally. A negative
+ * value of @c align_h makes the box to @b justify its children
+ * cells. The padding between them, in this case, is corrected so that
+ * the leftmost one touches the left border and the rightmost one
+ * touches the right border (even if they must overlap). The
+ * @c align_v and @c padding_v properties of the box don't contribute to
+ * its behaviour when this layout is chosen.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property tells the relative position
+ * of this overall child width in its allocated cell (@c 0.0 to
+ * extreme left, @c 1.0 to extreme right). A value of @c -1.0 to
+ * @c align_x makes the box try to resize this child element to the exact
+ * width of its cell (respecting the minimum and maximum size hints on
+ * the child's width and accounting for its horizontal padding
+ * hints). The child's @c padding_t, @c padding_b and @c align_y
+ * properties apply for padding/alignment relative to the overall
+ * height of the box. A value of @c -1.0 to @c align_y makes the box
+ * try to resize this child element to the exact height of its parent
+ * (respecting the max hint on the child's height).
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_homogeneous_max_size_horizontal(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] child No description supplied.
+ *
+ */
+EOAPI Evas_Object * evas_obj_box_internal_remove(Evas_Object *child);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b flow vertical box.
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_flow_horizontal(). The description of its
+ * behaviour can be derived from that function's documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_flow_vertical(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] opt No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_internal_option_free(Evas_Object_Box_Option *opt);
+
+/**
+ *
+ * Insert a new @a child object <b>after another existing one</b>, in
+ * a given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note This function will fail if @p reference is not a member of @p
+ * o.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.insert_after smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ * @param[in] reference The child object to place this new one after
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_insert_after(Evas_Object *child, const Evas_Object *reference);
+
+/**
+ *
+ * Remove @b all child objects from a box object, unparenting them
+ * again.
+ *
+ * @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+ *
+ * This has the same effect of calling evas_object_box_remove() on
+ * each of @p o's child objects, in sequence. If, and only if, all
+ * those calls succeed, so does this one.
+ * 
+ *
+ * @param[in] clear if true, it will delete just removed children.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_box_remove_all(Eina_Bool clear);
+
+/**
+ *
+ * Get an iterator to walk the list of children of a given box object.
+ *
+ * @return An iterator on @p o's child objects, on success, or @c NULL,
+ * on errors
+ *
+ * @note Do @b not remove or delete objects while walking the list.
+ * 
+ *
+ *
+ */
+EOAPI Eina_Iterator * evas_obj_box_iterator_new(void);
+
+/**
+ *
+ * Add a new box as a @b child of a given smart object.
+ *
+ * @return @c NULL on error, a pointer to a new box object on
+ * success.
+ *
+ * This is a helper function that has the same effect of putting a new
+ * box object into @p parent by use of evas_object_smart_member_add().
+ *
+ * @see evas_object_box_add()
+ * 
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_box_add_to(void);
+
+/**
+ *
+ * Append a new @a child object to the given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it. For example, on horizontal layouts
+ * an item in the end of the box's list of children will appear on its
+ * right.
+ *
+ * @note This call will trigger the box's _Evas_Object_Box_Api.append
+ * smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_append(Evas_Object *child);
+
+/**
+ *
+ * Get the numerical identifier of the property of the child elements
+ * of the box @a o which have @a name as name string
+ *
+ * @return The numerical ID of the given property or @c -1, on
+ * errors.
+ *
+ * @note This call won't do anything for a canonical Evas box. Only
+ * users which have @b subclassed it, setting custom box items options
+ * (see #Evas_Object_Box_Option) on it, would benefit from this
+ * function. They'd have to implement it and set it to be the
+ * _Evas_Object_Box_Api.property_id_get smart class function of the
+ * box, which is originally set to @c NULL.
+ * 
+ *
+ * @param[in] name The name string of the option being searched, for
+its ID
+ *
+ */
+EOAPI int  evas_obj_box_option_property_id_get(const char *name);
+
+/**
+ *
+ * Prepend a new @a child object to the given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it. For example, on horizontal layouts
+ * an item in the beginning of the box's list of children will appear
+ * on its left.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.prepend smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_prepend(Evas_Object *child);
+
+/**
+ *
+ * Get an accessor (a structure providing random items access) to the
+ * list of children of a given box object.
+ *
+ * @return An accessor on @p o's child objects, on success, or @c NULL,
+ * on errors
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * 
+ *
+ *
+ */
+EOAPI Eina_Accessor * evas_obj_box_accessor_new(void);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] child No description supplied.
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_internal_append(Evas_Object *child);
+
+/**
+ *
+ * Set a property value (by its given numerical identifier), on a
+ * given box child element -- by a variable argument list
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE on failure.
+ *
+ * This is a variable argument list variant of the
+ * evas_object_box_option_property_set(). See its documentation for
+ * more details.
+ * 
+ *
+ * @param[in] opt The box option structure bound to the child box element
+to set a property on
+ * @param[in] property The numerical ID of the given property
+ * @param[in] args The variable argument list implementing the value to
+be set for this property. It @b must be of the same type the user has
+defined for it.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_box_option_property_vset(Evas_Object_Box_Option *opt, int property, va_list *args);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] pos No description supplied.
+ *
+ */
+EOAPI Evas_Object * evas_obj_box_internal_remove_at(unsigned int pos);
+
+/**
+ *
+ * Remove an object, <b>bound to a given position</b> in a box object,
+ * unparenting it again.
+ *
+ * @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+ *
+ * On removal, you'll get an unparented object again, just as it was
+ * before you inserted it in the box. The @c option_free() box smart
+ * callback will be called automatically for you and, also, the
+ * @c "child,removed" smart event will take place.
+ *
+ * @note This function will fail if the given position is invalid,
+ * given @p o's internal list of elements.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.remove_at smart function.
+ * 
+ *
+ * @param[in] pos The numeric position (starting from @c 0) of the child
+object to be removed
+ *
+ */
+EOAPI Eina_Bool  evas_obj_box_remove_at(unsigned int pos);
+
+/**
+ *
+ * Get a property's value (by its given numerical identifier), on a
+ * given box child element -- by a variable argument list
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE on failure.
+ *
+ * This is a variable argument list variant of the
+ * evas_object_box_option_property_get(). See its documentation for
+ * more details.
+ * 
+ *
+ * @param[in] opt The box option structure bound to the child box element
+to get a property from
+ * @param[in] property The numerical ID of the given property
+ * @param[in] args The variable argument list with pointers to where to
+store the values of this property. They @b must point to variables
+of the same type the user has defined for them.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_box_option_property_vget(Evas_Object_Box_Option *opt, int property, va_list *args);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] child No description supplied.
+ * @param[in] pos No description supplied.
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_internal_insert_at(Evas_Object *child, unsigned int pos);
+
+/**
+ *
+ * Insert a new @a child object <b>before another existing one</b>, in
+ * a given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note This function will fail if @p reference is not a member of @p
+ * o.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.insert_before smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ * @param[in] reference The child object to place this new one before
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_insert_before(Evas_Object *child, const Evas_Object *reference);
+
+/**
+ *
+ * Get the name of the property of the child elements of the box @a o
+ * which have @a id as identifier
+ *
+ * @return The name of the given property or @c NULL, on errors.
+ *
+ * @note This call won't do anything for a canonical Evas box. Only
+ * users which have @b subclassed it, setting custom box items options
+ * (see #Evas_Object_Box_Option) on it, would benefit from this
+ * function. They'd have to implement it and set it to be the
+ * _Evas_Object_Box_Api.property_name_get smart class function of the
+ * box, which is originally set to @c NULL.
+ * 
+ *
+ * @param[in] property The numerical identifier of the option being searched,
+for its name
+ *
+ */
+EOAPI const char * evas_obj_box_option_property_name_get(int property);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] child No description supplied.
+ * @param[in] reference No description supplied.
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_internal_insert_before(Evas_Object *child, const Evas_Object *reference);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b homogeneous
+ * horizontal box
+ *
+ * In a homogeneous horizontal box, its width is divided @b equally
+ * between the contained objects. The box's overall behavior is
+ * controlled by its padding/alignment properties, which are set by
+ * the <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions.  The size hints the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c align_h has no influence on the box for this layout.
+ * @c padding_h tells the box to draw empty spaces of that size, in
+ * pixels, between the (equal) child objects' cells. The @c align_v
+ * and @c padding_v properties of the box don't contribute to its
+ * behaviour when this layout is chosen.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property tells the relative position
+ * of this overall child width in its allocated cell (@c 0.0 to
+ * extreme left, @c 1.0 to extreme right). A value of @c -1.0 to
+ * @c align_x makes the box try to resize this child element to the exact
+ * width of its cell (respecting the minimum and maximum size hints on
+ * the child's width and accounting for its horizontal padding
+ * hints). The child's @c padding_t, @c padding_b and @c align_y
+ * properties apply for padding/alignment relative to the overall
+ * height of the box. A value of @c -1.0 to @c align_y makes the box
+ * try to resize this child element to the exact height of its parent
+ * (respecting the maximum size hint on the child's height).
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_homogeneous_horizontal(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] child No description supplied.
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_internal_option_new(Evas_Object *child);
+
+/**
+ *
+ * Layout function which sets the box @a o to a <b>maximum size,
+ * homogeneous</b> vertical box
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_homogeneous_max_size_horizontal(). The
+ * description of its behaviour can be derived from that function's
+ * documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_homogeneous_max_size_vertical(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] child No description supplied.
+ * @param[in] reference No description supplied.
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_internal_insert_after(Evas_Object *child, const Evas_Object *reference);
+
+/**
+ *
+ * Insert a new @a child object <b>at a given position</b>, in a given
+ * box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note This function will fail if the given position is invalid,
+ * given @p o's internal list of elements.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.insert_at smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ * @param[in] pos The numeric position (starting from @c 0) to place the
+new child object at
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_insert_at(Evas_Object *child, unsigned int pos);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] child No description supplied.
+ *
+ */
+EOAPI Evas_Object_Box_Option * evas_obj_box_internal_prepend(Evas_Object *child);
+
+/**
+ *
+ * Remove a given object from a box object, unparenting it again.
+ *
+ * @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+ *
+ * On removal, you'll get an unparented object again, just as it was
+ * before you inserted it in the box. The
+ * _Evas_Object_Box_Api.option_free box smart callback will be called
+ * automatically for you and, also, the @c "child,removed" smart event
+ * will take place.
+ *
+ * @note This call will trigger the box's _Evas_Object_Box_Api.remove
+ * smart function.
+ * 
+ *
+ * @param[in] child The handle to the child object to be removed
+ *
+ */
+EOAPI Eina_Bool  evas_obj_box_remove(Evas_Object *child);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b stacking box
+ *
+ * In a stacking box, all children will be given the same size -- the
+ * box's own size -- and they will be stacked one above the other, so
+ * that the first object in @p o's internal list of child elements
+ * will be the bottommost in the stack.
+ *
+ * \par Box's properties:
+ * No box properties are used.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property tells the relative position
+ * of this overall child width in its allocated cell (@c 0.0 to
+ * extreme left, @c 1.0 to extreme right). A value of @c -1.0 to @c
+ * align_x makes the box try to resize this child element to the exact
+ * width of its cell (respecting the min and max hints on the child's
+ * width and accounting for its horizontal padding properties). The
+ * same applies to the vertical axis.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_stack(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b homogeneous
+ * vertical box
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_homogeneous_horizontal().  The description
+ * of its behaviour can be derived from that function's documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_homogeneous_vertical(Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b flow horizontal
+ * box.
+ *
+ * In a flow horizontal box, the box's child elements are placed in
+ * @b rows (think of text as an analogy). A row has as much elements as
+ * can fit into the box's width. The box's overall behavior is
+ * controlled by its properties, which are set by the
+ * <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions.  The size hints of the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c padding_h tells the box to draw empty spaces of that size, in
+ * pixels, between the child objects' cells. @c align_h dictates the
+ * horizontal alignment of the rows (@c 0.0 to left align them, @c 1.0
+ * to right align). A value of @c -1.0 to @c align_h lets the rows
+ * @b justified horizontally. @c align_v controls the vertical alignment
+ * of the entire set of rows (@c 0.0 to top, @c 1.0 to bottom). A
+ * value of @c -1.0 to @c align_v makes the box to @b justify the rows
+ * vertically. The padding between them, in this case, is corrected so
+ * that the first row touches the top border and the last one touches
+ * the bottom border (even if they must overlap). @c padding_v has no
+ * influence on the layout.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property has no influence on the
+ * layout. The child's @c padding_t and @c padding_b sum up to the
+ * required height of the child element and is the only means (besides
+ * row justifying) of setting space between rows. Note, however, that
+ * @c align_y dictates positioning relative to the <b>largest
+ * height</b> required by a child object in the actual row.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_obj_box_layout_flow_horizontal(Evas_Object_Box_Data *priv, void *data);
+
+EOAPI extern const Eo_Event_Description _EVAS_BOX_EVENT_CHILD_ADDED;
+EOAPI extern const Eo_Event_Description _EVAS_BOX_EVENT_CHILD_REMOVED;
+
+/**
+ * No description
+ */
+#define EVAS_BOX_EVENT_CHILD_ADDED (&(_EVAS_BOX_EVENT_CHILD_ADDED))
+
+/**
+ * No description
+ */
+#define EVAS_BOX_EVENT_CHILD_REMOVED (&(_EVAS_BOX_EVENT_CHILD_REMOVED))
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_box.eo.hh b/src/lib/evas/canvas/evas_box.eo.hh
--- a/src/lib/evas/canvas/evas_box.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_box.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,2226 @@
+#ifndef EFL_GENERATED_EVAS_BOX_HH
+#define EFL_GENERATED_EVAS_BOX_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_box.eo.h"
+}
+
+#include "evas_smart_clipped.eo.hh"
+#include <canvas/evas_object.eo.hh>
+#include <string>
+
+namespace evas {
+
+struct box
+      : evas::smart_clipped
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit box(Eo* eo)
+      : evas::smart_clipped(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit box(std::nullptr_t)
+      : evas::smart_clipped(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   box(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : box(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   box(box const& other)
+      : evas::smart_clipped(eo_ref(other._eo_ptr()))
+   {}
+
+   ~box() {}
+
+   /// @brief Retrieve user data stored on a given smart object.
+   ///
+   /// @return A pointer to data stored using
+   /// evas_object_smart_data_set(), or @c NULL, if none has been
+   /// set.
+   ///
+   /// @see evas_object_smart_data_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void * smart_data_get() const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_data_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Call the @b calculate() smart function immediately on a given smart
+   /// object.
+   ///
+   /// This will force immediate calculations (see #Evas_Smart_Class)
+   /// needed for renderization of this object and, besides, unset the
+   /// flag on it telling it needs recalculation for the next rendering
+   /// phase.
+   ///
+   /// @see evas_object_smart_need_recalculate_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void calculate() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_calculate());
+   }
+
+   /// @brief Instantiates a new smart object described by @p s.
+   ///
+   /// @return a new #Evas_Object handle
+   ///
+   /// This is the function one should use when defining the public
+   /// function @b adding an instance of the new smart object to a given
+   /// canvas. It will take care of setting all of its internals to work
+   /// as they should, if the user set things properly, as seem on the
+   /// #EVAS_SMART_SUBCLASS_NEW, for example.
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void add() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_add());
+   }
+
+   /// @brief Deletes a smart object.
+   ///
+   void del() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_del());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param w 
+   /// @param h 
+   ///
+   void resize(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+   }
+
+   /// @brief Get the alignment of the whole bounding box of contents, for a
+   /// given box object.
+   ///
+   /// @see evas_object_box_align_set() for more information
+   ///
+   /// @param horizontal The horizontal alignment, in pixels
+   /// @param vertical the vertical alignment, in pixels
+   ///
+   void align_get(double* horizontal_, double* vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_align_get(horizontal_, vertical_));
+   }
+
+   /// @brief Set the alignment of the whole bounding box of contents, for a
+   /// given box object.
+   ///
+   /// This will influence how a box object is to align its bounding box
+   /// of contents within its own area. The values @b must be in the range
+   /// @c 0.0 - @c 1.0, or undefined behavior is expected. For horizontal
+   /// alignment, @c 0.0 means to the left, with @c 1.0 meaning to the
+   /// right. For vertical alignment, @c 0.0 means to the top, with @c 1.0
+   /// meaning to the bottom.
+   ///
+   /// @note The default values for both alignments is @c 0.5.
+   ///
+   /// @see evas_object_box_align_get()
+   ///
+   /// @param horizontal The horizontal alignment, in pixels
+   /// @param vertical the vertical alignment, in pixels
+   ///
+   void align_set(double horizontal_, double vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_align_set(horizontal_, vertical_));
+   }
+
+   /// @brief Get the (space) padding between cells set for a given box object.
+   ///
+   /// @see evas_object_box_padding_set()
+   ///
+   /// @param horizontal The horizontal padding, in pixels
+   /// @param vertical the vertical padding, in pixels
+   ///
+   void padding_get(Evas_Coord* horizontal_, Evas_Coord* vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_padding_get(horizontal_, vertical_));
+   }
+
+   /// @brief Set the (space) padding between cells set for a given box object.
+   ///
+   /// @note The default values for both padding components is @c 0.
+   ///
+   /// @see evas_object_box_padding_get()
+   ///
+   /// @param horizontal The horizontal padding, in pixels
+   /// @param vertical the vertical padding, in pixels
+   ///
+   void padding_set(Evas_Coord horizontal_, Evas_Coord vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_padding_set(horizontal_, vertical_));
+   }
+
+   /// @brief Set a new layouting function to a given box object
+   ///
+   /// A box layout function affects how a box object displays child
+   /// elements within its area. The list of pre-defined box layouts
+   /// available in Evas is:
+   /// - evas_object_box_layout_horizontal()
+   /// - evas_object_box_layout_vertical()
+   /// - evas_object_box_layout_homogeneous_horizontal()
+   /// - evas_object_box_layout_homogeneous_vertical()
+   /// - evas_object_box_layout_homogeneous_max_size_horizontal()
+   /// - evas_object_box_layout_homogeneous_max_size_vertical()
+   /// - evas_object_box_layout_flow_horizontal()
+   /// - evas_object_box_layout_flow_vertical()
+   /// - evas_object_box_layout_stack()
+   ///
+   /// Refer to each of their documentation texts for details on them.
+   ///
+   /// @note A box layouting function will be triggered by the @c
+   /// 'calculate' smart callback of the box's smart class.
+   ///
+   /// @param cb The new layout function to set on @p o.
+   /// @param data Data pointer to be passed to @p cb.
+   /// @param free_data Function to free @p data, if need be.
+   ///
+   void layout_set(Evas_Object_Box_Layout cb_, const void * data_, Eina_Free_Cb free_data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_set(cb_, data_, free_data_));
+   }
+
+   /// @brief Layout function which sets the box @a o to a (basic) horizontal box
+   ///
+   /// In this layout, the box object's overall behavior is controlled by
+   /// its padding/alignment properties, which are set by the
+   /// <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+   /// functions. The size hints of the elements in the box -- set by the
+   /// <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+   /// -- also control the way this function works.
+   ///
+   /// \par Box's properties:
+   /// @c align_h controls the horizontal alignment of the child objects
+   /// relative to the containing box. When set to @c 0.0, children are
+   /// aligned to the left. A value of @c 1.0 makes them aligned to the
+   /// right border. Values in between align them proportionally. Note
+   /// that if the size required by the children, which is given by their
+   /// widths and the @c padding_h property of the box, is bigger than the
+   /// their container's width, the children will be displayed out of the
+   /// box's bounds. A negative value of @c align_h makes the box to
+   /// @b justify its children. The padding between them, in this case, is
+   /// corrected so that the leftmost one touches the left border and the
+   /// rightmost one touches the right border (even if they must
+   /// overlap). The @c align_v and @c padding_v properties of the box
+   /// @b don't contribute to its behaviour when this layout is chosen.
+   ///
+   /// \par Child element's properties:
+   /// @c align_x does @b not influence the box's behavior. @c padding_l
+   /// and @c padding_r sum up to the container's horizontal padding
+   /// between elements. The child's @c padding_t, @c padding_b and
+   /// @c align_y properties apply for padding/alignment relative to the
+   /// overall height of the box. Finally, there is the @c weight_x
+   /// property, which, if set to a non-zero value, tells the container
+   /// that the child width is @b not pre-defined. If the container can't
+   /// accommodate all its children, it sets the widths of the ones
+   /// <b>with weights</b> to sizes as small as they can all fit into
+   /// it. If the size required by the children is less than the
+   /// available, the box increases its childrens' (which have weights)
+   /// widths as to fit the remaining space. The @c weight_x property,
+   /// besides telling the element is resizable, gives a @b weight for the
+   /// resizing process.  The parent box will try to distribute (or take
+   /// off) widths accordingly to the @b normalized list of weights: most
+   /// weighted children remain/get larger in this process than the least
+   /// ones. @c weight_y does not influence the layout.
+   ///
+   /// If one desires that, besides having weights, child elements must be
+   /// resized bounded to a minimum or maximum size, those size hints must
+   /// be set, by the <c>evas_object_size_hint_{min,max}_set()</c>
+   /// functions.
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_horizontal(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_horizontal(priv_, data_));
+   }
+
+   /// @brief Layout function which sets the box @a o to a (basic) vertical box
+   ///
+   /// This function behaves analogously to
+   /// evas_object_box_layout_horizontal(). The description of its
+   /// behaviour can be derived from that function's documentation.
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_vertical(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_vertical(priv_, data_));
+   }
+
+   /// @brief Layout function which sets the box @a o to a <b>maximum size,
+   /// homogeneous</b> horizontal box
+   ///
+   /// In a maximum size, homogeneous horizontal box, besides having cells
+   /// of <b>equal size</b> reserved for the child objects, this size will
+   /// be defined by the size of the @b largest child in the box (in
+   /// width). The box's overall behavior is controlled by its properties,
+   /// which are set by the
+   /// <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+   /// functions.  The size hints of the elements in the box -- set by the
+   /// <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+   /// -- also control the way this function works.
+   ///
+   /// \par Box's properties:
+   /// @c padding_h tells the box to draw empty spaces of that size, in
+   /// pixels, between the child objects' cells. @c align_h controls the
+   /// horizontal alignment of the child objects, relative to the
+   /// containing box. When set to @c 0.0, children are aligned to the
+   /// left. A value of @c 1.0 lets them aligned to the right
+   /// border. Values in between align them proportionally. A negative
+   /// value of @c align_h makes the box to @b justify its children
+   /// cells. The padding between them, in this case, is corrected so that
+   /// the leftmost one touches the left border and the rightmost one
+   /// touches the right border (even if they must overlap). The
+   /// @c align_v and @c padding_v properties of the box don't contribute to
+   /// its behaviour when this layout is chosen.
+   ///
+   /// \par Child element's properties:
+   /// @c padding_l and @c padding_r sum up to the required width of the
+   /// child element. The @c align_x property tells the relative position
+   /// of this overall child width in its allocated cell (@c 0.0 to
+   /// extreme left, @c 1.0 to extreme right). A value of @c -1.0 to
+   /// @c align_x makes the box try to resize this child element to the exact
+   /// width of its cell (respecting the minimum and maximum size hints on
+   /// the child's width and accounting for its horizontal padding
+   /// hints). The child's @c padding_t, @c padding_b and @c align_y
+   /// properties apply for padding/alignment relative to the overall
+   /// height of the box. A value of @c -1.0 to @c align_y makes the box
+   /// try to resize this child element to the exact height of its parent
+   /// (respecting the max hint on the child's height).
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_homogeneous_max_size_horizontal(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_homogeneous_max_size_horizontal(priv_, data_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param child 
+   ///
+   evas::object internal_remove(evas::object child_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_remove(efl::eolian::to_c(child_)));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Layout function which sets the box @a o to a @b flow vertical box.
+   ///
+   /// This function behaves analogously to
+   /// evas_object_box_layout_flow_horizontal(). The description of its
+   /// behaviour can be derived from that function's documentation.
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_flow_vertical(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_flow_vertical(priv_, data_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param opt 
+   ///
+   void internal_option_free(Evas_Object_Box_Option * opt_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_internal_option_free(opt_));
+   }
+
+   /// @brief Insert a new @a child object <b>after another existing one</b>, in
+   /// a given box object @a o.
+   ///
+   /// @return A box option bound to the recently added box item or @c
+   /// NULL, on errors
+   ///
+   /// On success, the @c "child,added" smart event will take place.
+   ///
+   /// @note This function will fail if @p reference is not a member of @p
+   /// o.
+   ///
+   /// @note The actual placing of the item relative to @p o's area will
+   /// depend on the layout set to it.
+   ///
+   /// @note This call will trigger the box's
+   /// _Evas_Object_Box_Api.insert_after smart function.
+   ///
+   /// @param child A child Evas object to be made a member of @p o
+   /// @param reference The child object to place this new one after
+   ///
+   Evas_Object_Box_Option * insert_after(evas::object child_, const Evas_Object * reference_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_insert_after(efl::eolian::to_c(child_), reference_));
+      return _tmp_ret;
+   }
+
+   /// @brief Remove @b all child objects from a box object, unparenting them
+   /// again.
+   ///
+   /// @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+   ///
+   /// This has the same effect of calling evas_object_box_remove() on
+   /// each of @p o's child objects, in sequence. If, and only if, all
+   /// those calls succeed, so does this one.
+   ///
+   /// @param clear if true, it will delete just removed children.
+   ///
+   bool remove_all(bool clear_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_remove_all(efl::eolian::to_c(clear_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get an iterator to walk the list of children of a given box object.
+   ///
+   /// @return An iterator on @p o's child objects, on success, or @c NULL,
+   /// on errors
+   ///
+   /// @note Do @b not remove or delete objects while walking the list.
+   ///
+   Eina_Iterator * iterator_new() const
+   {
+      Eina_Iterator * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_iterator_new());
+      return _tmp_ret;
+   }
+
+   /// @brief Add a new box as a @b child of a given smart object.
+   ///
+   /// @return @c NULL on error, a pointer to a new box object on
+   /// success.
+   ///
+   /// This is a helper function that has the same effect of putting a new
+   /// box object into @p parent by use of evas_object_smart_member_add().
+   ///
+   /// @see evas_object_box_add()
+   ///
+   evas::object add_to() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_add_to());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Append a new @a child object to the given box object @a o.
+   ///
+   /// @return A box option bound to the recently added box item or @c
+   /// NULL, on errors
+   ///
+   /// On success, the @c "child,added" smart event will take place.
+   ///
+   /// @note The actual placing of the item relative to @p o's area will
+   /// depend on the layout set to it. For example, on horizontal layouts
+   /// an item in the end of the box's list of children will appear on its
+   /// right.
+   ///
+   /// @note This call will trigger the box's _Evas_Object_Box_Api.append
+   /// smart function.
+   ///
+   /// @param child A child Evas object to be made a member of @p o
+   ///
+   Evas_Object_Box_Option * append(evas::object child_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_append(efl::eolian::to_c(child_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Get the numerical identifier of the property of the child elements
+   /// of the box @a o which have @a name as name string
+   ///
+   /// @return The numerical ID of the given property or @c -1, on
+   /// errors.
+   ///
+   /// @note This call won't do anything for a canonical Evas box. Only
+   /// users which have @b subclassed it, setting custom box items options
+   /// (see #Evas_Object_Box_Option) on it, would benefit from this
+   /// function. They'd have to implement it and set it to be the
+   /// _Evas_Object_Box_Api.property_id_get smart class function of the
+   /// box, which is originally set to @c NULL.
+   ///
+   /// @param name The name string of the option being searched, for
+   /// its ID
+   ///
+   int option_property_id_get(std::string name_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_id_get(efl::eolian::to_c(name_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Prepend a new @a child object to the given box object @a o.
+   ///
+   /// @return A box option bound to the recently added box item or @c
+   /// NULL, on errors
+   ///
+   /// On success, the @c "child,added" smart event will take place.
+   ///
+   /// @note The actual placing of the item relative to @p o's area will
+   /// depend on the layout set to it. For example, on horizontal layouts
+   /// an item in the beginning of the box's list of children will appear
+   /// on its left.
+   ///
+   /// @note This call will trigger the box's
+   /// _Evas_Object_Box_Api.prepend smart function.
+   ///
+   /// @param child A child Evas object to be made a member of @p o
+   ///
+   Evas_Object_Box_Option * prepend(evas::object child_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_prepend(efl::eolian::to_c(child_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Get an accessor (a structure providing random items access) to the
+   /// list of children of a given box object.
+   ///
+   /// @return An accessor on @p o's child objects, on success, or @c NULL,
+   /// on errors
+   ///
+   /// @note Do not remove or delete objects while walking the list.
+   ///
+   Eina_Accessor * accessor_new() const
+   {
+      Eina_Accessor * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_accessor_new());
+      return _tmp_ret;
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param child 
+   ///
+   Evas_Object_Box_Option * internal_append(evas::object child_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_append(efl::eolian::to_c(child_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Set a property value (by its given numerical identifier), on a
+   /// given box child element -- by a variable argument list
+   ///
+   /// @return @c EINA_TRUE on success, @c EINA_FALSE on failure.
+   ///
+   /// This is a variable argument list variant of the
+   /// evas_object_box_option_property_set(). See its documentation for
+   /// more details.
+   ///
+   /// @param opt The box option structure bound to the child box element
+   /// to set a property on
+   /// @param property The numerical ID of the given property
+   /// @param args The variable argument list implementing the value to
+   /// be set for this property. It @b must be of the same type the user has
+   /// defined for it.
+   ///
+   bool option_property_vset(Evas_Object_Box_Option * opt_, int property_, va_list * args_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_vset(opt_, property_, args_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param pos 
+   ///
+   evas::object internal_remove_at(unsigned int pos_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_remove_at(pos_));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Remove an object, <b>bound to a given position</b> in a box object,
+   /// unparenting it again.
+   ///
+   /// @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+   ///
+   /// On removal, you'll get an unparented object again, just as it was
+   /// before you inserted it in the box. The @c option_free() box smart
+   /// callback will be called automatically for you and, also, the
+   /// @c "child,removed" smart event will take place.
+   ///
+   /// @note This function will fail if the given position is invalid,
+   /// given @p o's internal list of elements.
+   ///
+   /// @note This call will trigger the box's
+   /// _Evas_Object_Box_Api.remove_at smart function.
+   ///
+   /// @param pos The numeric position (starting from @c 0) of the child
+   /// object to be removed
+   ///
+   bool remove_at(unsigned int pos_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_remove_at(pos_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get a property's value (by its given numerical identifier), on a
+   /// given box child element -- by a variable argument list
+   ///
+   /// @return @c EINA_TRUE on success, @c EINA_FALSE on failure.
+   ///
+   /// This is a variable argument list variant of the
+   /// evas_object_box_option_property_get(). See its documentation for
+   /// more details.
+   ///
+   /// @param opt The box option structure bound to the child box element
+   /// to get a property from
+   /// @param property The numerical ID of the given property
+   /// @param args The variable argument list with pointers to where to
+   /// store the values of this property. They @b must point to variables
+   /// of the same type the user has defined for them.
+   ///
+   bool option_property_vget(Evas_Object_Box_Option * opt_, int property_, va_list * args_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_vget(opt_, property_, args_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param child 
+   /// @param pos 
+   ///
+   Evas_Object_Box_Option * internal_insert_at(evas::object child_, unsigned int pos_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_insert_at(efl::eolian::to_c(child_), pos_));
+      return _tmp_ret;
+   }
+
+   /// @brief Insert a new @a child object <b>before another existing one</b>, in
+   /// a given box object @a o.
+   ///
+   /// @return A box option bound to the recently added box item or @c
+   /// NULL, on errors
+   ///
+   /// On success, the @c "child,added" smart event will take place.
+   ///
+   /// @note This function will fail if @p reference is not a member of @p
+   /// o.
+   ///
+   /// @note The actual placing of the item relative to @p o's area will
+   /// depend on the layout set to it.
+   ///
+   /// @note This call will trigger the box's
+   /// _Evas_Object_Box_Api.insert_before smart function.
+   ///
+   /// @param child A child Evas object to be made a member of @p o
+   /// @param reference The child object to place this new one before
+   ///
+   Evas_Object_Box_Option * insert_before(evas::object child_, const Evas_Object * reference_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_insert_before(efl::eolian::to_c(child_), reference_));
+      return _tmp_ret;
+   }
+
+   /// @brief Get the name of the property of the child elements of the box @a o
+   /// which have @a id as identifier
+   ///
+   /// @return The name of the given property or @c NULL, on errors.
+   ///
+   /// @note This call won't do anything for a canonical Evas box. Only
+   /// users which have @b subclassed it, setting custom box items options
+   /// (see #Evas_Object_Box_Option) on it, would benefit from this
+   /// function. They'd have to implement it and set it to be the
+   /// _Evas_Object_Box_Api.property_name_get smart class function of the
+   /// box, which is originally set to @c NULL.
+   ///
+   /// @param property The numerical identifier of the option being searched,
+   /// for its name
+   ///
+   std::string option_property_name_get(int property_) const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_name_get(property_));
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param child 
+   /// @param reference 
+   ///
+   Evas_Object_Box_Option * internal_insert_before(evas::object child_, const Evas_Object * reference_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_insert_before(efl::eolian::to_c(child_), reference_));
+      return _tmp_ret;
+   }
+
+   /// @brief Layout function which sets the box @a o to a @b homogeneous
+   /// horizontal box
+   ///
+   /// In a homogeneous horizontal box, its width is divided @b equally
+   /// between the contained objects. The box's overall behavior is
+   /// controlled by its padding/alignment properties, which are set by
+   /// the <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+   /// functions.  The size hints the elements in the box -- set by the
+   /// <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+   /// -- also control the way this function works.
+   ///
+   /// \par Box's properties:
+   /// @c align_h has no influence on the box for this layout.
+   /// @c padding_h tells the box to draw empty spaces of that size, in
+   /// pixels, between the (equal) child objects' cells. The @c align_v
+   /// and @c padding_v properties of the box don't contribute to its
+   /// behaviour when this layout is chosen.
+   ///
+   /// \par Child element's properties:
+   /// @c padding_l and @c padding_r sum up to the required width of the
+   /// child element. The @c align_x property tells the relative position
+   /// of this overall child width in its allocated cell (@c 0.0 to
+   /// extreme left, @c 1.0 to extreme right). A value of @c -1.0 to
+   /// @c align_x makes the box try to resize this child element to the exact
+   /// width of its cell (respecting the minimum and maximum size hints on
+   /// the child's width and accounting for its horizontal padding
+   /// hints). The child's @c padding_t, @c padding_b and @c align_y
+   /// properties apply for padding/alignment relative to the overall
+   /// height of the box. A value of @c -1.0 to @c align_y makes the box
+   /// try to resize this child element to the exact height of its parent
+   /// (respecting the maximum size hint on the child's height).
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_homogeneous_horizontal(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_homogeneous_horizontal(priv_, data_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param child 
+   ///
+   Evas_Object_Box_Option * internal_option_new(evas::object child_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_option_new(efl::eolian::to_c(child_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Layout function which sets the box @a o to a <b>maximum size,
+   /// homogeneous</b> vertical box
+   ///
+   /// This function behaves analogously to
+   /// evas_object_box_layout_homogeneous_max_size_horizontal(). The
+   /// description of its behaviour can be derived from that function's
+   /// documentation.
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_homogeneous_max_size_vertical(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_homogeneous_max_size_vertical(priv_, data_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param child 
+   /// @param reference 
+   ///
+   Evas_Object_Box_Option * internal_insert_after(evas::object child_, const Evas_Object * reference_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_insert_after(efl::eolian::to_c(child_), reference_));
+      return _tmp_ret;
+   }
+
+   /// @brief Insert a new @a child object <b>at a given position</b>, in a given
+   /// box object @a o.
+   ///
+   /// @return A box option bound to the recently added box item or @c
+   /// NULL, on errors
+   ///
+   /// On success, the @c "child,added" smart event will take place.
+   ///
+   /// @note This function will fail if the given position is invalid,
+   /// given @p o's internal list of elements.
+   ///
+   /// @note The actual placing of the item relative to @p o's area will
+   /// depend on the layout set to it.
+   ///
+   /// @note This call will trigger the box's
+   /// _Evas_Object_Box_Api.insert_at smart function.
+   ///
+   /// @param child A child Evas object to be made a member of @p o
+   /// @param pos The numeric position (starting from @c 0) to place the
+   /// new child object at
+   ///
+   Evas_Object_Box_Option * insert_at(evas::object child_, unsigned int pos_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_insert_at(efl::eolian::to_c(child_), pos_));
+      return _tmp_ret;
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param child 
+   ///
+   Evas_Object_Box_Option * internal_prepend(evas::object child_) const
+   {
+      Evas_Object_Box_Option * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_prepend(efl::eolian::to_c(child_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Remove a given object from a box object, unparenting it again.
+   ///
+   /// @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+   ///
+   /// On removal, you'll get an unparented object again, just as it was
+   /// before you inserted it in the box. The
+   /// _Evas_Object_Box_Api.option_free box smart callback will be called
+   /// automatically for you and, also, the @c "child,removed" smart event
+   /// will take place.
+   ///
+   /// @note This call will trigger the box's _Evas_Object_Box_Api.remove
+   /// smart function.
+   ///
+   /// @param child The handle to the child object to be removed
+   ///
+   bool remove(evas::object child_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_box_remove(efl::eolian::to_c(child_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Layout function which sets the box @a o to a @b stacking box
+   ///
+   /// In a stacking box, all children will be given the same size -- the
+   /// box's own size -- and they will be stacked one above the other, so
+   /// that the first object in @p o's internal list of child elements
+   /// will be the bottommost in the stack.
+   ///
+   /// \par Box's properties:
+   /// No box properties are used.
+   ///
+   /// \par Child element's properties:
+   /// @c padding_l and @c padding_r sum up to the required width of the
+   /// child element. The @c align_x property tells the relative position
+   /// of this overall child width in its allocated cell (@c 0.0 to
+   /// extreme left, @c 1.0 to extreme right). A value of @c -1.0 to @c
+   /// align_x makes the box try to resize this child element to the exact
+   /// width of its cell (respecting the min and max hints on the child's
+   /// width and accounting for its horizontal padding properties). The
+   /// same applies to the vertical axis.
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_stack(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_stack(priv_, data_));
+   }
+
+   /// @brief Layout function which sets the box @a o to a @b homogeneous
+   /// vertical box
+   ///
+   /// This function behaves analogously to
+   /// evas_object_box_layout_homogeneous_horizontal().  The description
+   /// of its behaviour can be derived from that function's documentation.
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_homogeneous_vertical(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_homogeneous_vertical(priv_, data_));
+   }
+
+   /// @brief Layout function which sets the box @a o to a @b flow horizontal
+   /// box.
+   ///
+   /// In a flow horizontal box, the box's child elements are placed in
+   /// @b rows (think of text as an analogy). A row has as much elements as
+   /// can fit into the box's width. The box's overall behavior is
+   /// controlled by its properties, which are set by the
+   /// <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+   /// functions.  The size hints of the elements in the box -- set by the
+   /// <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+   /// -- also control the way this function works.
+   ///
+   /// \par Box's properties:
+   /// @c padding_h tells the box to draw empty spaces of that size, in
+   /// pixels, between the child objects' cells. @c align_h dictates the
+   /// horizontal alignment of the rows (@c 0.0 to left align them, @c 1.0
+   /// to right align). A value of @c -1.0 to @c align_h lets the rows
+   /// @b justified horizontally. @c align_v controls the vertical alignment
+   /// of the entire set of rows (@c 0.0 to top, @c 1.0 to bottom). A
+   /// value of @c -1.0 to @c align_v makes the box to @b justify the rows
+   /// vertically. The padding between them, in this case, is corrected so
+   /// that the first row touches the top border and the last one touches
+   /// the bottom border (even if they must overlap). @c padding_v has no
+   /// influence on the layout.
+   ///
+   /// \par Child element's properties:
+   /// @c padding_l and @c padding_r sum up to the required width of the
+   /// child element. The @c align_x property has no influence on the
+   /// layout. The child's @c padding_t and @c padding_b sum up to the
+   /// required height of the child element and is the only means (besides
+   /// row justifying) of setting space between rows. Note, however, that
+   /// @c align_y dictates positioning relative to the <b>largest
+   /// height</b> required by a child object in the actual row.
+   ///
+   /// @param priv 
+   /// @param data 
+   ///
+   void layout_flow_horizontal(Evas_Object_Box_Data * priv_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_box_layout_flow_horizontal(priv_, data_));
+   }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_child_added_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_BOX_EVENT_CHILD_ADDED, priority_,
+            &efl::eo::_detail::event_callback<evas::box, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::box, function_type>,
+         EVAS_BOX_EVENT_CHILD_ADDED );
+   }
+
+   template <typename T>
+   void
+   callback_child_added_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_BOX_EVENT_CHILD_ADDED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_child_removed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_BOX_EVENT_CHILD_REMOVED, priority_,
+            &efl::eo::_detail::event_callback<evas::box, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::box, function_type>,
+         EVAS_BOX_EVENT_CHILD_REMOVED );
+   }
+
+   template <typename T>
+   void
+   callback_child_removed_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_BOX_EVENT_CHILD_REMOVED, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_BOX_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_BOX_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void * evas_box_smart_data_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smart_data_get();
+}
+
+template <typename T>
+void evas_box_calculate_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->calculate();
+}
+
+template <typename T>
+void evas_box_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->add();
+}
+
+template <typename T>
+void evas_box_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->del();
+}
+
+template <typename T>
+void evas_box_resize_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->resize(w_, h_);
+}
+
+template <typename T>
+void evas_box_align_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double* horizontal_, double* vertical_)
+{
+   static_cast<T*>(self->this_)->align_get(horizontal_, vertical_);
+}
+
+template <typename T>
+void evas_box_align_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double horizontal_, double vertical_)
+{
+   static_cast<T*>(self->this_)->align_set(horizontal_, vertical_);
+}
+
+template <typename T>
+void evas_box_padding_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* horizontal_, Evas_Coord* vertical_)
+{
+   static_cast<T*>(self->this_)->padding_get(horizontal_, vertical_);
+}
+
+template <typename T>
+void evas_box_padding_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord horizontal_, Evas_Coord vertical_)
+{
+   static_cast<T*>(self->this_)->padding_set(horizontal_, vertical_);
+}
+
+template <typename T>
+void evas_box_layout_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Layout cb_, const void * data_, Eina_Free_Cb free_data_)
+{
+   static_cast<T*>(self->this_)->layout_set(cb_, data_, free_data_);
+}
+
+template <typename T>
+void evas_box_layout_horizontal_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_horizontal(priv_, data_);
+}
+
+template <typename T>
+void evas_box_layout_vertical_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_vertical(priv_, data_);
+}
+
+template <typename T>
+void evas_box_layout_homogeneous_max_size_horizontal_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_homogeneous_max_size_horizontal(priv_, data_);
+}
+
+template <typename T>
+evas::object evas_box_internal_remove_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->internal_remove(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_box_layout_flow_vertical_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_flow_vertical(priv_, data_);
+}
+
+template <typename T>
+void evas_box_internal_option_free_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Option * opt_)
+{
+   static_cast<T*>(self->this_)->internal_option_free(opt_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_insert_after_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, const Evas_Object * reference_)
+{
+   return static_cast<T*>(self->this_)->insert_after(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), reference_);
+}
+
+template <typename T>
+bool evas_box_remove_all_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool clear_)
+{
+   return static_cast<T*>(self->this_)->remove_all(efl::eolian::to_cxx<bool>(clear_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Eina_Iterator * evas_box_iterator_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->iterator_new();
+}
+
+template <typename T>
+evas::object evas_box_add_to_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->add_to();
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_append_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->append(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+int evas_box_option_property_id_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_)
+{
+   return static_cast<T*>(self->this_)->option_property_id_get(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_prepend_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->prepend(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Eina_Accessor * evas_box_accessor_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->accessor_new();
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_internal_append_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->internal_append(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_box_option_property_vset_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Option * opt_, int property_, va_list * args_)
+{
+   return static_cast<T*>(self->this_)->option_property_vset(opt_, property_, args_);
+}
+
+template <typename T>
+evas::object evas_box_internal_remove_at_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int pos_)
+{
+   return static_cast<T*>(self->this_)->internal_remove_at(pos_);
+}
+
+template <typename T>
+bool evas_box_remove_at_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int pos_)
+{
+   return static_cast<T*>(self->this_)->remove_at(pos_);
+}
+
+template <typename T>
+bool evas_box_option_property_vget_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Option * opt_, int property_, va_list * args_)
+{
+   return static_cast<T*>(self->this_)->option_property_vget(opt_, property_, args_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_internal_insert_at_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, unsigned int pos_)
+{
+   return static_cast<T*>(self->this_)->internal_insert_at(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), pos_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_insert_before_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, const Evas_Object * reference_)
+{
+   return static_cast<T*>(self->this_)->insert_before(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), reference_);
+}
+
+template <typename T>
+std::string evas_box_option_property_name_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int property_)
+{
+   return static_cast<T*>(self->this_)->option_property_name_get(property_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_internal_insert_before_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, const Evas_Object * reference_)
+{
+   return static_cast<T*>(self->this_)->internal_insert_before(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), reference_);
+}
+
+template <typename T>
+void evas_box_layout_homogeneous_horizontal_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_homogeneous_horizontal(priv_, data_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_internal_option_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->internal_option_new(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_box_layout_homogeneous_max_size_vertical_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_homogeneous_max_size_vertical(priv_, data_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_internal_insert_after_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, const Evas_Object * reference_)
+{
+   return static_cast<T*>(self->this_)->internal_insert_after(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), reference_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_insert_at_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, unsigned int pos_)
+{
+   return static_cast<T*>(self->this_)->insert_at(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), pos_);
+}
+
+template <typename T>
+Evas_Object_Box_Option * evas_box_internal_prepend_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->internal_prepend(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_box_remove_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->remove(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_box_layout_stack_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_stack(priv_, data_);
+}
+
+template <typename T>
+void evas_box_layout_homogeneous_vertical_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_homogeneous_vertical(priv_, data_);
+}
+
+template <typename T>
+void evas_box_layout_flow_horizontal_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Box_Data * priv_, void * data_)
+{
+   static_cast<T*>(self->this_)->layout_flow_horizontal(priv_, data_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::box >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void * smart_data_get()
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_data_get());
+            return _tmp_ret;
+      }
+
+      virtual void calculate()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_calculate());
+      }
+
+      virtual void add()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_add());
+      }
+
+      virtual void del()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_del());
+      }
+
+      virtual void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_resize(w_, h_));
+      }
+
+      virtual void align_get(double* horizontal_, double* vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_align_get(horizontal_, vertical_));
+      }
+
+      virtual void align_set(double horizontal_, double vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_align_set(horizontal_, vertical_));
+      }
+
+      virtual void padding_get(Evas_Coord* horizontal_, Evas_Coord* vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_padding_get(horizontal_, vertical_));
+      }
+
+      virtual void padding_set(Evas_Coord horizontal_, Evas_Coord vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_padding_set(horizontal_, vertical_));
+      }
+
+      virtual void layout_set(Evas_Object_Box_Layout cb_, const void * data_, Eina_Free_Cb free_data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_set(cb_, data_, free_data_));
+      }
+
+      virtual void layout_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_horizontal(priv_, data_));
+      }
+
+      virtual void layout_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_vertical(priv_, data_));
+      }
+
+      virtual void layout_homogeneous_max_size_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_homogeneous_max_size_horizontal(priv_, data_));
+      }
+
+      virtual evas::object internal_remove(evas::object child_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_remove(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void layout_flow_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_flow_vertical(priv_, data_));
+      }
+
+      virtual void internal_option_free(Evas_Object_Box_Option * opt_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_internal_option_free(opt_));
+      }
+
+      virtual Evas_Object_Box_Option * insert_after(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_insert_after(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      virtual bool remove_all(bool clear_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_remove_all(efl::eolian::to_c(clear_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_iterator_new());
+            return _tmp_ret;
+      }
+
+      virtual evas::object add_to()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_add_to());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Evas_Object_Box_Option * append(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_append(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      virtual int option_property_id_get(std::string name_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_option_property_id_get(efl::eolian::to_c(name_)));
+            return _tmp_ret;
+      }
+
+      virtual Evas_Object_Box_Option * prepend(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_prepend(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      virtual Eina_Accessor * accessor_new()
+      {
+         Eina_Accessor * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_accessor_new());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Object_Box_Option * internal_append(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_append(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      virtual bool option_property_vset(Evas_Object_Box_Option * opt_, int property_, va_list * args_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_option_property_vset(opt_, property_, args_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object internal_remove_at(unsigned int pos_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_remove_at(pos_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool remove_at(unsigned int pos_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_remove_at(pos_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool option_property_vget(Evas_Object_Box_Option * opt_, int property_, va_list * args_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_option_property_vget(opt_, property_, args_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Evas_Object_Box_Option * internal_insert_at(evas::object child_, unsigned int pos_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_insert_at(efl::eolian::to_c(child_), pos_));
+            return _tmp_ret;
+      }
+
+      virtual Evas_Object_Box_Option * insert_before(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_insert_before(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      virtual std::string option_property_name_get(int property_)
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_option_property_name_get(property_));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Evas_Object_Box_Option * internal_insert_before(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_insert_before(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      virtual void layout_homogeneous_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_homogeneous_horizontal(priv_, data_));
+      }
+
+      virtual Evas_Object_Box_Option * internal_option_new(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_option_new(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      virtual void layout_homogeneous_max_size_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_homogeneous_max_size_vertical(priv_, data_));
+      }
+
+      virtual Evas_Object_Box_Option * internal_insert_after(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_insert_after(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      virtual Evas_Object_Box_Option * insert_at(evas::object child_, unsigned int pos_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_insert_at(efl::eolian::to_c(child_), pos_));
+            return _tmp_ret;
+      }
+
+      virtual Evas_Object_Box_Option * internal_prepend(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_internal_prepend(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      virtual bool remove(evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_box_remove(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void layout_stack(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_stack(priv_, data_));
+      }
+
+      virtual void layout_homogeneous_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_homogeneous_vertical(priv_, data_));
+      }
+
+      virtual void layout_flow_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_box_layout_flow_horizontal(priv_, data_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::box >
+{
+   static const int value = 43;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::box>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_box_smart_data_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_data_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_box_calculate_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_calculate);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_box_add_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_add);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_box_del_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_del);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_box_resize_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_resize);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_box_align_get_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_box_align_get);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_box_align_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_box_align_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_box_padding_get_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_box_padding_get);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_box_padding_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_box_padding_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_box_layout_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_box_layout_horizontal_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_horizontal);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_box_layout_vertical_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_vertical);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_box_layout_homogeneous_max_size_horizontal_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_homogeneous_max_size_horizontal);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_box_internal_remove_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_remove);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_box_layout_flow_vertical_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_flow_vertical);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_box_internal_option_free_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_option_free);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_box_insert_after_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_obj_box_insert_after);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_box_remove_all_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_obj_box_remove_all);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_box_iterator_new_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_obj_box_iterator_new);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_box_add_to_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_obj_box_add_to);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_box_append_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_obj_box_append);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_box_option_property_id_get_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_obj_box_option_property_id_get);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::evas_box_prepend_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_obj_box_prepend);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::evas_box_accessor_new_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_obj_box_accessor_new);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::evas_box_internal_append_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_append);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::evas_box_option_property_vset_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_obj_box_option_property_vset);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::evas_box_internal_remove_at_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_remove_at);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::evas_box_remove_at_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::evas_obj_box_remove_at);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::evas_box_option_property_vget_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::evas_obj_box_option_property_vget);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   ops[29].func = reinterpret_cast<void*>(& ::evas_box_internal_insert_at_wrapper<T>);
+   ops[29].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_insert_at);
+   ops[29].op = EO_OP_OVERRIDE;
+   ops[29].op_type = EO_OP_TYPE_REGULAR;
+   ops[29].doc = NULL;
+
+   ops[30].func = reinterpret_cast<void*>(& ::evas_box_insert_before_wrapper<T>);
+   ops[30].api_func = reinterpret_cast<void*>(& ::evas_obj_box_insert_before);
+   ops[30].op = EO_OP_OVERRIDE;
+   ops[30].op_type = EO_OP_TYPE_REGULAR;
+   ops[30].doc = NULL;
+
+   ops[31].func = reinterpret_cast<void*>(& ::evas_box_option_property_name_get_wrapper<T>);
+   ops[31].api_func = reinterpret_cast<void*>(& ::evas_obj_box_option_property_name_get);
+   ops[31].op = EO_OP_OVERRIDE;
+   ops[31].op_type = EO_OP_TYPE_REGULAR;
+   ops[31].doc = NULL;
+
+   ops[32].func = reinterpret_cast<void*>(& ::evas_box_internal_insert_before_wrapper<T>);
+   ops[32].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_insert_before);
+   ops[32].op = EO_OP_OVERRIDE;
+   ops[32].op_type = EO_OP_TYPE_REGULAR;
+   ops[32].doc = NULL;
+
+   ops[33].func = reinterpret_cast<void*>(& ::evas_box_layout_homogeneous_horizontal_wrapper<T>);
+   ops[33].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_homogeneous_horizontal);
+   ops[33].op = EO_OP_OVERRIDE;
+   ops[33].op_type = EO_OP_TYPE_REGULAR;
+   ops[33].doc = NULL;
+
+   ops[34].func = reinterpret_cast<void*>(& ::evas_box_internal_option_new_wrapper<T>);
+   ops[34].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_option_new);
+   ops[34].op = EO_OP_OVERRIDE;
+   ops[34].op_type = EO_OP_TYPE_REGULAR;
+   ops[34].doc = NULL;
+
+   ops[35].func = reinterpret_cast<void*>(& ::evas_box_layout_homogeneous_max_size_vertical_wrapper<T>);
+   ops[35].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_homogeneous_max_size_vertical);
+   ops[35].op = EO_OP_OVERRIDE;
+   ops[35].op_type = EO_OP_TYPE_REGULAR;
+   ops[35].doc = NULL;
+
+   ops[36].func = reinterpret_cast<void*>(& ::evas_box_internal_insert_after_wrapper<T>);
+   ops[36].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_insert_after);
+   ops[36].op = EO_OP_OVERRIDE;
+   ops[36].op_type = EO_OP_TYPE_REGULAR;
+   ops[36].doc = NULL;
+
+   ops[37].func = reinterpret_cast<void*>(& ::evas_box_insert_at_wrapper<T>);
+   ops[37].api_func = reinterpret_cast<void*>(& ::evas_obj_box_insert_at);
+   ops[37].op = EO_OP_OVERRIDE;
+   ops[37].op_type = EO_OP_TYPE_REGULAR;
+   ops[37].doc = NULL;
+
+   ops[38].func = reinterpret_cast<void*>(& ::evas_box_internal_prepend_wrapper<T>);
+   ops[38].api_func = reinterpret_cast<void*>(& ::evas_obj_box_internal_prepend);
+   ops[38].op = EO_OP_OVERRIDE;
+   ops[38].op_type = EO_OP_TYPE_REGULAR;
+   ops[38].doc = NULL;
+
+   ops[39].func = reinterpret_cast<void*>(& ::evas_box_remove_wrapper<T>);
+   ops[39].api_func = reinterpret_cast<void*>(& ::evas_obj_box_remove);
+   ops[39].op = EO_OP_OVERRIDE;
+   ops[39].op_type = EO_OP_TYPE_REGULAR;
+   ops[39].doc = NULL;
+
+   ops[40].func = reinterpret_cast<void*>(& ::evas_box_layout_stack_wrapper<T>);
+   ops[40].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_stack);
+   ops[40].op = EO_OP_OVERRIDE;
+   ops[40].op_type = EO_OP_TYPE_REGULAR;
+   ops[40].doc = NULL;
+
+   ops[41].func = reinterpret_cast<void*>(& ::evas_box_layout_homogeneous_vertical_wrapper<T>);
+   ops[41].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_homogeneous_vertical);
+   ops[41].op = EO_OP_OVERRIDE;
+   ops[41].op_type = EO_OP_TYPE_REGULAR;
+   ops[41].doc = NULL;
+
+   ops[42].func = reinterpret_cast<void*>(& ::evas_box_layout_flow_horizontal_wrapper<T>);
+   ops[42].api_func = reinterpret_cast<void*>(& ::evas_obj_box_layout_flow_horizontal);
+   ops[42].op = EO_OP_OVERRIDE;
+   ops[42].op_type = EO_OP_TYPE_REGULAR;
+   ops[42].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::box >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::box, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::box >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::box, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::box>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::box() const
+      {
+         return evas::box(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void * smart_data_get()
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_data_get());
+            return _tmp_ret;
+      }
+
+      void calculate()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_calculate());
+      }
+
+      void add()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_add());
+      }
+
+      void del()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_del());
+      }
+
+      void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+      }
+
+      void align_get(double* horizontal_, double* vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_align_get(horizontal_, vertical_));
+      }
+
+      void align_set(double horizontal_, double vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_align_set(horizontal_, vertical_));
+      }
+
+      void padding_get(Evas_Coord* horizontal_, Evas_Coord* vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_padding_get(horizontal_, vertical_));
+      }
+
+      void padding_set(Evas_Coord horizontal_, Evas_Coord vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_padding_set(horizontal_, vertical_));
+      }
+
+      void layout_set(Evas_Object_Box_Layout cb_, const void * data_, Eina_Free_Cb free_data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_set(cb_, data_, free_data_));
+      }
+
+      void layout_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_horizontal(priv_, data_));
+      }
+
+      void layout_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_vertical(priv_, data_));
+      }
+
+      void layout_homogeneous_max_size_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_homogeneous_max_size_horizontal(priv_, data_));
+      }
+
+      evas::object internal_remove(evas::object child_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_remove(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void layout_flow_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_flow_vertical(priv_, data_));
+      }
+
+      void internal_option_free(Evas_Object_Box_Option * opt_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_internal_option_free(opt_));
+      }
+
+      Evas_Object_Box_Option * insert_after(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_insert_after(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      bool remove_all(bool clear_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_remove_all(efl::eolian::to_c(clear_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_iterator_new());
+            return _tmp_ret;
+      }
+
+      evas::object add_to()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_add_to());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Evas_Object_Box_Option * append(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_append(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      int option_property_id_get(std::string name_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_id_get(efl::eolian::to_c(name_)));
+            return _tmp_ret;
+      }
+
+      Evas_Object_Box_Option * prepend(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_prepend(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      Eina_Accessor * accessor_new()
+      {
+         Eina_Accessor * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_accessor_new());
+            return _tmp_ret;
+      }
+
+      Evas_Object_Box_Option * internal_append(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_append(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      bool option_property_vset(Evas_Object_Box_Option * opt_, int property_, va_list * args_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_vset(opt_, property_, args_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object internal_remove_at(unsigned int pos_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_remove_at(pos_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool remove_at(unsigned int pos_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_remove_at(pos_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool option_property_vget(Evas_Object_Box_Option * opt_, int property_, va_list * args_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_vget(opt_, property_, args_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Evas_Object_Box_Option * internal_insert_at(evas::object child_, unsigned int pos_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_insert_at(efl::eolian::to_c(child_), pos_));
+            return _tmp_ret;
+      }
+
+      Evas_Object_Box_Option * insert_before(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_insert_before(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      std::string option_property_name_get(int property_)
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_option_property_name_get(property_));
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Evas_Object_Box_Option * internal_insert_before(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_insert_before(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      void layout_homogeneous_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_homogeneous_horizontal(priv_, data_));
+      }
+
+      Evas_Object_Box_Option * internal_option_new(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_option_new(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      void layout_homogeneous_max_size_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_homogeneous_max_size_vertical(priv_, data_));
+      }
+
+      Evas_Object_Box_Option * internal_insert_after(evas::object child_, const Evas_Object * reference_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_insert_after(efl::eolian::to_c(child_), reference_));
+            return _tmp_ret;
+      }
+
+      Evas_Object_Box_Option * insert_at(evas::object child_, unsigned int pos_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_insert_at(efl::eolian::to_c(child_), pos_));
+            return _tmp_ret;
+      }
+
+      Evas_Object_Box_Option * internal_prepend(evas::object child_)
+      {
+         Evas_Object_Box_Option * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_internal_prepend(efl::eolian::to_c(child_)));
+            return _tmp_ret;
+      }
+
+      bool remove(evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_box_remove(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void layout_stack(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_stack(priv_, data_));
+      }
+
+      void layout_homogeneous_vertical(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_homogeneous_vertical(priv_, data_));
+      }
+
+      void layout_flow_horizontal(Evas_Object_Box_Data * priv_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_box_layout_flow_horizontal(priv_, data_));
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_child_added_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_BOX_EVENT_CHILD_ADDED, priority_,
+            &efl::eo::_detail::event_callback<evas::box, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::box, function_type>,
+         EVAS_BOX_EVENT_CHILD_ADDED );
+   }
+
+   template <typename T>
+   void
+   callback_child_added_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_BOX_EVENT_CHILD_ADDED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_child_removed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_BOX_EVENT_CHILD_REMOVED, priority_,
+            &efl::eo::_detail::event_callback<evas::box, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::box, function_type>,
+         EVAS_BOX_EVENT_CHILD_REMOVED );
+   }
+
+   template <typename T>
+   void
+   callback_child_removed_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_BOX_EVENT_CHILD_REMOVED, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::box>)
+{
+   return (EVAS_BOX_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_BOX_HH
+
diff -Naur a/src/lib/evas/canvas/evas_box.eo.legacy.h b/src/lib/evas/canvas/evas_box.eo.legacy.h
--- a/src/lib/evas/canvas/evas_box.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_box.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,640 @@
+#ifndef _EVAS_BOX_EO_LEGACY_H_
+#define _EVAS_BOX_EO_LEGACY_H_
+
+#ifndef _EVAS_BOX_EO_CLASS_TYPE
+#define _EVAS_BOX_EO_CLASS_TYPE
+
+typedef Eo Evas_Box;
+
+#endif
+
+#ifndef _EVAS_BOX_EO_TYPES
+#define _EVAS_BOX_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Set the alignment of the whole bounding box of contents, for a
+ * given box object.
+ *
+ * This will influence how a box object is to align its bounding box
+ * of contents within its own area. The values @b must be in the range
+ * @c 0.0 - @c 1.0, or undefined behavior is expected. For horizontal
+ * alignment, @c 0.0 means to the left, with @c 1.0 meaning to the
+ * right. For vertical alignment, @c 0.0 means to the top, with @c 1.0
+ * meaning to the bottom.
+ *
+ * @note The default values for both alignments is @c 0.5.
+ *
+ * @see evas_object_box_align_get()
+ *
+ * @param[in] horizontal The horizontal alignment, in pixels
+ * @param[in] vertical the vertical alignment, in pixels
+ */
+EAPI void evas_object_box_align_set(Evas_Box *obj, double horizontal, double vertical);
+
+/**
+ *
+ * Get the alignment of the whole bounding box of contents, for a
+ * given box object.
+ *
+ * @see evas_object_box_align_set() for more information
+ *
+ * @param[out] horizontal The horizontal alignment, in pixels
+ * @param[out] vertical the vertical alignment, in pixels
+ */
+EAPI void evas_object_box_align_get(const Evas_Box *obj, double *horizontal, double *vertical);
+
+/**
+ *
+ * Set the (space) padding between cells set for a given box object.
+ *
+ * @note The default values for both padding components is @c 0.
+ *
+ * @see evas_object_box_padding_get()
+ *
+ * @param[in] horizontal The horizontal padding, in pixels
+ * @param[in] vertical the vertical padding, in pixels
+ */
+EAPI void evas_object_box_padding_set(Evas_Box *obj, Evas_Coord horizontal, Evas_Coord vertical);
+
+/**
+ *
+ * Get the (space) padding between cells set for a given box object.
+ *
+ * @see evas_object_box_padding_set()
+ *
+ * @param[out] horizontal The horizontal padding, in pixels
+ * @param[out] vertical the vertical padding, in pixels
+ */
+EAPI void evas_object_box_padding_get(const Evas_Box *obj, Evas_Coord *horizontal, Evas_Coord *vertical);
+
+/**
+ *
+ * Set a new layouting function to a given box object
+ *
+ * A box layout function affects how a box object displays child
+ * elements within its area. The list of pre-defined box layouts
+ * available in Evas is:
+ * - evas_object_box_layout_horizontal()
+ * - evas_object_box_layout_vertical()
+ * - evas_object_box_layout_homogeneous_horizontal()
+ * - evas_object_box_layout_homogeneous_vertical()
+ * - evas_object_box_layout_homogeneous_max_size_horizontal()
+ * - evas_object_box_layout_homogeneous_max_size_vertical()
+ * - evas_object_box_layout_flow_horizontal()
+ * - evas_object_box_layout_flow_vertical()
+ * - evas_object_box_layout_stack()
+ *
+ * Refer to each of their documentation texts for details on them.
+ *
+ * @note A box layouting function will be triggered by the @c
+ * 'calculate' smart callback of the box's smart class.
+ *
+ * @param[in] cb The new layout function to set on @p o.
+ * @param[in] data Data pointer to be passed to @p cb.
+ * @param[in] free_data Function to free @p data, if need be.
+ */
+EAPI void evas_object_box_layout_set(Evas_Box *obj, Evas_Object_Box_Layout cb, const void *data, Eina_Free_Cb free_data) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Layout function which sets the box @a o to a (basic) horizontal box
+ *
+ * In this layout, the box object's overall behavior is controlled by
+ * its padding/alignment properties, which are set by the
+ * <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions. The size hints of the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c align_h controls the horizontal alignment of the child objects
+ * relative to the containing box. When set to @c 0.0, children are
+ * aligned to the left. A value of @c 1.0 makes them aligned to the
+ * right border. Values in between align them proportionally. Note
+ * that if the size required by the children, which is given by their
+ * widths and the @c padding_h property of the box, is bigger than the
+ * their container's width, the children will be displayed out of the
+ * box's bounds. A negative value of @c align_h makes the box to
+ * @b justify its children. The padding between them, in this case, is
+ * corrected so that the leftmost one touches the left border and the
+ * rightmost one touches the right border (even if they must
+ * overlap). The @c align_v and @c padding_v properties of the box
+ * @b don't contribute to its behaviour when this layout is chosen.
+ *
+ * \par Child element's properties:
+ * @c align_x does @b not influence the box's behavior. @c padding_l
+ * and @c padding_r sum up to the container's horizontal padding
+ * between elements. The child's @c padding_t, @c padding_b and
+ * @c align_y properties apply for padding/alignment relative to the
+ * overall height of the box. Finally, there is the @c weight_x
+ * property, which, if set to a non-zero value, tells the container
+ * that the child width is @b not pre-defined. If the container can't
+ * accommodate all its children, it sets the widths of the ones
+ * <b>with weights</b> to sizes as small as they can all fit into
+ * it. If the size required by the children is less than the
+ * available, the box increases its childrens' (which have weights)
+ * widths as to fit the remaining space. The @c weight_x property,
+ * besides telling the element is resizable, gives a @b weight for the
+ * resizing process.  The parent box will try to distribute (or take
+ * off) widths accordingly to the @b normalized list of weights: most
+ * weighted children remain/get larger in this process than the least
+ * ones. @c weight_y does not influence the layout.
+ *
+ * If one desires that, besides having weights, child elements must be
+ * resized bounded to a minimum or maximum size, those size hints must
+ * be set, by the <c>evas_object_size_hint_{min,max}_set()</c>
+ * functions.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a (basic) vertical box
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_horizontal(). The description of its
+ * behaviour can be derived from that function's documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a <b>maximum size,
+ * homogeneous</b> horizontal box
+ *
+ * In a maximum size, homogeneous horizontal box, besides having cells
+ * of <b>equal size</b> reserved for the child objects, this size will
+ * be defined by the size of the @b largest child in the box (in
+ * width). The box's overall behavior is controlled by its properties,
+ * which are set by the
+ * <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions.  The size hints of the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c padding_h tells the box to draw empty spaces of that size, in
+ * pixels, between the child objects' cells. @c align_h controls the
+ * horizontal alignment of the child objects, relative to the
+ * containing box. When set to @c 0.0, children are aligned to the
+ * left. A value of @c 1.0 lets them aligned to the right
+ * border. Values in between align them proportionally. A negative
+ * value of @c align_h makes the box to @b justify its children
+ * cells. The padding between them, in this case, is corrected so that
+ * the leftmost one touches the left border and the rightmost one
+ * touches the right border (even if they must overlap). The
+ * @c align_v and @c padding_v properties of the box don't contribute to
+ * its behaviour when this layout is chosen.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property tells the relative position
+ * of this overall child width in its allocated cell (@c 0.0 to
+ * extreme left, @c 1.0 to extreme right). A value of @c -1.0 to
+ * @c align_x makes the box try to resize this child element to the exact
+ * width of its cell (respecting the minimum and maximum size hints on
+ * the child's width and accounting for its horizontal padding
+ * hints). The child's @c padding_t, @c padding_b and @c align_y
+ * properties apply for padding/alignment relative to the overall
+ * height of the box. A value of @c -1.0 to @c align_y makes the box
+ * try to resize this child element to the exact height of its parent
+ * (respecting the max hint on the child's height).
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_homogeneous_max_size_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b flow vertical box.
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_flow_horizontal(). The description of its
+ * behaviour can be derived from that function's documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_flow_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Insert a new @a child object <b>after another existing one</b>, in
+ * a given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note This function will fail if @p reference is not a member of @p
+ * o.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.insert_after smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ * @param[in] reference The child object to place this new one after
+ */
+EAPI Evas_Object_Box_Option *evas_object_box_insert_after(Evas_Box *obj, Evas_Object *child, const Evas_Object *reference) EINA_ARG_NONNULL(2, 3);
+
+/**
+ *
+ * Remove @b all child objects from a box object, unparenting them
+ * again.
+ *
+ * @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+ *
+ * This has the same effect of calling evas_object_box_remove() on
+ * each of @p o's child objects, in sequence. If, and only if, all
+ * those calls succeed, so does this one.
+ * 
+ *
+ * @param[in] clear if true, it will delete just removed children.
+ */
+EAPI Eina_Bool evas_object_box_remove_all(Evas_Box *obj, Eina_Bool clear);
+
+/**
+ *
+ * Get an iterator to walk the list of children of a given box object.
+ *
+ * @return An iterator on @p o's child objects, on success, or @c NULL,
+ * on errors
+ *
+ * @note Do @b not remove or delete objects while walking the list.
+ * 
+ *
+ */
+EAPI Eina_Iterator *evas_object_box_iterator_new(const Evas_Box *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Add a new box as a @b child of a given smart object.
+ *
+ * @return @c NULL on error, a pointer to a new box object on
+ * success.
+ *
+ * This is a helper function that has the same effect of putting a new
+ * box object into @p parent by use of evas_object_smart_member_add().
+ *
+ * @see evas_object_box_add()
+ * 
+ *
+ */
+EAPI Evas_Object *evas_object_box_add_to(Evas_Box *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Append a new @a child object to the given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it. For example, on horizontal layouts
+ * an item in the end of the box's list of children will appear on its
+ * right.
+ *
+ * @note This call will trigger the box's _Evas_Object_Box_Api.append
+ * smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ */
+EAPI Evas_Object_Box_Option *evas_object_box_append(Evas_Box *obj, Evas_Object *child) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Get the numerical identifier of the property of the child elements
+ * of the box @a o which have @a name as name string
+ *
+ * @return The numerical ID of the given property or @c -1, on
+ * errors.
+ *
+ * @note This call won't do anything for a canonical Evas box. Only
+ * users which have @b subclassed it, setting custom box items options
+ * (see #Evas_Object_Box_Option) on it, would benefit from this
+ * function. They'd have to implement it and set it to be the
+ * _Evas_Object_Box_Api.property_id_get smart class function of the
+ * box, which is originally set to @c NULL.
+ * 
+ *
+ * @param[in] name The name string of the option being searched, for
+its ID
+ */
+EAPI int evas_object_box_option_property_id_get(const Evas_Box *obj, const char *name) EINA_WARN_UNUSED_RESULT EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Prepend a new @a child object to the given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it. For example, on horizontal layouts
+ * an item in the beginning of the box's list of children will appear
+ * on its left.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.prepend smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ */
+EAPI Evas_Object_Box_Option *evas_object_box_prepend(Evas_Box *obj, Evas_Object *child) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Get an accessor (a structure providing random items access) to the
+ * list of children of a given box object.
+ *
+ * @return An accessor on @p o's child objects, on success, or @c NULL,
+ * on errors
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * 
+ *
+ */
+EAPI Eina_Accessor *evas_object_box_accessor_new(const Evas_Box *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Remove an object, <b>bound to a given position</b> in a box object,
+ * unparenting it again.
+ *
+ * @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+ *
+ * On removal, you'll get an unparented object again, just as it was
+ * before you inserted it in the box. The @c option_free() box smart
+ * callback will be called automatically for you and, also, the
+ * @c "child,removed" smart event will take place.
+ *
+ * @note This function will fail if the given position is invalid,
+ * given @p o's internal list of elements.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.remove_at smart function.
+ * 
+ *
+ * @param[in] pos The numeric position (starting from @c 0) of the child
+object to be removed
+ */
+EAPI Eina_Bool evas_object_box_remove_at(Evas_Box *obj, unsigned int pos);
+
+/**
+ *
+ * Insert a new @a child object <b>before another existing one</b>, in
+ * a given box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note This function will fail if @p reference is not a member of @p
+ * o.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.insert_before smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ * @param[in] reference The child object to place this new one before
+ */
+EAPI Evas_Object_Box_Option *evas_object_box_insert_before(Evas_Box *obj, Evas_Object *child, const Evas_Object *reference) EINA_ARG_NONNULL(2, 3);
+
+/**
+ *
+ * Get the name of the property of the child elements of the box @a o
+ * which have @a id as identifier
+ *
+ * @return The name of the given property or @c NULL, on errors.
+ *
+ * @note This call won't do anything for a canonical Evas box. Only
+ * users which have @b subclassed it, setting custom box items options
+ * (see #Evas_Object_Box_Option) on it, would benefit from this
+ * function. They'd have to implement it and set it to be the
+ * _Evas_Object_Box_Api.property_name_get smart class function of the
+ * box, which is originally set to @c NULL.
+ * 
+ *
+ * @param[in] property The numerical identifier of the option being searched,
+for its name
+ */
+EAPI const char *evas_object_box_option_property_name_get(const Evas_Box *obj, int property) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b homogeneous
+ * horizontal box
+ *
+ * In a homogeneous horizontal box, its width is divided @b equally
+ * between the contained objects. The box's overall behavior is
+ * controlled by its padding/alignment properties, which are set by
+ * the <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions.  The size hints the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c align_h has no influence on the box for this layout.
+ * @c padding_h tells the box to draw empty spaces of that size, in
+ * pixels, between the (equal) child objects' cells. The @c align_v
+ * and @c padding_v properties of the box don't contribute to its
+ * behaviour when this layout is chosen.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property tells the relative position
+ * of this overall child width in its allocated cell (@c 0.0 to
+ * extreme left, @c 1.0 to extreme right). A value of @c -1.0 to
+ * @c align_x makes the box try to resize this child element to the exact
+ * width of its cell (respecting the minimum and maximum size hints on
+ * the child's width and accounting for its horizontal padding
+ * hints). The child's @c padding_t, @c padding_b and @c align_y
+ * properties apply for padding/alignment relative to the overall
+ * height of the box. A value of @c -1.0 to @c align_y makes the box
+ * try to resize this child element to the exact height of its parent
+ * (respecting the maximum size hint on the child's height).
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_homogeneous_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a <b>maximum size,
+ * homogeneous</b> vertical box
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_homogeneous_max_size_horizontal(). The
+ * description of its behaviour can be derived from that function's
+ * documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_homogeneous_max_size_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Insert a new @a child object <b>at a given position</b>, in a given
+ * box object @a o.
+ *
+ * @return A box option bound to the recently added box item or @c
+ * NULL, on errors
+ *
+ * On success, the @c "child,added" smart event will take place.
+ *
+ * @note This function will fail if the given position is invalid,
+ * given @p o's internal list of elements.
+ *
+ * @note The actual placing of the item relative to @p o's area will
+ * depend on the layout set to it.
+ *
+ * @note This call will trigger the box's
+ * _Evas_Object_Box_Api.insert_at smart function.
+ * 
+ *
+ * @param[in] child A child Evas object to be made a member of @p o
+ * @param[in] pos The numeric position (starting from @c 0) to place the
+new child object at
+ */
+EAPI Evas_Object_Box_Option *evas_object_box_insert_at(Evas_Box *obj, Evas_Object *child, unsigned int pos) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Remove a given object from a box object, unparenting it again.
+ *
+ * @return @c EINA_TRUE, on success, @c EINA_FALSE otherwise
+ *
+ * On removal, you'll get an unparented object again, just as it was
+ * before you inserted it in the box. The
+ * _Evas_Object_Box_Api.option_free box smart callback will be called
+ * automatically for you and, also, the @c "child,removed" smart event
+ * will take place.
+ *
+ * @note This call will trigger the box's _Evas_Object_Box_Api.remove
+ * smart function.
+ * 
+ *
+ * @param[in] child The handle to the child object to be removed
+ */
+EAPI Eina_Bool evas_object_box_remove(Evas_Box *obj, Evas_Object *child) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b stacking box
+ *
+ * In a stacking box, all children will be given the same size -- the
+ * box's own size -- and they will be stacked one above the other, so
+ * that the first object in @p o's internal list of child elements
+ * will be the bottommost in the stack.
+ *
+ * \par Box's properties:
+ * No box properties are used.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property tells the relative position
+ * of this overall child width in its allocated cell (@c 0.0 to
+ * extreme left, @c 1.0 to extreme right). A value of @c -1.0 to @c
+ * align_x makes the box try to resize this child element to the exact
+ * width of its cell (respecting the min and max hints on the child's
+ * width and accounting for its horizontal padding properties). The
+ * same applies to the vertical axis.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_stack(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b homogeneous
+ * vertical box
+ *
+ * This function behaves analogously to
+ * evas_object_box_layout_homogeneous_horizontal().  The description
+ * of its behaviour can be derived from that function's documentation.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_homogeneous_vertical(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+/**
+ *
+ * Layout function which sets the box @a o to a @b flow horizontal
+ * box.
+ *
+ * In a flow horizontal box, the box's child elements are placed in
+ * @b rows (think of text as an analogy). A row has as much elements as
+ * can fit into the box's width. The box's overall behavior is
+ * controlled by its properties, which are set by the
+ * <c>evas_object_box_{h,v}_{align,padding}_set()</c> family of
+ * functions.  The size hints of the elements in the box -- set by the
+ * <c>evas_object_size_hint_{align,padding,weight}_set()</c> functions
+ * -- also control the way this function works.
+ *
+ * \par Box's properties:
+ * @c padding_h tells the box to draw empty spaces of that size, in
+ * pixels, between the child objects' cells. @c align_h dictates the
+ * horizontal alignment of the rows (@c 0.0 to left align them, @c 1.0
+ * to right align). A value of @c -1.0 to @c align_h lets the rows
+ * @b justified horizontally. @c align_v controls the vertical alignment
+ * of the entire set of rows (@c 0.0 to top, @c 1.0 to bottom). A
+ * value of @c -1.0 to @c align_v makes the box to @b justify the rows
+ * vertically. The padding between them, in this case, is corrected so
+ * that the first row touches the top border and the last one touches
+ * the bottom border (even if they must overlap). @c padding_v has no
+ * influence on the layout.
+ *
+ * \par Child element's properties:
+ * @c padding_l and @c padding_r sum up to the required width of the
+ * child element. The @c align_x property has no influence on the
+ * layout. The child's @c padding_t and @c padding_b sum up to the
+ * required height of the child element and is the only means (besides
+ * row justifying) of setting space between rows. Note, however, that
+ * @c align_y dictates positioning relative to the <b>largest
+ * height</b> required by a child object in the actual row.
+ * 
+ *
+ * @param[in] priv No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_object_box_layout_flow_horizontal(Evas_Box *obj, Evas_Object_Box_Data *priv, void *data);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_canvas.eo.c b/src/lib/evas/canvas/evas_canvas.eo.c
--- a/src/lib/evas/canvas/evas_canvas.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_canvas.eo.c	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,1147 @@
+
+void _evas_canvas_output_framespace_set(Eo *obj, Evas_Public_Data *pd, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_output_framespace_set, EO_FUNC_CALL(x, y, w, h), Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+void _evas_canvas_output_framespace_get(Eo *obj, Evas_Public_Data *pd, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_output_framespace_get, EO_FUNC_CALL(x, y, w, h), Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+void _evas_canvas_output_viewport_set(Eo *obj, Evas_Public_Data *pd, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_output_viewport_set, EO_FUNC_CALL(x, y, w, h), Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+void _evas_canvas_output_viewport_get(Eo *obj, Evas_Public_Data *pd, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_output_viewport_get, EO_FUNC_CALL(x, y, w, h), Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+void _evas_canvas_image_cache_set(Eo *obj, Evas_Public_Data *pd, int size);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_image_cache_set, EO_FUNC_CALL(size), int size);
+
+int _evas_canvas_image_cache_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_image_cache_get, int, 0);
+
+void _evas_canvas_event_default_flags_set(Eo *obj, Evas_Public_Data *pd, Evas_Event_Flags flags);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_default_flags_set, EO_FUNC_CALL(flags), Evas_Event_Flags flags);
+
+Evas_Event_Flags _evas_canvas_event_default_flags_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_event_default_flags_get, Evas_Event_Flags, 0);
+
+void _evas_canvas_output_method_set(Eo *obj, Evas_Public_Data *pd, int render_method);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_output_method_set, EO_FUNC_CALL(render_method), int render_method);
+
+int _evas_canvas_output_method_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_output_method_get, int, 0);
+
+void _evas_canvas_font_cache_set(Eo *obj, Evas_Public_Data *pd, int size);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_font_cache_set, EO_FUNC_CALL(size), int size);
+
+int _evas_canvas_font_cache_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_font_cache_get, int, 0);
+
+void _evas_canvas_output_size_set(Eo *obj, Evas_Public_Data *pd, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_output_size_set, EO_FUNC_CALL(w, h), int w, int h);
+
+void _evas_canvas_output_size_get(Eo *obj, Evas_Public_Data *pd, int *w, int *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_output_size_get, EO_FUNC_CALL(w, h), int *w, int *h);
+
+void _evas_canvas_data_attach_set(Eo *obj, Evas_Public_Data *pd, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_data_attach_set, EO_FUNC_CALL(data), void *data);
+
+void * _evas_canvas_data_attach_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_data_attach_get, void *, 0);
+
+void _evas_canvas_font_hinting_set(Eo *obj, Evas_Public_Data *pd, Evas_Font_Hinting_Flags hinting);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_font_hinting_set, EO_FUNC_CALL(hinting), Evas_Font_Hinting_Flags hinting);
+
+Evas_Font_Hinting_Flags _evas_canvas_font_hinting_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_font_hinting_get, Evas_Font_Hinting_Flags, 0);
+
+Eina_Bool _evas_canvas_engine_info_set(Eo *obj, Evas_Public_Data *pd, Evas_Engine_Info *info);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_engine_info_set, Eina_Bool, 0, EO_FUNC_CALL(info), Evas_Engine_Info *info);
+
+Evas_Engine_Info * _evas_canvas_engine_info_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_engine_info_get, Evas_Engine_Info *, 0);
+
+Evas_Object * _evas_canvas_focus_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_focus_get, Evas_Object *, 0);
+
+Evas_Object * _evas_canvas_object_top_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_object_top_get, Evas_Object *, 0);
+
+const Evas_Lock * _evas_canvas_key_lock_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_key_lock_get, const Evas_Lock *, 0);
+
+void _evas_canvas_pointer_canvas_xy_get(Eo *obj, Evas_Public_Data *pd, Evas_Coord *x, Evas_Coord *y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_pointer_canvas_xy_get, EO_FUNC_CALL(x, y), Evas_Coord *x, Evas_Coord *y);
+
+int _evas_canvas_event_down_count_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_event_down_count_get, int, 0);
+
+int _evas_canvas_smart_objects_calculate_count_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_smart_objects_calculate_count_get, int, 0);
+
+Eina_Bool _evas_canvas_focus_state_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_focus_state_get, Eina_Bool, 0);
+
+Eina_Bool _evas_canvas_changed_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_changed_get, Eina_Bool, 0);
+
+void _evas_canvas_pointer_output_xy_get(Eo *obj, Evas_Public_Data *pd, int *x, int *y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_pointer_output_xy_get, EO_FUNC_CALL(x, y), int *x, int *y);
+
+Eina_Bool _evas_canvas_pointer_inside_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_pointer_inside_get, Eina_Bool, 0);
+
+Eina_Bool _evas_canvas_image_max_size_get(Eo *obj, Evas_Public_Data *pd, int *maxw, int *maxh);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_image_max_size_get, Eina_Bool, 0, EO_FUNC_CALL(maxw, maxh), int *maxw, int *maxh);
+
+Evas_Object * _evas_canvas_object_bottom_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_object_bottom_get, Evas_Object *, 0);
+
+const Evas_Modifier * _evas_canvas_key_modifier_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_key_modifier_get, const Evas_Modifier *, 0);
+
+int _evas_canvas_pointer_button_down_mask_get(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_pointer_button_down_mask_get, int, 0);
+
+Eina_List * _evas_canvas_tree_objects_at_xy_get(Eo *obj, Evas_Public_Data *pd, Evas_Object *stop, int x, int y);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_tree_objects_at_xy_get, Eina_List *, 0, EO_FUNC_CALL(stop, x, y), Evas_Object *stop, int x, int y);
+
+void _evas_canvas_event_feed_mouse_wheel(Eo *obj, Evas_Public_Data *pd, int direction, int z, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_mouse_wheel, EO_FUNC_CALL(direction, z, timestamp, data), int direction, int z, unsigned int timestamp, const void *data);
+
+void _evas_canvas_key_lock_on(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_lock_on, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_event_feed_key_down(Eo *obj, Evas_Public_Data *pd, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_key_down, EO_FUNC_CALL(keyname, key, string, compose, timestamp, data), const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+Evas_Modifier_Mask _evas_canvas_key_modifier_mask_get(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_key_modifier_mask_get, Evas_Modifier_Mask, 0, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_key_modifier_add(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_modifier_add, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_key_modifier_off(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_modifier_off, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_event_feed_hold(Eo *obj, Evas_Public_Data *pd, int hold, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_hold, EO_FUNC_CALL(hold, timestamp, data), int hold, unsigned int timestamp, const void *data);
+
+void _evas_canvas_event_feed_mouse_move(Eo *obj, Evas_Public_Data *pd, int x, int y, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_mouse_move, EO_FUNC_CALL(x, y, timestamp, data), int x, int y, unsigned int timestamp, const void *data);
+
+void _evas_canvas_event_feed_key_up(Eo *obj, Evas_Public_Data *pd, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_key_up, EO_FUNC_CALL(keyname, key, string, compose, timestamp, data), const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+void _evas_canvas_event_feed_mouse_out(Eo *obj, Evas_Public_Data *pd, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_mouse_out, EO_FUNC_CALL(timestamp, data), unsigned int timestamp, const void *data);
+
+void _evas_canvas_event_input_multi_move(Eo *obj, Evas_Public_Data *pd, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_input_multi_move, EO_FUNC_CALL(d, x, y, rad, radx, rady, pres, ang, fx, fy, timestamp, data), int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+Eina_List * _evas_canvas_objects_at_xy_get(Eo *obj, Evas_Public_Data *pd, Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_objects_at_xy_get, Eina_List *, 0, EO_FUNC_CALL(x, y, include_pass_events_objects, include_hidden_objects), Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+void _evas_canvas_event_input_multi_up(Eo *obj, Evas_Public_Data *pd, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_input_multi_up, EO_FUNC_CALL(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data), int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+void _evas_canvas_event_feed_multi_down(Eo *obj, Evas_Public_Data *pd, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_multi_down, EO_FUNC_CALL(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data), int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+Eina_Bool _evas_canvas_render_async(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_render_async, Eina_Bool, 0);
+
+void _evas_canvas_focus_out(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_focus_out);
+
+void _evas_canvas_event_input_mouse_move(Eo *obj, Evas_Public_Data *pd, int x, int y, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_input_mouse_move, EO_FUNC_CALL(x, y, timestamp, data), int x, int y, unsigned int timestamp, const void *data);
+
+void _evas_canvas_norender(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_norender);
+
+unsigned int _evas_canvas_touch_point_list_count(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_touch_point_list_count, unsigned int, 0);
+
+void _evas_canvas_event_input_multi_down(Eo *obj, Evas_Public_Data *pd, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_input_multi_down, EO_FUNC_CALL(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data), int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+void _evas_canvas_nochange_pop(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_nochange_pop);
+
+void _evas_canvas_key_lock_off(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_lock_off, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_nochange_push(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_nochange_push);
+
+void _evas_canvas_font_cache_flush(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_font_cache_flush);
+
+Eina_Bool _evas_canvas_font_hinting_can_hint(Eo *obj, Evas_Public_Data *pd, Evas_Font_Hinting_Flags hinting);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_font_hinting_can_hint, Eina_Bool, 0, EO_FUNC_CALL(hinting), Evas_Font_Hinting_Flags hinting);
+
+Evas_Object * _evas_canvas_object_top_at_xy_get(Eo *obj, Evas_Public_Data *pd, Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_object_top_at_xy_get, Evas_Object *, 0, EO_FUNC_CALL(x, y, include_pass_events_objects, include_hidden_objects), Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+void _evas_canvas_key_modifier_on(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_modifier_on, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_event_feed_mouse_up(Eo *obj, Evas_Public_Data *pd, int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_mouse_up, EO_FUNC_CALL(b, flags, timestamp, data), int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+void _evas_canvas_event_feed_mouse_down(Eo *obj, Evas_Public_Data *pd, int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_mouse_down, EO_FUNC_CALL(b, flags, timestamp, data), int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+void _evas_canvas_event_refeed_event(Eo *obj, Evas_Public_Data *pd, void *event_copy, Evas_Callback_Type event_type);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_refeed_event, EO_FUNC_CALL(event_copy, event_type), void *event_copy, Evas_Callback_Type event_type);
+
+Eina_List * _evas_canvas_font_available_list(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_font_available_list, Eina_List *, 0);
+
+Eina_List * _evas_canvas_objects_in_rectangle_get(Eo *obj, Evas_Public_Data *pd, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_objects_in_rectangle_get, Eina_List *, 0, EO_FUNC_CALL(x, y, w, h, include_pass_events_objects, include_hidden_objects), Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+Evas_Object * _evas_canvas_object_name_find(Eo *obj, Evas_Public_Data *pd, const char *name);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_object_name_find, Evas_Object *, 0, EO_FUNC_CALL(name), const char *name);
+
+void _evas_canvas_font_path_append(Eo *obj, Evas_Public_Data *pd, const char *path);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_font_path_append, EO_FUNC_CALL(path), const char *path);
+
+int _evas_canvas_touch_point_list_nth_id_get(Eo *obj, Evas_Public_Data *pd, unsigned int n);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_touch_point_list_nth_id_get, int, 0, EO_FUNC_CALL(n), unsigned int n);
+
+void _evas_canvas_font_path_clear(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_font_path_clear);
+
+void _evas_canvas_smart_objects_calculate(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_smart_objects_calculate);
+
+void _evas_canvas_touch_point_list_nth_xy_get(Eo *obj, Evas_Public_Data *pd, unsigned int n, Evas_Coord *x, Evas_Coord *y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_touch_point_list_nth_xy_get, EO_FUNC_CALL(n, x, y), unsigned int n, Evas_Coord *x, Evas_Coord *y);
+
+void _evas_canvas_key_lock_del(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_lock_del, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_damage_rectangle_add(Eo *obj, Evas_Public_Data *pd, int x, int y, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_damage_rectangle_add, EO_FUNC_CALL(x, y, w, h), int x, int y, int w, int h);
+
+void _evas_canvas_sync(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_sync);
+
+const Eina_List * _evas_canvas_font_path_list(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_font_path_list, const Eina_List *, 0);
+
+void _evas_canvas_image_cache_reload(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_image_cache_reload);
+
+int _evas_canvas_coord_world_x_to_screen(Eo *obj, Evas_Public_Data *pd, Evas_Coord x);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_coord_world_x_to_screen, int, 0, EO_FUNC_CALL(x), Evas_Coord x);
+
+void _evas_canvas_event_feed_multi_move(Eo *obj, Evas_Public_Data *pd, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_multi_move, EO_FUNC_CALL(d, x, y, rad, radx, rady, pres, ang, fx, fy, timestamp, data), int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+Eina_List * _evas_canvas_render_updates(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_canvas_render_updates, Eina_List *, 0);
+
+void _evas_canvas_image_cache_flush(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_image_cache_flush);
+
+Evas_Coord _evas_canvas_coord_screen_y_to_world(Eo *obj, Evas_Public_Data *pd, int y);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_coord_screen_y_to_world, Evas_Coord, 0, EO_FUNC_CALL(y), int y);
+
+void _evas_canvas_key_modifier_del(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_modifier_del, EO_FUNC_CALL(keyname), const char *keyname);
+
+Evas_Touch_Point_State _evas_canvas_touch_point_list_nth_state_get(Eo *obj, Evas_Public_Data *pd, unsigned int n);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_touch_point_list_nth_state_get, Evas_Touch_Point_State, 0, EO_FUNC_CALL(n), unsigned int n);
+
+void _evas_canvas_focus_in(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_focus_in);
+
+void _evas_canvas_obscured_rectangle_add(Eo *obj, Evas_Public_Data *pd, int x, int y, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_obscured_rectangle_add, EO_FUNC_CALL(x, y, w, h), int x, int y, int w, int h);
+
+void _evas_canvas_render_dump(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_render_dump);
+
+void _evas_canvas_event_feed_mouse_in(Eo *obj, Evas_Public_Data *pd, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_mouse_in, EO_FUNC_CALL(timestamp, data), unsigned int timestamp, const void *data);
+
+Evas_Object * _evas_canvas_object_top_in_rectangle_get(Eo *obj, Evas_Public_Data *pd, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_object_top_in_rectangle_get, Evas_Object *, 0, EO_FUNC_CALL(x, y, w, h, include_pass_events_objects, include_hidden_objects), Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+void _evas_canvas_render(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_render);
+
+void _evas_canvas_event_feed_multi_up(Eo *obj, Evas_Public_Data *pd, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_multi_up, EO_FUNC_CALL(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data), int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+void _evas_canvas_font_path_prepend(Eo *obj, Evas_Public_Data *pd, const char *path);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_font_path_prepend, EO_FUNC_CALL(path), const char *path);
+
+void _evas_canvas_obscured_clear(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_obscured_clear);
+
+void _evas_canvas_event_feed_mouse_cancel(Eo *obj, Evas_Public_Data *pd, unsigned int timestamp, const void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_mouse_cancel, EO_FUNC_CALL(timestamp, data), unsigned int timestamp, const void *data);
+
+Evas_Coord _evas_canvas_coord_screen_x_to_world(Eo *obj, Evas_Public_Data *pd, int x);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_coord_screen_x_to_world, Evas_Coord, 0, EO_FUNC_CALL(x), int x);
+
+void _evas_canvas_key_lock_add(Eo *obj, Evas_Public_Data *pd, const char *keyname);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_key_lock_add, EO_FUNC_CALL(keyname), const char *keyname);
+
+void _evas_canvas_render_idle_flush(Eo *obj, Evas_Public_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_canvas_render_idle_flush);
+
+int _evas_canvas_coord_world_y_to_screen(Eo *obj, Evas_Public_Data *pd, Evas_Coord y);
+
+EOAPI EO_FUNC_BODYV(evas_canvas_coord_world_y_to_screen, int, 0, EO_FUNC_CALL(y), Evas_Coord y);
+
+void _evas_canvas_event_feed_key_down_with_keycode(Eo *obj, Evas_Public_Data *pd, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_key_down_with_keycode, EO_FUNC_CALL(keyname, key, string, compose, timestamp, data, keycode), const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+void _evas_canvas_event_feed_key_up_with_keycode(Eo *obj, Evas_Public_Data *pd, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_canvas_event_feed_key_up_with_keycode, EO_FUNC_CALL(keyname, key, string, compose, timestamp, data, keycode), const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+void _evas_canvas_eo_base_constructor(Eo *obj, Evas_Public_Data *pd);
+
+
+void _evas_canvas_eo_base_destructor(Eo *obj, Evas_Public_Data *pd);
+
+
+void _evas_canvas_eo_base_event_thaw(Eo *obj, Evas_Public_Data *pd);
+
+
+void _evas_canvas_eo_base_event_freeze(Eo *obj, Evas_Public_Data *pd);
+
+
+Evas * _evas_canvas_evas_common_interface_evas_get(Eo *obj, Evas_Public_Data *pd);
+
+
+static Eo_Op_Description _evas_canvas_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_canvas_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_canvas_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_event_thaw, _evas_canvas_eo_base_event_thaw),
+     EO_OP_FUNC_OVERRIDE(eo_event_freeze, _evas_canvas_eo_base_event_freeze),
+     EO_OP_FUNC_OVERRIDE(evas_common_evas_get, _evas_canvas_evas_common_interface_evas_get),
+     EO_OP_FUNC(evas_canvas_output_framespace_set, _evas_canvas_output_framespace_set, "Sets the output framespace size of the render engine of the given evas."),
+     EO_OP_FUNC(evas_canvas_output_framespace_get, _evas_canvas_output_framespace_get, "Get the render engine's output framespace co-ordinates in canvas units."),
+     EO_OP_FUNC(evas_canvas_output_viewport_set, _evas_canvas_output_viewport_set, "Sets the output viewport of the given evas in evas units."),
+     EO_OP_FUNC(evas_canvas_output_viewport_get, _evas_canvas_output_viewport_get, "Get the render engine's output viewport co-ordinates in canvas units."),
+     EO_OP_FUNC(evas_canvas_image_cache_set, _evas_canvas_image_cache_set, "Set the image cache."),
+     EO_OP_FUNC(evas_canvas_image_cache_get, _evas_canvas_image_cache_get, "Get the image cache"),
+     EO_OP_FUNC(evas_canvas_event_default_flags_set, _evas_canvas_event_default_flags_set, "Set the default set of flags an event begins with"),
+     EO_OP_FUNC(evas_canvas_event_default_flags_get, _evas_canvas_event_default_flags_get, "Get the default set of flags an event begins with"),
+     EO_OP_FUNC(evas_canvas_output_method_set, _evas_canvas_output_method_set, "Sets the output engine for the given evas."),
+     EO_OP_FUNC(evas_canvas_output_method_get, _evas_canvas_output_method_get, "Retrieves the number of the output engine used for the given evas."),
+     EO_OP_FUNC(evas_canvas_font_cache_set, _evas_canvas_font_cache_set, "Changes the size of font cache of the given evas."),
+     EO_OP_FUNC(evas_canvas_font_cache_get, _evas_canvas_font_cache_get, "Changes the size of font cache of the given evas."),
+     EO_OP_FUNC(evas_canvas_output_size_set, _evas_canvas_output_size_set, "Sets the output size of the render engine of the given evas."),
+     EO_OP_FUNC(evas_canvas_output_size_get, _evas_canvas_output_size_get, "Retrieve the output size of the render engine of the given evas."),
+     EO_OP_FUNC(evas_canvas_data_attach_set, _evas_canvas_data_attach_set, "Attaches a specific pointer to the evas for fetching later"),
+     EO_OP_FUNC(evas_canvas_data_attach_get, _evas_canvas_data_attach_get, "Returns the pointer attached by evas_data_attach_set()"),
+     EO_OP_FUNC(evas_canvas_font_hinting_set, _evas_canvas_font_hinting_set, "Changes the font hinting for the given evas."),
+     EO_OP_FUNC(evas_canvas_font_hinting_get, _evas_canvas_font_hinting_get, "Retrieves the font hinting used by the given evas."),
+     EO_OP_FUNC(evas_canvas_engine_info_set, _evas_canvas_engine_info_set, "Applies the engine settings for the given evas from the given @c"),
+     EO_OP_FUNC(evas_canvas_engine_info_get, _evas_canvas_engine_info_get, "Retrieves the current render engine info struct from the given evas."),
+     EO_OP_FUNC(evas_canvas_focus_get, _evas_canvas_focus_get, "Retrieve the object that currently has focus."),
+     EO_OP_FUNC(evas_canvas_object_top_get, _evas_canvas_object_top_get, "Get the highest (stacked) Evas object on the canvas @p e."),
+     EO_OP_FUNC(evas_canvas_key_lock_get, _evas_canvas_key_lock_get, "Returns a handle to the list of lock keys registered in the canvas"),
+     EO_OP_FUNC(evas_canvas_pointer_canvas_xy_get, _evas_canvas_pointer_canvas_xy_get, "This function returns the current known pointer co-ordinates"),
+     EO_OP_FUNC(evas_canvas_event_down_count_get, _evas_canvas_event_down_count_get, "Get the number of mouse or multi presses currently active"),
+     EO_OP_FUNC(evas_canvas_smart_objects_calculate_count_get, _evas_canvas_smart_objects_calculate_count_get, "This gets the internal counter that counts the number of smart calculations"),
+     EO_OP_FUNC(evas_canvas_focus_state_get, _evas_canvas_focus_state_get, "Get the focus state known by the given evas"),
+     EO_OP_FUNC(evas_canvas_changed_get, _evas_canvas_changed_get, "Get the changed marker for the canvas"),
+     EO_OP_FUNC(evas_canvas_pointer_output_xy_get, _evas_canvas_pointer_output_xy_get, "This function returns the current known pointer co-ordinates"),
+     EO_OP_FUNC(evas_canvas_pointer_inside_get, _evas_canvas_pointer_inside_get, "Returns whether the mouse pointer is logically inside the canvas"),
+     EO_OP_FUNC(evas_canvas_image_max_size_get, _evas_canvas_image_max_size_get, "Get the maximum image size evas can possibly handle"),
+     EO_OP_FUNC(evas_canvas_object_bottom_get, _evas_canvas_object_bottom_get, "Get the lowest (stacked) Evas object on the canvas @p e."),
+     EO_OP_FUNC(evas_canvas_key_modifier_get, _evas_canvas_key_modifier_get, "Returns a handle to the list of modifier keys registered in the"),
+     EO_OP_FUNC(evas_canvas_pointer_button_down_mask_get, _evas_canvas_pointer_button_down_mask_get, "Returns a bitmask with the mouse buttons currently pressed, set to 1"),
+     EO_OP_FUNC(evas_canvas_tree_objects_at_xy_get, _evas_canvas_tree_objects_at_xy_get, "Retrieve a list of Evas objects lying over a given position in"),
+     EO_OP_FUNC(evas_canvas_event_feed_mouse_wheel, _evas_canvas_event_feed_mouse_wheel, "Mouse wheel event feed."),
+     EO_OP_FUNC(evas_canvas_key_lock_on, _evas_canvas_key_lock_on, "Enables or turns on programmatically the lock key with name @p"),
+     EO_OP_FUNC(evas_canvas_event_feed_key_down, _evas_canvas_event_feed_key_down, "Key down event feed"),
+     EO_OP_FUNC(evas_canvas_key_modifier_mask_get, _evas_canvas_key_modifier_mask_get, "Creates a bit mask from the @p keyname @b modifier key. Values"),
+     EO_OP_FUNC(evas_canvas_key_modifier_add, _evas_canvas_key_modifier_add, "Adds the @p keyname key to the current list of modifier keys."),
+     EO_OP_FUNC(evas_canvas_key_modifier_off, _evas_canvas_key_modifier_off, "Disables or turns off programmatically the modifier key with name"),
+     EO_OP_FUNC(evas_canvas_event_feed_hold, _evas_canvas_event_feed_hold, "Hold event feed"),
+     EO_OP_FUNC(evas_canvas_event_feed_mouse_move, _evas_canvas_event_feed_mouse_move, "Mouse move event feed."),
+     EO_OP_FUNC(evas_canvas_event_feed_key_up, _evas_canvas_event_feed_key_up, "Key up event feed"),
+     EO_OP_FUNC(evas_canvas_event_feed_mouse_out, _evas_canvas_event_feed_mouse_out, "Mouse out event feed."),
+     EO_OP_FUNC(evas_canvas_event_input_multi_move, _evas_canvas_event_input_multi_move, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_canvas_objects_at_xy_get, _evas_canvas_objects_at_xy_get, "Retrieve a list of Evas objects lying over a given position in"),
+     EO_OP_FUNC(evas_canvas_event_input_multi_up, _evas_canvas_event_input_multi_up, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_canvas_event_feed_multi_down, _evas_canvas_event_feed_multi_down, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_canvas_render_async, _evas_canvas_render_async, "Render the given Evas canvas asynchronously."),
+     EO_OP_FUNC(evas_canvas_focus_out, _evas_canvas_focus_out, "Inform to the evas that it lost the focus."),
+     EO_OP_FUNC(evas_canvas_event_input_mouse_move, _evas_canvas_event_input_mouse_move, "Mouse move event feed from input."),
+     EO_OP_FUNC(evas_canvas_norender, _evas_canvas_norender, "Update the canvas internal objects but not triggering immediate"),
+     EO_OP_FUNC(evas_canvas_touch_point_list_count, _evas_canvas_touch_point_list_count, "Get the number of touched point in the evas."),
+     EO_OP_FUNC(evas_canvas_event_input_multi_down, _evas_canvas_event_input_multi_down, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_canvas_nochange_pop, _evas_canvas_nochange_pop, "Pop the nochange flag down 1"),
+     EO_OP_FUNC(evas_canvas_key_lock_off, _evas_canvas_key_lock_off, "Disables or turns off programmatically the lock key with name @p"),
+     EO_OP_FUNC(evas_canvas_nochange_push, _evas_canvas_nochange_push, "Push the nochange flag up 1"),
+     EO_OP_FUNC(evas_canvas_font_cache_flush, _evas_canvas_font_cache_flush, "Force the given evas and associated engine to flush its font cache."),
+     EO_OP_FUNC(evas_canvas_font_hinting_can_hint, _evas_canvas_font_hinting_can_hint, "Checks if the font hinting is supported by the given evas."),
+     EO_OP_FUNC(evas_canvas_object_top_at_xy_get, _evas_canvas_object_top_at_xy_get, "Retrieve the Evas object stacked at the top of a given position in"),
+     EO_OP_FUNC(evas_canvas_key_modifier_on, _evas_canvas_key_modifier_on, "Enables or turns on programmatically the modifier key with name @p"),
+     EO_OP_FUNC(evas_canvas_event_feed_mouse_up, _evas_canvas_event_feed_mouse_up, "Mouse up event feed."),
+     EO_OP_FUNC(evas_canvas_event_feed_mouse_down, _evas_canvas_event_feed_mouse_down, "Mouse down event feed."),
+     EO_OP_FUNC(evas_canvas_event_refeed_event, _evas_canvas_event_refeed_event, "Re feed event."),
+     EO_OP_FUNC(evas_canvas_font_available_list, _evas_canvas_font_available_list, "List of available font descriptions known or found by this evas."),
+     EO_OP_FUNC(evas_canvas_objects_in_rectangle_get, _evas_canvas_objects_in_rectangle_get, ""),
+     EO_OP_FUNC(evas_canvas_object_name_find, _evas_canvas_object_name_find, "Retrieves the object on the given evas with the given name."),
+     EO_OP_FUNC(evas_canvas_font_path_append, _evas_canvas_font_path_append, "Appends a font path to the list of font paths used by the given evas."),
+     EO_OP_FUNC(evas_canvas_touch_point_list_nth_id_get, _evas_canvas_touch_point_list_nth_id_get, "This function returns the @p id of nth touch point."),
+     EO_OP_FUNC(evas_canvas_font_path_clear, _evas_canvas_font_path_clear, "Removes all font paths loaded into memory for the given evas."),
+     EO_OP_FUNC(evas_canvas_smart_objects_calculate, _evas_canvas_smart_objects_calculate, "Call user-provided @c calculate() smart functions and unset the"),
+     EO_OP_FUNC(evas_canvas_touch_point_list_nth_xy_get, _evas_canvas_touch_point_list_nth_xy_get, "This function returns the nth touch point's co-ordinates."),
+     EO_OP_FUNC(evas_canvas_key_lock_del, _evas_canvas_key_lock_del, "Removes the @p keyname key from the current list of lock keys on"),
+     EO_OP_FUNC(evas_canvas_damage_rectangle_add, _evas_canvas_damage_rectangle_add, "Add a damage rectangle."),
+     EO_OP_FUNC(evas_canvas_sync, _evas_canvas_sync, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_canvas_font_path_list, _evas_canvas_font_path_list, "Retrieves the list of font paths used by the given evas."),
+     EO_OP_FUNC(evas_canvas_image_cache_reload, _evas_canvas_image_cache_reload, "Reload the image cache"),
+     EO_OP_FUNC(evas_canvas_coord_world_x_to_screen, _evas_canvas_coord_world_x_to_screen, "Convert/scale a canvas co-ordinate into output screen co-ordinates"),
+     EO_OP_FUNC(evas_canvas_event_feed_multi_move, _evas_canvas_event_feed_multi_move, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_canvas_render_updates, _evas_canvas_render_updates, "Force immediate renderization of the given Evas canvas."),
+     EO_OP_FUNC(evas_canvas_image_cache_flush, _evas_canvas_image_cache_flush, "Flush the image cache of the canvas."),
+     EO_OP_FUNC(evas_canvas_coord_screen_y_to_world, _evas_canvas_coord_screen_y_to_world, "Convert/scale an output screen co-ordinate into canvas co-ordinates"),
+     EO_OP_FUNC(evas_canvas_key_modifier_del, _evas_canvas_key_modifier_del, "Removes the @p keyname key from the current list of modifier keys"),
+     EO_OP_FUNC(evas_canvas_touch_point_list_nth_state_get, _evas_canvas_touch_point_list_nth_state_get, "This function returns the @p state of nth touch point."),
+     EO_OP_FUNC(evas_canvas_focus_in, _evas_canvas_focus_in, "Inform to the evas that it got the focus."),
+     EO_OP_FUNC(evas_canvas_obscured_rectangle_add, _evas_canvas_obscured_rectangle_add, "Add an \"obscured region\" to an Evas canvas."),
+     EO_OP_FUNC(evas_canvas_render_dump, _evas_canvas_render_dump, "Make the canvas discard as much data as possible used by the engine at"),
+     EO_OP_FUNC(evas_canvas_event_feed_mouse_in, _evas_canvas_event_feed_mouse_in, "Mouse in event feed."),
+     EO_OP_FUNC(evas_canvas_object_top_in_rectangle_get, _evas_canvas_object_top_in_rectangle_get, "Retrieve the Evas object stacked at the top of a given rectangular"),
+     EO_OP_FUNC(evas_canvas_render, _evas_canvas_render, "Force renderization of the given canvas."),
+     EO_OP_FUNC(evas_canvas_event_feed_multi_up, _evas_canvas_event_feed_multi_up, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_canvas_font_path_prepend, _evas_canvas_font_path_prepend, "Prepends a font path to the list of font paths used by the given evas."),
+     EO_OP_FUNC(evas_canvas_obscured_clear, _evas_canvas_obscured_clear, "Remove all \"obscured regions\" from an Evas canvas."),
+     EO_OP_FUNC(evas_canvas_event_feed_mouse_cancel, _evas_canvas_event_feed_mouse_cancel, "Mouse cancel event feed."),
+     EO_OP_FUNC(evas_canvas_coord_screen_x_to_world, _evas_canvas_coord_screen_x_to_world, "Convert/scale an output screen co-ordinate into canvas co-ordinates"),
+     EO_OP_FUNC(evas_canvas_key_lock_add, _evas_canvas_key_lock_add, "Adds the @p keyname key to the current list of lock keys."),
+     EO_OP_FUNC(evas_canvas_render_idle_flush, _evas_canvas_render_idle_flush, "Make the canvas discard internally cached data used for rendering."),
+     EO_OP_FUNC(evas_canvas_coord_world_y_to_screen, _evas_canvas_coord_world_y_to_screen, "Convert/scale a canvas co-ordinate into output screen co-ordinates"),
+     EO_OP_FUNC(evas_canvas_event_feed_key_down_with_keycode, _evas_canvas_event_feed_key_down_with_keycode, "Key down event feed with keycode"),
+     EO_OP_FUNC(evas_canvas_event_feed_key_up_with_keycode, _evas_canvas_event_feed_key_up_with_keycode, "Key up event feed with keycode"),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_canvas_class_desc = {
+     EO_VERSION,
+     "Evas_Canvas",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_canvas_op_desc),
+     NULL,
+     sizeof(Evas_Public_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_canvas_class_get, &_evas_canvas_class_desc, EO_BASE_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
+EAPI void
+evas_output_framespace_set(Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_output_framespace_set(x, y, w, h));
+}
+
+EAPI void
+evas_output_framespace_get(const Evas_Canvas *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_output_framespace_get(x, y, w, h));
+}
+
+EAPI void
+evas_output_viewport_set(Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_output_viewport_set(x, y, w, h));
+}
+
+EAPI void
+evas_output_viewport_get(const Evas_Canvas *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_output_viewport_get(x, y, w, h));
+}
+
+EAPI void
+evas_image_cache_set(Evas_Canvas *obj, int size)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_image_cache_set(size));
+}
+
+EAPI int
+evas_image_cache_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_image_cache_get());
+}
+
+EAPI void
+evas_event_default_flags_set(Evas_Canvas *obj, Evas_Event_Flags flags)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_default_flags_set(flags));
+}
+
+EAPI Evas_Event_Flags
+evas_event_default_flags_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_event_default_flags_get());
+}
+
+EAPI void
+evas_output_method_set(Evas_Canvas *obj, int render_method)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_output_method_set(render_method));
+}
+
+EAPI int
+evas_output_method_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_output_method_get());
+}
+
+EAPI void
+evas_font_cache_set(Evas_Canvas *obj, int size)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_font_cache_set(size));
+}
+
+EAPI int
+evas_font_cache_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_font_cache_get());
+}
+
+EAPI void
+evas_output_size_set(Evas_Canvas *obj, int w, int h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_output_size_set(w, h));
+}
+
+EAPI void
+evas_output_size_get(const Evas_Canvas *obj, int *w, int *h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_output_size_get(w, h));
+}
+
+EAPI void
+evas_data_attach_set(Evas_Canvas *obj, void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_data_attach_set(data));
+}
+
+EAPI void *
+evas_data_attach_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_data_attach_get());
+}
+
+EAPI void
+evas_font_hinting_set(Evas_Canvas *obj, Evas_Font_Hinting_Flags hinting)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_font_hinting_set(hinting));
+}
+
+EAPI Evas_Font_Hinting_Flags
+evas_font_hinting_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_font_hinting_get());
+}
+
+EAPI Eina_Bool
+evas_engine_info_set(Evas_Canvas *obj, Evas_Engine_Info *info)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_engine_info_set(info));
+}
+
+EAPI Evas_Engine_Info *
+evas_engine_info_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_engine_info_get());
+}
+
+EAPI Evas_Object *
+evas_focus_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_focus_get());
+}
+
+EAPI Evas_Object *
+evas_object_top_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_object_top_get());
+}
+
+EAPI const Evas_Lock *
+evas_key_lock_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_key_lock_get());
+}
+
+EAPI void
+evas_pointer_canvas_xy_get(const Evas_Canvas *obj, Evas_Coord *x, Evas_Coord *y)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_pointer_canvas_xy_get(x, y));
+}
+
+EAPI int
+evas_event_down_count_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_event_down_count_get());
+}
+
+EAPI int
+evas_smart_objects_calculate_count_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_smart_objects_calculate_count_get());
+}
+
+EAPI Eina_Bool
+evas_focus_state_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_focus_state_get());
+}
+
+EAPI Eina_Bool
+evas_changed_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_changed_get());
+}
+
+EAPI void
+evas_pointer_output_xy_get(const Evas_Canvas *obj, int *x, int *y)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_pointer_output_xy_get(x, y));
+}
+
+EAPI Eina_Bool
+evas_pointer_inside_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_pointer_inside_get());
+}
+
+EAPI Eina_Bool
+evas_image_max_size_get(const Evas_Canvas *obj, int *maxw, int *maxh)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_image_max_size_get(maxw, maxh));
+}
+
+EAPI Evas_Object *
+evas_object_bottom_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_object_bottom_get());
+}
+
+EAPI const Evas_Modifier *
+evas_key_modifier_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_key_modifier_get());
+}
+
+EAPI int
+evas_pointer_button_down_mask_get(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_pointer_button_down_mask_get());
+}
+
+EAPI Eina_List *
+evas_tree_objects_at_xy_get(Evas_Canvas *obj, Evas_Object *stop, int x, int y)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_tree_objects_at_xy_get(stop, x, y));
+}
+
+EAPI void
+evas_event_feed_mouse_wheel(Evas_Canvas *obj, int direction, int z, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_mouse_wheel(direction, z, timestamp, data));
+}
+
+EAPI void
+evas_key_lock_on(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_lock_on(keyname));
+}
+
+EAPI void
+evas_event_feed_key_down(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_key_down(keyname, key, string, compose, timestamp, data));
+}
+
+EAPI Evas_Modifier_Mask
+evas_key_modifier_mask_get(const Evas_Canvas *obj, const char *keyname)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_key_modifier_mask_get(keyname));
+}
+
+EAPI void
+evas_key_modifier_add(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_modifier_add(keyname));
+}
+
+EAPI void
+evas_key_modifier_off(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_modifier_off(keyname));
+}
+
+EAPI void
+evas_event_feed_hold(Evas_Canvas *obj, int hold, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_hold(hold, timestamp, data));
+}
+
+EAPI void
+evas_event_feed_mouse_move(Evas_Canvas *obj, int x, int y, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_mouse_move(x, y, timestamp, data));
+}
+
+EAPI void
+evas_event_feed_key_up(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_key_up(keyname, key, string, compose, timestamp, data));
+}
+
+EAPI void
+evas_event_feed_mouse_out(Evas_Canvas *obj, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_mouse_out(timestamp, data));
+}
+
+EAPI void
+evas_event_input_multi_move(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_input_multi_move(d, x, y, rad, radx, rady, pres, ang, fx, fy, timestamp, data));
+}
+
+EAPI Eina_List *
+evas_objects_at_xy_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_objects_at_xy_get(x, y, include_pass_events_objects, include_hidden_objects));
+}
+
+EAPI void
+evas_event_input_multi_up(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_input_multi_up(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data));
+}
+
+EAPI void
+evas_event_feed_multi_down(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_multi_down(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data));
+}
+
+EAPI Eina_Bool
+evas_render_async(Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_render_async());
+}
+
+EAPI void
+evas_focus_out(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_focus_out());
+}
+
+EAPI void
+evas_event_input_mouse_move(Evas_Canvas *obj, int x, int y, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_input_mouse_move(x, y, timestamp, data));
+}
+
+EAPI void
+evas_norender(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_norender());
+}
+
+EAPI unsigned int
+evas_touch_point_list_count(Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_touch_point_list_count());
+}
+
+EAPI void
+evas_event_input_multi_down(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_input_multi_down(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data));
+}
+
+EAPI void
+evas_nochange_pop(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_nochange_pop());
+}
+
+EAPI void
+evas_key_lock_off(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_lock_off(keyname));
+}
+
+EAPI void
+evas_nochange_push(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_nochange_push());
+}
+
+EAPI void
+evas_font_cache_flush(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_font_cache_flush());
+}
+
+EAPI Eina_Bool
+evas_font_hinting_can_hint(const Evas_Canvas *obj, Evas_Font_Hinting_Flags hinting)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_font_hinting_can_hint(hinting));
+}
+
+EAPI Evas_Object *
+evas_object_top_at_xy_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_object_top_at_xy_get(x, y, include_pass_events_objects, include_hidden_objects));
+}
+
+EAPI void
+evas_key_modifier_on(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_modifier_on(keyname));
+}
+
+EAPI void
+evas_event_feed_mouse_up(Evas_Canvas *obj, int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_mouse_up(b, flags, timestamp, data));
+}
+
+EAPI void
+evas_event_feed_mouse_down(Evas_Canvas *obj, int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_mouse_down(b, flags, timestamp, data));
+}
+
+EAPI void
+evas_event_refeed_event(Evas_Canvas *obj, void *event_copy, Evas_Callback_Type event_type)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_refeed_event(event_copy, event_type));
+}
+
+EAPI Eina_List *
+evas_font_available_list(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_font_available_list());
+}
+
+EAPI Eina_List *
+evas_objects_in_rectangle_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_objects_in_rectangle_get(x, y, w, h, include_pass_events_objects, include_hidden_objects));
+}
+
+EAPI Evas_Object *
+evas_object_name_find(const Evas_Canvas *obj, const char *name)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_object_name_find(name));
+}
+
+EAPI void
+evas_font_path_append(Evas_Canvas *obj, const char *path)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_font_path_append(path));
+}
+
+EAPI int
+evas_touch_point_list_nth_id_get(Evas_Canvas *obj, unsigned int n)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_touch_point_list_nth_id_get(n));
+}
+
+EAPI void
+evas_font_path_clear(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_font_path_clear());
+}
+
+EAPI void
+evas_smart_objects_calculate(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_smart_objects_calculate());
+}
+
+EAPI void
+evas_touch_point_list_nth_xy_get(Evas_Canvas *obj, unsigned int n, Evas_Coord *x, Evas_Coord *y)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_touch_point_list_nth_xy_get(n, x, y));
+}
+
+EAPI void
+evas_key_lock_del(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_lock_del(keyname));
+}
+
+EAPI void
+evas_damage_rectangle_add(Evas_Canvas *obj, int x, int y, int w, int h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_damage_rectangle_add(x, y, w, h));
+}
+
+EAPI void
+evas_sync(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_sync());
+}
+
+EAPI const Eina_List *
+evas_font_path_list(const Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_font_path_list());
+}
+
+EAPI void
+evas_image_cache_reload(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_image_cache_reload());
+}
+
+EAPI int
+evas_coord_world_x_to_screen(const Evas_Canvas *obj, Evas_Coord x)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_coord_world_x_to_screen(x));
+}
+
+EAPI void
+evas_event_feed_multi_move(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_multi_move(d, x, y, rad, radx, rady, pres, ang, fx, fy, timestamp, data));
+}
+
+EAPI Eina_List *
+evas_render_updates(Evas_Canvas *obj)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_render_updates());
+}
+
+EAPI void
+evas_image_cache_flush(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_image_cache_flush());
+}
+
+EAPI Evas_Coord
+evas_coord_screen_y_to_world(const Evas_Canvas *obj, int y)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_coord_screen_y_to_world(y));
+}
+
+EAPI void
+evas_key_modifier_del(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_modifier_del(keyname));
+}
+
+EAPI Evas_Touch_Point_State
+evas_touch_point_list_nth_state_get(Evas_Canvas *obj, unsigned int n)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_touch_point_list_nth_state_get(n));
+}
+
+EAPI void
+evas_focus_in(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_focus_in());
+}
+
+EAPI void
+evas_obscured_rectangle_add(Evas_Canvas *obj, int x, int y, int w, int h)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_obscured_rectangle_add(x, y, w, h));
+}
+
+EAPI void
+evas_render_dump(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_render_dump());
+}
+
+EAPI void
+evas_event_feed_mouse_in(Evas_Canvas *obj, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_mouse_in(timestamp, data));
+}
+
+EAPI Evas_Object *
+evas_object_top_in_rectangle_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_object_top_in_rectangle_get(x, y, w, h, include_pass_events_objects, include_hidden_objects));
+}
+
+EAPI void
+evas_render(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_render());
+}
+
+EAPI void
+evas_event_feed_multi_up(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_multi_up(d, x, y, rad, radx, rady, pres, ang, fx, fy, flags, timestamp, data));
+}
+
+EAPI void
+evas_font_path_prepend(Evas_Canvas *obj, const char *path)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_font_path_prepend(path));
+}
+
+EAPI void
+evas_obscured_clear(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_obscured_clear());
+}
+
+EAPI void
+evas_event_feed_mouse_cancel(Evas_Canvas *obj, unsigned int timestamp, const void *data)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_mouse_cancel(timestamp, data));
+}
+
+EAPI Evas_Coord
+evas_coord_screen_x_to_world(const Evas_Canvas *obj, int x)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_coord_screen_x_to_world(x));
+}
+
+EAPI void
+evas_key_lock_add(Evas_Canvas *obj, const char *keyname)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_key_lock_add(keyname));
+}
+
+EAPI void
+evas_render_idle_flush(Evas_Canvas *obj)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_render_idle_flush());
+}
+
+EAPI int
+evas_coord_world_y_to_screen(const Evas_Canvas *obj, Evas_Coord y)
+{
+   return eo_do((Evas_Canvas *)obj, evas_canvas_coord_world_y_to_screen(y));
+}
+
+EAPI void
+evas_event_feed_key_down_with_keycode(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_key_down_with_keycode(keyname, key, string, compose, timestamp, data, keycode));
+}
+
+EAPI void
+evas_event_feed_key_up_with_keycode(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode)
+{
+   eo_do((Evas_Canvas *)obj, evas_canvas_event_feed_key_up_with_keycode(keyname, key, string, compose, timestamp, data, keycode));
+}
diff -Naur a/src/lib/evas/canvas/evas_canvas.eo.h b/src/lib/evas/canvas/evas_canvas.eo.h
--- a/src/lib/evas/canvas/evas_canvas.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_canvas.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,2014 @@
+#ifndef _EVAS_CANVAS_EO_H_
+#define _EVAS_CANVAS_EO_H_
+
+#ifndef _EVAS_CANVAS_EO_CLASS_TYPE
+#define _EVAS_CANVAS_EO_CLASS_TYPE
+
+typedef Eo Evas_Canvas;
+
+#endif
+
+#ifndef _EVAS_CANVAS_EO_TYPES
+#define _EVAS_CANVAS_EO_TYPES
+
+
+#endif
+#define EVAS_CANVAS_CLASS evas_canvas_class_get()
+
+const Eo_Class *evas_canvas_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Sets the output framespace size of the render engine of the given evas.
+ *
+ * The framespace size is used in the Wayland engines to denote space where
+ * the output is not drawn. This is mainly used in ecore_evas to draw borders
+ *
+ * The units used for @p w and @p h depend on the engine used by the
+ * evas.
+ *
+ * @ingroup Evas_Output_Size
+ * @since 1.1
+ *
+ * @param[in] x The left coordinate in output units, usually pixels.
+ * @param[in] y The top coordinate in output units, usually pixels.
+ * @param[in] w The width in output units, usually pixels.
+ * @param[in] h The height in output units, usually pixels.
+ *
+ */
+EOAPI void  evas_canvas_output_framespace_set(Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Get the render engine's output framespace co-ordinates in canvas units.
+ *
+ * @ingroup Evas_Output_Size
+ * @since 1.1
+ *
+ * @param[out] x The left coordinate in output units, usually pixels.
+ * @param[out] y The top coordinate in output units, usually pixels.
+ * @param[out] w The width in output units, usually pixels.
+ * @param[out] h The height in output units, usually pixels.
+ *
+ */
+EOAPI void  evas_canvas_output_framespace_get(Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the output viewport of the given evas in evas units.
+ *
+ * The output viewport is the area of the evas that will be visible to
+ * the viewer.  The viewport will be stretched to fit the output
+ * target of the evas when rendering is performed.
+ *
+ * @note The coordinate values do not have to map 1-to-1 with the output
+ * target.  However, it is generally advised that it is done for ease
+ * of use.
+ *
+ * @ingroup Evas_Output_Size
+ *
+ * @param[in] x The top-left corner x value of the viewport.
+ * @param[in] y The top-left corner y value of the viewport.
+ * @param[in] w The width of the viewport.  Must be greater than 0.
+ * @param[in] h The height of the viewport.  Must be greater than 0.
+ *
+ */
+EOAPI void  evas_canvas_output_viewport_set(Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Get the render engine's output viewport co-ordinates in canvas units.
+ * Calling this function writes the current canvas output viewport
+ * size and location values into the variables pointed to by @p x, @p
+ * y, @p w and @p h.  On success the variables have the output
+ * location and size values written to them in canvas units. Any of @p
+ * x, @p y, @p w or @p h that are @c NULL will not be written to. If @p e
+ * is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Coord x, y, width, height;
+ *
+ * evas_output_viewport_get(evas, &x, &y, &w, &h);
+ * @endcode
+ *
+ * @param[out] x The top-left corner x value of the viewport.
+ * @param[out] y The top-left corner y value of the viewport.
+ * @param[out] w The width of the viewport.  Must be greater than 0.
+ * @param[out] h The height of the viewport.  Must be greater than 0.
+ *
+ */
+EOAPI void  evas_canvas_output_viewport_get(Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Set the image cache.
+ *
+ * This function sets the image cache of canvas in bytes.
+ *
+ * @param[in] size The cache size.
+ *
+ */
+EOAPI void  evas_canvas_image_cache_set(int size);
+
+/**
+ *
+ * Get the image cache
+ *
+ * This function returns the image cache size of canvas in bytes.
+ *
+ *
+ */
+EOAPI int  evas_canvas_image_cache_get(void);
+
+/**
+ *
+ * Set the default set of flags an event begins with
+ *
+ * Events in evas can have an event_flags member. This starts out with
+ * and initial value (no flags). This lets you set the default flags that
+ * an event begins with to be @p flags
+ *
+ * @since 1.2
+ *
+ * @param[in] flags The default flags to use
+ *
+ */
+EOAPI void  evas_canvas_event_default_flags_set(Evas_Event_Flags flags);
+
+/**
+ *
+ * Get the default set of flags an event begins with
+ *
+ * @return The default event flags for that canvas
+ *
+ * This gets the default event flags events are produced with when fed in.
+ *
+ * @see evas_event_default_flags_set()
+ * @since 1.2
+ *
+ *
+ */
+EOAPI Evas_Event_Flags  evas_canvas_event_default_flags_get(void);
+
+/**
+ *
+ * Sets the output engine for the given evas.
+ *
+ * Once the output engine for an evas is set, any attempt to change it
+ * will be ignored.  The value for @p render_method can be found using
+ * @ref evas_render_method_lookup .
+ *
+ * @attention it is mandatory that one calls evas_init() before
+ * setting the output method.
+ *
+ * @ingroup Evas_Output_Method
+ *
+ * @param[in] render_method The numeric engine value to use.
+ *
+ */
+EOAPI void  evas_canvas_output_method_set(int render_method);
+
+/**
+ *
+ * Retrieves the number of the output engine used for the given evas.
+ * @return  The ID number of the output engine being used.  @c 0 is
+ * returned if there is an error.
+ * @ingroup Evas_Output_Method
+ *
+ *
+ */
+EOAPI int  evas_canvas_output_method_get(void);
+
+/**
+ *
+ * Changes the size of font cache of the given evas.
+ *
+ * @ingroup Evas_Font_Group
+ *
+ * @param[in] size The size, in bytes.
+ *
+ */
+EOAPI void  evas_canvas_font_cache_set(int size);
+
+/**
+ *
+ * Changes the size of font cache of the given evas.
+ *
+ * @return The size, in bytes.
+ *
+ * @ingroup Evas_Font_Group
+ *
+ *
+ */
+EOAPI int  evas_canvas_font_cache_get(void);
+
+/**
+ *
+ * Sets the output size of the render engine of the given evas.
+ *
+ * The evas will render to a rectangle of the given size once this
+ * function is called.  The output size is independent of the viewport
+ * size.  The viewport will be stretched to fill the given rectangle.
+ *
+ * The units used for @p w and @p h depend on the engine used by the
+ * evas.
+ *
+ * @ingroup Evas_Output_Size
+ *
+ * @param[in] w The width in output units, usually pixels.
+ * @param[in] h The height in output units, usually pixels.
+ *
+ */
+EOAPI void  evas_canvas_output_size_set(int w, int h);
+
+/**
+ *
+ * Retrieve the output size of the render engine of the given evas.
+ *
+ * The output size is given in whatever the output units are for the
+ * engine.
+ *
+ * If either @p w or @p h is @c NULL, then it is ignored.  If @p e is
+ * invalid, the returned results are undefined.
+ *
+ * @ingroup Evas_Output_Size
+ *
+ * @param[out] w The width in output units, usually pixels.
+ * @param[out] h The height in output units, usually pixels.
+ *
+ */
+EOAPI void  evas_canvas_output_size_get(int *w, int *h);
+
+/**
+ *
+ * Attaches a specific pointer to the evas for fetching later
+ *
+ * @ingroup Evas_Canvas
+ *
+ * @param[in] data The pointer to attach
+ *
+ */
+EOAPI void  evas_canvas_data_attach_set(void *data);
+
+/**
+ *
+ * Returns the pointer attached by evas_data_attach_set()
+ *
+ * @return The pointer attached
+ * @ingroup Evas_Canvas
+ *
+ *
+ */
+EOAPI void * evas_canvas_data_attach_get(void);
+
+/**
+ *
+ * Changes the font hinting for the given evas.
+ *
+ * #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+ * @ingroup Evas_Font_Group
+ *
+ * @param[in] hinting The hinting to use, one of #EVAS_FONT_HINTING_NONE,
+ *
+ */
+EOAPI void  evas_canvas_font_hinting_set(Evas_Font_Hinting_Flags hinting);
+
+/**
+ *
+ * Retrieves the font hinting used by the given evas.
+ *
+ * @return The hinting in use, one of #EVAS_FONT_HINTING_NONE,
+ * #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+ * @ingroup Evas_Font_Group
+ *
+ *
+ */
+EOAPI Evas_Font_Hinting_Flags  evas_canvas_font_hinting_get(void);
+
+/**
+ *
+ * Applies the engine settings for the given evas from the given @c
+ * Evas_Engine_Info structure.
+ *
+ * To get the Evas_Engine_Info structure to use, call @ref
+ * evas_engine_info_get .  Do not try to obtain a pointer to an
+ * @c Evas_Engine_Info structure in any other way.
+ *
+ * You will need to call this function at least once before you can
+ * create objects on an evas or render that evas.  Some engines allow
+ * their settings to be changed more than once.
+ *
+ * Once called, the @p info pointer should be considered invalid.
+ *
+ * @return  @c EINA_TRUE if no error occurred, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Output_Method
+ *
+ * @param[in] info The pointer to the Engine Info to use
+ *
+ */
+EOAPI Eina_Bool  evas_canvas_engine_info_set(Evas_Engine_Info *info);
+
+/**
+ *
+ * Retrieves the current render engine info struct from the given evas.
+ *
+ * The returned structure is publicly modifiable.  The contents are
+ * valid until either @ref evas_engine_info_set or @ref evas_render
+ * are called.
+ *
+ * This structure does not need to be freed by the caller.
+ *
+ * @return  A pointer to the Engine Info structure.  @c NULL is returned if
+ * an engine has not yet been assigned.
+ * @ingroup Evas_Output_Method
+ *
+ *
+ */
+EOAPI Evas_Engine_Info * evas_canvas_engine_info_get(void);
+
+/**
+ *
+ * Retrieve the object that currently has focus.
+ *
+ * @return The object that has focus or @c NULL if there is not one.
+ *
+ * Evas can have (at most) one of its objects focused at a time.
+ * Focused objects will be the ones having <b>key events</b> delivered
+ * to, which the programmer can act upon by means of
+ * evas_object_event_callback_add() usage.
+ *
+ * @note Most users wouldn't be dealing directly with Evas' focused
+ * objects. Instead, they would be using a higher level library for
+ * that (like a toolkit, as Elementary) to handle focus and who's
+ * receiving input for them.
+ *
+ * This call returns the object that currently has focus on the canvas
+ * @p e or @c NULL, if none.
+ *
+ * @see evas_object_focus_set
+ * @see evas_object_focus_get
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip evas_event_callback_add(d.canvas, EVAS_CALLBACK_CANVAS_OBJECT_FOCUS_IN,
+ * @until evas_object_focus_set(d.bg, EINA_TRUE);
+ * @dontinclude evas-events.c
+ * @skip called when our rectangle gets focus
+ * @until }
+ *
+ * In this example the @c event_info is exactly a pointer to that
+ * focused rectangle. See the full @ref Example_Evas_Events "example".
+ *
+ * @ingroup Evas_Object_Group_Find
+ *
+ *
+ */
+EOAPI Evas_Object * evas_canvas_focus_get(void);
+
+/**
+ *
+ * Get the highest (stacked) Evas object on the canvas @p e.
+ *
+ * @return a pointer to the highest object on it, if any, or @c NULL,
+ * otherwise
+ *
+ * This function will take all populated layers in the canvas into
+ * account, getting the highest object for the highest layer,
+ * naturally.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ * @see evas_object_above_get()
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ *
+ *
+ */
+EOAPI Evas_Object * evas_canvas_object_top_get(void);
+
+/**
+ *
+ * Returns a handle to the list of lock keys registered in the canvas
+ * @p e. This is required to check for which locks are set at a given
+ * time with the evas_key_lock_is_set() function.
+ *
+ * @see evas_key_lock_add
+ * @see evas_key_lock_del
+ * @see evas_key_lock_on
+ * @see evas_key_lock_off
+ * @see evas_key_lock_is_set
+ *
+ * @return An .Evas_Lock handle to query Evas' keys subsystem with
+ * evas_key_lock_is_set(), or @c NULL on error.
+ *
+ *
+ */
+EOAPI const Evas_Lock * evas_canvas_key_lock_get(void);
+
+/**
+ *
+ * This function returns the current known pointer co-ordinates
+ *
+ * This function returns the current known canvas unit co-ordinates of
+ * the mouse pointer and sets the contents of the Evas_Coords pointed
+ * to by @p x and @p y to contain these co-ordinates. If @p e is not a
+ * valid canvas the results of this function are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Coord mouse_x, mouse_y;
+ *
+ * evas_pointer_output_xy_get(evas, &mouse_x, &mouse_y);
+ * printf("Mouse is at canvas position %d, %d\n", mouse_x, mouse_y);
+ * @endcode
+ *
+ * @param[out] x The pointer to a Evas_Coord to be filled in
+ * @param[out] y The pointer to a Evas_Coord to be filled in
+@ingroup Evas_Pointer_Group
+ *
+ */
+EOAPI void  evas_canvas_pointer_canvas_xy_get(Evas_Coord *x, Evas_Coord *y);
+
+/**
+ *
+ * Get the number of mouse or multi presses currently active
+ *
+ * @p e The given canvas pointer.
+ * @return The number of presses (0 if none active).
+ *
+ * @since 1.2
+ *
+ *
+ */
+EOAPI int  evas_canvas_event_down_count_get(void);
+
+/**
+ *
+ * This gets the internal counter that counts the number of smart calculations
+ *
+ * Whenever evas performs smart object calculations on the whole canvas
+ * it increments a counter by 1. This is the smart object calculate counter
+ * that this function returns the value of. It starts at the value of 0 and
+ * will increase (and eventually wrap around to negative values and so on) by
+ * 1 every time objects are calculated. You can use this counter to ensure
+ * you don't re-do calculations withint the same calculation generation/run
+ * if the calculations maybe cause self-feeding effects.
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * @since 1.1
+ *
+ *
+ */
+EOAPI int  evas_canvas_smart_objects_calculate_count_get(void);
+
+/**
+ *
+ * Get the focus state known by the given evas
+ *
+ * @return @c EINA_TRUE if it got the focus, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Canvas
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_canvas_focus_state_get(void);
+
+/**
+ *
+ * Get the changed marker for the canvas
+ *
+ * @return @c EINA_TRUE if something has been marked as changed, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Canvas
+ * @since 1.11
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_canvas_changed_get(void);
+
+/**
+ *
+ * This function returns the current known pointer co-ordinates
+ *
+ * This function returns the current known screen/output co-ordinates
+ * of the mouse pointer and sets the contents of the integers pointed
+ * to by @p x and @p y to contain these co-ordinates. If @p e is not a
+ * valid canvas the results of this function are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int mouse_x, mouse_y;
+ *
+ * evas_pointer_output_xy_get(evas, &mouse_x, &mouse_y);
+ * printf("Mouse is at screen position %i, %i\n", mouse_x, mouse_y);
+ * @endcode
+ *
+ * @param[out] x The pointer to an integer to be filled in
+ * @param[out] y The pointer to an integer to be filled in
+@ingroup Evas_Pointer_Group
+ *
+ */
+EOAPI void  evas_canvas_pointer_output_xy_get(int *x, int *y);
+
+/**
+ *
+ * Returns whether the mouse pointer is logically inside the canvas
+ *
+ * @return An integer that is 1 if the mouse is inside the canvas, 0 otherwise
+ * @ingroup Evas_Pointer_Group
+ *
+ * When this function is called it will return a value of either 0 or
+ * 1, depending on if evas_event_feed_mouse_in(),
+ * evas_event_feed_mouse_in_data(), or evas_event_feed_mouse_out(),
+ * evas_event_feed_mouse_out_data() have been called to feed in a
+ * mouse enter event into the canvas.
+ *
+ * A return value of 1 indicates the mouse is logically inside the
+ * canvas, and 0 implies it is logically outside the canvas.
+ *
+ * A canvas begins with the mouse being assumed outside (0).
+ *
+ * If @p e is not a valid canvas, the return value is undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ *
+ * if (evas_pointer_inside_get(evas)) printf("Mouse is in!\n");
+ * else printf("Mouse is out!\n");
+ * @endcode
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_canvas_pointer_inside_get(void);
+
+/**
+ *
+ * Get the maximum image size evas can possibly handle
+ *
+ * This function returns the larges image or surface size that evas can handle
+ * in pixels, and if there is one, returns @c EINA_TRUE. It returns
+ * @c EINA_FALSE if no extra constraint on maximum image size exists. You still
+ * should check the return values of @p maxw and @p maxh as there may still be
+ * a limit, just a much higher one.
+ *
+ * @since 1.1
+ *
+ * @param[out] maxw Pointer to hold the return value in pixels of the maximum width
+ * @param[out] maxh Pointer to hold the return value in pixels of the maximum height
+ *
+ */
+EOAPI Eina_Bool  evas_canvas_image_max_size_get(int *maxw, int *maxh);
+
+/**
+ *
+ * Get the lowest (stacked) Evas object on the canvas @p e.
+ *
+ * @return a pointer to the lowest object on it, if any, or @c NULL,
+ * otherwise
+ *
+ * This function will take all populated layers in the canvas into
+ * account, getting the lowest object for the lowest layer, naturally.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ * @see evas_object_above_get()
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ *
+ *
+ */
+EOAPI Evas_Object * evas_canvas_object_bottom_get(void);
+
+/**
+ *
+ * Returns a handle to the list of modifier keys registered in the
+ * canvas @p e. This is required to check for which modifiers are set
+ * at a given time with the evas_key_modifier_is_set() function.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_del
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ *
+ * @return An .Evas_Modifier handle to query Evas' keys subsystem
+ * with evas_key_modifier_is_set(), or @c NULL on error.
+ *
+ *
+ */
+EOAPI const Evas_Modifier * evas_canvas_key_modifier_get(void);
+
+/**
+ *
+ * Returns a bitmask with the mouse buttons currently pressed, set to 1
+ *
+ * @return A bitmask of the currently depressed buttons on the canvas
+ * @ingroup Evas_Pointer_Group
+ *
+ * Calling this function will return a 32-bit integer with the
+ * appropriate bits set to 1 that correspond to a mouse button being
+ * depressed. This limits Evas to a mouse devices with a maximum of 32
+ * buttons, but that is generally in excess of any host system's
+ * pointing device abilities.
+ *
+ * A canvas by default begins with no mouse buttons being pressed and
+ * only calls to evas_event_feed_mouse_down(),
+ * evas_event_feed_mouse_down_data(), evas_event_feed_mouse_up() and
+ * evas_event_feed_mouse_up_data() will alter that.
+ *
+ * The least significant bit corresponds to the first mouse button
+ * (button 1) and the most significant bit corresponds to the last
+ * mouse button (button 32).
+ *
+ * If @p e is not a valid canvas, the return value is undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int button_mask, i;
+ *
+ * button_mask = evas_pointer_button_down_mask_get(evas);
+ * printf("Buttons currently pressed:\n");
+ * for (i = 0; i < 32; i++)
+ * {
+ * if ((button_mask & (1 << i)) != 0) printf("Button %i\n", i + 1);
+ * }
+ * @endcode
+ *
+ *
+ */
+EOAPI int  evas_canvas_pointer_button_down_mask_get(void);
+
+/**
+ *
+ * Retrieve a list of Evas objects lying over a given position in
+ * a canvas.
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas covering the
+ * given position. It will enter the smart objects.
+ * It will not append to the list pass events as hidden objects.
+ * Call eina_list_free on the returned list after usage.
+ * 
+ *
+ * @param[in] stop An Evas Object where to stop searching.
+ * @param[in] x The horizontal coordinate of the position.
+ * @param[in] y The vertical coordinate of the position.
+ *
+ */
+EOAPI Eina_List * evas_canvas_tree_objects_at_xy_get(Evas_Object *stop, int x, int y);
+
+/**
+ *
+ * Mouse wheel event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse wheel is scrolled up or down. It prepares information to
+ * be treated by the callback function.
+ * 
+ *
+ * @param[in] direction The wheel mouse direction.
+ * @param[in] z How much mouse wheel was scrolled up or down.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_mouse_wheel(int direction, int z, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Enables or turns on programmatically the lock key with name @p
+ * keyname.
+ *
+ * The effect will be as if the key was put on its active state after
+ * this call.
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_add
+ * @see evas_key_lock_del
+ * @see evas_key_lock_off
+ * 
+ *
+ * @param[in] keyname The name of the lock to enable.
+ *
+ */
+EOAPI void  evas_canvas_key_lock_on(const char *keyname);
+
+/**
+ *
+ * Key down event feed
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is pressed. It prepares information to be treated by the
+ * callback function.
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key pressed.
+ * @param[in] string A String
+ * @param[in] compose The compose string
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_key_down(const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Creates a bit mask from the @p keyname @b modifier key. Values
+ * returned from different calls to it may be ORed together,
+ * naturally.
+ *
+ * @returns the bit mask or 0 if the @p keyname key wasn't registered as a
+ * modifier for canvas @p e.
+ *
+ * This function is meant to be using in conjunction with
+ * evas_object_key_grab()/evas_object_key_ungrab(). Go check their
+ * documentation for more information.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ * 
+ *
+ * @param[in] keyname The name of the modifier key to create the mask for.
+ *
+ */
+EOAPI Evas_Modifier_Mask  evas_canvas_key_modifier_mask_get(const char *keyname);
+
+/**
+ *
+ * Adds the @p keyname key to the current list of modifier keys.
+ *
+ * Modifiers are keys like shift, alt and ctrl, i.e., keys which are
+ * meant to be pressed together with others, altering the behavior of
+ * the secondly pressed keys somehow. Evas is so that these keys can
+ * be user defined.
+ *
+ * This call allows custom modifiers to be added to the Evas system at
+ * run time. It is then possible to set and unset modifier keys
+ * programmatically for other parts of the program to check and act
+ * on. Programmers using Evas would check for modifier keys on key
+ * event callbacks using evas_key_modifier_is_set().
+ *
+ * @see evas_key_modifier_del
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ *
+ * @note If the programmer instantiates the canvas by means of the
+ * ecore_evas_new() family of helper functions, Ecore will take
+ * care of registering on it all standard modifiers: "Shift",
+ * "Control", "Alt", "Meta", "Hyper", "Super".
+ * 
+ *
+ * @param[in] keyname The name of the modifier key to add to the list of
+Evas modifiers.
+ *
+ */
+EOAPI void  evas_canvas_key_modifier_add(const char *keyname);
+
+/**
+ *
+ * Disables or turns off programmatically the modifier key with name
+ * @p keyname.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_is_set
+ * 
+ *
+ * @param[in] keyname The name of the modifier to disable.
+ *
+ */
+EOAPI void  evas_canvas_key_modifier_off(const char *keyname);
+
+/**
+ *
+ * Hold event feed
+ *
+ * This function makes the object to stop sending events.
+ * 
+ *
+ * @param[in] hold The hold.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_hold(int hold, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Mouse move event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse is moved from its last position. It prepares information
+ * to be treated by the callback function.
+ * 
+ *
+ * @param[in] x The horizontal position of the mouse pointer.
+ * @param[in] y The vertical position of the mouse pointer.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_mouse_move(int x, int y, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Key up event feed
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is released. It prepares information to be treated by the
+ * callback function.
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key released.
+ * @param[in] string string
+ * @param[in] compose compose
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_key_up(const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Mouse out event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse out event happens. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] timestamp Timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_mouse_out(unsigned int timestamp, const void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_canvas_event_input_multi_move(int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Retrieve a list of Evas objects lying over a given position in
+ * a canvas
+ *
+ * @return  The list of Evas objects that are over the given position
+ * in @p e
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas covering the
+ * given position. The user can remove from query
+ * objects which are hidden and/or which are set to pass events.
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ * 
+ *
+ * @param[in] x The horizontal coordinate of the position
+ * @param[in] y The vertical coordinate of the position
+ * @param[in] include_pass_events_objects Boolean flag to include or not
+objects which pass events in this calculation
+ * @param[in] include_hidden_objects Boolean flag to include or not hidden
+objects in this calculation
+ *
+ */
+EOAPI Eina_List * evas_canvas_objects_at_xy_get(Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_canvas_event_input_multi_up(int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_multi_down(int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Render the given Evas canvas asynchronously.
+ *
+ * @return EINA_TRUE if the canvas will render, EINA_FALSE otherwise.
+ *
+ * This function only returns EINA_TRUE when a frame will be rendered. If the
+ * previous frame is still rendering, EINA_FALSE will be returned so the users
+ * know not to wait for the updates callback and just return to their main
+ * loop.
+ *
+ * If a @p func callback is given, a list of updated areas will be generated
+ * and the function will be called from the main thread after the rendered
+ * frame is flushed to the screen. The resulting list should be freed with
+ * @f evas_render_updates_free().
+ * The list is given in the @p event_info parameter of the callback function.
+ *
+ * @ingroup Evas_Canvas
+ * @since 1.8
+ * 
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_canvas_render_async(void);
+
+/**
+ *
+ * Inform to the evas that it lost the focus.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_focus_out(void);
+
+/**
+ *
+ * Mouse move event feed from input.
+ *
+ * Similar to the evas_event_feed_mouse_move(), this function will inform Evas
+ * about mouse move events which were received by the input system, relative to
+ * the 0,0 of the window, not to the canvas 0,0. It will take care of doing any
+ * special transformation like adding the framespace offset to the mouse event.
+ *
+ * @since 1.8
+ * @see evas_event_feed_mouse_move
+ * 
+ *
+ * @param[in] x The horizontal position of the mouse pointer relative to the 0,0 of
+the window/surface.
+ * @param[in] y The vertical position of the mouse pointer relative to the 0,0 of
+the window/surface.
+ * @param[in] timestamp The timestamp of the mouse move event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_input_mouse_move(int x, int y, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Update the canvas internal objects but not triggering immediate
+ * renderization.
+ *
+ * This function updates the canvas internal objects not triggering
+ * renderization. To force renderization function evas_render() should
+ * be used.
+ *
+ * @see evas_render.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_norender(void);
+
+/**
+ *
+ * Get the number of touched point in the evas.
+ *
+ * @return The number of touched point on the evas.
+ *
+ * New touched point is added to the list whenever touching the evas
+ * and point is removed whenever removing touched point from the evas.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int count;
+ *
+ * count = evas_touch_point_list_count(evas);
+ * printf("The count of touch points: %i\n", count);
+ * @endcode
+ *
+ * @see evas_touch_point_list_nth_xy_get()
+ * @see evas_touch_point_list_nth_id_get()
+ * @see evas_touch_point_list_nth_state_get()
+ * 
+ *
+ *
+ */
+EOAPI unsigned int  evas_canvas_touch_point_list_count(void);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_canvas_event_input_multi_down(int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Pop the nochange flag down 1
+ *
+ * This tells evas, that while the nochange flag is greater than 0, do not
+ * mark objects as "changed" when making changes.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_nochange_pop(void);
+
+/**
+ *
+ * Disables or turns off programmatically the lock key with name @p
+ * keyname.
+ *
+ * The effect will be as if the key was put on its inactive state
+ * after this call.
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_add
+ * @see evas_key_lock_del
+ * @see evas_key_lock_on
+ * 
+ *
+ * @param[in] keyname The name of the lock to disable.
+ *
+ */
+EOAPI void  evas_canvas_key_lock_off(const char *keyname);
+
+/**
+ *
+ * Push the nochange flag up 1
+ *
+ * This tells evas, that while the nochange flag is greater than 0, do not
+ * mark objects as "changed" when making changes.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_nochange_push(void);
+
+/**
+ *
+ * Force the given evas and associated engine to flush its font cache.
+ *
+ * @ingroup Evas_Font_Group
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_font_cache_flush(void);
+
+/**
+ *
+ * Checks if the font hinting is supported by the given evas.
+ *
+ * #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+ * @return @c EINA_TRUE if it is supported, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Font_Group
+ * 
+ *
+ * @param[in] hinting The hinting to use, one of #EVAS_FONT_HINTING_NONE,
+ *
+ */
+EOAPI Eina_Bool  evas_canvas_font_hinting_can_hint(Evas_Font_Hinting_Flags hinting);
+
+/**
+ *
+ * Retrieve the Evas object stacked at the top of a given position in
+ * a canvas
+ *
+ * @return  The Evas object that is over all other objects at the given
+ * position.
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas covering the
+ * given position. The user can remove from the query
+ * objects which are hidden and/or which are set to pass events.
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ * 
+ *
+ * @param[in] x The horizontal coordinate of the position
+ * @param[in] y The vertical coordinate of the position
+ * @param[in] include_pass_events_objects Boolean flag to include or not
+objects which pass events in this calculation
+ * @param[in] include_hidden_objects Boolean flag to include or not hidden
+objects in this calculation
+ *
+ */
+EOAPI Evas_Object * evas_canvas_object_top_at_xy_get(Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+/**
+ *
+ * Enables or turns on programmatically the modifier key with name @p
+ * keyname.
+ *
+ * The effect will be as if the key was pressed for the whole time
+ * between this call and a matching evas_key_modifier_off().
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ * 
+ *
+ * @param[in] keyname The name of the modifier to enable.
+ *
+ */
+EOAPI void  evas_canvas_key_modifier_on(const char *keyname);
+
+/**
+ *
+ * Mouse up event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse button is released. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] b The button number.
+ * @param[in] flags evas button flags.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_mouse_up(int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Mouse down event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse button is pressed. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] b The button number.
+ * @param[in] flags The evas button flags.
+ * @param[in] timestamp The timestamp of the mouse down event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_mouse_down(int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Re feed event.
+ *
+ * This function re-feeds the event pointed by event_copy
+ *
+ * This function call evas_event_feed_* functions, so it can
+ * cause havoc if not used wisely. Please use it responsibly.
+ * 
+ *
+ * @param[in] event_copy the event to refeed
+ * @param[in] event_type Event type
+ *
+ */
+EOAPI void  evas_canvas_event_refeed_event(void *event_copy, Evas_Callback_Type event_type);
+
+/**
+ *
+ * List of available font descriptions known or found by this evas.
+ *
+ * The list depends on Evas compile time configuration, such as
+ * fontconfig support, and the paths provided at runtime as explained
+ * in @ref Evas_Font_Path_Group.
+ *
+ * @return a newly allocated list of strings. Do not change the
+ * strings.  Be sure to call evas_font_available_list_free()
+ * after you're done.
+ *
+ * @ingroup Evas_Font_Group
+ * 
+ *
+ *
+ */
+EOAPI Eina_List * evas_canvas_font_available_list(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] w No description supplied.
+ * @param[in] h No description supplied.
+ * @param[in] include_pass_events_objects No description supplied.
+ * @param[in] include_hidden_objects No description supplied.
+ *
+ */
+EOAPI Eina_List * evas_canvas_objects_in_rectangle_get(Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+/**
+ *
+ * Retrieves the object on the given evas with the given name.
+ * @return  If successful, the Evas object with the given name.  Otherwise,
+ * @c NULL.
+ *
+ * This looks for the evas object given a name by evas_object_name_set(). If
+ * the name is not unique canvas-wide, then which one of the many objects
+ * with that name is returned is undefined, so only use this if you can ensure
+ * the object name is unique.
+ *
+ * @ingroup Evas_Object_Group_Find
+ * 
+ *
+ * @param[in] name The given name.
+ *
+ */
+EOAPI Evas_Object * evas_canvas_object_name_find(const char *name);
+
+/**
+ *
+ * Appends a font path to the list of font paths used by the given evas.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ * @param[in] path The new font path.
+ *
+ */
+EOAPI void  evas_canvas_font_path_append(const char *path);
+
+/**
+ *
+ * This function returns the @p id of nth touch point.
+ *
+ * @return id of nth touch point, if the call succeeded, -1 otherwise.
+ *
+ * The point which comes from Mouse Event has @p id 0 and The point
+ * which comes from Multi Event has @p id that is same as Multi
+ * Event's device id.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int id;
+ *
+ * if (evas_touch_point_list_count(evas))
+ * {
+ * id = evas_touch_point_nth_id_get(evas, 0);
+ * printf("The first touch point's id: %i\n", id);
+ * }
+ * @endcode
+ *
+ * @see evas_touch_point_list_count()
+ * @see evas_touch_point_list_nth_xy_get()
+ * @see evas_touch_point_list_nth_state_get()
+ * 
+ *
+ * @param[in] n The number of the touched point (0 being the first).
+ *
+ */
+EOAPI int  evas_canvas_touch_point_list_nth_id_get(unsigned int n);
+
+/**
+ *
+ * Removes all font paths loaded into memory for the given evas.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_font_path_clear(void);
+
+/**
+ *
+ * Call user-provided @c calculate() smart functions and unset the
+ * flag signalling that the object needs to get recalculated to @b all
+ * smart objects in the canvas.
+ *
+ * @see evas_object_smart_need_recalculate_set()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_smart_objects_calculate(void);
+
+/**
+ *
+ * This function returns the nth touch point's co-ordinates.
+ *
+ * Touch point's co-ordinates is updated whenever moving that point
+ * on the canvas.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Coord x, y;
+ *
+ * if (evas_touch_point_list_count(evas))
+ * {
+ * evas_touch_point_nth_xy_get(evas, 0, &x, &y);
+ * printf("The first touch point's co-ordinate: (%i, %i)\n", x, y);
+ * }
+ * @endcode
+ *
+ * @see evas_touch_point_list_count()
+ * @see evas_touch_point_list_nth_id_get()
+ * @see evas_touch_point_list_nth_state_get()
+ * 
+ *
+ * @param[in] n The number of the touched point (0 being the first).
+ * @param[out] x The pointer to a Evas_Coord to be filled in.
+ * @param[out] y The pointer to a Evas_Coord to be filled in.
+ *
+ */
+EOAPI void  evas_canvas_touch_point_list_nth_xy_get(unsigned int n, Evas_Coord *x, Evas_Coord *y);
+
+/**
+ *
+ * Removes the @p keyname key from the current list of lock keys on
+ * canvas @p e.
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_add
+ * @see evas_key_lock_on
+ * @see evas_key_lock_off
+ * 
+ *
+ * @param[in] keyname The name of the key to remove from the locks list.
+ *
+ */
+EOAPI void  evas_canvas_key_lock_del(const char *keyname);
+
+/**
+ *
+ * Add a damage rectangle.
+ *
+ * This is the function by which one tells evas that a part of the
+ * canvas has to be repainted.
+ *
+ * @note All newly created Evas rectangles get the default color values of 255 255 255 255 (opaque white).
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ * @param[in] x The rectangle's left position.
+ * @param[in] y The rectangle's top position.
+ * @param[in] w The rectangle's width.
+ * @param[in] h The rectangle's height.
+ *
+ */
+EOAPI void  evas_canvas_damage_rectangle_add(int x, int y, int w, int h);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_sync(void);
+
+/**
+ *
+ * Retrieves the list of font paths used by the given evas.
+ * @return  The list of font paths used.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ *
+ */
+EOAPI const Eina_List * evas_canvas_font_path_list(void);
+
+/**
+ *
+ * Reload the image cache
+ *
+ * This function reloads the image cache of canvas.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_image_cache_reload(void);
+
+/**
+ *
+ * Convert/scale a canvas co-ordinate into output screen co-ordinates
+ *
+ * @return The output/screen co-ordinate translated to output co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a horizontal co-ordinate as the @p x
+ * parameter and converts it into output units, accounting for output
+ * size, viewport size and location, returning it as the function
+ * return value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int screen_x;
+ * extern Evas_Coord canvas_x;
+ *
+ * screen_x = evas_coord_world_x_to_screen(evas, canvas_x);
+ * @endcode
+ * 
+ *
+ * @param[in] x The canvas x co-ordinate
+ *
+ */
+EOAPI int  evas_canvas_coord_world_x_to_screen(Evas_Coord x);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_multi_move(int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Force immediate renderization of the given Evas canvas.
+ *
+ * @return A newly allocated list of updated rectangles of the canvas
+ * (@c Eina.Rectangle structs). Free this list with
+ * evas_render_updates_free().
+ *
+ * This function forces an immediate renderization update of the given
+ * canvas @p e.
+ *
+ * @note This is a <b>very low level function</b>, which most of
+ * Evas' users wouldn't care about. One would use it, for example, to
+ * grab an Evas' canvas update regions and paint them back, using the
+ * canvas' pixmap, on a displaying system working below Evas.
+ *
+ * @note Evas is a stateful canvas. If no operations changing its
+ * state took place since the last rendering action, you won't see no
+ * changes and this call will be a no-op.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip add an obscured
+ * @until d.obscured = !d.obscured;
+ *
+ * See the full @ref Example_Evas_Events "example".
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI Eina_List * evas_canvas_render_updates(void);
+
+/**
+ *
+ * Flush the image cache of the canvas.
+ *
+ * This function flushes image cache of canvas.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_image_cache_flush(void);
+
+/**
+ *
+ * Convert/scale an output screen co-ordinate into canvas co-ordinates
+ *
+ * @return The screen co-ordinate translated to canvas unit co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a vertical co-ordinate as the @p y parameter
+ * and converts it into canvas units, accounting for output size,
+ * viewport size and location, returning it as the function return
+ * value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * extern int screen_y;
+ * Evas_Coord canvas_y;
+ *
+ * canvas_y = evas_coord_screen_y_to_world(evas, screen_y);
+ * @endcode
+ * 
+ *
+ * @param[in] y The screen/output y co-ordinate
+ *
+ */
+EOAPI Evas_Coord  evas_canvas_coord_screen_y_to_world(int y);
+
+/**
+ *
+ * Removes the @p keyname key from the current list of modifier keys
+ * on canvas @p e.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ * 
+ *
+ * @param[in] keyname The name of the key to remove from the modifiers list.
+ *
+ */
+EOAPI void  evas_canvas_key_modifier_del(const char *keyname);
+
+/**
+ *
+ * This function returns the @p state of nth touch point.
+ *
+ * @return @p state of nth touch point, if the call succeeded,
+ * EVAS_TOUCH_POINT_CANCEL otherwise.
+ *
+ * The point's @p state is EVAS_TOUCH_POINT_DOWN when pressed,
+ * EVAS_TOUCH_POINT_STILL when the point is not moved after pressed,
+ * EVAS_TOUCH_POINT_MOVE when moved at least once after pressed and
+ * EVAS_TOUCH_POINT_UP when released.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Touch_Point_State state;
+ *
+ * if (evas_touch_point_list_count(evas))
+ * {
+ * state = evas_touch_point_nth_state_get(evas, 0);
+ * printf("The first touch point's state: %i\n", state);
+ * }
+ * @endcode
+ *
+ * @see evas_touch_point_list_count()
+ * @see evas_touch_point_list_nth_xy_get()
+ * @see evas_touch_point_list_nth_id_get()
+ * 
+ *
+ * @param[in] n The number of the touched point (0 being the first).
+ *
+ */
+EOAPI Evas_Touch_Point_State  evas_canvas_touch_point_list_nth_state_get(unsigned int n);
+
+/**
+ *
+ * Inform to the evas that it got the focus.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_focus_in(void);
+
+/**
+ *
+ * Add an "obscured region" to an Evas canvas.
+ *
+ * This is the function by which one tells an Evas canvas that a part
+ * of it <b>must not</b> be repainted. The region must be
+ * rectangular and its coordinates inside the canvas viewport are
+ * passed in the call. After this call, the region specified won't
+ * participate in any form in Evas' calculations and actions during
+ * its rendering updates, having its displaying content frozen as it
+ * was just after this function took place.
+ *
+ * We call it "obscured region" because the most common use case for
+ * this rendering (partial) freeze is something else (most probably
+ * other canvas) being on top of the specified rectangular region,
+ * thus shading it completely from the user's final scene in a
+ * display. To avoid unnecessary processing, one should indicate to the
+ * obscured canvas not to bother about the non-important area.
+ *
+ * The majority of users won't have to worry about this function, as
+ * they'll be using just one canvas in their applications, with
+ * nothing inset or on top of it in any form.
+ *
+ * To make this region one that @b has to be repainted again, call the
+ * function evas_obscured_clear().
+ *
+ * @note This is a <b>very low level function</b>, which most of
+ * Evas' users wouldn't care about.
+ *
+ * @note This function does @b not flag the canvas as having its state
+ * changed. If you want to re-render it afterwards expecting new
+ * contents, you have to add "damage" regions yourself (see
+ * evas_damage_rectangle_add()).
+ *
+ * @see evas_obscured_clear()
+ * @see evas_render_updates()
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip add an obscured
+ * @until evas_obscured_clear(evas);
+ *
+ * In that example, pressing the "Ctrl" and "o" keys will impose or
+ * remove an obscured region in the middle of the canvas. You'll get
+ * the same contents at the time the key was pressed, if toggling it
+ * on, until you toggle it off again (make sure the animation is
+ * running on to get the idea better). See the full @ref
+ * Example_Evas_Events "example".
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ * @param[in] x The rectangle's top left corner's horizontal coordinate.
+ * @param[in] y The rectangle's top left corner's vertical coordinate
+ * @param[in] w The rectangle's width.
+ * @param[in] h The rectangle's height.
+ *
+ */
+EOAPI void  evas_canvas_obscured_rectangle_add(int x, int y, int w, int h);
+
+/**
+ *
+ * Make the canvas discard as much data as possible used by the engine at
+ * runtime.
+ *
+ * This function will unload images, delete textures and much more, where
+ * possible. You may also want to call evas_render_idle_flush() immediately
+ * prior to this to perhaps discard a little more, though evas_render_dump()
+ * should implicitly delete most of what evas_render_idle_flush() might
+ * discard too.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_render_dump(void);
+
+/**
+ *
+ * Mouse in event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse in event happens. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_mouse_in(unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Retrieve the Evas object stacked at the top of a given rectangular
+ * region in a canvas
+ *
+ * @return  The Evas object that is over all other objects at the given
+ * rectangular region.
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas overlapping
+ * with the given rectangular region inside @p e. The user can remove
+ * from the query objects which are hidden and/or which are set to
+ * pass events.
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ * 
+ *
+ * @param[in] x The top left corner's horizontal coordinate for the
+rectangular region
+ * @param[in] y The top left corner's vertical coordinate for the
+rectangular region
+ * @param[in] w The width of the rectangular region
+ * @param[in] h The height of the rectangular region
+ * @param[in] include_pass_events_objects Boolean flag to include or not
+objects which pass events in this calculation
+ * @param[in] include_hidden_objects Boolean flag to include or not hidden
+objects in this calculation
+ *
+ */
+EOAPI Evas_Object * evas_canvas_object_top_in_rectangle_get(Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects);
+
+/**
+ *
+ * Force renderization of the given canvas.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_render(void);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_multi_up(int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Prepends a font path to the list of font paths used by the given evas.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ * @param[in] path The new font path.
+ *
+ */
+EOAPI void  evas_canvas_font_path_prepend(const char *path);
+
+/**
+ *
+ * Remove all "obscured regions" from an Evas canvas.
+ *
+ * This function removes all the rectangles from the obscured regions
+ * list of the canvas @p e. It takes obscured areas added with
+ * evas_obscured_rectangle_add() and make them again a regions that @b
+ * have to be repainted on rendering updates.
+ *
+ * @note This is a <b>very low level function</b>, which most of
+ * Evas' users wouldn't care about.
+ *
+ * @note This function does @b not flag the canvas as having its state
+ * changed. If you want to re-render it afterwards expecting new
+ * contents, you have to add "damage" regions yourself (see
+ * evas_damage_rectangle_add()).
+ *
+ * @see evas_obscured_rectangle_add() for an example
+ * @see evas_render_updates()
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_obscured_clear(void);
+
+/**
+ *
+ * Mouse cancel event feed.
+ *
+ * This function will call evas_event_feed_mouse_up() when a
+ * mouse cancel event happens.
+ * 
+ *
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_mouse_cancel(unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Convert/scale an output screen co-ordinate into canvas co-ordinates
+ *
+ * @return The screen co-ordinate translated to canvas unit co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a horizontal co-ordinate as the @p x
+ * parameter and converts it into canvas units, accounting for output
+ * size, viewport size and location, returning it as the function
+ * return value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * extern int screen_x;
+ * Evas_Coord canvas_x;
+ *
+ * canvas_x = evas_coord_screen_x_to_world(evas, screen_x);
+ * @endcode
+ * 
+ *
+ * @param[in] x The screen/output x co-ordinate
+ *
+ */
+EOAPI Evas_Coord  evas_canvas_coord_screen_x_to_world(int x);
+
+/**
+ *
+ * Adds the @p keyname key to the current list of lock keys.
+ *
+ * Locks are keys like caps lock, num lock or scroll lock, i.e., keys
+ * which are meant to be pressed once -- toggling a binary state which
+ * is bound to it -- and thus altering the behavior of all
+ * subsequently pressed keys somehow, depending on its state. Evas is
+ * so that these keys can be defined by the user.
+ *
+ * This allows custom locks to be added to the evas system at run
+ * time. It is then possible to set and unset lock keys
+ * programmatically for other parts of the program to check and act
+ * on. Programmers using Evas would check for lock keys on key event
+ * callbacks using evas_key_lock_is_set().
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_del
+ * @see evas_key_lock_on
+ * @see evas_key_lock_off
+ * @see evas_key_lock_is_set
+ *
+ * @note If the programmer instantiates the canvas by means of the
+ * ecore_evas_new() family of helper functions, Ecore will take
+ * care of registering on it all standard lock keys: "Caps_Lock",
+ * "Num_Lock", "Scroll_Lock".
+ * 
+ *
+ * @param[in] keyname The name of the key to add to the locks list.
+ *
+ */
+EOAPI void  evas_canvas_key_lock_add(const char *keyname);
+
+/**
+ *
+ * Make the canvas discard internally cached data used for rendering.
+ *
+ * This function flushes the arrays of delete, active and render objects.
+ * Other things it may also discard are: shared memory segments,
+ * temporary scratch buffers, cached data to avoid re-compute of that data etc.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ *
+ */
+EOAPI void  evas_canvas_render_idle_flush(void);
+
+/**
+ *
+ * Convert/scale a canvas co-ordinate into output screen co-ordinates
+ *
+ * @return The output/screen co-ordinate translated to output co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a vertical co-ordinate as the @p x parameter
+ * and converts it into output units, accounting for output size,
+ * viewport size and location, returning it as the function return
+ * value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int screen_y;
+ * extern Evas_Coord canvas_y;
+ *
+ * screen_y = evas_coord_world_y_to_screen(evas, canvas_y);
+ * @endcode
+ * 
+ *
+ * @param[in] y The canvas y co-ordinate
+ *
+ */
+EOAPI int  evas_canvas_coord_world_y_to_screen(Evas_Coord y);
+
+/**
+ *
+ * Key down event feed with keycode
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is pressed. It prepares information to be treated by the
+ * callback function.
+ *
+ * @since 1.10
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key pressed.
+ * @param[in] string A String
+ * @param[in] compose The compose string
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ * @param[in] keycode Key scan code numeric value for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_key_down_with_keycode(const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+/**
+ *
+ * Key up event feed with keycode
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is released. It prepares information to be treated by the
+ * callback function.
+ *
+ * @since 1.10
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key released.
+ * @param[in] string string
+ * @param[in] compose compose
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ * @param[in] keycode Key scan code numeric value for canvas.
+ *
+ */
+EOAPI void  evas_canvas_event_feed_key_up_with_keycode(const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_canvas.eo.hh b/src/lib/evas/canvas/evas_canvas.eo.hh
--- a/src/lib/evas/canvas/evas_canvas.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_canvas.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,4801 @@
+#ifndef EFL_GENERATED_EVAS_CANVAS_HH
+#define EFL_GENERATED_EVAS_CANVAS_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_canvas.eo.h"
+}
+
+#include "evas_common_interface.eo.hh"
+#include <canvas/evas_object.eo.hh>
+#include <string>
+
+namespace evas {
+
+struct canvas
+      : efl::eo::base,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas::canvas>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit canvas(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit canvas(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   canvas(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : canvas(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   canvas(canvas const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~canvas() {}
+
+   /// @brief thaw events of object.
+   /// Lets event callbacks be called for the object.
+   ///
+   void event_thaw() const
+   {
+      eo_do(_eo_ptr(), ::eo_event_thaw());
+   }
+
+   /// @brief freeze events of object.
+   /// Prevents event callbacks from being called for the object.
+   ///
+   void event_freeze() const
+   {
+      eo_do(_eo_ptr(), ::eo_event_freeze());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param ret 
+   ///
+   Evas * evas_get() const
+   {
+      Evas * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the render engine's output framespace co-ordinates in canvas units.
+   ///
+   /// @ingroup Evas_Output_Size
+   /// @since 1.1
+   ///
+   /// @param x The left coordinate in output units, usually pixels.
+   /// @param y The top coordinate in output units, usually pixels.
+   /// @param w The width in output units, usually pixels.
+   /// @param h The height in output units, usually pixels.
+   ///
+   void output_framespace_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_output_framespace_get(x_, y_, w_, h_));
+   }
+
+   /// @brief Sets the output framespace size of the render engine of the given evas.
+   ///
+   /// The framespace size is used in the Wayland engines to denote space where
+   /// the output is not drawn. This is mainly used in ecore_evas to draw borders
+   ///
+   /// The units used for @p w and @p h depend on the engine used by the
+   /// evas.
+   ///
+   /// @ingroup Evas_Output_Size
+   /// @since 1.1
+   ///
+   /// @param x The left coordinate in output units, usually pixels.
+   /// @param y The top coordinate in output units, usually pixels.
+   /// @param w The width in output units, usually pixels.
+   /// @param h The height in output units, usually pixels.
+   ///
+   void output_framespace_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_output_framespace_set(x_, y_, w_, h_));
+   }
+
+   /// @brief Get the render engine's output viewport co-ordinates in canvas units.
+   /// Calling this function writes the current canvas output viewport
+   /// size and location values into the variables pointed to by @p x, @p
+   /// y, @p w and @p h.  On success the variables have the output
+   /// location and size values written to them in canvas units. Any of @p
+   /// x, @p y, @p w or @p h that are @c NULL will not be written to. If @p e
+   /// is invalid, the results are undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// Evas_Coord x, y, width, height;
+   ///
+   /// evas_output_viewport_get(evas, &x, &y, &w, &h);
+   /// @endcode
+   ///
+   /// @param x The top-left corner x value of the viewport.
+   /// @param y The top-left corner y value of the viewport.
+   /// @param w The width of the viewport.  Must be greater than 0.
+   /// @param h The height of the viewport.  Must be greater than 0.
+   ///
+   void output_viewport_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_output_viewport_get(x_, y_, w_, h_));
+   }
+
+   /// @brief Sets the output viewport of the given evas in evas units.
+   ///
+   /// The output viewport is the area of the evas that will be visible to
+   /// the viewer.  The viewport will be stretched to fit the output
+   /// target of the evas when rendering is performed.
+   ///
+   /// @note The coordinate values do not have to map 1-to-1 with the output
+   /// target.  However, it is generally advised that it is done for ease
+   /// of use.
+   ///
+   /// @ingroup Evas_Output_Size
+   ///
+   /// @param x The top-left corner x value of the viewport.
+   /// @param y The top-left corner y value of the viewport.
+   /// @param w The width of the viewport.  Must be greater than 0.
+   /// @param h The height of the viewport.  Must be greater than 0.
+   ///
+   void output_viewport_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_output_viewport_set(x_, y_, w_, h_));
+   }
+
+   /// @brief Get the image cache
+   ///
+   /// This function returns the image cache size of canvas in bytes.
+   ///
+   /// @param size The cache size.
+   ///
+   int image_cache_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_image_cache_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the image cache.
+   ///
+   /// This function sets the image cache of canvas in bytes.
+   ///
+   /// @param size The cache size.
+   ///
+   void image_cache_set(int size_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_image_cache_set(size_));
+   }
+
+   /// @brief Get the default set of flags an event begins with
+   ///
+   /// @return The default event flags for that canvas
+   ///
+   /// This gets the default event flags events are produced with when fed in.
+   ///
+   /// @see evas_event_default_flags_set()
+   /// @since 1.2
+   ///
+   /// @param flags The default flags to use
+   ///
+   Evas_Event_Flags event_default_flags_get() const
+   {
+      Evas_Event_Flags _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_event_default_flags_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the default set of flags an event begins with
+   ///
+   /// Events in evas can have an event_flags member. This starts out with
+   /// and initial value (no flags). This lets you set the default flags that
+   /// an event begins with to be @p flags
+   ///
+   /// @since 1.2
+   ///
+   /// @param flags The default flags to use
+   ///
+   void event_default_flags_set(Evas_Event_Flags flags_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_default_flags_set(flags_));
+   }
+
+   /// @brief Retrieves the number of the output engine used for the given evas.
+   /// @return  The ID number of the output engine being used.  @c 0 is
+   /// returned if there is an error.
+   /// @ingroup Evas_Output_Method
+   ///
+   /// @param render_method The numeric engine value to use.
+   ///
+   int output_method_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_output_method_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the output engine for the given evas.
+   ///
+   /// Once the output engine for an evas is set, any attempt to change it
+   /// will be ignored.  The value for @p render_method can be found using
+   /// @ref evas_render_method_lookup .
+   ///
+   /// @attention it is mandatory that one calls evas_init() before
+   /// setting the output method.
+   ///
+   /// @ingroup Evas_Output_Method
+   ///
+   /// @param render_method The numeric engine value to use.
+   ///
+   void output_method_set(int render_method_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_output_method_set(render_method_));
+   }
+
+   /// @brief Changes the size of font cache of the given evas.
+   ///
+   /// @return The size, in bytes.
+   ///
+   /// @ingroup Evas_Font_Group
+   ///
+   /// @param size The size, in bytes.
+   ///
+   int font_cache_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_font_cache_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Changes the size of font cache of the given evas.
+   ///
+   /// @ingroup Evas_Font_Group
+   ///
+   /// @param size The size, in bytes.
+   ///
+   void font_cache_set(int size_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_font_cache_set(size_));
+   }
+
+   /// @brief Retrieve the output size of the render engine of the given evas.
+   ///
+   /// The output size is given in whatever the output units are for the
+   /// engine.
+   ///
+   /// If either @p w or @p h is @c NULL, then it is ignored.  If @p e is
+   /// invalid, the returned results are undefined.
+   ///
+   /// @ingroup Evas_Output_Size
+   ///
+   /// @param w The width in output units, usually pixels.
+   /// @param h The height in output units, usually pixels.
+   ///
+   void output_size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_output_size_get(w_, h_));
+   }
+
+   /// @brief Sets the output size of the render engine of the given evas.
+   ///
+   /// The evas will render to a rectangle of the given size once this
+   /// function is called.  The output size is independent of the viewport
+   /// size.  The viewport will be stretched to fill the given rectangle.
+   ///
+   /// The units used for @p w and @p h depend on the engine used by the
+   /// evas.
+   ///
+   /// @ingroup Evas_Output_Size
+   ///
+   /// @param w The width in output units, usually pixels.
+   /// @param h The height in output units, usually pixels.
+   ///
+   void output_size_set(int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_output_size_set(w_, h_));
+   }
+
+   /// @brief Returns the pointer attached by evas_data_attach_set()
+   ///
+   /// @return The pointer attached
+   /// @ingroup Evas_Canvas
+   ///
+   /// @param data The pointer to attach
+   ///
+   void * data_attach_get() const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_data_attach_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Attaches a specific pointer to the evas for fetching later
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   /// @param data The pointer to attach
+   ///
+   void data_attach_set(void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_data_attach_set(data_));
+   }
+
+   /// @brief Retrieves the font hinting used by the given evas.
+   ///
+   /// @return The hinting in use, one of #EVAS_FONT_HINTING_NONE,
+   /// #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+   /// @ingroup Evas_Font_Group
+   ///
+   /// @param hinting The hinting to use, one of #EVAS_FONT_HINTING_NONE,
+   ///
+   Evas_Font_Hinting_Flags font_hinting_get() const
+   {
+      Evas_Font_Hinting_Flags _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_font_hinting_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Changes the font hinting for the given evas.
+   ///
+   /// #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+   /// @ingroup Evas_Font_Group
+   ///
+   /// @param hinting The hinting to use, one of #EVAS_FONT_HINTING_NONE,
+   ///
+   void font_hinting_set(Evas_Font_Hinting_Flags hinting_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_font_hinting_set(hinting_));
+   }
+
+   /// @brief Retrieves the current render engine info struct from the given evas.
+   ///
+   /// The returned structure is publicly modifiable.  The contents are
+   /// valid until either @ref evas_engine_info_set or @ref evas_render
+   /// are called.
+   ///
+   /// This structure does not need to be freed by the caller.
+   ///
+   /// @return  A pointer to the Engine Info structure.  @c NULL is returned if
+   /// an engine has not yet been assigned.
+   /// @ingroup Evas_Output_Method
+   ///
+   /// @param info The pointer to the Engine Info to use
+   ///
+   Evas_Engine_Info * engine_info_get() const
+   {
+      Evas_Engine_Info * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_engine_info_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Applies the engine settings for the given evas from the given @c
+   /// Evas_Engine_Info structure.
+   ///
+   /// To get the Evas_Engine_Info structure to use, call @ref
+   /// evas_engine_info_get .  Do not try to obtain a pointer to an
+   /// @c Evas_Engine_Info structure in any other way.
+   ///
+   /// You will need to call this function at least once before you can
+   /// create objects on an evas or render that evas.  Some engines allow
+   /// their settings to be changed more than once.
+   ///
+   /// Once called, the @p info pointer should be considered invalid.
+   ///
+   /// @return  @c EINA_TRUE if no error occurred, @c EINA_FALSE otherwise.
+   /// @ingroup Evas_Output_Method
+   ///
+   /// @param info The pointer to the Engine Info to use
+   ///
+   bool engine_info_set(Evas_Engine_Info * info_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_engine_info_set(info_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve the object that currently has focus.
+   ///
+   /// @return The object that has focus or @c NULL if there is not one.
+   ///
+   /// Evas can have (at most) one of its objects focused at a time.
+   /// Focused objects will be the ones having <b>key events</b> delivered
+   /// to, which the programmer can act upon by means of
+   /// evas_object_event_callback_add() usage.
+   ///
+   /// @note Most users wouldn't be dealing directly with Evas' focused
+   /// objects. Instead, they would be using a higher level library for
+   /// that (like a toolkit, as Elementary) to handle focus and who's
+   /// receiving input for them.
+   ///
+   /// This call returns the object that currently has focus on the canvas
+   /// @p e or @c NULL, if none.
+   ///
+   /// @see evas_object_focus_set
+   /// @see evas_object_focus_get
+   /// @see evas_object_key_grab
+   /// @see evas_object_key_ungrab
+   ///
+   /// Example:
+   /// @dontinclude evas-events.c
+   /// @skip evas_event_callback_add(d.canvas, EVAS_CALLBACK_CANVAS_OBJECT_FOCUS_IN,
+   /// @until evas_object_focus_set(d.bg, EINA_TRUE);
+   /// @dontinclude evas-events.c
+   /// @skip called when our rectangle gets focus
+   /// @until }
+   ///
+   /// In this example the @c event_info is exactly a pointer to that
+   /// focused rectangle. See the full @ref Example_Evas_Events "example".
+   ///
+   /// @ingroup Evas_Object_Group_Find
+   ///
+   evas::object focus_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_focus_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the highest (stacked) Evas object on the canvas @p e.
+   ///
+   /// @return a pointer to the highest object on it, if any, or @c NULL,
+   /// otherwise
+   ///
+   /// This function will take all populated layers in the canvas into
+   /// account, getting the highest object for the highest layer,
+   /// naturally.
+   ///
+   /// @see evas_object_layer_get()
+   /// @see evas_object_layer_set()
+   /// @see evas_object_below_get()
+   /// @see evas_object_above_get()
+   ///
+   /// @warning This function will @b skip objects parented by smart
+   /// objects, acting only on the ones at the "top level", with regard to
+   /// object parenting.
+   ///
+   evas::object object_top_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_object_top_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Returns a handle to the list of lock keys registered in the canvas
+   /// @p e. This is required to check for which locks are set at a given
+   /// time with the evas_key_lock_is_set() function.
+   ///
+   /// @see evas_key_lock_add
+   /// @see evas_key_lock_del
+   /// @see evas_key_lock_on
+   /// @see evas_key_lock_off
+   /// @see evas_key_lock_is_set
+   ///
+   /// @return An .Evas_Lock handle to query Evas' keys subsystem with
+   /// evas_key_lock_is_set(), or @c NULL on error.
+   ///
+   const Evas_Lock * key_lock_get() const
+   {
+      const Evas_Lock * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_key_lock_get());
+      return _tmp_ret;
+   }
+
+   /// @brief This function returns the current known pointer co-ordinates
+   ///
+   /// This function returns the current known canvas unit co-ordinates of
+   /// the mouse pointer and sets the contents of the Evas_Coords pointed
+   /// to by @p x and @p y to contain these co-ordinates. If @p e is not a
+   /// valid canvas the results of this function are undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// Evas_Coord mouse_x, mouse_y;
+   ///
+   /// evas_pointer_output_xy_get(evas, &mouse_x, &mouse_y);
+   /// printf("Mouse is at canvas position %d, %d\n", mouse_x, mouse_y);
+   /// @endcode
+   ///
+   /// @param x The pointer to a Evas_Coord to be filled in
+   /// @param y The pointer to a Evas_Coord to be filled in
+   /// @ingroup Evas_Pointer_Group
+   ///
+   void pointer_canvas_xy_get(Evas_Coord* x_, Evas_Coord* y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_pointer_canvas_xy_get(x_, y_));
+   }
+
+   /// @brief Get the number of mouse or multi presses currently active
+   ///
+   /// @p e The given canvas pointer.
+   /// @return The number of presses (0 if none active).
+   ///
+   /// @since 1.2
+   ///
+   int event_down_count_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_event_down_count_get());
+      return _tmp_ret;
+   }
+
+   /// @brief This gets the internal counter that counts the number of smart calculations
+   ///
+   /// Whenever evas performs smart object calculations on the whole canvas
+   /// it increments a counter by 1. This is the smart object calculate counter
+   /// that this function returns the value of. It starts at the value of 0 and
+   /// will increase (and eventually wrap around to negative values and so on) by
+   /// 1 every time objects are calculated. You can use this counter to ensure
+   /// you don't re-do calculations withint the same calculation generation/run
+   /// if the calculations maybe cause self-feeding effects.
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   /// @since 1.1
+   ///
+   int smart_objects_calculate_count_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_smart_objects_calculate_count_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the focus state known by the given evas
+   ///
+   /// @return @c EINA_TRUE if it got the focus, @c EINA_FALSE otherwise.
+   /// @ingroup Evas_Canvas
+   ///
+   bool focus_state_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_focus_state_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the changed marker for the canvas
+   ///
+   /// @return @c EINA_TRUE if something has been marked as changed, @c EINA_FALSE otherwise.
+   /// @ingroup Evas_Canvas
+   /// @since 1.11
+   ///
+   bool changed_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_changed_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief This function returns the current known pointer co-ordinates
+   ///
+   /// This function returns the current known screen/output co-ordinates
+   /// of the mouse pointer and sets the contents of the integers pointed
+   /// to by @p x and @p y to contain these co-ordinates. If @p e is not a
+   /// valid canvas the results of this function are undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// int mouse_x, mouse_y;
+   ///
+   /// evas_pointer_output_xy_get(evas, &mouse_x, &mouse_y);
+   /// printf("Mouse is at screen position %i, %i\n", mouse_x, mouse_y);
+   /// @endcode
+   ///
+   /// @param x The pointer to an integer to be filled in
+   /// @param y The pointer to an integer to be filled in
+   /// @ingroup Evas_Pointer_Group
+   ///
+   void pointer_output_xy_get(int* x_, int* y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_pointer_output_xy_get(x_, y_));
+   }
+
+   /// @brief Returns whether the mouse pointer is logically inside the canvas
+   ///
+   /// @return An integer that is 1 if the mouse is inside the canvas, 0 otherwise
+   /// @ingroup Evas_Pointer_Group
+   ///
+   /// When this function is called it will return a value of either 0 or
+   /// 1, depending on if evas_event_feed_mouse_in(),
+   /// evas_event_feed_mouse_in_data(), or evas_event_feed_mouse_out(),
+   /// evas_event_feed_mouse_out_data() have been called to feed in a
+   /// mouse enter event into the canvas.
+   ///
+   /// A return value of 1 indicates the mouse is logically inside the
+   /// canvas, and 0 implies it is logically outside the canvas.
+   ///
+   /// A canvas begins with the mouse being assumed outside (0).
+   ///
+   /// If @p e is not a valid canvas, the return value is undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   ///
+   /// if (evas_pointer_inside_get(evas)) printf("Mouse is in!\n");
+   /// else printf("Mouse is out!\n");
+   /// @endcode
+   ///
+   bool pointer_inside_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_pointer_inside_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the maximum image size evas can possibly handle
+   ///
+   /// This function returns the larges image or surface size that evas can handle
+   /// in pixels, and if there is one, returns @c EINA_TRUE. It returns
+   /// @c EINA_FALSE if no extra constraint on maximum image size exists. You still
+   /// should check the return values of @p maxw and @p maxh as there may still be
+   /// a limit, just a much higher one.
+   ///
+   /// @since 1.1
+   ///
+   /// @param maxw Pointer to hold the return value in pixels of the maximum width
+   /// @param maxh Pointer to hold the return value in pixels of the maximum height
+   ///
+   bool image_max_size_get(int* maxw_, int* maxh_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_image_max_size_get(maxw_, maxh_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the lowest (stacked) Evas object on the canvas @p e.
+   ///
+   /// @return a pointer to the lowest object on it, if any, or @c NULL,
+   /// otherwise
+   ///
+   /// This function will take all populated layers in the canvas into
+   /// account, getting the lowest object for the lowest layer, naturally.
+   ///
+   /// @see evas_object_layer_get()
+   /// @see evas_object_layer_set()
+   /// @see evas_object_below_get()
+   /// @see evas_object_above_get()
+   ///
+   /// @warning This function will @b skip objects parented by smart
+   /// objects, acting only on the ones at the "top level", with regard to
+   /// object parenting.
+   ///
+   evas::object object_bottom_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_object_bottom_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Returns a handle to the list of modifier keys registered in the
+   /// canvas @p e. This is required to check for which modifiers are set
+   /// at a given time with the evas_key_modifier_is_set() function.
+   ///
+   /// @see evas_key_modifier_add
+   /// @see evas_key_modifier_del
+   /// @see evas_key_modifier_on
+   /// @see evas_key_modifier_off
+   /// @see evas_key_modifier_is_set
+   ///
+   /// @return An .Evas_Modifier handle to query Evas' keys subsystem
+   /// with evas_key_modifier_is_set(), or @c NULL on error.
+   ///
+   const Evas_Modifier * key_modifier_get() const
+   {
+      const Evas_Modifier * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_key_modifier_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Returns a bitmask with the mouse buttons currently pressed, set to 1
+   ///
+   /// @return A bitmask of the currently depressed buttons on the canvas
+   /// @ingroup Evas_Pointer_Group
+   ///
+   /// Calling this function will return a 32-bit integer with the
+   /// appropriate bits set to 1 that correspond to a mouse button being
+   /// depressed. This limits Evas to a mouse devices with a maximum of 32
+   /// buttons, but that is generally in excess of any host system's
+   /// pointing device abilities.
+   ///
+   /// A canvas by default begins with no mouse buttons being pressed and
+   /// only calls to evas_event_feed_mouse_down(),
+   /// evas_event_feed_mouse_down_data(), evas_event_feed_mouse_up() and
+   /// evas_event_feed_mouse_up_data() will alter that.
+   ///
+   /// The least significant bit corresponds to the first mouse button
+   /// (button 1) and the most significant bit corresponds to the last
+   /// mouse button (button 32).
+   ///
+   /// If @p e is not a valid canvas, the return value is undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// int button_mask, i;
+   ///
+   /// button_mask = evas_pointer_button_down_mask_get(evas);
+   /// printf("Buttons currently pressed:\n");
+   /// for (i = 0; i < 32; i++)
+   /// {
+   /// if ((button_mask & (1 << i)) != 0) printf("Button %i\n", i + 1);
+   /// }
+   /// @endcode
+   ///
+   int pointer_button_down_mask_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_pointer_button_down_mask_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Retrieve a list of Evas objects lying over a given position in
+   /// a canvas.
+   ///
+   /// This function will traverse all the layers of the given canvas,
+   /// from top to bottom, querying for objects with areas covering the
+   /// given position. It will enter the smart objects.
+   /// It will not append to the list pass events as hidden objects.
+   /// Call eina_list_free on the returned list after usage.
+   ///
+   /// @param stop An Evas Object where to stop searching.
+   /// @param x The horizontal coordinate of the position.
+   /// @param y The vertical coordinate of the position.
+   ///
+   efl::eina::range_list< evas::object > tree_objects_at_xy_get(evas::object stop_, int x_, int y_) const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_tree_objects_at_xy_get(efl::eolian::to_c(stop_), x_, y_));
+      return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief Mouse wheel event feed.
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// the mouse wheel is scrolled up or down. It prepares information to
+   /// be treated by the callback function.
+   ///
+   /// @param direction The wheel mouse direction.
+   /// @param z How much mouse wheel was scrolled up or down.
+   /// @param timestamp The timestamp of the mouse up event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_mouse_wheel(int direction_, int z_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_mouse_wheel(direction_, z_, timestamp_, data_));
+   }
+
+   /// @brief Enables or turns on programmatically the lock key with name @p
+   /// keyname.
+   ///
+   /// The effect will be as if the key was put on its active state after
+   /// this call.
+   ///
+   /// @see evas_key_lock_get
+   /// @see evas_key_lock_add
+   /// @see evas_key_lock_del
+   /// @see evas_key_lock_off
+   ///
+   /// @param keyname The name of the lock to enable.
+   ///
+   void key_lock_on(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_lock_on(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief Key down event feed
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// a key is pressed. It prepares information to be treated by the
+   /// callback function.
+   ///
+   /// @param keyname Name of the key
+   /// @param key The key pressed.
+   /// @param string A String
+   /// @param compose The compose string
+   /// @param timestamp Timestamp of the mouse up event
+   /// @param data Data for canvas.
+   ///
+   void event_feed_key_down(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_key_down(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_));
+   }
+
+   /// @brief Creates a bit mask from the @p keyname @b modifier key. Values
+   /// returned from different calls to it may be ORed together,
+   /// naturally.
+   ///
+   /// @returns the bit mask or 0 if the @p keyname key wasn't registered as a
+   /// modifier for canvas @p e.
+   ///
+   /// This function is meant to be using in conjunction with
+   /// evas_object_key_grab()/evas_object_key_ungrab(). Go check their
+   /// documentation for more information.
+   ///
+   /// @see evas_key_modifier_add
+   /// @see evas_key_modifier_get
+   /// @see evas_key_modifier_on
+   /// @see evas_key_modifier_off
+   /// @see evas_key_modifier_is_set
+   /// @see evas_object_key_grab
+   /// @see evas_object_key_ungrab
+   ///
+   /// @param keyname The name of the modifier key to create the mask for.
+   ///
+   Evas_Modifier_Mask key_modifier_mask_get(std::string keyname_) const
+   {
+      Evas_Modifier_Mask _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_key_modifier_mask_get(efl::eolian::to_c(keyname_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Adds the @p keyname key to the current list of modifier keys.
+   ///
+   /// Modifiers are keys like shift, alt and ctrl, i.e., keys which are
+   /// meant to be pressed together with others, altering the behavior of
+   /// the secondly pressed keys somehow. Evas is so that these keys can
+   /// be user defined.
+   ///
+   /// This call allows custom modifiers to be added to the Evas system at
+   /// run time. It is then possible to set and unset modifier keys
+   /// programmatically for other parts of the program to check and act
+   /// on. Programmers using Evas would check for modifier keys on key
+   /// event callbacks using evas_key_modifier_is_set().
+   ///
+   /// @see evas_key_modifier_del
+   /// @see evas_key_modifier_get
+   /// @see evas_key_modifier_on
+   /// @see evas_key_modifier_off
+   /// @see evas_key_modifier_is_set
+   ///
+   /// @note If the programmer instantiates the canvas by means of the
+   /// ecore_evas_new() family of helper functions, Ecore will take
+   /// care of registering on it all standard modifiers: "Shift",
+   /// "Control", "Alt", "Meta", "Hyper", "Super".
+   ///
+   /// @param keyname The name of the modifier key to add to the list of
+   /// Evas modifiers.
+   ///
+   void key_modifier_add(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_modifier_add(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief Disables or turns off programmatically the modifier key with name
+   /// @p keyname.
+   ///
+   /// @see evas_key_modifier_add
+   /// @see evas_key_modifier_get
+   /// @see evas_key_modifier_on
+   /// @see evas_key_modifier_is_set
+   ///
+   /// @param keyname The name of the modifier to disable.
+   ///
+   void key_modifier_off(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_modifier_off(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief Hold event feed
+   ///
+   /// This function makes the object to stop sending events.
+   ///
+   /// @param hold The hold.
+   /// @param timestamp The timestamp of the mouse up event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_hold(int hold_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_hold(hold_, timestamp_, data_));
+   }
+
+   /// @brief Mouse move event feed.
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// the mouse is moved from its last position. It prepares information
+   /// to be treated by the callback function.
+   ///
+   /// @param x The horizontal position of the mouse pointer.
+   /// @param y The vertical position of the mouse pointer.
+   /// @param timestamp The timestamp of the mouse up event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_mouse_move(int x_, int y_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_mouse_move(x_, y_, timestamp_, data_));
+   }
+
+   /// @brief Key up event feed
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// a key is released. It prepares information to be treated by the
+   /// callback function.
+   ///
+   /// @param keyname Name of the key
+   /// @param key The key released.
+   /// @param string string
+   /// @param compose compose
+   /// @param timestamp Timestamp of the mouse up event
+   /// @param data Data for canvas.
+   ///
+   void event_feed_key_up(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_key_up(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_));
+   }
+
+   /// @brief Mouse out event feed.
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// the mouse out event happens. It prepares information to be treated
+   /// by the callback function.
+   ///
+   /// @param timestamp Timestamp of the mouse up event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_mouse_out(unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_mouse_out(timestamp_, data_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param d 
+   /// @param x 
+   /// @param y 
+   /// @param rad 
+   /// @param radx 
+   /// @param rady 
+   /// @param pres 
+   /// @param ang 
+   /// @param fx 
+   /// @param fy 
+   /// @param timestamp 
+   /// @param data 
+   ///
+   void event_input_multi_move(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_input_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_));
+   }
+
+   /// @brief Retrieve a list of Evas objects lying over a given position in
+   /// a canvas
+   ///
+   /// @return  The list of Evas objects that are over the given position
+   /// in @p e
+   ///
+   /// This function will traverse all the layers of the given canvas,
+   /// from top to bottom, querying for objects with areas covering the
+   /// given position. The user can remove from query
+   /// objects which are hidden and/or which are set to pass events.
+   ///
+   /// @warning This function will @b skip objects parented by smart
+   /// objects, acting only on the ones at the "top level", with regard to
+   /// object parenting.
+   ///
+   /// @param x The horizontal coordinate of the position
+   /// @param y The vertical coordinate of the position
+   /// @param include_pass_events_objects Boolean flag to include or not
+   /// objects which pass events in this calculation
+   /// @param include_hidden_objects Boolean flag to include or not hidden
+   /// objects in this calculation
+   ///
+   efl::eina::range_list< evas::object > objects_at_xy_get(Evas_Coord x_, Evas_Coord y_, bool include_pass_events_objects_, bool include_hidden_objects_) const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_objects_at_xy_get(x_, y_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+      return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param d 
+   /// @param x 
+   /// @param y 
+   /// @param rad 
+   /// @param radx 
+   /// @param rady 
+   /// @param pres 
+   /// @param ang 
+   /// @param fx 
+   /// @param fy 
+   /// @param flags 
+   /// @param timestamp 
+   /// @param data 
+   ///
+   void event_input_multi_up(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_input_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param d 
+   /// @param x 
+   /// @param y 
+   /// @param rad 
+   /// @param radx 
+   /// @param rady 
+   /// @param pres 
+   /// @param ang 
+   /// @param fx 
+   /// @param fy 
+   /// @param flags 
+   /// @param timestamp 
+   /// @param data 
+   ///
+   void event_feed_multi_down(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+   }
+
+   /// @brief Render the given Evas canvas asynchronously.
+   ///
+   /// @return EINA_TRUE if the canvas will render, EINA_FALSE otherwise.
+   ///
+   /// This function only returns EINA_TRUE when a frame will be rendered. If the
+   /// previous frame is still rendering, EINA_FALSE will be returned so the users
+   /// know not to wait for the updates callback and just return to their main
+   /// loop.
+   ///
+   /// If a @p func callback is given, a list of updated areas will be generated
+   /// and the function will be called from the main thread after the rendered
+   /// frame is flushed to the screen. The resulting list should be freed with
+   /// @f evas_render_updates_free().
+   /// The list is given in the @p event_info parameter of the callback function.
+   ///
+   /// @ingroup Evas_Canvas
+   /// @since 1.8
+   ///
+   bool render_async() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_render_async());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Inform to the evas that it lost the focus.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void focus_out() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_focus_out());
+   }
+
+   /// @brief Mouse move event feed from input.
+   ///
+   /// Similar to the evas_event_feed_mouse_move(), this function will inform Evas
+   /// about mouse move events which were received by the input system, relative to
+   /// the 0,0 of the window, not to the canvas 0,0. It will take care of doing any
+   /// special transformation like adding the framespace offset to the mouse event.
+   ///
+   /// @since 1.8
+   /// @see evas_event_feed_mouse_move
+   ///
+   /// @param x The horizontal position of the mouse pointer relative to the 0,0 of
+   /// the window/surface.
+   /// @param y The vertical position of the mouse pointer relative to the 0,0 of
+   /// the window/surface.
+   /// @param timestamp The timestamp of the mouse move event.
+   /// @param data The data for canvas.
+   ///
+   void event_input_mouse_move(int x_, int y_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_input_mouse_move(x_, y_, timestamp_, data_));
+   }
+
+   /// @brief Update the canvas internal objects but not triggering immediate
+   /// renderization.
+   ///
+   /// This function updates the canvas internal objects not triggering
+   /// renderization. To force renderization function evas_render() should
+   /// be used.
+   ///
+   /// @see evas_render.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void norender() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_norender());
+   }
+
+   /// @brief Get the number of touched point in the evas.
+   ///
+   /// @return The number of touched point on the evas.
+   ///
+   /// New touched point is added to the list whenever touching the evas
+   /// and point is removed whenever removing touched point from the evas.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// int count;
+   ///
+   /// count = evas_touch_point_list_count(evas);
+   /// printf("The count of touch points: %i\n", count);
+   /// @endcode
+   ///
+   /// @see evas_touch_point_list_nth_xy_get()
+   /// @see evas_touch_point_list_nth_id_get()
+   /// @see evas_touch_point_list_nth_state_get()
+   ///
+   unsigned int touch_point_list_count() const
+   {
+      unsigned int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_touch_point_list_count());
+      return _tmp_ret;
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param d 
+   /// @param x 
+   /// @param y 
+   /// @param rad 
+   /// @param radx 
+   /// @param rady 
+   /// @param pres 
+   /// @param ang 
+   /// @param fx 
+   /// @param fy 
+   /// @param flags 
+   /// @param timestamp 
+   /// @param data 
+   ///
+   void event_input_multi_down(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_input_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+   }
+
+   /// @brief Pop the nochange flag down 1
+   ///
+   /// This tells evas, that while the nochange flag is greater than 0, do not
+   /// mark objects as "changed" when making changes.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void nochange_pop() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_nochange_pop());
+   }
+
+   /// @brief Disables or turns off programmatically the lock key with name @p
+   /// keyname.
+   ///
+   /// The effect will be as if the key was put on its inactive state
+   /// after this call.
+   ///
+   /// @see evas_key_lock_get
+   /// @see evas_key_lock_add
+   /// @see evas_key_lock_del
+   /// @see evas_key_lock_on
+   ///
+   /// @param keyname The name of the lock to disable.
+   ///
+   void key_lock_off(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_lock_off(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief Push the nochange flag up 1
+   ///
+   /// This tells evas, that while the nochange flag is greater than 0, do not
+   /// mark objects as "changed" when making changes.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void nochange_push() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_nochange_push());
+   }
+
+   /// @brief Force the given evas and associated engine to flush its font cache.
+   ///
+   /// @ingroup Evas_Font_Group
+   ///
+   void font_cache_flush() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_font_cache_flush());
+   }
+
+   /// @brief Checks if the font hinting is supported by the given evas.
+   ///
+   /// #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+   /// @return @c EINA_TRUE if it is supported, @c EINA_FALSE otherwise.
+   /// @ingroup Evas_Font_Group
+   ///
+   /// @param hinting The hinting to use, one of #EVAS_FONT_HINTING_NONE,
+   ///
+   bool font_hinting_can_hint(Evas_Font_Hinting_Flags hinting_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_font_hinting_can_hint(hinting_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve the Evas object stacked at the top of a given position in
+   /// a canvas
+   ///
+   /// @return  The Evas object that is over all other objects at the given
+   /// position.
+   ///
+   /// This function will traverse all the layers of the given canvas,
+   /// from top to bottom, querying for objects with areas covering the
+   /// given position. The user can remove from the query
+   /// objects which are hidden and/or which are set to pass events.
+   ///
+   /// @warning This function will @b skip objects parented by smart
+   /// objects, acting only on the ones at the "top level", with regard to
+   /// object parenting.
+   ///
+   /// @param x The horizontal coordinate of the position
+   /// @param y The vertical coordinate of the position
+   /// @param include_pass_events_objects Boolean flag to include or not
+   /// objects which pass events in this calculation
+   /// @param include_hidden_objects Boolean flag to include or not hidden
+   /// objects in this calculation
+   ///
+   evas::object object_top_at_xy_get(Evas_Coord x_, Evas_Coord y_, bool include_pass_events_objects_, bool include_hidden_objects_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_object_top_at_xy_get(x_, y_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Enables or turns on programmatically the modifier key with name @p
+   /// keyname.
+   ///
+   /// The effect will be as if the key was pressed for the whole time
+   /// between this call and a matching evas_key_modifier_off().
+   ///
+   /// @see evas_key_modifier_add
+   /// @see evas_key_modifier_get
+   /// @see evas_key_modifier_off
+   /// @see evas_key_modifier_is_set
+   ///
+   /// @param keyname The name of the modifier to enable.
+   ///
+   void key_modifier_on(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_modifier_on(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief Mouse up event feed.
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// the mouse button is released. It prepares information to be treated
+   /// by the callback function.
+   ///
+   /// @param b The button number.
+   /// @param flags evas button flags.
+   /// @param timestamp The timestamp of the mouse up event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_mouse_up(int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_mouse_up(b_, flags_, timestamp_, data_));
+   }
+
+   /// @brief Mouse down event feed.
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// the mouse button is pressed. It prepares information to be treated
+   /// by the callback function.
+   ///
+   /// @param b The button number.
+   /// @param flags The evas button flags.
+   /// @param timestamp The timestamp of the mouse down event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_mouse_down(int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_mouse_down(b_, flags_, timestamp_, data_));
+   }
+
+   /// @brief Re feed event.
+   ///
+   /// This function re-feeds the event pointed by event_copy
+   ///
+   /// This function call evas_event_feed_* functions, so it can
+   /// cause havoc if not used wisely. Please use it responsibly.
+   ///
+   /// @param event_copy the event to refeed
+   /// @param event_type Event type
+   ///
+   void event_refeed_event(void * event_copy_, Evas_Callback_Type event_type_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_refeed_event(event_copy_, event_type_));
+   }
+
+   /// @brief List of available font descriptions known or found by this evas.
+   ///
+   /// The list depends on Evas compile time configuration, such as
+   /// fontconfig support, and the paths provided at runtime as explained
+   /// in @ref Evas_Font_Path_Group.
+   ///
+   /// @return a newly allocated list of strings. Do not change the
+   /// strings.  Be sure to call evas_font_available_list_free()
+   /// after you're done.
+   ///
+   /// @ingroup Evas_Font_Group
+   ///
+   efl::eina::range_list< std::string > font_available_list() const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_font_available_list());
+      return efl::eolian::to_cxx<efl::eina::range_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @param x 
+   /// @param y 
+   /// @param w 
+   /// @param h 
+   /// @param include_pass_events_objects 
+   /// @param include_hidden_objects 
+   ///
+   efl::eina::range_list< evas::object > objects_in_rectangle_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, bool include_pass_events_objects_, bool include_hidden_objects_) const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_objects_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+      return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief Retrieves the object on the given evas with the given name.
+   /// @return  If successful, the Evas object with the given name.  Otherwise,
+   /// @c NULL.
+   ///
+   /// This looks for the evas object given a name by evas_object_name_set(). If
+   /// the name is not unique canvas-wide, then which one of the many objects
+   /// with that name is returned is undefined, so only use this if you can ensure
+   /// the object name is unique.
+   ///
+   /// @ingroup Evas_Object_Group_Find
+   ///
+   /// @param name The given name.
+   ///
+   evas::object object_name_find(std::string name_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_object_name_find(efl::eolian::to_c(name_)));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Appends a font path to the list of font paths used by the given evas.
+   /// @ingroup Evas_Font_Path_Group
+   ///
+   /// @param path The new font path.
+   ///
+   void font_path_append(std::string path_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_font_path_append(efl::eolian::to_c(path_)));
+   }
+
+   /// @brief This function returns the @p id of nth touch point.
+   ///
+   /// @return id of nth touch point, if the call succeeded, -1 otherwise.
+   ///
+   /// The point which comes from Mouse Event has @p id 0 and The point
+   /// which comes from Multi Event has @p id that is same as Multi
+   /// Event's device id.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// int id;
+   ///
+   /// if (evas_touch_point_list_count(evas))
+   /// {
+   /// id = evas_touch_point_nth_id_get(evas, 0);
+   /// printf("The first touch point's id: %i\n", id);
+   /// }
+   /// @endcode
+   ///
+   /// @see evas_touch_point_list_count()
+   /// @see evas_touch_point_list_nth_xy_get()
+   /// @see evas_touch_point_list_nth_state_get()
+   ///
+   /// @param n The number of the touched point (0 being the first).
+   ///
+   int touch_point_list_nth_id_get(unsigned int n_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_touch_point_list_nth_id_get(n_));
+      return _tmp_ret;
+   }
+
+   /// @brief Removes all font paths loaded into memory for the given evas.
+   /// @ingroup Evas_Font_Path_Group
+   ///
+   void font_path_clear() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_font_path_clear());
+   }
+
+   /// @brief Call user-provided @c calculate() smart functions and unset the
+   /// flag signalling that the object needs to get recalculated to @b all
+   /// smart objects in the canvas.
+   ///
+   /// @see evas_object_smart_need_recalculate_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void smart_objects_calculate() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_smart_objects_calculate());
+   }
+
+   /// @brief This function returns the nth touch point's co-ordinates.
+   ///
+   /// Touch point's co-ordinates is updated whenever moving that point
+   /// on the canvas.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// Evas_Coord x, y;
+   ///
+   /// if (evas_touch_point_list_count(evas))
+   /// {
+   /// evas_touch_point_nth_xy_get(evas, 0, &x, &y);
+   /// printf("The first touch point's co-ordinate: (%i, %i)\n", x, y);
+   /// }
+   /// @endcode
+   ///
+   /// @see evas_touch_point_list_count()
+   /// @see evas_touch_point_list_nth_id_get()
+   /// @see evas_touch_point_list_nth_state_get()
+   ///
+   /// @param n The number of the touched point (0 being the first).
+   /// @param[out] x The pointer to a Evas_Coord to be filled in.
+   /// @param[out] y The pointer to a Evas_Coord to be filled in.
+   ///
+   void touch_point_list_nth_xy_get(unsigned int n_, Evas_Coord* x_, Evas_Coord* y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_touch_point_list_nth_xy_get(n_, x_, y_));
+   }
+
+   /// @brief Removes the @p keyname key from the current list of lock keys on
+   /// canvas @p e.
+   ///
+   /// @see evas_key_lock_get
+   /// @see evas_key_lock_add
+   /// @see evas_key_lock_on
+   /// @see evas_key_lock_off
+   ///
+   /// @param keyname The name of the key to remove from the locks list.
+   ///
+   void key_lock_del(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_lock_del(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief Add a damage rectangle.
+   ///
+   /// This is the function by which one tells evas that a part of the
+   /// canvas has to be repainted.
+   ///
+   /// @note All newly created Evas rectangles get the default color values of 255 255 255 255 (opaque white).
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   /// @param x The rectangle's left position.
+   /// @param y The rectangle's top position.
+   /// @param w The rectangle's width.
+   /// @param h The rectangle's height.
+   ///
+   void damage_rectangle_add(int x_, int y_, int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_damage_rectangle_add(x_, y_, w_, h_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void sync() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_sync());
+   }
+
+   /// @brief Retrieves the list of font paths used by the given evas.
+   /// @return  The list of font paths used.
+   /// @ingroup Evas_Font_Path_Group
+   ///
+   efl::eina::crange_list< std::string > font_path_list() const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_font_path_list());
+      return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief Reload the image cache
+   ///
+   /// This function reloads the image cache of canvas.
+   ///
+   void image_cache_reload() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_image_cache_reload());
+   }
+
+   /// @brief Convert/scale a canvas co-ordinate into output screen co-ordinates
+   ///
+   /// @return The output/screen co-ordinate translated to output co-ordinates
+   /// @ingroup Evas_Coord_Mapping_Group
+   ///
+   /// This function takes in a horizontal co-ordinate as the @p x
+   /// parameter and converts it into output units, accounting for output
+   /// size, viewport size and location, returning it as the function
+   /// return value. If @p e is invalid, the results are undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// int screen_x;
+   /// extern Evas_Coord canvas_x;
+   ///
+   /// screen_x = evas_coord_world_x_to_screen(evas, canvas_x);
+   /// @endcode
+   ///
+   /// @param x The canvas x co-ordinate
+   ///
+   int coord_world_x_to_screen(Evas_Coord x_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_coord_world_x_to_screen(x_));
+      return _tmp_ret;
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param d 
+   /// @param x 
+   /// @param y 
+   /// @param rad 
+   /// @param radx 
+   /// @param rady 
+   /// @param pres 
+   /// @param ang 
+   /// @param fx 
+   /// @param fy 
+   /// @param timestamp 
+   /// @param data 
+   ///
+   void event_feed_multi_move(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_));
+   }
+
+   /// @brief Force immediate renderization of the given Evas canvas.
+   ///
+   /// @return A newly allocated list of updated rectangles of the canvas
+   /// (@c Eina.Rectangle structs). Free this list with
+   /// evas_render_updates_free().
+   ///
+   /// This function forces an immediate renderization update of the given
+   /// canvas @p e.
+   ///
+   /// @note This is a <b>very low level function</b>, which most of
+   /// Evas' users wouldn't care about. One would use it, for example, to
+   /// grab an Evas' canvas update regions and paint them back, using the
+   /// canvas' pixmap, on a displaying system working below Evas.
+   ///
+   /// @note Evas is a stateful canvas. If no operations changing its
+   /// state took place since the last rendering action, you won't see no
+   /// changes and this call will be a no-op.
+   ///
+   /// Example code follows.
+   /// @dontinclude evas-events.c
+   /// @skip add an obscured
+   /// @until d.obscured = !d.obscured;
+   ///
+   /// See the full @ref Example_Evas_Events "example".
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   efl::eina::list< Eina_Rectangle * > render_updates() const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_render_updates());
+      return efl::eolian::to_cxx<efl::eina::list< Eina_Rectangle * >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+   }
+
+   /// @brief Flush the image cache of the canvas.
+   ///
+   /// This function flushes image cache of canvas.
+   ///
+   void image_cache_flush() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_image_cache_flush());
+   }
+
+   /// @brief Convert/scale an output screen co-ordinate into canvas co-ordinates
+   ///
+   /// @return The screen co-ordinate translated to canvas unit co-ordinates
+   /// @ingroup Evas_Coord_Mapping_Group
+   ///
+   /// This function takes in a vertical co-ordinate as the @p y parameter
+   /// and converts it into canvas units, accounting for output size,
+   /// viewport size and location, returning it as the function return
+   /// value. If @p e is invalid, the results are undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// extern int screen_y;
+   /// Evas_Coord canvas_y;
+   ///
+   /// canvas_y = evas_coord_screen_y_to_world(evas, screen_y);
+   /// @endcode
+   ///
+   /// @param y The screen/output y co-ordinate
+   ///
+   Evas_Coord coord_screen_y_to_world(int y_) const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_coord_screen_y_to_world(y_));
+      return _tmp_ret;
+   }
+
+   /// @brief Removes the @p keyname key from the current list of modifier keys
+   /// on canvas @p e.
+   ///
+   /// @see evas_key_modifier_add
+   /// @see evas_key_modifier_get
+   /// @see evas_key_modifier_on
+   /// @see evas_key_modifier_off
+   /// @see evas_key_modifier_is_set
+   ///
+   /// @param keyname The name of the key to remove from the modifiers list.
+   ///
+   void key_modifier_del(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_modifier_del(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief This function returns the @p state of nth touch point.
+   ///
+   /// @return @p state of nth touch point, if the call succeeded,
+   /// EVAS_TOUCH_POINT_CANCEL otherwise.
+   ///
+   /// The point's @p state is EVAS_TOUCH_POINT_DOWN when pressed,
+   /// EVAS_TOUCH_POINT_STILL when the point is not moved after pressed,
+   /// EVAS_TOUCH_POINT_MOVE when moved at least once after pressed and
+   /// EVAS_TOUCH_POINT_UP when released.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// Evas_Touch_Point_State state;
+   ///
+   /// if (evas_touch_point_list_count(evas))
+   /// {
+   /// state = evas_touch_point_nth_state_get(evas, 0);
+   /// printf("The first touch point's state: %i\n", state);
+   /// }
+   /// @endcode
+   ///
+   /// @see evas_touch_point_list_count()
+   /// @see evas_touch_point_list_nth_xy_get()
+   /// @see evas_touch_point_list_nth_id_get()
+   ///
+   /// @param n The number of the touched point (0 being the first).
+   ///
+   Evas_Touch_Point_State touch_point_list_nth_state_get(unsigned int n_) const
+   {
+      Evas_Touch_Point_State _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_touch_point_list_nth_state_get(n_));
+      return _tmp_ret;
+   }
+
+   /// @brief Inform to the evas that it got the focus.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void focus_in() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_focus_in());
+   }
+
+   /// @brief Add an "obscured region" to an Evas canvas.
+   ///
+   /// This is the function by which one tells an Evas canvas that a part
+   /// of it <b>must not</b> be repainted. The region must be
+   /// rectangular and its coordinates inside the canvas viewport are
+   /// passed in the call. After this call, the region specified won't
+   /// participate in any form in Evas' calculations and actions during
+   /// its rendering updates, having its displaying content frozen as it
+   /// was just after this function took place.
+   ///
+   /// We call it "obscured region" because the most common use case for
+   /// this rendering (partial) freeze is something else (most probably
+   /// other canvas) being on top of the specified rectangular region,
+   /// thus shading it completely from the user's final scene in a
+   /// display. To avoid unnecessary processing, one should indicate to the
+   /// obscured canvas not to bother about the non-important area.
+   ///
+   /// The majority of users won't have to worry about this function, as
+   /// they'll be using just one canvas in their applications, with
+   /// nothing inset or on top of it in any form.
+   ///
+   /// To make this region one that @b has to be repainted again, call the
+   /// function evas_obscured_clear().
+   ///
+   /// @note This is a <b>very low level function</b>, which most of
+   /// Evas' users wouldn't care about.
+   ///
+   /// @note This function does @b not flag the canvas as having its state
+   /// changed. If you want to re-render it afterwards expecting new
+   /// contents, you have to add "damage" regions yourself (see
+   /// evas_damage_rectangle_add()).
+   ///
+   /// @see evas_obscured_clear()
+   /// @see evas_render_updates()
+   ///
+   /// Example code follows.
+   /// @dontinclude evas-events.c
+   /// @skip add an obscured
+   /// @until evas_obscured_clear(evas);
+   ///
+   /// In that example, pressing the "Ctrl" and "o" keys will impose or
+   /// remove an obscured region in the middle of the canvas. You'll get
+   /// the same contents at the time the key was pressed, if toggling it
+   /// on, until you toggle it off again (make sure the animation is
+   /// running on to get the idea better). See the full @ref
+   /// Example_Evas_Events "example".
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   /// @param x The rectangle's top left corner's horizontal coordinate.
+   /// @param y The rectangle's top left corner's vertical coordinate
+   /// @param w The rectangle's width.
+   /// @param h The rectangle's height.
+   ///
+   void obscured_rectangle_add(int x_, int y_, int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_obscured_rectangle_add(x_, y_, w_, h_));
+   }
+
+   /// @brief Make the canvas discard as much data as possible used by the engine at
+   /// runtime.
+   ///
+   /// This function will unload images, delete textures and much more, where
+   /// possible. You may also want to call evas_render_idle_flush() immediately
+   /// prior to this to perhaps discard a little more, though evas_render_dump()
+   /// should implicitly delete most of what evas_render_idle_flush() might
+   /// discard too.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void render_dump() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_render_dump());
+   }
+
+   /// @brief Mouse in event feed.
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// the mouse in event happens. It prepares information to be treated
+   /// by the callback function.
+   ///
+   /// @param timestamp The timestamp of the mouse up event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_mouse_in(unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_mouse_in(timestamp_, data_));
+   }
+
+   /// @brief Retrieve the Evas object stacked at the top of a given rectangular
+   /// region in a canvas
+   ///
+   /// @return  The Evas object that is over all other objects at the given
+   /// rectangular region.
+   ///
+   /// This function will traverse all the layers of the given canvas,
+   /// from top to bottom, querying for objects with areas overlapping
+   /// with the given rectangular region inside @p e. The user can remove
+   /// from the query objects which are hidden and/or which are set to
+   /// pass events.
+   ///
+   /// @warning This function will @b skip objects parented by smart
+   /// objects, acting only on the ones at the "top level", with regard to
+   /// object parenting.
+   ///
+   /// @param x The top left corner's horizontal coordinate for the
+   /// rectangular region
+   /// @param y The top left corner's vertical coordinate for the
+   /// rectangular region
+   /// @param w The width of the rectangular region
+   /// @param h The height of the rectangular region
+   /// @param include_pass_events_objects Boolean flag to include or not
+   /// objects which pass events in this calculation
+   /// @param include_hidden_objects Boolean flag to include or not hidden
+   /// objects in this calculation
+   ///
+   evas::object object_top_in_rectangle_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, bool include_pass_events_objects_, bool include_hidden_objects_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_object_top_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Force renderization of the given canvas.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void render() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_render());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param d 
+   /// @param x 
+   /// @param y 
+   /// @param rad 
+   /// @param radx 
+   /// @param rady 
+   /// @param pres 
+   /// @param ang 
+   /// @param fx 
+   /// @param fy 
+   /// @param flags 
+   /// @param timestamp 
+   /// @param data 
+   ///
+   void event_feed_multi_up(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+   }
+
+   /// @brief Prepends a font path to the list of font paths used by the given evas.
+   /// @ingroup Evas_Font_Path_Group
+   ///
+   /// @param path The new font path.
+   ///
+   void font_path_prepend(std::string path_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_font_path_prepend(efl::eolian::to_c(path_)));
+   }
+
+   /// @brief Remove all "obscured regions" from an Evas canvas.
+   ///
+   /// This function removes all the rectangles from the obscured regions
+   /// list of the canvas @p e. It takes obscured areas added with
+   /// evas_obscured_rectangle_add() and make them again a regions that @b
+   /// have to be repainted on rendering updates.
+   ///
+   /// @note This is a <b>very low level function</b>, which most of
+   /// Evas' users wouldn't care about.
+   ///
+   /// @note This function does @b not flag the canvas as having its state
+   /// changed. If you want to re-render it afterwards expecting new
+   /// contents, you have to add "damage" regions yourself (see
+   /// evas_damage_rectangle_add()).
+   ///
+   /// @see evas_obscured_rectangle_add() for an example
+   /// @see evas_render_updates()
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void obscured_clear() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_obscured_clear());
+   }
+
+   /// @brief Mouse cancel event feed.
+   ///
+   /// This function will call evas_event_feed_mouse_up() when a
+   /// mouse cancel event happens.
+   ///
+   /// @param timestamp The timestamp of the mouse up event.
+   /// @param data The data for canvas.
+   ///
+   void event_feed_mouse_cancel(unsigned int timestamp_, const void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_mouse_cancel(timestamp_, data_));
+   }
+
+   /// @brief Convert/scale an output screen co-ordinate into canvas co-ordinates
+   ///
+   /// @return The screen co-ordinate translated to canvas unit co-ordinates
+   /// @ingroup Evas_Coord_Mapping_Group
+   ///
+   /// This function takes in a horizontal co-ordinate as the @p x
+   /// parameter and converts it into canvas units, accounting for output
+   /// size, viewport size and location, returning it as the function
+   /// return value. If @p e is invalid, the results are undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// extern int screen_x;
+   /// Evas_Coord canvas_x;
+   ///
+   /// canvas_x = evas_coord_screen_x_to_world(evas, screen_x);
+   /// @endcode
+   ///
+   /// @param x The screen/output x co-ordinate
+   ///
+   Evas_Coord coord_screen_x_to_world(int x_) const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_coord_screen_x_to_world(x_));
+      return _tmp_ret;
+   }
+
+   /// @brief Adds the @p keyname key to the current list of lock keys.
+   ///
+   /// Locks are keys like caps lock, num lock or scroll lock, i.e., keys
+   /// which are meant to be pressed once -- toggling a binary state which
+   /// is bound to it -- and thus altering the behavior of all
+   /// subsequently pressed keys somehow, depending on its state. Evas is
+   /// so that these keys can be defined by the user.
+   ///
+   /// This allows custom locks to be added to the evas system at run
+   /// time. It is then possible to set and unset lock keys
+   /// programmatically for other parts of the program to check and act
+   /// on. Programmers using Evas would check for lock keys on key event
+   /// callbacks using evas_key_lock_is_set().
+   ///
+   /// @see evas_key_lock_get
+   /// @see evas_key_lock_del
+   /// @see evas_key_lock_on
+   /// @see evas_key_lock_off
+   /// @see evas_key_lock_is_set
+   ///
+   /// @note If the programmer instantiates the canvas by means of the
+   /// ecore_evas_new() family of helper functions, Ecore will take
+   /// care of registering on it all standard lock keys: "Caps_Lock",
+   /// "Num_Lock", "Scroll_Lock".
+   ///
+   /// @param keyname The name of the key to add to the locks list.
+   ///
+   void key_lock_add(std::string keyname_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_key_lock_add(efl::eolian::to_c(keyname_)));
+   }
+
+   /// @brief Make the canvas discard internally cached data used for rendering.
+   ///
+   /// This function flushes the arrays of delete, active and render objects.
+   /// Other things it may also discard are: shared memory segments,
+   /// temporary scratch buffers, cached data to avoid re-compute of that data etc.
+   ///
+   /// @ingroup Evas_Canvas
+   ///
+   void render_idle_flush() const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_render_idle_flush());
+   }
+
+   /// @brief Convert/scale a canvas co-ordinate into output screen co-ordinates
+   ///
+   /// @return The output/screen co-ordinate translated to output co-ordinates
+   /// @ingroup Evas_Coord_Mapping_Group
+   ///
+   /// This function takes in a vertical co-ordinate as the @p x parameter
+   /// and converts it into output units, accounting for output size,
+   /// viewport size and location, returning it as the function return
+   /// value. If @p e is invalid, the results are undefined.
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas *evas;
+   /// int screen_y;
+   /// extern Evas_Coord canvas_y;
+   ///
+   /// screen_y = evas_coord_world_y_to_screen(evas, canvas_y);
+   /// @endcode
+   ///
+   /// @param y The canvas y co-ordinate
+   ///
+   int coord_world_y_to_screen(Evas_Coord y_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_canvas_coord_world_y_to_screen(y_));
+      return _tmp_ret;
+   }
+
+   /// @brief Key down event feed with keycode
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// a key is pressed. It prepares information to be treated by the
+   /// callback function.
+   ///
+   /// @since 1.10
+   ///
+   /// @param keyname Name of the key
+   /// @param key The key pressed.
+   /// @param string A String
+   /// @param compose The compose string
+   /// @param timestamp Timestamp of the mouse up event
+   /// @param data Data for canvas.
+   /// @param keycode Key scan code numeric value for canvas.
+   ///
+   void event_feed_key_down_with_keycode(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_key_down_with_keycode(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_, keycode_));
+   }
+
+   /// @brief Key up event feed with keycode
+   ///
+   /// This function will set some evas properties that is necessary when
+   /// a key is released. It prepares information to be treated by the
+   /// callback function.
+   ///
+   /// @since 1.10
+   ///
+   /// @param keyname Name of the key
+   /// @param key The key released.
+   /// @param string string
+   /// @param compose compose
+   /// @param timestamp Timestamp of the mouse up event
+   /// @param data Data for canvas.
+   /// @param keycode Key scan code numeric value for canvas.
+   ///
+   void event_feed_key_up_with_keycode(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_) const
+   {
+      eo_do(_eo_ptr(), ::evas_canvas_event_feed_key_up_with_keycode(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_, keycode_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_CANVAS_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_CANVAS_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_canvas_event_thaw_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->event_thaw();
+}
+
+template <typename T>
+void evas_canvas_event_freeze_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->event_freeze();
+}
+
+template <typename T>
+Evas * evas_canvas_evas_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->evas_get();
+}
+
+template <typename T>
+void evas_canvas_output_framespace_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->output_framespace_get(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_canvas_output_framespace_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->output_framespace_set(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_canvas_output_viewport_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->output_viewport_get(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_canvas_output_viewport_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->output_viewport_set(x_, y_, w_, h_);
+}
+
+template <typename T>
+int evas_canvas_image_cache_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->image_cache_get();
+}
+
+template <typename T>
+void evas_canvas_image_cache_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int size_)
+{
+   static_cast<T*>(self->this_)->image_cache_set(size_);
+}
+
+template <typename T>
+Evas_Event_Flags evas_canvas_event_default_flags_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->event_default_flags_get();
+}
+
+template <typename T>
+void evas_canvas_event_default_flags_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Event_Flags flags_)
+{
+   static_cast<T*>(self->this_)->event_default_flags_set(flags_);
+}
+
+template <typename T>
+int evas_canvas_output_method_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->output_method_get();
+}
+
+template <typename T>
+void evas_canvas_output_method_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int render_method_)
+{
+   static_cast<T*>(self->this_)->output_method_set(render_method_);
+}
+
+template <typename T>
+int evas_canvas_font_cache_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->font_cache_get();
+}
+
+template <typename T>
+void evas_canvas_font_cache_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int size_)
+{
+   static_cast<T*>(self->this_)->font_cache_set(size_);
+}
+
+template <typename T>
+void evas_canvas_output_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->output_size_get(w_, h_);
+}
+
+template <typename T>
+void evas_canvas_output_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->output_size_set(w_, h_);
+}
+
+template <typename T>
+void * evas_canvas_data_attach_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->data_attach_get();
+}
+
+template <typename T>
+void evas_canvas_data_attach_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * data_)
+{
+   static_cast<T*>(self->this_)->data_attach_set(data_);
+}
+
+template <typename T>
+Evas_Font_Hinting_Flags evas_canvas_font_hinting_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->font_hinting_get();
+}
+
+template <typename T>
+void evas_canvas_font_hinting_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Font_Hinting_Flags hinting_)
+{
+   static_cast<T*>(self->this_)->font_hinting_set(hinting_);
+}
+
+template <typename T>
+Evas_Engine_Info * evas_canvas_engine_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->engine_info_get();
+}
+
+template <typename T>
+bool evas_canvas_engine_info_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Engine_Info * info_)
+{
+   return static_cast<T*>(self->this_)->engine_info_set(info_);
+}
+
+template <typename T>
+evas::object evas_canvas_focus_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->focus_get();
+}
+
+template <typename T>
+evas::object evas_canvas_object_top_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->object_top_get();
+}
+
+template <typename T>
+const Evas_Lock * evas_canvas_key_lock_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->key_lock_get();
+}
+
+template <typename T>
+void evas_canvas_pointer_canvas_xy_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x_, Evas_Coord* y_)
+{
+   static_cast<T*>(self->this_)->pointer_canvas_xy_get(x_, y_);
+}
+
+template <typename T>
+int evas_canvas_event_down_count_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->event_down_count_get();
+}
+
+template <typename T>
+int evas_canvas_smart_objects_calculate_count_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smart_objects_calculate_count_get();
+}
+
+template <typename T>
+bool evas_canvas_focus_state_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->focus_state_get();
+}
+
+template <typename T>
+bool evas_canvas_changed_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->changed_get();
+}
+
+template <typename T>
+void evas_canvas_pointer_output_xy_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* x_, int* y_)
+{
+   static_cast<T*>(self->this_)->pointer_output_xy_get(x_, y_);
+}
+
+template <typename T>
+bool evas_canvas_pointer_inside_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->pointer_inside_get();
+}
+
+template <typename T>
+bool evas_canvas_image_max_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* maxw_, int* maxh_)
+{
+   return static_cast<T*>(self->this_)->image_max_size_get(maxw_, maxh_);
+}
+
+template <typename T>
+evas::object evas_canvas_object_bottom_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->object_bottom_get();
+}
+
+template <typename T>
+const Evas_Modifier * evas_canvas_key_modifier_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->key_modifier_get();
+}
+
+template <typename T>
+int evas_canvas_pointer_button_down_mask_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->pointer_button_down_mask_get();
+}
+
+template <typename T>
+efl::eina::range_list< evas::object > evas_canvas_tree_objects_at_xy_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * stop_, int x_, int y_)
+{
+   return static_cast<T*>(self->this_)->tree_objects_at_xy_get(efl::eolian::to_cxx<evas::object>(stop_, std::tuple<std::false_type>()), x_, y_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_mouse_wheel_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int direction_, int z_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_mouse_wheel(direction_, z_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_key_lock_on_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_lock_on(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_event_feed_key_down_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_, const char * key_, const char * string_, const char * compose_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_key_down(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(string_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(compose_, std::tuple<std::false_type>()), timestamp_, data_);
+}
+
+template <typename T>
+Evas_Modifier_Mask evas_canvas_key_modifier_mask_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   return static_cast<T*>(self->this_)->key_modifier_mask_get(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_key_modifier_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_modifier_add(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_key_modifier_off_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_modifier_off(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_event_feed_hold_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int hold_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_hold(hold_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_mouse_move_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_, int y_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_mouse_move(x_, y_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_key_up_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_, const char * key_, const char * string_, const char * compose_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_key_up(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(string_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(compose_, std::tuple<std::false_type>()), timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_mouse_out_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_mouse_out(timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_event_input_multi_move_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_input_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_);
+}
+
+template <typename T>
+efl::eina::range_list< evas::object > evas_canvas_objects_at_xy_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Eina_Bool include_pass_events_objects_, Eina_Bool include_hidden_objects_)
+{
+   return static_cast<T*>(self->this_)->objects_at_xy_get(x_, y_, efl::eolian::to_cxx<bool>(include_pass_events_objects_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(include_hidden_objects_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_event_input_multi_up_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_input_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_multi_down_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_);
+}
+
+template <typename T>
+bool evas_canvas_render_async_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->render_async();
+}
+
+template <typename T>
+void evas_canvas_focus_out_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->focus_out();
+}
+
+template <typename T>
+void evas_canvas_event_input_mouse_move_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_, int y_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_input_mouse_move(x_, y_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_norender_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->norender();
+}
+
+template <typename T>
+unsigned int evas_canvas_touch_point_list_count_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->touch_point_list_count();
+}
+
+template <typename T>
+void evas_canvas_event_input_multi_down_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_input_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_nochange_pop_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->nochange_pop();
+}
+
+template <typename T>
+void evas_canvas_key_lock_off_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_lock_off(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_nochange_push_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->nochange_push();
+}
+
+template <typename T>
+void evas_canvas_font_cache_flush_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->font_cache_flush();
+}
+
+template <typename T>
+bool evas_canvas_font_hinting_can_hint_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Font_Hinting_Flags hinting_)
+{
+   return static_cast<T*>(self->this_)->font_hinting_can_hint(hinting_);
+}
+
+template <typename T>
+evas::object evas_canvas_object_top_at_xy_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Eina_Bool include_pass_events_objects_, Eina_Bool include_hidden_objects_)
+{
+   return static_cast<T*>(self->this_)->object_top_at_xy_get(x_, y_, efl::eolian::to_cxx<bool>(include_pass_events_objects_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(include_hidden_objects_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_key_modifier_on_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_modifier_on(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_event_feed_mouse_up_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_mouse_up(b_, flags_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_mouse_down_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_mouse_down(b_, flags_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_event_refeed_event_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * event_copy_, Evas_Callback_Type event_type_)
+{
+   static_cast<T*>(self->this_)->event_refeed_event(event_copy_, event_type_);
+}
+
+template <typename T>
+efl::eina::range_list< std::string > evas_canvas_font_available_list_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->font_available_list();
+}
+
+template <typename T>
+efl::eina::range_list< evas::object > evas_canvas_objects_in_rectangle_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, Eina_Bool include_pass_events_objects_, Eina_Bool include_hidden_objects_)
+{
+   return static_cast<T*>(self->this_)->objects_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_cxx<bool>(include_pass_events_objects_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(include_hidden_objects_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+evas::object evas_canvas_object_name_find_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_)
+{
+   return static_cast<T*>(self->this_)->object_name_find(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_font_path_append_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * path_)
+{
+   static_cast<T*>(self->this_)->font_path_append(efl::eolian::to_cxx<std::string>(path_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+int evas_canvas_touch_point_list_nth_id_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int n_)
+{
+   return static_cast<T*>(self->this_)->touch_point_list_nth_id_get(n_);
+}
+
+template <typename T>
+void evas_canvas_font_path_clear_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->font_path_clear();
+}
+
+template <typename T>
+void evas_canvas_smart_objects_calculate_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->smart_objects_calculate();
+}
+
+template <typename T>
+void evas_canvas_touch_point_list_nth_xy_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int n_, Evas_Coord* x_, Evas_Coord* y_)
+{
+   static_cast<T*>(self->this_)->touch_point_list_nth_xy_get(n_, x_, y_);
+}
+
+template <typename T>
+void evas_canvas_key_lock_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_lock_del(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_damage_rectangle_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_, int y_, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->damage_rectangle_add(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_canvas_sync_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->sync();
+}
+
+template <typename T>
+efl::eina::crange_list< std::string > evas_canvas_font_path_list_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->font_path_list();
+}
+
+template <typename T>
+void evas_canvas_image_cache_reload_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->image_cache_reload();
+}
+
+template <typename T>
+int evas_canvas_coord_world_x_to_screen_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_)
+{
+   return static_cast<T*>(self->this_)->coord_world_x_to_screen(x_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_multi_move_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_);
+}
+
+template <typename T>
+efl::eina::list< Eina_Rectangle * > evas_canvas_render_updates_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->render_updates();
+}
+
+template <typename T>
+void evas_canvas_image_cache_flush_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->image_cache_flush();
+}
+
+template <typename T>
+Evas_Coord evas_canvas_coord_screen_y_to_world_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int y_)
+{
+   return static_cast<T*>(self->this_)->coord_screen_y_to_world(y_);
+}
+
+template <typename T>
+void evas_canvas_key_modifier_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_modifier_del(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Touch_Point_State evas_canvas_touch_point_list_nth_state_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int n_)
+{
+   return static_cast<T*>(self->this_)->touch_point_list_nth_state_get(n_);
+}
+
+template <typename T>
+void evas_canvas_focus_in_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->focus_in();
+}
+
+template <typename T>
+void evas_canvas_obscured_rectangle_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_, int y_, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->obscured_rectangle_add(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_canvas_render_dump_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->render_dump();
+}
+
+template <typename T>
+void evas_canvas_event_feed_mouse_in_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_mouse_in(timestamp_, data_);
+}
+
+template <typename T>
+evas::object evas_canvas_object_top_in_rectangle_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, Eina_Bool include_pass_events_objects_, Eina_Bool include_hidden_objects_)
+{
+   return static_cast<T*>(self->this_)->object_top_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_cxx<bool>(include_pass_events_objects_, std::tuple<std::false_type>()), efl::eolian::to_cxx<bool>(include_hidden_objects_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_render_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->render();
+}
+
+template <typename T>
+void evas_canvas_event_feed_multi_up_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_);
+}
+
+template <typename T>
+void evas_canvas_font_path_prepend_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * path_)
+{
+   static_cast<T*>(self->this_)->font_path_prepend(efl::eolian::to_cxx<std::string>(path_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_obscured_clear_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->obscured_clear();
+}
+
+template <typename T>
+void evas_canvas_event_feed_mouse_cancel_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int timestamp_, const void * data_)
+{
+   static_cast<T*>(self->this_)->event_feed_mouse_cancel(timestamp_, data_);
+}
+
+template <typename T>
+Evas_Coord evas_canvas_coord_screen_x_to_world_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_)
+{
+   return static_cast<T*>(self->this_)->coord_screen_x_to_world(x_);
+}
+
+template <typename T>
+void evas_canvas_key_lock_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_)
+{
+   static_cast<T*>(self->this_)->key_lock_add(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_canvas_render_idle_flush_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->render_idle_flush();
+}
+
+template <typename T>
+int evas_canvas_coord_world_y_to_screen_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord y_)
+{
+   return static_cast<T*>(self->this_)->coord_world_y_to_screen(y_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_key_down_with_keycode_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_, const char * key_, const char * string_, const char * compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_)
+{
+   static_cast<T*>(self->this_)->event_feed_key_down_with_keycode(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(string_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(compose_, std::tuple<std::false_type>()), timestamp_, data_, keycode_);
+}
+
+template <typename T>
+void evas_canvas_event_feed_key_up_with_keycode_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_, const char * key_, const char * string_, const char * compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_)
+{
+   static_cast<T*>(self->this_)->event_feed_key_up_with_keycode(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(string_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(compose_, std::tuple<std::false_type>()), timestamp_, data_, keycode_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::canvas >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void event_thaw()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_event_thaw());
+      }
+
+      virtual void event_freeze()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_event_freeze());
+      }
+
+      virtual Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+      virtual void output_framespace_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_output_framespace_get(x_, y_, w_, h_));
+      }
+
+      virtual void output_framespace_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_output_framespace_set(x_, y_, w_, h_));
+      }
+
+      virtual void output_viewport_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_output_viewport_get(x_, y_, w_, h_));
+      }
+
+      virtual void output_viewport_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_output_viewport_set(x_, y_, w_, h_));
+      }
+
+      virtual int image_cache_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_image_cache_get());
+            return _tmp_ret;
+      }
+
+      virtual void image_cache_set(int size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_image_cache_set(size_));
+      }
+
+      virtual Evas_Event_Flags event_default_flags_get()
+      {
+         Evas_Event_Flags _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_event_default_flags_get());
+            return _tmp_ret;
+      }
+
+      virtual void event_default_flags_set(Evas_Event_Flags flags_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_default_flags_set(flags_));
+      }
+
+      virtual int output_method_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_output_method_get());
+            return _tmp_ret;
+      }
+
+      virtual void output_method_set(int render_method_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_output_method_set(render_method_));
+      }
+
+      virtual int font_cache_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_font_cache_get());
+            return _tmp_ret;
+      }
+
+      virtual void font_cache_set(int size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_font_cache_set(size_));
+      }
+
+      virtual void output_size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_output_size_get(w_, h_));
+      }
+
+      virtual void output_size_set(int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_output_size_set(w_, h_));
+      }
+
+      virtual void * data_attach_get()
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_data_attach_get());
+            return _tmp_ret;
+      }
+
+      virtual void data_attach_set(void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_data_attach_set(data_));
+      }
+
+      virtual Evas_Font_Hinting_Flags font_hinting_get()
+      {
+         Evas_Font_Hinting_Flags _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_font_hinting_get());
+            return _tmp_ret;
+      }
+
+      virtual void font_hinting_set(Evas_Font_Hinting_Flags hinting_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_font_hinting_set(hinting_));
+      }
+
+      virtual Evas_Engine_Info * engine_info_get()
+      {
+         Evas_Engine_Info * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_engine_info_get());
+            return _tmp_ret;
+      }
+
+      virtual bool engine_info_set(Evas_Engine_Info * info_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_engine_info_set(info_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object focus_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_focus_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object object_top_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_object_top_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual const Evas_Lock * key_lock_get()
+      {
+         const Evas_Lock * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_key_lock_get());
+            return _tmp_ret;
+      }
+
+      virtual void pointer_canvas_xy_get(Evas_Coord* x_, Evas_Coord* y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_pointer_canvas_xy_get(x_, y_));
+      }
+
+      virtual int event_down_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_event_down_count_get());
+            return _tmp_ret;
+      }
+
+      virtual int smart_objects_calculate_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_smart_objects_calculate_count_get());
+            return _tmp_ret;
+      }
+
+      virtual bool focus_state_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_focus_state_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool changed_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_changed_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void pointer_output_xy_get(int* x_, int* y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_pointer_output_xy_get(x_, y_));
+      }
+
+      virtual bool pointer_inside_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_pointer_inside_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool image_max_size_get(int* maxw_, int* maxh_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_image_max_size_get(maxw_, maxh_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object object_bottom_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_object_bottom_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual const Evas_Modifier * key_modifier_get()
+      {
+         const Evas_Modifier * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_key_modifier_get());
+            return _tmp_ret;
+      }
+
+      virtual int pointer_button_down_mask_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_pointer_button_down_mask_get());
+            return _tmp_ret;
+      }
+
+      virtual efl::eina::range_list< evas::object > tree_objects_at_xy_get(evas::object stop_, int x_, int y_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_tree_objects_at_xy_get(efl::eolian::to_c(stop_), x_, y_));
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual void event_feed_mouse_wheel(int direction_, int z_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_mouse_wheel(direction_, z_, timestamp_, data_));
+      }
+
+      virtual void key_lock_on(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_lock_on(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual void event_feed_key_down(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_key_down(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_));
+      }
+
+      virtual Evas_Modifier_Mask key_modifier_mask_get(std::string keyname_)
+      {
+         Evas_Modifier_Mask _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_key_modifier_mask_get(efl::eolian::to_c(keyname_)));
+            return _tmp_ret;
+      }
+
+      virtual void key_modifier_add(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_modifier_add(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual void key_modifier_off(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_modifier_off(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual void event_feed_hold(int hold_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_hold(hold_, timestamp_, data_));
+      }
+
+      virtual void event_feed_mouse_move(int x_, int y_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_mouse_move(x_, y_, timestamp_, data_));
+      }
+
+      virtual void event_feed_key_up(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_key_up(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_));
+      }
+
+      virtual void event_feed_mouse_out(unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_mouse_out(timestamp_, data_));
+      }
+
+      virtual void event_input_multi_move(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_input_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_));
+      }
+
+      virtual efl::eina::range_list< evas::object > objects_at_xy_get(Evas_Coord x_, Evas_Coord y_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_objects_at_xy_get(x_, y_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual void event_input_multi_up(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_input_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      virtual void event_feed_multi_down(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      virtual bool render_async()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_render_async());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void focus_out()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_focus_out());
+      }
+
+      virtual void event_input_mouse_move(int x_, int y_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_input_mouse_move(x_, y_, timestamp_, data_));
+      }
+
+      virtual void norender()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_norender());
+      }
+
+      virtual unsigned int touch_point_list_count()
+      {
+         unsigned int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_touch_point_list_count());
+            return _tmp_ret;
+      }
+
+      virtual void event_input_multi_down(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_input_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      virtual void nochange_pop()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_nochange_pop());
+      }
+
+      virtual void key_lock_off(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_lock_off(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual void nochange_push()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_nochange_push());
+      }
+
+      virtual void font_cache_flush()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_font_cache_flush());
+      }
+
+      virtual bool font_hinting_can_hint(Evas_Font_Hinting_Flags hinting_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_font_hinting_can_hint(hinting_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object object_top_at_xy_get(Evas_Coord x_, Evas_Coord y_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_object_top_at_xy_get(x_, y_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void key_modifier_on(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_modifier_on(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual void event_feed_mouse_up(int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_mouse_up(b_, flags_, timestamp_, data_));
+      }
+
+      virtual void event_feed_mouse_down(int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_mouse_down(b_, flags_, timestamp_, data_));
+      }
+
+      virtual void event_refeed_event(void * event_copy_, Evas_Callback_Type event_type_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_refeed_event(event_copy_, event_type_));
+      }
+
+      virtual efl::eina::range_list< std::string > font_available_list()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_font_available_list());
+            return efl::eolian::to_cxx<efl::eina::range_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual efl::eina::range_list< evas::object > objects_in_rectangle_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_objects_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual evas::object object_name_find(std::string name_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_object_name_find(efl::eolian::to_c(name_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void font_path_append(std::string path_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_font_path_append(efl::eolian::to_c(path_)));
+      }
+
+      virtual int touch_point_list_nth_id_get(unsigned int n_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_touch_point_list_nth_id_get(n_));
+            return _tmp_ret;
+      }
+
+      virtual void font_path_clear()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_font_path_clear());
+      }
+
+      virtual void smart_objects_calculate()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_smart_objects_calculate());
+      }
+
+      virtual void touch_point_list_nth_xy_get(unsigned int n_, Evas_Coord* x_, Evas_Coord* y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_touch_point_list_nth_xy_get(n_, x_, y_));
+      }
+
+      virtual void key_lock_del(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_lock_del(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual void damage_rectangle_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_damage_rectangle_add(x_, y_, w_, h_));
+      }
+
+      virtual void sync()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_sync());
+      }
+
+      virtual efl::eina::crange_list< std::string > font_path_list()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_font_path_list());
+            return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual void image_cache_reload()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_image_cache_reload());
+      }
+
+      virtual int coord_world_x_to_screen(Evas_Coord x_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_coord_world_x_to_screen(x_));
+            return _tmp_ret;
+      }
+
+      virtual void event_feed_multi_move(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_));
+      }
+
+      virtual efl::eina::list< Eina_Rectangle * > render_updates()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_render_updates());
+            return efl::eolian::to_cxx<efl::eina::list< Eina_Rectangle * >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+      }
+
+      virtual void image_cache_flush()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_image_cache_flush());
+      }
+
+      virtual Evas_Coord coord_screen_y_to_world(int y_)
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_coord_screen_y_to_world(y_));
+            return _tmp_ret;
+      }
+
+      virtual void key_modifier_del(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_modifier_del(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual Evas_Touch_Point_State touch_point_list_nth_state_get(unsigned int n_)
+      {
+         Evas_Touch_Point_State _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_touch_point_list_nth_state_get(n_));
+            return _tmp_ret;
+      }
+
+      virtual void focus_in()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_focus_in());
+      }
+
+      virtual void obscured_rectangle_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_obscured_rectangle_add(x_, y_, w_, h_));
+      }
+
+      virtual void render_dump()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_render_dump());
+      }
+
+      virtual void event_feed_mouse_in(unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_mouse_in(timestamp_, data_));
+      }
+
+      virtual evas::object object_top_in_rectangle_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_object_top_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void render()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_render());
+      }
+
+      virtual void event_feed_multi_up(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      virtual void font_path_prepend(std::string path_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_font_path_prepend(efl::eolian::to_c(path_)));
+      }
+
+      virtual void obscured_clear()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_obscured_clear());
+      }
+
+      virtual void event_feed_mouse_cancel(unsigned int timestamp_, const void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_mouse_cancel(timestamp_, data_));
+      }
+
+      virtual Evas_Coord coord_screen_x_to_world(int x_)
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_coord_screen_x_to_world(x_));
+            return _tmp_ret;
+      }
+
+      virtual void key_lock_add(std::string keyname_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_key_lock_add(efl::eolian::to_c(keyname_)));
+      }
+
+      virtual void render_idle_flush()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_render_idle_flush());
+      }
+
+      virtual int coord_world_y_to_screen(Evas_Coord y_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_canvas_coord_world_y_to_screen(y_));
+            return _tmp_ret;
+      }
+
+      virtual void event_feed_key_down_with_keycode(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_key_down_with_keycode(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_, keycode_));
+      }
+
+      virtual void event_feed_key_up_with_keycode(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_canvas_event_feed_key_up_with_keycode(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_, keycode_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::canvas >
+{
+   static const int value = 104;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::canvas>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_canvas_event_thaw_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_event_thaw);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_canvas_event_freeze_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::eo_event_freeze);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_canvas_evas_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_common_evas_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_canvas_output_framespace_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_framespace_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_canvas_output_framespace_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_framespace_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_canvas_output_viewport_get_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_viewport_get);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_canvas_output_viewport_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_viewport_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_get_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_get);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_canvas_event_default_flags_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_default_flags_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_canvas_event_default_flags_set_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_default_flags_set);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_canvas_output_method_get_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_method_get);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_canvas_output_method_set_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_method_set);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_canvas_font_cache_get_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_cache_get);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_canvas_font_cache_set_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_cache_set);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_canvas_output_size_get_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_size_get);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_canvas_output_size_set_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_canvas_output_size_set);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_canvas_data_attach_get_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_canvas_data_attach_get);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_canvas_data_attach_set_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_canvas_data_attach_set);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_canvas_font_hinting_get_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_hinting_get);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_canvas_font_hinting_set_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_hinting_set);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_canvas_engine_info_get_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_canvas_engine_info_get);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::evas_canvas_engine_info_set_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_canvas_engine_info_set);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::evas_canvas_focus_get_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_canvas_focus_get);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::evas_canvas_object_top_get_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_canvas_object_top_get);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_get_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_get);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::evas_canvas_pointer_canvas_xy_get_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_canvas_pointer_canvas_xy_get);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::evas_canvas_event_down_count_get_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_down_count_get);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::evas_canvas_smart_objects_calculate_count_get_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::evas_canvas_smart_objects_calculate_count_get);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   ops[29].func = reinterpret_cast<void*>(& ::evas_canvas_focus_state_get_wrapper<T>);
+   ops[29].api_func = reinterpret_cast<void*>(& ::evas_canvas_focus_state_get);
+   ops[29].op = EO_OP_OVERRIDE;
+   ops[29].op_type = EO_OP_TYPE_REGULAR;
+   ops[29].doc = NULL;
+
+   ops[30].func = reinterpret_cast<void*>(& ::evas_canvas_changed_get_wrapper<T>);
+   ops[30].api_func = reinterpret_cast<void*>(& ::evas_canvas_changed_get);
+   ops[30].op = EO_OP_OVERRIDE;
+   ops[30].op_type = EO_OP_TYPE_REGULAR;
+   ops[30].doc = NULL;
+
+   ops[31].func = reinterpret_cast<void*>(& ::evas_canvas_pointer_output_xy_get_wrapper<T>);
+   ops[31].api_func = reinterpret_cast<void*>(& ::evas_canvas_pointer_output_xy_get);
+   ops[31].op = EO_OP_OVERRIDE;
+   ops[31].op_type = EO_OP_TYPE_REGULAR;
+   ops[31].doc = NULL;
+
+   ops[32].func = reinterpret_cast<void*>(& ::evas_canvas_pointer_inside_get_wrapper<T>);
+   ops[32].api_func = reinterpret_cast<void*>(& ::evas_canvas_pointer_inside_get);
+   ops[32].op = EO_OP_OVERRIDE;
+   ops[32].op_type = EO_OP_TYPE_REGULAR;
+   ops[32].doc = NULL;
+
+   ops[33].func = reinterpret_cast<void*>(& ::evas_canvas_image_max_size_get_wrapper<T>);
+   ops[33].api_func = reinterpret_cast<void*>(& ::evas_canvas_image_max_size_get);
+   ops[33].op = EO_OP_OVERRIDE;
+   ops[33].op_type = EO_OP_TYPE_REGULAR;
+   ops[33].doc = NULL;
+
+   ops[34].func = reinterpret_cast<void*>(& ::evas_canvas_object_bottom_get_wrapper<T>);
+   ops[34].api_func = reinterpret_cast<void*>(& ::evas_canvas_object_bottom_get);
+   ops[34].op = EO_OP_OVERRIDE;
+   ops[34].op_type = EO_OP_TYPE_REGULAR;
+   ops[34].doc = NULL;
+
+   ops[35].func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_get_wrapper<T>);
+   ops[35].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_get);
+   ops[35].op = EO_OP_OVERRIDE;
+   ops[35].op_type = EO_OP_TYPE_REGULAR;
+   ops[35].doc = NULL;
+
+   ops[36].func = reinterpret_cast<void*>(& ::evas_canvas_pointer_button_down_mask_get_wrapper<T>);
+   ops[36].api_func = reinterpret_cast<void*>(& ::evas_canvas_pointer_button_down_mask_get);
+   ops[36].op = EO_OP_OVERRIDE;
+   ops[36].op_type = EO_OP_TYPE_REGULAR;
+   ops[36].doc = NULL;
+
+   ops[37].func = reinterpret_cast<void*>(& ::evas_canvas_tree_objects_at_xy_get_wrapper<T>);
+   ops[37].api_func = reinterpret_cast<void*>(& ::evas_canvas_tree_objects_at_xy_get);
+   ops[37].op = EO_OP_OVERRIDE;
+   ops[37].op_type = EO_OP_TYPE_REGULAR;
+   ops[37].doc = NULL;
+
+   ops[38].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_wheel_wrapper<T>);
+   ops[38].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_wheel);
+   ops[38].op = EO_OP_OVERRIDE;
+   ops[38].op_type = EO_OP_TYPE_REGULAR;
+   ops[38].doc = NULL;
+
+   ops[39].func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_on_wrapper<T>);
+   ops[39].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_on);
+   ops[39].op = EO_OP_OVERRIDE;
+   ops[39].op_type = EO_OP_TYPE_REGULAR;
+   ops[39].doc = NULL;
+
+   ops[40].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_down_wrapper<T>);
+   ops[40].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_down);
+   ops[40].op = EO_OP_OVERRIDE;
+   ops[40].op_type = EO_OP_TYPE_REGULAR;
+   ops[40].doc = NULL;
+
+   ops[41].func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_mask_get_wrapper<T>);
+   ops[41].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_mask_get);
+   ops[41].op = EO_OP_OVERRIDE;
+   ops[41].op_type = EO_OP_TYPE_REGULAR;
+   ops[41].doc = NULL;
+
+   ops[42].func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_add_wrapper<T>);
+   ops[42].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_add);
+   ops[42].op = EO_OP_OVERRIDE;
+   ops[42].op_type = EO_OP_TYPE_REGULAR;
+   ops[42].doc = NULL;
+
+   ops[43].func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_off_wrapper<T>);
+   ops[43].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_off);
+   ops[43].op = EO_OP_OVERRIDE;
+   ops[43].op_type = EO_OP_TYPE_REGULAR;
+   ops[43].doc = NULL;
+
+   ops[44].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_hold_wrapper<T>);
+   ops[44].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_hold);
+   ops[44].op = EO_OP_OVERRIDE;
+   ops[44].op_type = EO_OP_TYPE_REGULAR;
+   ops[44].doc = NULL;
+
+   ops[45].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_move_wrapper<T>);
+   ops[45].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_move);
+   ops[45].op = EO_OP_OVERRIDE;
+   ops[45].op_type = EO_OP_TYPE_REGULAR;
+   ops[45].doc = NULL;
+
+   ops[46].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_up_wrapper<T>);
+   ops[46].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_up);
+   ops[46].op = EO_OP_OVERRIDE;
+   ops[46].op_type = EO_OP_TYPE_REGULAR;
+   ops[46].doc = NULL;
+
+   ops[47].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_out_wrapper<T>);
+   ops[47].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_out);
+   ops[47].op = EO_OP_OVERRIDE;
+   ops[47].op_type = EO_OP_TYPE_REGULAR;
+   ops[47].doc = NULL;
+
+   ops[48].func = reinterpret_cast<void*>(& ::evas_canvas_event_input_multi_move_wrapper<T>);
+   ops[48].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_input_multi_move);
+   ops[48].op = EO_OP_OVERRIDE;
+   ops[48].op_type = EO_OP_TYPE_REGULAR;
+   ops[48].doc = NULL;
+
+   ops[49].func = reinterpret_cast<void*>(& ::evas_canvas_objects_at_xy_get_wrapper<T>);
+   ops[49].api_func = reinterpret_cast<void*>(& ::evas_canvas_objects_at_xy_get);
+   ops[49].op = EO_OP_OVERRIDE;
+   ops[49].op_type = EO_OP_TYPE_REGULAR;
+   ops[49].doc = NULL;
+
+   ops[50].func = reinterpret_cast<void*>(& ::evas_canvas_event_input_multi_up_wrapper<T>);
+   ops[50].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_input_multi_up);
+   ops[50].op = EO_OP_OVERRIDE;
+   ops[50].op_type = EO_OP_TYPE_REGULAR;
+   ops[50].doc = NULL;
+
+   ops[51].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_multi_down_wrapper<T>);
+   ops[51].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_multi_down);
+   ops[51].op = EO_OP_OVERRIDE;
+   ops[51].op_type = EO_OP_TYPE_REGULAR;
+   ops[51].doc = NULL;
+
+   ops[52].func = reinterpret_cast<void*>(& ::evas_canvas_render_async_wrapper<T>);
+   ops[52].api_func = reinterpret_cast<void*>(& ::evas_canvas_render_async);
+   ops[52].op = EO_OP_OVERRIDE;
+   ops[52].op_type = EO_OP_TYPE_REGULAR;
+   ops[52].doc = NULL;
+
+   ops[53].func = reinterpret_cast<void*>(& ::evas_canvas_focus_out_wrapper<T>);
+   ops[53].api_func = reinterpret_cast<void*>(& ::evas_canvas_focus_out);
+   ops[53].op = EO_OP_OVERRIDE;
+   ops[53].op_type = EO_OP_TYPE_REGULAR;
+   ops[53].doc = NULL;
+
+   ops[54].func = reinterpret_cast<void*>(& ::evas_canvas_event_input_mouse_move_wrapper<T>);
+   ops[54].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_input_mouse_move);
+   ops[54].op = EO_OP_OVERRIDE;
+   ops[54].op_type = EO_OP_TYPE_REGULAR;
+   ops[54].doc = NULL;
+
+   ops[55].func = reinterpret_cast<void*>(& ::evas_canvas_norender_wrapper<T>);
+   ops[55].api_func = reinterpret_cast<void*>(& ::evas_canvas_norender);
+   ops[55].op = EO_OP_OVERRIDE;
+   ops[55].op_type = EO_OP_TYPE_REGULAR;
+   ops[55].doc = NULL;
+
+   ops[56].func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_count_wrapper<T>);
+   ops[56].api_func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_count);
+   ops[56].op = EO_OP_OVERRIDE;
+   ops[56].op_type = EO_OP_TYPE_REGULAR;
+   ops[56].doc = NULL;
+
+   ops[57].func = reinterpret_cast<void*>(& ::evas_canvas_event_input_multi_down_wrapper<T>);
+   ops[57].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_input_multi_down);
+   ops[57].op = EO_OP_OVERRIDE;
+   ops[57].op_type = EO_OP_TYPE_REGULAR;
+   ops[57].doc = NULL;
+
+   ops[58].func = reinterpret_cast<void*>(& ::evas_canvas_nochange_pop_wrapper<T>);
+   ops[58].api_func = reinterpret_cast<void*>(& ::evas_canvas_nochange_pop);
+   ops[58].op = EO_OP_OVERRIDE;
+   ops[58].op_type = EO_OP_TYPE_REGULAR;
+   ops[58].doc = NULL;
+
+   ops[59].func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_off_wrapper<T>);
+   ops[59].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_off);
+   ops[59].op = EO_OP_OVERRIDE;
+   ops[59].op_type = EO_OP_TYPE_REGULAR;
+   ops[59].doc = NULL;
+
+   ops[60].func = reinterpret_cast<void*>(& ::evas_canvas_nochange_push_wrapper<T>);
+   ops[60].api_func = reinterpret_cast<void*>(& ::evas_canvas_nochange_push);
+   ops[60].op = EO_OP_OVERRIDE;
+   ops[60].op_type = EO_OP_TYPE_REGULAR;
+   ops[60].doc = NULL;
+
+   ops[61].func = reinterpret_cast<void*>(& ::evas_canvas_font_cache_flush_wrapper<T>);
+   ops[61].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_cache_flush);
+   ops[61].op = EO_OP_OVERRIDE;
+   ops[61].op_type = EO_OP_TYPE_REGULAR;
+   ops[61].doc = NULL;
+
+   ops[62].func = reinterpret_cast<void*>(& ::evas_canvas_font_hinting_can_hint_wrapper<T>);
+   ops[62].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_hinting_can_hint);
+   ops[62].op = EO_OP_OVERRIDE;
+   ops[62].op_type = EO_OP_TYPE_REGULAR;
+   ops[62].doc = NULL;
+
+   ops[63].func = reinterpret_cast<void*>(& ::evas_canvas_object_top_at_xy_get_wrapper<T>);
+   ops[63].api_func = reinterpret_cast<void*>(& ::evas_canvas_object_top_at_xy_get);
+   ops[63].op = EO_OP_OVERRIDE;
+   ops[63].op_type = EO_OP_TYPE_REGULAR;
+   ops[63].doc = NULL;
+
+   ops[64].func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_on_wrapper<T>);
+   ops[64].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_on);
+   ops[64].op = EO_OP_OVERRIDE;
+   ops[64].op_type = EO_OP_TYPE_REGULAR;
+   ops[64].doc = NULL;
+
+   ops[65].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_up_wrapper<T>);
+   ops[65].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_up);
+   ops[65].op = EO_OP_OVERRIDE;
+   ops[65].op_type = EO_OP_TYPE_REGULAR;
+   ops[65].doc = NULL;
+
+   ops[66].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_down_wrapper<T>);
+   ops[66].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_down);
+   ops[66].op = EO_OP_OVERRIDE;
+   ops[66].op_type = EO_OP_TYPE_REGULAR;
+   ops[66].doc = NULL;
+
+   ops[67].func = reinterpret_cast<void*>(& ::evas_canvas_event_refeed_event_wrapper<T>);
+   ops[67].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_refeed_event);
+   ops[67].op = EO_OP_OVERRIDE;
+   ops[67].op_type = EO_OP_TYPE_REGULAR;
+   ops[67].doc = NULL;
+
+   ops[68].func = reinterpret_cast<void*>(& ::evas_canvas_font_available_list_wrapper<T>);
+   ops[68].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_available_list);
+   ops[68].op = EO_OP_OVERRIDE;
+   ops[68].op_type = EO_OP_TYPE_REGULAR;
+   ops[68].doc = NULL;
+
+   ops[69].func = reinterpret_cast<void*>(& ::evas_canvas_objects_in_rectangle_get_wrapper<T>);
+   ops[69].api_func = reinterpret_cast<void*>(& ::evas_canvas_objects_in_rectangle_get);
+   ops[69].op = EO_OP_OVERRIDE;
+   ops[69].op_type = EO_OP_TYPE_REGULAR;
+   ops[69].doc = NULL;
+
+   ops[70].func = reinterpret_cast<void*>(& ::evas_canvas_object_name_find_wrapper<T>);
+   ops[70].api_func = reinterpret_cast<void*>(& ::evas_canvas_object_name_find);
+   ops[70].op = EO_OP_OVERRIDE;
+   ops[70].op_type = EO_OP_TYPE_REGULAR;
+   ops[70].doc = NULL;
+
+   ops[71].func = reinterpret_cast<void*>(& ::evas_canvas_font_path_append_wrapper<T>);
+   ops[71].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_path_append);
+   ops[71].op = EO_OP_OVERRIDE;
+   ops[71].op_type = EO_OP_TYPE_REGULAR;
+   ops[71].doc = NULL;
+
+   ops[72].func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_nth_id_get_wrapper<T>);
+   ops[72].api_func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_nth_id_get);
+   ops[72].op = EO_OP_OVERRIDE;
+   ops[72].op_type = EO_OP_TYPE_REGULAR;
+   ops[72].doc = NULL;
+
+   ops[73].func = reinterpret_cast<void*>(& ::evas_canvas_font_path_clear_wrapper<T>);
+   ops[73].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_path_clear);
+   ops[73].op = EO_OP_OVERRIDE;
+   ops[73].op_type = EO_OP_TYPE_REGULAR;
+   ops[73].doc = NULL;
+
+   ops[74].func = reinterpret_cast<void*>(& ::evas_canvas_smart_objects_calculate_wrapper<T>);
+   ops[74].api_func = reinterpret_cast<void*>(& ::evas_canvas_smart_objects_calculate);
+   ops[74].op = EO_OP_OVERRIDE;
+   ops[74].op_type = EO_OP_TYPE_REGULAR;
+   ops[74].doc = NULL;
+
+   ops[75].func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_nth_xy_get_wrapper<T>);
+   ops[75].api_func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_nth_xy_get);
+   ops[75].op = EO_OP_OVERRIDE;
+   ops[75].op_type = EO_OP_TYPE_REGULAR;
+   ops[75].doc = NULL;
+
+   ops[76].func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_del_wrapper<T>);
+   ops[76].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_del);
+   ops[76].op = EO_OP_OVERRIDE;
+   ops[76].op_type = EO_OP_TYPE_REGULAR;
+   ops[76].doc = NULL;
+
+   ops[77].func = reinterpret_cast<void*>(& ::evas_canvas_damage_rectangle_add_wrapper<T>);
+   ops[77].api_func = reinterpret_cast<void*>(& ::evas_canvas_damage_rectangle_add);
+   ops[77].op = EO_OP_OVERRIDE;
+   ops[77].op_type = EO_OP_TYPE_REGULAR;
+   ops[77].doc = NULL;
+
+   ops[78].func = reinterpret_cast<void*>(& ::evas_canvas_sync_wrapper<T>);
+   ops[78].api_func = reinterpret_cast<void*>(& ::evas_canvas_sync);
+   ops[78].op = EO_OP_OVERRIDE;
+   ops[78].op_type = EO_OP_TYPE_REGULAR;
+   ops[78].doc = NULL;
+
+   ops[79].func = reinterpret_cast<void*>(& ::evas_canvas_font_path_list_wrapper<T>);
+   ops[79].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_path_list);
+   ops[79].op = EO_OP_OVERRIDE;
+   ops[79].op_type = EO_OP_TYPE_REGULAR;
+   ops[79].doc = NULL;
+
+   ops[80].func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_reload_wrapper<T>);
+   ops[80].api_func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_reload);
+   ops[80].op = EO_OP_OVERRIDE;
+   ops[80].op_type = EO_OP_TYPE_REGULAR;
+   ops[80].doc = NULL;
+
+   ops[81].func = reinterpret_cast<void*>(& ::evas_canvas_coord_world_x_to_screen_wrapper<T>);
+   ops[81].api_func = reinterpret_cast<void*>(& ::evas_canvas_coord_world_x_to_screen);
+   ops[81].op = EO_OP_OVERRIDE;
+   ops[81].op_type = EO_OP_TYPE_REGULAR;
+   ops[81].doc = NULL;
+
+   ops[82].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_multi_move_wrapper<T>);
+   ops[82].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_multi_move);
+   ops[82].op = EO_OP_OVERRIDE;
+   ops[82].op_type = EO_OP_TYPE_REGULAR;
+   ops[82].doc = NULL;
+
+   ops[83].func = reinterpret_cast<void*>(& ::evas_canvas_render_updates_wrapper<T>);
+   ops[83].api_func = reinterpret_cast<void*>(& ::evas_canvas_render_updates);
+   ops[83].op = EO_OP_OVERRIDE;
+   ops[83].op_type = EO_OP_TYPE_REGULAR;
+   ops[83].doc = NULL;
+
+   ops[84].func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_flush_wrapper<T>);
+   ops[84].api_func = reinterpret_cast<void*>(& ::evas_canvas_image_cache_flush);
+   ops[84].op = EO_OP_OVERRIDE;
+   ops[84].op_type = EO_OP_TYPE_REGULAR;
+   ops[84].doc = NULL;
+
+   ops[85].func = reinterpret_cast<void*>(& ::evas_canvas_coord_screen_y_to_world_wrapper<T>);
+   ops[85].api_func = reinterpret_cast<void*>(& ::evas_canvas_coord_screen_y_to_world);
+   ops[85].op = EO_OP_OVERRIDE;
+   ops[85].op_type = EO_OP_TYPE_REGULAR;
+   ops[85].doc = NULL;
+
+   ops[86].func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_del_wrapper<T>);
+   ops[86].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_modifier_del);
+   ops[86].op = EO_OP_OVERRIDE;
+   ops[86].op_type = EO_OP_TYPE_REGULAR;
+   ops[86].doc = NULL;
+
+   ops[87].func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_nth_state_get_wrapper<T>);
+   ops[87].api_func = reinterpret_cast<void*>(& ::evas_canvas_touch_point_list_nth_state_get);
+   ops[87].op = EO_OP_OVERRIDE;
+   ops[87].op_type = EO_OP_TYPE_REGULAR;
+   ops[87].doc = NULL;
+
+   ops[88].func = reinterpret_cast<void*>(& ::evas_canvas_focus_in_wrapper<T>);
+   ops[88].api_func = reinterpret_cast<void*>(& ::evas_canvas_focus_in);
+   ops[88].op = EO_OP_OVERRIDE;
+   ops[88].op_type = EO_OP_TYPE_REGULAR;
+   ops[88].doc = NULL;
+
+   ops[89].func = reinterpret_cast<void*>(& ::evas_canvas_obscured_rectangle_add_wrapper<T>);
+   ops[89].api_func = reinterpret_cast<void*>(& ::evas_canvas_obscured_rectangle_add);
+   ops[89].op = EO_OP_OVERRIDE;
+   ops[89].op_type = EO_OP_TYPE_REGULAR;
+   ops[89].doc = NULL;
+
+   ops[90].func = reinterpret_cast<void*>(& ::evas_canvas_render_dump_wrapper<T>);
+   ops[90].api_func = reinterpret_cast<void*>(& ::evas_canvas_render_dump);
+   ops[90].op = EO_OP_OVERRIDE;
+   ops[90].op_type = EO_OP_TYPE_REGULAR;
+   ops[90].doc = NULL;
+
+   ops[91].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_in_wrapper<T>);
+   ops[91].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_in);
+   ops[91].op = EO_OP_OVERRIDE;
+   ops[91].op_type = EO_OP_TYPE_REGULAR;
+   ops[91].doc = NULL;
+
+   ops[92].func = reinterpret_cast<void*>(& ::evas_canvas_object_top_in_rectangle_get_wrapper<T>);
+   ops[92].api_func = reinterpret_cast<void*>(& ::evas_canvas_object_top_in_rectangle_get);
+   ops[92].op = EO_OP_OVERRIDE;
+   ops[92].op_type = EO_OP_TYPE_REGULAR;
+   ops[92].doc = NULL;
+
+   ops[93].func = reinterpret_cast<void*>(& ::evas_canvas_render_wrapper<T>);
+   ops[93].api_func = reinterpret_cast<void*>(& ::evas_canvas_render);
+   ops[93].op = EO_OP_OVERRIDE;
+   ops[93].op_type = EO_OP_TYPE_REGULAR;
+   ops[93].doc = NULL;
+
+   ops[94].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_multi_up_wrapper<T>);
+   ops[94].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_multi_up);
+   ops[94].op = EO_OP_OVERRIDE;
+   ops[94].op_type = EO_OP_TYPE_REGULAR;
+   ops[94].doc = NULL;
+
+   ops[95].func = reinterpret_cast<void*>(& ::evas_canvas_font_path_prepend_wrapper<T>);
+   ops[95].api_func = reinterpret_cast<void*>(& ::evas_canvas_font_path_prepend);
+   ops[95].op = EO_OP_OVERRIDE;
+   ops[95].op_type = EO_OP_TYPE_REGULAR;
+   ops[95].doc = NULL;
+
+   ops[96].func = reinterpret_cast<void*>(& ::evas_canvas_obscured_clear_wrapper<T>);
+   ops[96].api_func = reinterpret_cast<void*>(& ::evas_canvas_obscured_clear);
+   ops[96].op = EO_OP_OVERRIDE;
+   ops[96].op_type = EO_OP_TYPE_REGULAR;
+   ops[96].doc = NULL;
+
+   ops[97].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_cancel_wrapper<T>);
+   ops[97].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_mouse_cancel);
+   ops[97].op = EO_OP_OVERRIDE;
+   ops[97].op_type = EO_OP_TYPE_REGULAR;
+   ops[97].doc = NULL;
+
+   ops[98].func = reinterpret_cast<void*>(& ::evas_canvas_coord_screen_x_to_world_wrapper<T>);
+   ops[98].api_func = reinterpret_cast<void*>(& ::evas_canvas_coord_screen_x_to_world);
+   ops[98].op = EO_OP_OVERRIDE;
+   ops[98].op_type = EO_OP_TYPE_REGULAR;
+   ops[98].doc = NULL;
+
+   ops[99].func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_add_wrapper<T>);
+   ops[99].api_func = reinterpret_cast<void*>(& ::evas_canvas_key_lock_add);
+   ops[99].op = EO_OP_OVERRIDE;
+   ops[99].op_type = EO_OP_TYPE_REGULAR;
+   ops[99].doc = NULL;
+
+   ops[100].func = reinterpret_cast<void*>(& ::evas_canvas_render_idle_flush_wrapper<T>);
+   ops[100].api_func = reinterpret_cast<void*>(& ::evas_canvas_render_idle_flush);
+   ops[100].op = EO_OP_OVERRIDE;
+   ops[100].op_type = EO_OP_TYPE_REGULAR;
+   ops[100].doc = NULL;
+
+   ops[101].func = reinterpret_cast<void*>(& ::evas_canvas_coord_world_y_to_screen_wrapper<T>);
+   ops[101].api_func = reinterpret_cast<void*>(& ::evas_canvas_coord_world_y_to_screen);
+   ops[101].op = EO_OP_OVERRIDE;
+   ops[101].op_type = EO_OP_TYPE_REGULAR;
+   ops[101].doc = NULL;
+
+   ops[102].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_down_with_keycode_wrapper<T>);
+   ops[102].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_down_with_keycode);
+   ops[102].op = EO_OP_OVERRIDE;
+   ops[102].op_type = EO_OP_TYPE_REGULAR;
+   ops[102].doc = NULL;
+
+   ops[103].func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_up_with_keycode_wrapper<T>);
+   ops[103].api_func = reinterpret_cast<void*>(& ::evas_canvas_event_feed_key_up_with_keycode);
+   ops[103].op = EO_OP_OVERRIDE;
+   ops[103].op_type = EO_OP_TYPE_REGULAR;
+   ops[103].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::canvas >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::canvas, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::canvas >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::canvas, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::canvas>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::canvas() const
+      {
+         return evas::canvas(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void event_thaw()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_event_thaw());
+      }
+
+      void event_freeze()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_event_freeze());
+      }
+
+      Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+      void output_framespace_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_output_framespace_get(x_, y_, w_, h_));
+      }
+
+      void output_framespace_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_output_framespace_set(x_, y_, w_, h_));
+      }
+
+      void output_viewport_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_output_viewport_get(x_, y_, w_, h_));
+      }
+
+      void output_viewport_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_output_viewport_set(x_, y_, w_, h_));
+      }
+
+      int image_cache_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_image_cache_get());
+            return _tmp_ret;
+      }
+
+      void image_cache_set(int size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_image_cache_set(size_));
+      }
+
+      Evas_Event_Flags event_default_flags_get()
+      {
+         Evas_Event_Flags _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_event_default_flags_get());
+            return _tmp_ret;
+      }
+
+      void event_default_flags_set(Evas_Event_Flags flags_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_default_flags_set(flags_));
+      }
+
+      int output_method_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_output_method_get());
+            return _tmp_ret;
+      }
+
+      void output_method_set(int render_method_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_output_method_set(render_method_));
+      }
+
+      int font_cache_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_font_cache_get());
+            return _tmp_ret;
+      }
+
+      void font_cache_set(int size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_font_cache_set(size_));
+      }
+
+      void output_size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_output_size_get(w_, h_));
+      }
+
+      void output_size_set(int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_output_size_set(w_, h_));
+      }
+
+      void * data_attach_get()
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_data_attach_get());
+            return _tmp_ret;
+      }
+
+      void data_attach_set(void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_data_attach_set(data_));
+      }
+
+      Evas_Font_Hinting_Flags font_hinting_get()
+      {
+         Evas_Font_Hinting_Flags _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_font_hinting_get());
+            return _tmp_ret;
+      }
+
+      void font_hinting_set(Evas_Font_Hinting_Flags hinting_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_font_hinting_set(hinting_));
+      }
+
+      Evas_Engine_Info * engine_info_get()
+      {
+         Evas_Engine_Info * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_engine_info_get());
+            return _tmp_ret;
+      }
+
+      bool engine_info_set(Evas_Engine_Info * info_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_engine_info_set(info_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object focus_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_focus_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object object_top_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_object_top_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      const Evas_Lock * key_lock_get()
+      {
+         const Evas_Lock * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_key_lock_get());
+            return _tmp_ret;
+      }
+
+      void pointer_canvas_xy_get(Evas_Coord* x_, Evas_Coord* y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_pointer_canvas_xy_get(x_, y_));
+      }
+
+      int event_down_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_event_down_count_get());
+            return _tmp_ret;
+      }
+
+      int smart_objects_calculate_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_smart_objects_calculate_count_get());
+            return _tmp_ret;
+      }
+
+      bool focus_state_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_focus_state_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool changed_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_changed_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void pointer_output_xy_get(int* x_, int* y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_pointer_output_xy_get(x_, y_));
+      }
+
+      bool pointer_inside_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_pointer_inside_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool image_max_size_get(int* maxw_, int* maxh_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_image_max_size_get(maxw_, maxh_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object object_bottom_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_object_bottom_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      const Evas_Modifier * key_modifier_get()
+      {
+         const Evas_Modifier * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_key_modifier_get());
+            return _tmp_ret;
+      }
+
+      int pointer_button_down_mask_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_pointer_button_down_mask_get());
+            return _tmp_ret;
+      }
+
+      efl::eina::range_list< evas::object > tree_objects_at_xy_get(evas::object stop_, int x_, int y_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_tree_objects_at_xy_get(efl::eolian::to_c(stop_), x_, y_));
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      void event_feed_mouse_wheel(int direction_, int z_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_mouse_wheel(direction_, z_, timestamp_, data_));
+      }
+
+      void key_lock_on(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_lock_on(efl::eolian::to_c(keyname_)));
+      }
+
+      void event_feed_key_down(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_key_down(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_));
+      }
+
+      Evas_Modifier_Mask key_modifier_mask_get(std::string keyname_)
+      {
+         Evas_Modifier_Mask _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_key_modifier_mask_get(efl::eolian::to_c(keyname_)));
+            return _tmp_ret;
+      }
+
+      void key_modifier_add(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_modifier_add(efl::eolian::to_c(keyname_)));
+      }
+
+      void key_modifier_off(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_modifier_off(efl::eolian::to_c(keyname_)));
+      }
+
+      void event_feed_hold(int hold_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_hold(hold_, timestamp_, data_));
+      }
+
+      void event_feed_mouse_move(int x_, int y_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_mouse_move(x_, y_, timestamp_, data_));
+      }
+
+      void event_feed_key_up(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_key_up(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_));
+      }
+
+      void event_feed_mouse_out(unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_mouse_out(timestamp_, data_));
+      }
+
+      void event_input_multi_move(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_input_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_));
+      }
+
+      efl::eina::range_list< evas::object > objects_at_xy_get(Evas_Coord x_, Evas_Coord y_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_objects_at_xy_get(x_, y_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      void event_input_multi_up(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_input_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      void event_feed_multi_down(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      bool render_async()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_render_async());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void focus_out()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_focus_out());
+      }
+
+      void event_input_mouse_move(int x_, int y_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_input_mouse_move(x_, y_, timestamp_, data_));
+      }
+
+      void norender()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_norender());
+      }
+
+      unsigned int touch_point_list_count()
+      {
+         unsigned int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_touch_point_list_count());
+            return _tmp_ret;
+      }
+
+      void event_input_multi_down(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_input_multi_down(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      void nochange_pop()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_nochange_pop());
+      }
+
+      void key_lock_off(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_lock_off(efl::eolian::to_c(keyname_)));
+      }
+
+      void nochange_push()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_nochange_push());
+      }
+
+      void font_cache_flush()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_font_cache_flush());
+      }
+
+      bool font_hinting_can_hint(Evas_Font_Hinting_Flags hinting_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_font_hinting_can_hint(hinting_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object object_top_at_xy_get(Evas_Coord x_, Evas_Coord y_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_object_top_at_xy_get(x_, y_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void key_modifier_on(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_modifier_on(efl::eolian::to_c(keyname_)));
+      }
+
+      void event_feed_mouse_up(int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_mouse_up(b_, flags_, timestamp_, data_));
+      }
+
+      void event_feed_mouse_down(int b_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_mouse_down(b_, flags_, timestamp_, data_));
+      }
+
+      void event_refeed_event(void * event_copy_, Evas_Callback_Type event_type_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_refeed_event(event_copy_, event_type_));
+      }
+
+      efl::eina::range_list< std::string > font_available_list()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_font_available_list());
+            return efl::eolian::to_cxx<efl::eina::range_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      efl::eina::range_list< evas::object > objects_in_rectangle_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_objects_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      evas::object object_name_find(std::string name_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_object_name_find(efl::eolian::to_c(name_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void font_path_append(std::string path_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_font_path_append(efl::eolian::to_c(path_)));
+      }
+
+      int touch_point_list_nth_id_get(unsigned int n_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_touch_point_list_nth_id_get(n_));
+            return _tmp_ret;
+      }
+
+      void font_path_clear()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_font_path_clear());
+      }
+
+      void smart_objects_calculate()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_smart_objects_calculate());
+      }
+
+      void touch_point_list_nth_xy_get(unsigned int n_, Evas_Coord* x_, Evas_Coord* y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_touch_point_list_nth_xy_get(n_, x_, y_));
+      }
+
+      void key_lock_del(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_lock_del(efl::eolian::to_c(keyname_)));
+      }
+
+      void damage_rectangle_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_damage_rectangle_add(x_, y_, w_, h_));
+      }
+
+      void sync()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_sync());
+      }
+
+      efl::eina::crange_list< std::string > font_path_list()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_font_path_list());
+            return efl::eolian::to_cxx<efl::eina::crange_list< std::string >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      void image_cache_reload()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_image_cache_reload());
+      }
+
+      int coord_world_x_to_screen(Evas_Coord x_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_coord_world_x_to_screen(x_));
+            return _tmp_ret;
+      }
+
+      void event_feed_multi_move(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_multi_move(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, timestamp_, data_));
+      }
+
+      efl::eina::list< Eina_Rectangle * > render_updates()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_render_updates());
+            return efl::eolian::to_cxx<efl::eina::list< Eina_Rectangle * >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+      }
+
+      void image_cache_flush()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_image_cache_flush());
+      }
+
+      Evas_Coord coord_screen_y_to_world(int y_)
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_coord_screen_y_to_world(y_));
+            return _tmp_ret;
+      }
+
+      void key_modifier_del(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_modifier_del(efl::eolian::to_c(keyname_)));
+      }
+
+      Evas_Touch_Point_State touch_point_list_nth_state_get(unsigned int n_)
+      {
+         Evas_Touch_Point_State _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_touch_point_list_nth_state_get(n_));
+            return _tmp_ret;
+      }
+
+      void focus_in()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_focus_in());
+      }
+
+      void obscured_rectangle_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_obscured_rectangle_add(x_, y_, w_, h_));
+      }
+
+      void render_dump()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_render_dump());
+      }
+
+      void event_feed_mouse_in(unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_mouse_in(timestamp_, data_));
+      }
+
+      evas::object object_top_in_rectangle_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_, bool include_pass_events_objects_, bool include_hidden_objects_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_object_top_in_rectangle_get(x_, y_, w_, h_, efl::eolian::to_c(include_pass_events_objects_), efl::eolian::to_c(include_hidden_objects_)));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void render()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_render());
+      }
+
+      void event_feed_multi_up(int d_, int x_, int y_, double rad_, double radx_, double rady_, double pres_, double ang_, double fx_, double fy_, Evas_Button_Flags flags_, unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_multi_up(d_, x_, y_, rad_, radx_, rady_, pres_, ang_, fx_, fy_, flags_, timestamp_, data_));
+      }
+
+      void font_path_prepend(std::string path_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_font_path_prepend(efl::eolian::to_c(path_)));
+      }
+
+      void obscured_clear()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_obscured_clear());
+      }
+
+      void event_feed_mouse_cancel(unsigned int timestamp_, const void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_mouse_cancel(timestamp_, data_));
+      }
+
+      Evas_Coord coord_screen_x_to_world(int x_)
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_coord_screen_x_to_world(x_));
+            return _tmp_ret;
+      }
+
+      void key_lock_add(std::string keyname_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_key_lock_add(efl::eolian::to_c(keyname_)));
+      }
+
+      void render_idle_flush()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_render_idle_flush());
+      }
+
+      int coord_world_y_to_screen(Evas_Coord y_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_canvas_coord_world_y_to_screen(y_));
+            return _tmp_ret;
+      }
+
+      void event_feed_key_down_with_keycode(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_key_down_with_keycode(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_, keycode_));
+      }
+
+      void event_feed_key_up_with_keycode(std::string keyname_, std::string key_, std::string string_, std::string compose_, unsigned int timestamp_, const void * data_, unsigned int keycode_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_canvas_event_feed_key_up_with_keycode(efl::eolian::to_c(keyname_), efl::eolian::to_c(key_), efl::eolian::to_c(string_), efl::eolian::to_c(compose_), timestamp_, data_, keycode_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::canvas>)
+{
+   return (EVAS_CANVAS_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_CANVAS_HH
+
diff -Naur a/src/lib/evas/canvas/evas_canvas.eo.legacy.h b/src/lib/evas/canvas/evas_canvas.eo.legacy.h
--- a/src/lib/evas/canvas/evas_canvas.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_canvas.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,1909 @@
+#ifndef _EVAS_CANVAS_EO_LEGACY_H_
+#define _EVAS_CANVAS_EO_LEGACY_H_
+
+#ifndef _EVAS_CANVAS_EO_CLASS_TYPE
+#define _EVAS_CANVAS_EO_CLASS_TYPE
+
+typedef Eo Evas_Canvas;
+
+#endif
+
+#ifndef _EVAS_CANVAS_EO_TYPES
+#define _EVAS_CANVAS_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Sets the output framespace size of the render engine of the given evas.
+ *
+ * The framespace size is used in the Wayland engines to denote space where
+ * the output is not drawn. This is mainly used in ecore_evas to draw borders
+ *
+ * The units used for @p w and @p h depend on the engine used by the
+ * evas.
+ *
+ * @ingroup Evas_Output_Size
+ * @since 1.1
+ *
+ * @param[in] x The left coordinate in output units, usually pixels.
+ * @param[in] y The top coordinate in output units, usually pixels.
+ * @param[in] w The width in output units, usually pixels.
+ * @param[in] h The height in output units, usually pixels.
+ */
+EAPI void evas_output_framespace_set(Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Get the render engine's output framespace co-ordinates in canvas units.
+ *
+ * @ingroup Evas_Output_Size
+ * @since 1.1
+ *
+ * @param[out] x The left coordinate in output units, usually pixels.
+ * @param[out] y The top coordinate in output units, usually pixels.
+ * @param[out] w The width in output units, usually pixels.
+ * @param[out] h The height in output units, usually pixels.
+ */
+EAPI void evas_output_framespace_get(const Evas_Canvas *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the output viewport of the given evas in evas units.
+ *
+ * The output viewport is the area of the evas that will be visible to
+ * the viewer.  The viewport will be stretched to fit the output
+ * target of the evas when rendering is performed.
+ *
+ * @note The coordinate values do not have to map 1-to-1 with the output
+ * target.  However, it is generally advised that it is done for ease
+ * of use.
+ *
+ * @ingroup Evas_Output_Size
+ *
+ * @param[in] x The top-left corner x value of the viewport.
+ * @param[in] y The top-left corner y value of the viewport.
+ * @param[in] w The width of the viewport.  Must be greater than 0.
+ * @param[in] h The height of the viewport.  Must be greater than 0.
+ */
+EAPI void evas_output_viewport_set(Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Get the render engine's output viewport co-ordinates in canvas units.
+ * Calling this function writes the current canvas output viewport
+ * size and location values into the variables pointed to by @p x, @p
+ * y, @p w and @p h.  On success the variables have the output
+ * location and size values written to them in canvas units. Any of @p
+ * x, @p y, @p w or @p h that are @c NULL will not be written to. If @p e
+ * is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Coord x, y, width, height;
+ *
+ * evas_output_viewport_get(evas, &x, &y, &w, &h);
+ * @endcode
+ *
+ * @param[out] x The top-left corner x value of the viewport.
+ * @param[out] y The top-left corner y value of the viewport.
+ * @param[out] w The width of the viewport.  Must be greater than 0.
+ * @param[out] h The height of the viewport.  Must be greater than 0.
+ */
+EAPI void evas_output_viewport_get(const Evas_Canvas *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Set the image cache.
+ *
+ * This function sets the image cache of canvas in bytes.
+ *
+ * @param[in] size The cache size.
+ */
+EAPI void evas_image_cache_set(Evas_Canvas *obj, int size);
+
+/**
+ *
+ * Get the image cache
+ *
+ * This function returns the image cache size of canvas in bytes.
+ *
+ */
+EAPI int evas_image_cache_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Set the default set of flags an event begins with
+ *
+ * Events in evas can have an event_flags member. This starts out with
+ * and initial value (no flags). This lets you set the default flags that
+ * an event begins with to be @p flags
+ *
+ * @since 1.2
+ *
+ * @param[in] flags The default flags to use
+ */
+EAPI void evas_event_default_flags_set(Evas_Canvas *obj, Evas_Event_Flags flags);
+
+/**
+ *
+ * Get the default set of flags an event begins with
+ *
+ * @return The default event flags for that canvas
+ *
+ * This gets the default event flags events are produced with when fed in.
+ *
+ * @see evas_event_default_flags_set()
+ * @since 1.2
+ *
+ */
+EAPI Evas_Event_Flags evas_event_default_flags_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Sets the output engine for the given evas.
+ *
+ * Once the output engine for an evas is set, any attempt to change it
+ * will be ignored.  The value for @p render_method can be found using
+ * @ref evas_render_method_lookup .
+ *
+ * @attention it is mandatory that one calls evas_init() before
+ * setting the output method.
+ *
+ * @ingroup Evas_Output_Method
+ *
+ * @param[in] render_method The numeric engine value to use.
+ */
+EAPI void evas_output_method_set(Evas_Canvas *obj, int render_method);
+
+/**
+ *
+ * Retrieves the number of the output engine used for the given evas.
+ * @return  The ID number of the output engine being used.  @c 0 is
+ * returned if there is an error.
+ * @ingroup Evas_Output_Method
+ *
+ */
+EAPI int evas_output_method_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Changes the size of font cache of the given evas.
+ *
+ * @ingroup Evas_Font_Group
+ *
+ * @param[in] size The size, in bytes.
+ */
+EAPI void evas_font_cache_set(Evas_Canvas *obj, int size);
+
+/**
+ *
+ * Changes the size of font cache of the given evas.
+ *
+ * @return The size, in bytes.
+ *
+ * @ingroup Evas_Font_Group
+ *
+ */
+EAPI int evas_font_cache_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Sets the output size of the render engine of the given evas.
+ *
+ * The evas will render to a rectangle of the given size once this
+ * function is called.  The output size is independent of the viewport
+ * size.  The viewport will be stretched to fill the given rectangle.
+ *
+ * The units used for @p w and @p h depend on the engine used by the
+ * evas.
+ *
+ * @ingroup Evas_Output_Size
+ *
+ * @param[in] w The width in output units, usually pixels.
+ * @param[in] h The height in output units, usually pixels.
+ */
+EAPI void evas_output_size_set(Evas_Canvas *obj, int w, int h);
+
+/**
+ *
+ * Retrieve the output size of the render engine of the given evas.
+ *
+ * The output size is given in whatever the output units are for the
+ * engine.
+ *
+ * If either @p w or @p h is @c NULL, then it is ignored.  If @p e is
+ * invalid, the returned results are undefined.
+ *
+ * @ingroup Evas_Output_Size
+ *
+ * @param[out] w The width in output units, usually pixels.
+ * @param[out] h The height in output units, usually pixels.
+ */
+EAPI void evas_output_size_get(const Evas_Canvas *obj, int *w, int *h);
+
+/**
+ *
+ * Attaches a specific pointer to the evas for fetching later
+ *
+ * @ingroup Evas_Canvas
+ *
+ * @param[in] data The pointer to attach
+ */
+EAPI void evas_data_attach_set(Evas_Canvas *obj, void *data);
+
+/**
+ *
+ * Returns the pointer attached by evas_data_attach_set()
+ *
+ * @return The pointer attached
+ * @ingroup Evas_Canvas
+ *
+ */
+EAPI void *evas_data_attach_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Changes the font hinting for the given evas.
+ *
+ * #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+ * @ingroup Evas_Font_Group
+ *
+ * @param[in] hinting The hinting to use, one of #EVAS_FONT_HINTING_NONE,
+ */
+EAPI void evas_font_hinting_set(Evas_Canvas *obj, Evas_Font_Hinting_Flags hinting);
+
+/**
+ *
+ * Retrieves the font hinting used by the given evas.
+ *
+ * @return The hinting in use, one of #EVAS_FONT_HINTING_NONE,
+ * #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+ * @ingroup Evas_Font_Group
+ *
+ */
+EAPI Evas_Font_Hinting_Flags evas_font_hinting_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Applies the engine settings for the given evas from the given @c
+ * Evas_Engine_Info structure.
+ *
+ * To get the Evas_Engine_Info structure to use, call @ref
+ * evas_engine_info_get .  Do not try to obtain a pointer to an
+ * @c Evas_Engine_Info structure in any other way.
+ *
+ * You will need to call this function at least once before you can
+ * create objects on an evas or render that evas.  Some engines allow
+ * their settings to be changed more than once.
+ *
+ * Once called, the @p info pointer should be considered invalid.
+ *
+ * @return  @c EINA_TRUE if no error occurred, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Output_Method
+ *
+ * @param[in] info The pointer to the Engine Info to use
+ */
+EAPI Eina_Bool evas_engine_info_set(Evas_Canvas *obj, Evas_Engine_Info *info);
+
+/**
+ *
+ * Retrieves the current render engine info struct from the given evas.
+ *
+ * The returned structure is publicly modifiable.  The contents are
+ * valid until either @ref evas_engine_info_set or @ref evas_render
+ * are called.
+ *
+ * This structure does not need to be freed by the caller.
+ *
+ * @return  A pointer to the Engine Info structure.  @c NULL is returned if
+ * an engine has not yet been assigned.
+ * @ingroup Evas_Output_Method
+ *
+ */
+EAPI Evas_Engine_Info *evas_engine_info_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Retrieve the object that currently has focus.
+ *
+ * @return The object that has focus or @c NULL if there is not one.
+ *
+ * Evas can have (at most) one of its objects focused at a time.
+ * Focused objects will be the ones having <b>key events</b> delivered
+ * to, which the programmer can act upon by means of
+ * evas_object_event_callback_add() usage.
+ *
+ * @note Most users wouldn't be dealing directly with Evas' focused
+ * objects. Instead, they would be using a higher level library for
+ * that (like a toolkit, as Elementary) to handle focus and who's
+ * receiving input for them.
+ *
+ * This call returns the object that currently has focus on the canvas
+ * @p e or @c NULL, if none.
+ *
+ * @see evas_object_focus_set
+ * @see evas_object_focus_get
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip evas_event_callback_add(d.canvas, EVAS_CALLBACK_CANVAS_OBJECT_FOCUS_IN,
+ * @until evas_object_focus_set(d.bg, EINA_TRUE);
+ * @dontinclude evas-events.c
+ * @skip called when our rectangle gets focus
+ * @until }
+ *
+ * In this example the @c event_info is exactly a pointer to that
+ * focused rectangle. See the full @ref Example_Evas_Events "example".
+ *
+ * @ingroup Evas_Object_Group_Find
+ *
+ */
+EAPI Evas_Object *evas_focus_get(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the highest (stacked) Evas object on the canvas @p e.
+ *
+ * @return a pointer to the highest object on it, if any, or @c NULL,
+ * otherwise
+ *
+ * This function will take all populated layers in the canvas into
+ * account, getting the highest object for the highest layer,
+ * naturally.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ * @see evas_object_above_get()
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ *
+ */
+EAPI Evas_Object *evas_object_top_get(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Returns a handle to the list of lock keys registered in the canvas
+ * @p e. This is required to check for which locks are set at a given
+ * time with the evas_key_lock_is_set() function.
+ *
+ * @see evas_key_lock_add
+ * @see evas_key_lock_del
+ * @see evas_key_lock_on
+ * @see evas_key_lock_off
+ * @see evas_key_lock_is_set
+ *
+ * @return An .Evas_Lock handle to query Evas' keys subsystem with
+ * evas_key_lock_is_set(), or @c NULL on error.
+ *
+ */
+EAPI const Evas_Lock *evas_key_lock_get(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * This function returns the current known pointer co-ordinates
+ *
+ * This function returns the current known canvas unit co-ordinates of
+ * the mouse pointer and sets the contents of the Evas_Coords pointed
+ * to by @p x and @p y to contain these co-ordinates. If @p e is not a
+ * valid canvas the results of this function are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Coord mouse_x, mouse_y;
+ *
+ * evas_pointer_output_xy_get(evas, &mouse_x, &mouse_y);
+ * printf("Mouse is at canvas position %d, %d\n", mouse_x, mouse_y);
+ * @endcode
+ *
+ * @param[out] x The pointer to a Evas_Coord to be filled in
+ * @param[out] y The pointer to a Evas_Coord to be filled in
+@ingroup Evas_Pointer_Group
+ */
+EAPI void evas_pointer_canvas_xy_get(const Evas_Canvas *obj, Evas_Coord *x, Evas_Coord *y);
+
+/**
+ *
+ * Get the number of mouse or multi presses currently active
+ *
+ * @p e The given canvas pointer.
+ * @return The number of presses (0 if none active).
+ *
+ * @since 1.2
+ *
+ */
+EAPI int evas_event_down_count_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * This gets the internal counter that counts the number of smart calculations
+ *
+ * Whenever evas performs smart object calculations on the whole canvas
+ * it increments a counter by 1. This is the smart object calculate counter
+ * that this function returns the value of. It starts at the value of 0 and
+ * will increase (and eventually wrap around to negative values and so on) by
+ * 1 every time objects are calculated. You can use this counter to ensure
+ * you don't re-do calculations withint the same calculation generation/run
+ * if the calculations maybe cause self-feeding effects.
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * @since 1.1
+ *
+ */
+EAPI int evas_smart_objects_calculate_count_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Get the focus state known by the given evas
+ *
+ * @return @c EINA_TRUE if it got the focus, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Canvas
+ *
+ */
+EAPI Eina_Bool evas_focus_state_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * Get the changed marker for the canvas
+ *
+ * @return @c EINA_TRUE if something has been marked as changed, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Canvas
+ * @since 1.11
+ *
+ */
+EAPI Eina_Bool evas_changed_get(const Evas_Canvas *obj);
+
+/**
+ *
+ * This function returns the current known pointer co-ordinates
+ *
+ * This function returns the current known screen/output co-ordinates
+ * of the mouse pointer and sets the contents of the integers pointed
+ * to by @p x and @p y to contain these co-ordinates. If @p e is not a
+ * valid canvas the results of this function are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int mouse_x, mouse_y;
+ *
+ * evas_pointer_output_xy_get(evas, &mouse_x, &mouse_y);
+ * printf("Mouse is at screen position %i, %i\n", mouse_x, mouse_y);
+ * @endcode
+ *
+ * @param[out] x The pointer to an integer to be filled in
+ * @param[out] y The pointer to an integer to be filled in
+@ingroup Evas_Pointer_Group
+ */
+EAPI void evas_pointer_output_xy_get(const Evas_Canvas *obj, int *x, int *y);
+
+/**
+ *
+ * Returns whether the mouse pointer is logically inside the canvas
+ *
+ * @return An integer that is 1 if the mouse is inside the canvas, 0 otherwise
+ * @ingroup Evas_Pointer_Group
+ *
+ * When this function is called it will return a value of either 0 or
+ * 1, depending on if evas_event_feed_mouse_in(),
+ * evas_event_feed_mouse_in_data(), or evas_event_feed_mouse_out(),
+ * evas_event_feed_mouse_out_data() have been called to feed in a
+ * mouse enter event into the canvas.
+ *
+ * A return value of 1 indicates the mouse is logically inside the
+ * canvas, and 0 implies it is logically outside the canvas.
+ *
+ * A canvas begins with the mouse being assumed outside (0).
+ *
+ * If @p e is not a valid canvas, the return value is undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ *
+ * if (evas_pointer_inside_get(evas)) printf("Mouse is in!\n");
+ * else printf("Mouse is out!\n");
+ * @endcode
+ *
+ */
+EAPI Eina_Bool evas_pointer_inside_get(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the maximum image size evas can possibly handle
+ *
+ * This function returns the larges image or surface size that evas can handle
+ * in pixels, and if there is one, returns @c EINA_TRUE. It returns
+ * @c EINA_FALSE if no extra constraint on maximum image size exists. You still
+ * should check the return values of @p maxw and @p maxh as there may still be
+ * a limit, just a much higher one.
+ *
+ * @since 1.1
+ *
+ * @param[out] maxw Pointer to hold the return value in pixels of the maximum width
+ * @param[out] maxh Pointer to hold the return value in pixels of the maximum height
+ */
+EAPI Eina_Bool evas_image_max_size_get(const Evas_Canvas *obj, int *maxw, int *maxh);
+
+/**
+ *
+ * Get the lowest (stacked) Evas object on the canvas @p e.
+ *
+ * @return a pointer to the lowest object on it, if any, or @c NULL,
+ * otherwise
+ *
+ * This function will take all populated layers in the canvas into
+ * account, getting the lowest object for the lowest layer, naturally.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ * @see evas_object_above_get()
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ *
+ */
+EAPI Evas_Object *evas_object_bottom_get(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Returns a handle to the list of modifier keys registered in the
+ * canvas @p e. This is required to check for which modifiers are set
+ * at a given time with the evas_key_modifier_is_set() function.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_del
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ *
+ * @return An .Evas_Modifier handle to query Evas' keys subsystem
+ * with evas_key_modifier_is_set(), or @c NULL on error.
+ *
+ */
+EAPI const Evas_Modifier *evas_key_modifier_get(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Returns a bitmask with the mouse buttons currently pressed, set to 1
+ *
+ * @return A bitmask of the currently depressed buttons on the canvas
+ * @ingroup Evas_Pointer_Group
+ *
+ * Calling this function will return a 32-bit integer with the
+ * appropriate bits set to 1 that correspond to a mouse button being
+ * depressed. This limits Evas to a mouse devices with a maximum of 32
+ * buttons, but that is generally in excess of any host system's
+ * pointing device abilities.
+ *
+ * A canvas by default begins with no mouse buttons being pressed and
+ * only calls to evas_event_feed_mouse_down(),
+ * evas_event_feed_mouse_down_data(), evas_event_feed_mouse_up() and
+ * evas_event_feed_mouse_up_data() will alter that.
+ *
+ * The least significant bit corresponds to the first mouse button
+ * (button 1) and the most significant bit corresponds to the last
+ * mouse button (button 32).
+ *
+ * If @p e is not a valid canvas, the return value is undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int button_mask, i;
+ *
+ * button_mask = evas_pointer_button_down_mask_get(evas);
+ * printf("Buttons currently pressed:\n");
+ * for (i = 0; i < 32; i++)
+ * {
+ * if ((button_mask & (1 << i)) != 0) printf("Button %i\n", i + 1);
+ * }
+ * @endcode
+ *
+ */
+EAPI int evas_pointer_button_down_mask_get(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Retrieve a list of Evas objects lying over a given position in
+ * a canvas.
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas covering the
+ * given position. It will enter the smart objects.
+ * It will not append to the list pass events as hidden objects.
+ * Call eina_list_free on the returned list after usage.
+ * 
+ *
+ * @param[in] stop An Evas Object where to stop searching.
+ * @param[in] x The horizontal coordinate of the position.
+ * @param[in] y The vertical coordinate of the position.
+ */
+EAPI Eina_List *evas_tree_objects_at_xy_get(Evas_Canvas *obj, Evas_Object *stop, int x, int y) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Mouse wheel event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse wheel is scrolled up or down. It prepares information to
+ * be treated by the callback function.
+ * 
+ *
+ * @param[in] direction The wheel mouse direction.
+ * @param[in] z How much mouse wheel was scrolled up or down.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_mouse_wheel(Evas_Canvas *obj, int direction, int z, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Enables or turns on programmatically the lock key with name @p
+ * keyname.
+ *
+ * The effect will be as if the key was put on its active state after
+ * this call.
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_add
+ * @see evas_key_lock_del
+ * @see evas_key_lock_off
+ * 
+ *
+ * @param[in] keyname The name of the lock to enable.
+ */
+EAPI void evas_key_lock_on(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Key down event feed
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is pressed. It prepares information to be treated by the
+ * callback function.
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key pressed.
+ * @param[in] string A String
+ * @param[in] compose The compose string
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ */
+EAPI void evas_event_feed_key_down(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Creates a bit mask from the @p keyname @b modifier key. Values
+ * returned from different calls to it may be ORed together,
+ * naturally.
+ *
+ * @returns the bit mask or 0 if the @p keyname key wasn't registered as a
+ * modifier for canvas @p e.
+ *
+ * This function is meant to be using in conjunction with
+ * evas_object_key_grab()/evas_object_key_ungrab(). Go check their
+ * documentation for more information.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ * 
+ *
+ * @param[in] keyname The name of the modifier key to create the mask for.
+ */
+EAPI Evas_Modifier_Mask evas_key_modifier_mask_get(const Evas_Canvas *obj, const char *keyname) EINA_WARN_UNUSED_RESULT EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Adds the @p keyname key to the current list of modifier keys.
+ *
+ * Modifiers are keys like shift, alt and ctrl, i.e., keys which are
+ * meant to be pressed together with others, altering the behavior of
+ * the secondly pressed keys somehow. Evas is so that these keys can
+ * be user defined.
+ *
+ * This call allows custom modifiers to be added to the Evas system at
+ * run time. It is then possible to set and unset modifier keys
+ * programmatically for other parts of the program to check and act
+ * on. Programmers using Evas would check for modifier keys on key
+ * event callbacks using evas_key_modifier_is_set().
+ *
+ * @see evas_key_modifier_del
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ *
+ * @note If the programmer instantiates the canvas by means of the
+ * ecore_evas_new() family of helper functions, Ecore will take
+ * care of registering on it all standard modifiers: "Shift",
+ * "Control", "Alt", "Meta", "Hyper", "Super".
+ * 
+ *
+ * @param[in] keyname The name of the modifier key to add to the list of
+Evas modifiers.
+ */
+EAPI void evas_key_modifier_add(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Disables or turns off programmatically the modifier key with name
+ * @p keyname.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_is_set
+ * 
+ *
+ * @param[in] keyname The name of the modifier to disable.
+ */
+EAPI void evas_key_modifier_off(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Hold event feed
+ *
+ * This function makes the object to stop sending events.
+ * 
+ *
+ * @param[in] hold The hold.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_hold(Evas_Canvas *obj, int hold, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Mouse move event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse is moved from its last position. It prepares information
+ * to be treated by the callback function.
+ * 
+ *
+ * @param[in] x The horizontal position of the mouse pointer.
+ * @param[in] y The vertical position of the mouse pointer.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_mouse_move(Evas_Canvas *obj, int x, int y, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Key up event feed
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is released. It prepares information to be treated by the
+ * callback function.
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key released.
+ * @param[in] string string
+ * @param[in] compose compose
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ */
+EAPI void evas_event_feed_key_up(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Mouse out event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse out event happens. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] timestamp Timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_mouse_out(Evas_Canvas *obj, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_event_input_multi_move(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Retrieve a list of Evas objects lying over a given position in
+ * a canvas
+ *
+ * @return  The list of Evas objects that are over the given position
+ * in @p e
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas covering the
+ * given position. The user can remove from query
+ * objects which are hidden and/or which are set to pass events.
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ * 
+ *
+ * @param[in] x The horizontal coordinate of the position
+ * @param[in] y The vertical coordinate of the position
+ * @param[in] include_pass_events_objects Boolean flag to include or not
+objects which pass events in this calculation
+ * @param[in] include_hidden_objects Boolean flag to include or not hidden
+objects in this calculation
+ */
+EAPI Eina_List *evas_objects_at_xy_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_event_input_multi_up(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_event_feed_multi_down(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Render the given Evas canvas asynchronously.
+ *
+ * @return EINA_TRUE if the canvas will render, EINA_FALSE otherwise.
+ *
+ * This function only returns EINA_TRUE when a frame will be rendered. If the
+ * previous frame is still rendering, EINA_FALSE will be returned so the users
+ * know not to wait for the updates callback and just return to their main
+ * loop.
+ *
+ * If a @p func callback is given, a list of updated areas will be generated
+ * and the function will be called from the main thread after the rendered
+ * frame is flushed to the screen. The resulting list should be freed with
+ * @f evas_render_updates_free().
+ * The list is given in the @p event_info parameter of the callback function.
+ *
+ * @ingroup Evas_Canvas
+ * @since 1.8
+ * 
+ *
+ */
+EAPI Eina_Bool evas_render_async(Evas_Canvas *obj);
+
+/**
+ *
+ * Inform to the evas that it lost the focus.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_focus_out(Evas_Canvas *obj);
+
+/**
+ *
+ * Mouse move event feed from input.
+ *
+ * Similar to the evas_event_feed_mouse_move(), this function will inform Evas
+ * about mouse move events which were received by the input system, relative to
+ * the 0,0 of the window, not to the canvas 0,0. It will take care of doing any
+ * special transformation like adding the framespace offset to the mouse event.
+ *
+ * @since 1.8
+ * @see evas_event_feed_mouse_move
+ * 
+ *
+ * @param[in] x The horizontal position of the mouse pointer relative to the 0,0 of
+the window/surface.
+ * @param[in] y The vertical position of the mouse pointer relative to the 0,0 of
+the window/surface.
+ * @param[in] timestamp The timestamp of the mouse move event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_input_mouse_move(Evas_Canvas *obj, int x, int y, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Update the canvas internal objects but not triggering immediate
+ * renderization.
+ *
+ * This function updates the canvas internal objects not triggering
+ * renderization. To force renderization function evas_render() should
+ * be used.
+ *
+ * @see evas_render.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_norender(Evas_Canvas *obj);
+
+/**
+ *
+ * Get the number of touched point in the evas.
+ *
+ * @return The number of touched point on the evas.
+ *
+ * New touched point is added to the list whenever touching the evas
+ * and point is removed whenever removing touched point from the evas.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int count;
+ *
+ * count = evas_touch_point_list_count(evas);
+ * printf("The count of touch points: %i\n", count);
+ * @endcode
+ *
+ * @see evas_touch_point_list_nth_xy_get()
+ * @see evas_touch_point_list_nth_id_get()
+ * @see evas_touch_point_list_nth_state_get()
+ * 
+ *
+ */
+EAPI unsigned int evas_touch_point_list_count(Evas_Canvas *obj);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_event_input_multi_down(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Pop the nochange flag down 1
+ *
+ * This tells evas, that while the nochange flag is greater than 0, do not
+ * mark objects as "changed" when making changes.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_nochange_pop(Evas_Canvas *obj);
+
+/**
+ *
+ * Disables or turns off programmatically the lock key with name @p
+ * keyname.
+ *
+ * The effect will be as if the key was put on its inactive state
+ * after this call.
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_add
+ * @see evas_key_lock_del
+ * @see evas_key_lock_on
+ * 
+ *
+ * @param[in] keyname The name of the lock to disable.
+ */
+EAPI void evas_key_lock_off(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Push the nochange flag up 1
+ *
+ * This tells evas, that while the nochange flag is greater than 0, do not
+ * mark objects as "changed" when making changes.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_nochange_push(Evas_Canvas *obj);
+
+/**
+ *
+ * Force the given evas and associated engine to flush its font cache.
+ *
+ * @ingroup Evas_Font_Group
+ * 
+ *
+ */
+EAPI void evas_font_cache_flush(Evas_Canvas *obj);
+
+/**
+ *
+ * Checks if the font hinting is supported by the given evas.
+ *
+ * #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.
+ * @return @c EINA_TRUE if it is supported, @c EINA_FALSE otherwise.
+ * @ingroup Evas_Font_Group
+ * 
+ *
+ * @param[in] hinting The hinting to use, one of #EVAS_FONT_HINTING_NONE,
+ */
+EAPI Eina_Bool evas_font_hinting_can_hint(const Evas_Canvas *obj, Evas_Font_Hinting_Flags hinting) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Retrieve the Evas object stacked at the top of a given position in
+ * a canvas
+ *
+ * @return  The Evas object that is over all other objects at the given
+ * position.
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas covering the
+ * given position. The user can remove from the query
+ * objects which are hidden and/or which are set to pass events.
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ * 
+ *
+ * @param[in] x The horizontal coordinate of the position
+ * @param[in] y The vertical coordinate of the position
+ * @param[in] include_pass_events_objects Boolean flag to include or not
+objects which pass events in this calculation
+ * @param[in] include_hidden_objects Boolean flag to include or not hidden
+objects in this calculation
+ */
+EAPI Evas_Object *evas_object_top_at_xy_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Enables or turns on programmatically the modifier key with name @p
+ * keyname.
+ *
+ * The effect will be as if the key was pressed for the whole time
+ * between this call and a matching evas_key_modifier_off().
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ * 
+ *
+ * @param[in] keyname The name of the modifier to enable.
+ */
+EAPI void evas_key_modifier_on(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Mouse up event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse button is released. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] b The button number.
+ * @param[in] flags evas button flags.
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_mouse_up(Evas_Canvas *obj, int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Mouse down event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse button is pressed. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] b The button number.
+ * @param[in] flags The evas button flags.
+ * @param[in] timestamp The timestamp of the mouse down event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_mouse_down(Evas_Canvas *obj, int b, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Re feed event.
+ *
+ * This function re-feeds the event pointed by event_copy
+ *
+ * This function call evas_event_feed_* functions, so it can
+ * cause havoc if not used wisely. Please use it responsibly.
+ * 
+ *
+ * @param[in] event_copy the event to refeed
+ * @param[in] event_type Event type
+ */
+EAPI void evas_event_refeed_event(Evas_Canvas *obj, void *event_copy, Evas_Callback_Type event_type);
+
+/**
+ *
+ * List of available font descriptions known or found by this evas.
+ *
+ * The list depends on Evas compile time configuration, such as
+ * fontconfig support, and the paths provided at runtime as explained
+ * in @ref Evas_Font_Path_Group.
+ *
+ * @return a newly allocated list of strings. Do not change the
+ * strings.  Be sure to call evas_font_available_list_free()
+ * after you're done.
+ *
+ * @ingroup Evas_Font_Group
+ * 
+ *
+ */
+EAPI Eina_List *evas_font_available_list(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] w No description supplied.
+ * @param[in] h No description supplied.
+ * @param[in] include_pass_events_objects No description supplied.
+ * @param[in] include_hidden_objects No description supplied.
+ */
+EAPI Eina_List *evas_objects_in_rectangle_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Retrieves the object on the given evas with the given name.
+ * @return  If successful, the Evas object with the given name.  Otherwise,
+ * @c NULL.
+ *
+ * This looks for the evas object given a name by evas_object_name_set(). If
+ * the name is not unique canvas-wide, then which one of the many objects
+ * with that name is returned is undefined, so only use this if you can ensure
+ * the object name is unique.
+ *
+ * @ingroup Evas_Object_Group_Find
+ * 
+ *
+ * @param[in] name The given name.
+ */
+EAPI Evas_Object *evas_object_name_find(const Evas_Canvas *obj, const char *name) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Appends a font path to the list of font paths used by the given evas.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ * @param[in] path The new font path.
+ */
+EAPI void evas_font_path_append(Evas_Canvas *obj, const char *path) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * This function returns the @p id of nth touch point.
+ *
+ * @return id of nth touch point, if the call succeeded, -1 otherwise.
+ *
+ * The point which comes from Mouse Event has @p id 0 and The point
+ * which comes from Multi Event has @p id that is same as Multi
+ * Event's device id.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int id;
+ *
+ * if (evas_touch_point_list_count(evas))
+ * {
+ * id = evas_touch_point_nth_id_get(evas, 0);
+ * printf("The first touch point's id: %i\n", id);
+ * }
+ * @endcode
+ *
+ * @see evas_touch_point_list_count()
+ * @see evas_touch_point_list_nth_xy_get()
+ * @see evas_touch_point_list_nth_state_get()
+ * 
+ *
+ * @param[in] n The number of the touched point (0 being the first).
+ */
+EAPI int evas_touch_point_list_nth_id_get(Evas_Canvas *obj, unsigned int n);
+
+/**
+ *
+ * Removes all font paths loaded into memory for the given evas.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ */
+EAPI void evas_font_path_clear(Evas_Canvas *obj);
+
+/**
+ *
+ * Call user-provided @c calculate() smart functions and unset the
+ * flag signalling that the object needs to get recalculated to @b all
+ * smart objects in the canvas.
+ *
+ * @see evas_object_smart_need_recalculate_set()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ */
+EAPI void evas_smart_objects_calculate(Evas_Canvas *obj);
+
+/**
+ *
+ * This function returns the nth touch point's co-ordinates.
+ *
+ * Touch point's co-ordinates is updated whenever moving that point
+ * on the canvas.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Coord x, y;
+ *
+ * if (evas_touch_point_list_count(evas))
+ * {
+ * evas_touch_point_nth_xy_get(evas, 0, &x, &y);
+ * printf("The first touch point's co-ordinate: (%i, %i)\n", x, y);
+ * }
+ * @endcode
+ *
+ * @see evas_touch_point_list_count()
+ * @see evas_touch_point_list_nth_id_get()
+ * @see evas_touch_point_list_nth_state_get()
+ * 
+ *
+ * @param[in] n The number of the touched point (0 being the first).
+ * @param[out] x The pointer to a Evas_Coord to be filled in.
+ * @param[out] y The pointer to a Evas_Coord to be filled in.
+ */
+EAPI void evas_touch_point_list_nth_xy_get(Evas_Canvas *obj, unsigned int n, Evas_Coord *x, Evas_Coord *y);
+
+/**
+ *
+ * Removes the @p keyname key from the current list of lock keys on
+ * canvas @p e.
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_add
+ * @see evas_key_lock_on
+ * @see evas_key_lock_off
+ * 
+ *
+ * @param[in] keyname The name of the key to remove from the locks list.
+ */
+EAPI void evas_key_lock_del(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Add a damage rectangle.
+ *
+ * This is the function by which one tells evas that a part of the
+ * canvas has to be repainted.
+ *
+ * @note All newly created Evas rectangles get the default color values of 255 255 255 255 (opaque white).
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ * @param[in] x The rectangle's left position.
+ * @param[in] y The rectangle's top position.
+ * @param[in] w The rectangle's width.
+ * @param[in] h The rectangle's height.
+ */
+EAPI void evas_damage_rectangle_add(Evas_Canvas *obj, int x, int y, int w, int h);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ */
+EAPI void evas_sync(Evas_Canvas *obj);
+
+/**
+ *
+ * Retrieves the list of font paths used by the given evas.
+ * @return  The list of font paths used.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ */
+EAPI const Eina_List *evas_font_path_list(const Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Reload the image cache
+ *
+ * This function reloads the image cache of canvas.
+ * 
+ *
+ */
+EAPI void evas_image_cache_reload(Evas_Canvas *obj);
+
+/**
+ *
+ * Convert/scale a canvas co-ordinate into output screen co-ordinates
+ *
+ * @return The output/screen co-ordinate translated to output co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a horizontal co-ordinate as the @p x
+ * parameter and converts it into output units, accounting for output
+ * size, viewport size and location, returning it as the function
+ * return value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int screen_x;
+ * extern Evas_Coord canvas_x;
+ *
+ * screen_x = evas_coord_world_x_to_screen(evas, canvas_x);
+ * @endcode
+ * 
+ *
+ * @param[in] x The canvas x co-ordinate
+ */
+EAPI int evas_coord_world_x_to_screen(const Evas_Canvas *obj, Evas_Coord x) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_event_feed_multi_move(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Force immediate renderization of the given Evas canvas.
+ *
+ * @return A newly allocated list of updated rectangles of the canvas
+ * (@c Eina.Rectangle structs). Free this list with
+ * evas_render_updates_free().
+ *
+ * This function forces an immediate renderization update of the given
+ * canvas @p e.
+ *
+ * @note This is a <b>very low level function</b>, which most of
+ * Evas' users wouldn't care about. One would use it, for example, to
+ * grab an Evas' canvas update regions and paint them back, using the
+ * canvas' pixmap, on a displaying system working below Evas.
+ *
+ * @note Evas is a stateful canvas. If no operations changing its
+ * state took place since the last rendering action, you won't see no
+ * changes and this call will be a no-op.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip add an obscured
+ * @until d.obscured = !d.obscured;
+ *
+ * See the full @ref Example_Evas_Events "example".
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI Eina_List *evas_render_updates(Evas_Canvas *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Flush the image cache of the canvas.
+ *
+ * This function flushes image cache of canvas.
+ * 
+ *
+ */
+EAPI void evas_image_cache_flush(Evas_Canvas *obj);
+
+/**
+ *
+ * Convert/scale an output screen co-ordinate into canvas co-ordinates
+ *
+ * @return The screen co-ordinate translated to canvas unit co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a vertical co-ordinate as the @p y parameter
+ * and converts it into canvas units, accounting for output size,
+ * viewport size and location, returning it as the function return
+ * value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * extern int screen_y;
+ * Evas_Coord canvas_y;
+ *
+ * canvas_y = evas_coord_screen_y_to_world(evas, screen_y);
+ * @endcode
+ * 
+ *
+ * @param[in] y The screen/output y co-ordinate
+ */
+EAPI Evas_Coord evas_coord_screen_y_to_world(const Evas_Canvas *obj, int y) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Removes the @p keyname key from the current list of modifier keys
+ * on canvas @p e.
+ *
+ * @see evas_key_modifier_add
+ * @see evas_key_modifier_get
+ * @see evas_key_modifier_on
+ * @see evas_key_modifier_off
+ * @see evas_key_modifier_is_set
+ * 
+ *
+ * @param[in] keyname The name of the key to remove from the modifiers list.
+ */
+EAPI void evas_key_modifier_del(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * This function returns the @p state of nth touch point.
+ *
+ * @return @p state of nth touch point, if the call succeeded,
+ * EVAS_TOUCH_POINT_CANCEL otherwise.
+ *
+ * The point's @p state is EVAS_TOUCH_POINT_DOWN when pressed,
+ * EVAS_TOUCH_POINT_STILL when the point is not moved after pressed,
+ * EVAS_TOUCH_POINT_MOVE when moved at least once after pressed and
+ * EVAS_TOUCH_POINT_UP when released.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * Evas_Touch_Point_State state;
+ *
+ * if (evas_touch_point_list_count(evas))
+ * {
+ * state = evas_touch_point_nth_state_get(evas, 0);
+ * printf("The first touch point's state: %i\n", state);
+ * }
+ * @endcode
+ *
+ * @see evas_touch_point_list_count()
+ * @see evas_touch_point_list_nth_xy_get()
+ * @see evas_touch_point_list_nth_id_get()
+ * 
+ *
+ * @param[in] n The number of the touched point (0 being the first).
+ */
+EAPI Evas_Touch_Point_State evas_touch_point_list_nth_state_get(Evas_Canvas *obj, unsigned int n);
+
+/**
+ *
+ * Inform to the evas that it got the focus.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_focus_in(Evas_Canvas *obj);
+
+/**
+ *
+ * Add an "obscured region" to an Evas canvas.
+ *
+ * This is the function by which one tells an Evas canvas that a part
+ * of it <b>must not</b> be repainted. The region must be
+ * rectangular and its coordinates inside the canvas viewport are
+ * passed in the call. After this call, the region specified won't
+ * participate in any form in Evas' calculations and actions during
+ * its rendering updates, having its displaying content frozen as it
+ * was just after this function took place.
+ *
+ * We call it "obscured region" because the most common use case for
+ * this rendering (partial) freeze is something else (most probably
+ * other canvas) being on top of the specified rectangular region,
+ * thus shading it completely from the user's final scene in a
+ * display. To avoid unnecessary processing, one should indicate to the
+ * obscured canvas not to bother about the non-important area.
+ *
+ * The majority of users won't have to worry about this function, as
+ * they'll be using just one canvas in their applications, with
+ * nothing inset or on top of it in any form.
+ *
+ * To make this region one that @b has to be repainted again, call the
+ * function evas_obscured_clear().
+ *
+ * @note This is a <b>very low level function</b>, which most of
+ * Evas' users wouldn't care about.
+ *
+ * @note This function does @b not flag the canvas as having its state
+ * changed. If you want to re-render it afterwards expecting new
+ * contents, you have to add "damage" regions yourself (see
+ * evas_damage_rectangle_add()).
+ *
+ * @see evas_obscured_clear()
+ * @see evas_render_updates()
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip add an obscured
+ * @until evas_obscured_clear(evas);
+ *
+ * In that example, pressing the "Ctrl" and "o" keys will impose or
+ * remove an obscured region in the middle of the canvas. You'll get
+ * the same contents at the time the key was pressed, if toggling it
+ * on, until you toggle it off again (make sure the animation is
+ * running on to get the idea better). See the full @ref
+ * Example_Evas_Events "example".
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ * @param[in] x The rectangle's top left corner's horizontal coordinate.
+ * @param[in] y The rectangle's top left corner's vertical coordinate
+ * @param[in] w The rectangle's width.
+ * @param[in] h The rectangle's height.
+ */
+EAPI void evas_obscured_rectangle_add(Evas_Canvas *obj, int x, int y, int w, int h);
+
+/**
+ *
+ * Make the canvas discard as much data as possible used by the engine at
+ * runtime.
+ *
+ * This function will unload images, delete textures and much more, where
+ * possible. You may also want to call evas_render_idle_flush() immediately
+ * prior to this to perhaps discard a little more, though evas_render_dump()
+ * should implicitly delete most of what evas_render_idle_flush() might
+ * discard too.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_render_dump(Evas_Canvas *obj);
+
+/**
+ *
+ * Mouse in event feed.
+ *
+ * This function will set some evas properties that is necessary when
+ * the mouse in event happens. It prepares information to be treated
+ * by the callback function.
+ * 
+ *
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_mouse_in(Evas_Canvas *obj, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Retrieve the Evas object stacked at the top of a given rectangular
+ * region in a canvas
+ *
+ * @return  The Evas object that is over all other objects at the given
+ * rectangular region.
+ *
+ * This function will traverse all the layers of the given canvas,
+ * from top to bottom, querying for objects with areas overlapping
+ * with the given rectangular region inside @p e. The user can remove
+ * from the query objects which are hidden and/or which are set to
+ * pass events.
+ *
+ * @warning This function will @b skip objects parented by smart
+ * objects, acting only on the ones at the "top level", with regard to
+ * object parenting.
+ * 
+ *
+ * @param[in] x The top left corner's horizontal coordinate for the
+rectangular region
+ * @param[in] y The top left corner's vertical coordinate for the
+rectangular region
+ * @param[in] w The width of the rectangular region
+ * @param[in] h The height of the rectangular region
+ * @param[in] include_pass_events_objects Boolean flag to include or not
+objects which pass events in this calculation
+ * @param[in] include_hidden_objects Boolean flag to include or not hidden
+objects in this calculation
+ */
+EAPI Evas_Object *evas_object_top_in_rectangle_get(const Evas_Canvas *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Force renderization of the given canvas.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_render(Evas_Canvas *obj);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] d No description supplied.
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] rad No description supplied.
+ * @param[in] radx No description supplied.
+ * @param[in] rady No description supplied.
+ * @param[in] pres No description supplied.
+ * @param[in] ang No description supplied.
+ * @param[in] fx No description supplied.
+ * @param[in] fy No description supplied.
+ * @param[in] flags No description supplied.
+ * @param[in] timestamp No description supplied.
+ * @param[in] data No description supplied.
+ */
+EAPI void evas_event_feed_multi_up(Evas_Canvas *obj, int d, int x, int y, double rad, double radx, double rady, double pres, double ang, double fx, double fy, Evas_Button_Flags flags, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Prepends a font path to the list of font paths used by the given evas.
+ * @ingroup Evas_Font_Path_Group
+ * 
+ *
+ * @param[in] path The new font path.
+ */
+EAPI void evas_font_path_prepend(Evas_Canvas *obj, const char *path) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Remove all "obscured regions" from an Evas canvas.
+ *
+ * This function removes all the rectangles from the obscured regions
+ * list of the canvas @p e. It takes obscured areas added with
+ * evas_obscured_rectangle_add() and make them again a regions that @b
+ * have to be repainted on rendering updates.
+ *
+ * @note This is a <b>very low level function</b>, which most of
+ * Evas' users wouldn't care about.
+ *
+ * @note This function does @b not flag the canvas as having its state
+ * changed. If you want to re-render it afterwards expecting new
+ * contents, you have to add "damage" regions yourself (see
+ * evas_damage_rectangle_add()).
+ *
+ * @see evas_obscured_rectangle_add() for an example
+ * @see evas_render_updates()
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_obscured_clear(Evas_Canvas *obj);
+
+/**
+ *
+ * Mouse cancel event feed.
+ *
+ * This function will call evas_event_feed_mouse_up() when a
+ * mouse cancel event happens.
+ * 
+ *
+ * @param[in] timestamp The timestamp of the mouse up event.
+ * @param[in] data The data for canvas.
+ */
+EAPI void evas_event_feed_mouse_cancel(Evas_Canvas *obj, unsigned int timestamp, const void *data);
+
+/**
+ *
+ * Convert/scale an output screen co-ordinate into canvas co-ordinates
+ *
+ * @return The screen co-ordinate translated to canvas unit co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a horizontal co-ordinate as the @p x
+ * parameter and converts it into canvas units, accounting for output
+ * size, viewport size and location, returning it as the function
+ * return value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * extern int screen_x;
+ * Evas_Coord canvas_x;
+ *
+ * canvas_x = evas_coord_screen_x_to_world(evas, screen_x);
+ * @endcode
+ * 
+ *
+ * @param[in] x The screen/output x co-ordinate
+ */
+EAPI Evas_Coord evas_coord_screen_x_to_world(const Evas_Canvas *obj, int x) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Adds the @p keyname key to the current list of lock keys.
+ *
+ * Locks are keys like caps lock, num lock or scroll lock, i.e., keys
+ * which are meant to be pressed once -- toggling a binary state which
+ * is bound to it -- and thus altering the behavior of all
+ * subsequently pressed keys somehow, depending on its state. Evas is
+ * so that these keys can be defined by the user.
+ *
+ * This allows custom locks to be added to the evas system at run
+ * time. It is then possible to set and unset lock keys
+ * programmatically for other parts of the program to check and act
+ * on. Programmers using Evas would check for lock keys on key event
+ * callbacks using evas_key_lock_is_set().
+ *
+ * @see evas_key_lock_get
+ * @see evas_key_lock_del
+ * @see evas_key_lock_on
+ * @see evas_key_lock_off
+ * @see evas_key_lock_is_set
+ *
+ * @note If the programmer instantiates the canvas by means of the
+ * ecore_evas_new() family of helper functions, Ecore will take
+ * care of registering on it all standard lock keys: "Caps_Lock",
+ * "Num_Lock", "Scroll_Lock".
+ * 
+ *
+ * @param[in] keyname The name of the key to add to the locks list.
+ */
+EAPI void evas_key_lock_add(Evas_Canvas *obj, const char *keyname) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Make the canvas discard internally cached data used for rendering.
+ *
+ * This function flushes the arrays of delete, active and render objects.
+ * Other things it may also discard are: shared memory segments,
+ * temporary scratch buffers, cached data to avoid re-compute of that data etc.
+ *
+ * @ingroup Evas_Canvas
+ * 
+ *
+ */
+EAPI void evas_render_idle_flush(Evas_Canvas *obj);
+
+/**
+ *
+ * Convert/scale a canvas co-ordinate into output screen co-ordinates
+ *
+ * @return The output/screen co-ordinate translated to output co-ordinates
+ * @ingroup Evas_Coord_Mapping_Group
+ *
+ * This function takes in a vertical co-ordinate as the @p x parameter
+ * and converts it into output units, accounting for output size,
+ * viewport size and location, returning it as the function return
+ * value. If @p e is invalid, the results are undefined.
+ *
+ * Example:
+ * @code
+ * extern Evas *evas;
+ * int screen_y;
+ * extern Evas_Coord canvas_y;
+ *
+ * screen_y = evas_coord_world_y_to_screen(evas, canvas_y);
+ * @endcode
+ * 
+ *
+ * @param[in] y The canvas y co-ordinate
+ */
+EAPI int evas_coord_world_y_to_screen(const Evas_Canvas *obj, Evas_Coord y) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Key down event feed with keycode
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is pressed. It prepares information to be treated by the
+ * callback function.
+ *
+ * @since 1.10
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key pressed.
+ * @param[in] string A String
+ * @param[in] compose The compose string
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ * @param[in] keycode Key scan code numeric value for canvas.
+ */
+EAPI void evas_event_feed_key_down_with_keycode(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+/**
+ *
+ * Key up event feed with keycode
+ *
+ * This function will set some evas properties that is necessary when
+ * a key is released. It prepares information to be treated by the
+ * callback function.
+ *
+ * @since 1.10
+ * 
+ *
+ * @param[in] keyname Name of the key
+ * @param[in] key The key released.
+ * @param[in] string string
+ * @param[in] compose compose
+ * @param[in] timestamp Timestamp of the mouse up event
+ * @param[in] data Data for canvas.
+ * @param[in] keycode Key scan code numeric value for canvas.
+ */
+EAPI void evas_event_feed_key_up_with_keycode(Evas_Canvas *obj, const char *keyname, const char *key, const char *string, const char *compose, unsigned int timestamp, const void *data, unsigned int keycode);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_clickable_interface.eo.c b/src/lib/evas/canvas/evas_clickable_interface.eo.c
--- a/src/lib/evas/canvas/evas_clickable_interface.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_clickable_interface.eo.c	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,38 @@
+EOAPI const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED =
+   EO_EVENT_DESCRIPTION("clicked", "");
+EOAPI const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE =
+   EO_EVENT_DESCRIPTION("clicked,double", "");
+EOAPI const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE =
+   EO_EVENT_DESCRIPTION("clicked,triple", "");
+EOAPI const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED =
+   EO_EVENT_DESCRIPTION("pressed", "");
+EOAPI const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED =
+   EO_EVENT_DESCRIPTION("unpressed", "");
+EOAPI const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED =
+   EO_EVENT_DESCRIPTION("longpressed", "");
+EOAPI const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED =
+   EO_EVENT_DESCRIPTION("repeated", "");
+
+static const Eo_Event_Description *_evas_clickable_interface_event_desc[] = {
+     EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED,
+     EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE,
+     EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE,
+     EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED,
+     EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED,
+     EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED,
+     EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED,
+     NULL
+};
+
+static const Eo_Class_Description _evas_clickable_interface_class_desc = {
+     EO_VERSION,
+     "Evas_Clickable_Interface",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     _evas_clickable_interface_event_desc,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_clickable_interface_interface_get, &_evas_clickable_interface_class_desc, EVAS_SIGNAL_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_clickable_interface.eo.h b/src/lib/evas/canvas/evas_clickable_interface.eo.h
--- a/src/lib/evas/canvas/evas_clickable_interface.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_clickable_interface.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,63 @@
+#ifndef _EVAS_CLICKABLE_INTERFACE_EO_H_
+#define _EVAS_CLICKABLE_INTERFACE_EO_H_
+
+#ifndef _EVAS_CLICKABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_CLICKABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Clickable_Interface;
+
+#endif
+
+#ifndef _EVAS_CLICKABLE_INTERFACE_EO_TYPES
+#define _EVAS_CLICKABLE_INTERFACE_EO_TYPES
+
+
+#endif
+#define EVAS_CLICKABLE_INTERFACE_INTERFACE evas_clickable_interface_interface_get()
+
+const Eo_Class *evas_clickable_interface_interface_get(void) EINA_CONST;
+
+EOAPI extern const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED;
+EOAPI extern const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE;
+EOAPI extern const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE;
+EOAPI extern const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED;
+EOAPI extern const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED;
+EOAPI extern const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED;
+EOAPI extern const Eo_Event_Description _EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED;
+
+/**
+ * No description
+ */
+#define EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED (&(_EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED))
+
+/**
+ * No description
+ */
+#define EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE (&(_EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE))
+
+/**
+ * No description
+ */
+#define EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE (&(_EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE))
+
+/**
+ * No description
+ */
+#define EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED (&(_EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED))
+
+/**
+ * No description
+ */
+#define EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED (&(_EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED))
+
+/**
+ * No description
+ */
+#define EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED (&(_EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED))
+
+/**
+ * No description
+ */
+#define EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED (&(_EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED))
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_clickable_interface.eo.hh b/src/lib/evas/canvas/evas_clickable_interface.eo.hh
--- a/src/lib/evas/canvas/evas_clickable_interface.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_clickable_interface.eo.hh	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,450 @@
+#ifndef EFL_GENERATED_EVAS_CLICKABLE_INTERFACE_HH
+#define EFL_GENERATED_EVAS_CLICKABLE_INTERFACE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_clickable_interface.eo.h"
+}
+
+#include "evas_signal_interface.eo.hh"
+
+namespace evas {
+
+struct clickable_interface
+      : evas::signal_interface
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit clickable_interface(Eo* eo)
+      : evas::signal_interface(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit clickable_interface(std::nullptr_t)
+      : evas::signal_interface(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   clickable_interface(clickable_interface const& other)
+      : evas::signal_interface(eo_ref(other._eo_ptr()))
+   {}
+
+   ~clickable_interface() {}
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_clicked_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED );
+   }
+
+   template <typename T>
+   void
+   callback_clicked_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_clicked_double_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE );
+   }
+
+   template <typename T>
+   void
+   callback_clicked_double_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_clicked_triple_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE );
+   }
+
+   template <typename T>
+   void
+   callback_clicked_triple_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_pressed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED );
+   }
+
+   template <typename T>
+   void
+   callback_pressed_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_unpressed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED );
+   }
+
+   template <typename T>
+   void
+   callback_unpressed_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_longpressed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED );
+   }
+
+   template <typename T>
+   void
+   callback_longpressed_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_repeated_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED );
+   }
+
+   template <typename T>
+   void
+   callback_repeated_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_CLICKABLE_INTERFACE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::clickable_interface >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::clickable_interface >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::clickable_interface>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< evas::clickable_interface >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::clickable_interface, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::clickable_interface>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::clickable_interface() const
+      {
+         return evas::clickable_interface(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_clicked_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED );
+   }
+
+   template <typename T>
+   void
+   callback_clicked_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_clicked_double_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE );
+   }
+
+   template <typename T>
+   void
+   callback_clicked_double_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_clicked_triple_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE );
+   }
+
+   template <typename T>
+   void
+   callback_clicked_triple_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_pressed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED );
+   }
+
+   template <typename T>
+   void
+   callback_pressed_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_unpressed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED );
+   }
+
+   template <typename T>
+   void
+   callback_unpressed_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_longpressed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED );
+   }
+
+   template <typename T>
+   void
+   callback_longpressed_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_repeated_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED, priority_,
+            &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::clickable_interface, function_type>,
+         EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED );
+   }
+
+   template <typename T>
+   void
+   callback_repeated_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::clickable_interface>)
+{
+   return (EVAS_CLICKABLE_INTERFACE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_CLICKABLE_INTERFACE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_clickable_interface.eo.legacy.h b/src/lib/evas/canvas/evas_clickable_interface.eo.legacy.h
--- a/src/lib/evas/canvas/evas_clickable_interface.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_clickable_interface.eo.legacy.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_CLICKABLE_INTERFACE_EO_LEGACY_H_
+#define _EVAS_CLICKABLE_INTERFACE_EO_LEGACY_H_
+
+#ifndef _EVAS_CLICKABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_CLICKABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Clickable_Interface;
+
+#endif
+
+#ifndef _EVAS_CLICKABLE_INTERFACE_EO_TYPES
+#define _EVAS_CLICKABLE_INTERFACE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_common_interface.eo.c b/src/lib/evas/canvas/evas_common_interface.eo.c
--- a/src/lib/evas/canvas/evas_common_interface.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_common_interface.eo.c	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,24 @@
+EOAPI EO_FUNC_BODY(evas_common_evas_get, Evas *, 0);
+
+static Eo_Op_Description _evas_common_interface_op_desc[] = {
+     EO_OP_FUNC(evas_common_evas_get, NULL, "No description supplied by the EAPI."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_common_interface_class_desc = {
+     EO_VERSION,
+     "Evas_Common_Interface",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_OPS(_evas_common_interface_op_desc),
+     NULL,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_common_interface_interface_get, &_evas_common_interface_class_desc, NULL, NULL);
+EAPI Evas *
+evas_object_evas_get(const Evas_Common_Interface *obj)
+{
+   return eo_do((Evas_Common_Interface *)obj, evas_common_evas_get());
+}
diff -Naur a/src/lib/evas/canvas/evas_common_interface.eo.h b/src/lib/evas/canvas/evas_common_interface.eo.h
--- a/src/lib/evas/canvas/evas_common_interface.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_common_interface.eo.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,29 @@
+#ifndef _EVAS_COMMON_INTERFACE_EO_H_
+#define _EVAS_COMMON_INTERFACE_EO_H_
+
+#ifndef _EVAS_COMMON_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_COMMON_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Common_Interface;
+
+#endif
+
+#ifndef _EVAS_COMMON_INTERFACE_EO_TYPES
+#define _EVAS_COMMON_INTERFACE_EO_TYPES
+
+
+#endif
+#define EVAS_COMMON_INTERFACE_INTERFACE evas_common_interface_interface_get()
+
+const Eo_Class *evas_common_interface_interface_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ *
+ */
+EOAPI Evas * evas_common_evas_get(void);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_common_interface.eo.hh b/src/lib/evas/canvas/evas_common_interface.eo.hh
--- a/src/lib/evas/canvas/evas_common_interface.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_common_interface.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,152 @@
+#ifndef EFL_GENERATED_EVAS_COMMON_INTERFACE_HH
+#define EFL_GENERATED_EVAS_COMMON_INTERFACE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_common_interface.eo.h"
+}
+
+
+namespace evas {
+
+struct common_interface
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit common_interface(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit common_interface(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   common_interface(common_interface const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~common_interface() {}
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param ret 
+   ///
+   Evas * evas_get() const
+   {
+      Evas * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+      return _tmp_ret;
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_COMMON_INTERFACE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+template <typename T>
+Evas * evas_common_interface_evas_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->evas_get();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::common_interface >
+{
+   template <typename T>
+   struct type
+   {
+      virtual Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::common_interface >
+{
+   static const int value = 1;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::common_interface>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_common_interface_evas_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_common_evas_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::common_interface >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::common_interface, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::common_interface>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::common_interface() const
+      {
+         return evas::common_interface(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::common_interface>)
+{
+   return (EVAS_COMMON_INTERFACE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_COMMON_INTERFACE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_common_interface.eo.legacy.h b/src/lib/evas/canvas/evas_common_interface.eo.legacy.h
--- a/src/lib/evas/canvas/evas_common_interface.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_common_interface.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,24 @@
+#ifndef _EVAS_COMMON_INTERFACE_EO_LEGACY_H_
+#define _EVAS_COMMON_INTERFACE_EO_LEGACY_H_
+
+#ifndef _EVAS_COMMON_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_COMMON_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Common_Interface;
+
+#endif
+
+#ifndef _EVAS_COMMON_INTERFACE_EO_TYPES
+#define _EVAS_COMMON_INTERFACE_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ */
+EAPI Evas *evas_object_evas_get(const Evas_Common_Interface *obj);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_draggable_interface.eo.c b/src/lib/evas/canvas/evas_draggable_interface.eo.c
--- a/src/lib/evas/canvas/evas_draggable_interface.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_draggable_interface.eo.c	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,41 @@
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG =
+   EO_EVENT_DESCRIPTION("drag", "");
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START =
+   EO_EVENT_DESCRIPTION("drag,start", "");
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP =
+   EO_EVENT_DESCRIPTION("drag,stop", "");
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END =
+   EO_EVENT_DESCRIPTION("drag,end", "");
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP =
+   EO_EVENT_DESCRIPTION("drag,start,up", "");
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN =
+   EO_EVENT_DESCRIPTION("drag,start,down", "");
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT =
+   EO_EVENT_DESCRIPTION("drag,start,right", "");
+EOAPI const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT =
+   EO_EVENT_DESCRIPTION("drag,start,left", "");
+
+static const Eo_Event_Description *_evas_draggable_interface_event_desc[] = {
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG,
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START,
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP,
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END,
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP,
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN,
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT,
+     EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT,
+     NULL
+};
+
+static const Eo_Class_Description _evas_draggable_interface_class_desc = {
+     EO_VERSION,
+     "Evas_Draggable_Interface",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     _evas_draggable_interface_event_desc,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_draggable_interface_interface_get, &_evas_draggable_interface_class_desc, EVAS_SIGNAL_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_draggable_interface.eo.h b/src/lib/evas/canvas/evas_draggable_interface.eo.h
--- a/src/lib/evas/canvas/evas_draggable_interface.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_draggable_interface.eo.h	2014-11-27 00:57:33.490380314 +0200
@@ -0,0 +1,69 @@
+#ifndef _EVAS_DRAGGABLE_INTERFACE_EO_H_
+#define _EVAS_DRAGGABLE_INTERFACE_EO_H_
+
+#ifndef _EVAS_DRAGGABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_DRAGGABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Draggable_Interface;
+
+#endif
+
+#ifndef _EVAS_DRAGGABLE_INTERFACE_EO_TYPES
+#define _EVAS_DRAGGABLE_INTERFACE_EO_TYPES
+
+
+#endif
+#define EVAS_DRAGGABLE_INTERFACE_INTERFACE evas_draggable_interface_interface_get()
+
+const Eo_Class *evas_draggable_interface_interface_get(void) EINA_CONST;
+
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG;
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START;
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP;
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END;
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP;
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN;
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT;
+EOAPI extern const Eo_Event_Description _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT;
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG))
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START))
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP))
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END))
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP))
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN))
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT))
+
+/**
+ * No description
+ */
+#define EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT (&(_EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT))
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_draggable_interface.eo.hh b/src/lib/evas/canvas/evas_draggable_interface.eo.hh
--- a/src/lib/evas/canvas/evas_draggable_interface.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_draggable_interface.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,498 @@
+#ifndef EFL_GENERATED_EVAS_DRAGGABLE_INTERFACE_HH
+#define EFL_GENERATED_EVAS_DRAGGABLE_INTERFACE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_draggable_interface.eo.h"
+}
+
+#include "evas_signal_interface.eo.hh"
+
+namespace evas {
+
+struct draggable_interface
+      : evas::signal_interface
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit draggable_interface(Eo* eo)
+      : evas::signal_interface(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit draggable_interface(std::nullptr_t)
+      : evas::signal_interface(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   draggable_interface(draggable_interface const& other)
+      : evas::signal_interface(eo_ref(other._eo_ptr()))
+   {}
+
+   ~draggable_interface() {}
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG );
+   }
+
+   template <typename T>
+   void
+   callback_drag_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_drag_stop_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_end_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END );
+   }
+
+   template <typename T>
+   void
+   callback_drag_end_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_up_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_down_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_right_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_right_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_left_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_left_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_DRAGGABLE_INTERFACE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::draggable_interface >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::draggable_interface >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::draggable_interface>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< evas::draggable_interface >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::draggable_interface, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::draggable_interface>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::draggable_interface() const
+      {
+         return evas::draggable_interface(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG );
+   }
+
+   template <typename T>
+   void
+   callback_drag_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_drag_stop_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_end_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END );
+   }
+
+   template <typename T>
+   void
+   callback_drag_end_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_up_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_down_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_right_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_right_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_drag_start_left_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT, priority_,
+            &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::draggable_interface, function_type>,
+         EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT );
+   }
+
+   template <typename T>
+   void
+   callback_drag_start_left_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::draggable_interface>)
+{
+   return (EVAS_DRAGGABLE_INTERFACE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_DRAGGABLE_INTERFACE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_draggable_interface.eo.legacy.h b/src/lib/evas/canvas/evas_draggable_interface.eo.legacy.h
--- a/src/lib/evas/canvas/evas_draggable_interface.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_draggable_interface.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_DRAGGABLE_INTERFACE_EO_LEGACY_H_
+#define _EVAS_DRAGGABLE_INTERFACE_EO_LEGACY_H_
+
+#ifndef _EVAS_DRAGGABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_DRAGGABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Draggable_Interface;
+
+#endif
+
+#ifndef _EVAS_DRAGGABLE_INTERFACE_EO_TYPES
+#define _EVAS_DRAGGABLE_INTERFACE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_grid.eo.c b/src/lib/evas/canvas/evas_grid.eo.c
--- a/src/lib/evas/canvas/evas_grid.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_grid.eo.c	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,152 @@
+
+void _evas_grid_mirrored_set(Eo *obj, Evas_Grid_Data *pd, Eina_Bool mirrored);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_grid_mirrored_set, EO_FUNC_CALL(mirrored), Eina_Bool mirrored);
+
+Eina_Bool _evas_grid_mirrored_get(Eo *obj, Evas_Grid_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_grid_mirrored_get, Eina_Bool, 0);
+
+void _evas_grid_size_set(Eo *obj, Evas_Grid_Data *pd, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_grid_size_set, EO_FUNC_CALL(w, h), int w, int h);
+
+void _evas_grid_size_get(Eo *obj, Evas_Grid_Data *pd, int *w, int *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_grid_size_get, EO_FUNC_CALL(w, h), int *w, int *h);
+
+Eina_List * _evas_grid_children_get(Eo *obj, Evas_Grid_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_grid_children_get, Eina_List *, 0);
+
+Eina_Accessor * _evas_grid_accessor_new(Eo *obj, Evas_Grid_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_grid_accessor_new, Eina_Accessor *, 0);
+
+void _evas_grid_clear(Eo *obj, Evas_Grid_Data *pd, Eina_Bool clear);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_grid_clear, EO_FUNC_CALL(clear), Eina_Bool clear);
+
+Eina_Iterator * _evas_grid_iterator_new(Eo *obj, Evas_Grid_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_grid_iterator_new, Eina_Iterator *, 0);
+
+Evas_Object * _evas_grid_add_to(Eo *obj, Evas_Grid_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_grid_add_to, Evas_Object *, 0);
+
+Eina_Bool _evas_grid_unpack(Eo *obj, Evas_Grid_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_grid_unpack, Eina_Bool, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+Eina_Bool _evas_grid_pack_get(Eo *obj, Evas_Grid_Data *pd, Evas_Object *child, int *x, int *y, int *w, int *h);
+
+EOAPI EO_FUNC_BODYV(evas_obj_grid_pack_get, Eina_Bool, 0, EO_FUNC_CALL(child, x, y, w, h), Evas_Object *child, int *x, int *y, int *w, int *h);
+
+Eina_Bool _evas_grid_pack(Eo *obj, Evas_Grid_Data *pd, Evas_Object *child, int x, int y, int w, int h);
+
+EOAPI EO_FUNC_BODYV(evas_obj_grid_pack, Eina_Bool, 0, EO_FUNC_CALL(child, x, y, w, h), Evas_Object *child, int x, int y, int w, int h);
+
+void _evas_grid_eo_base_constructor(Eo *obj, Evas_Grid_Data *pd);
+
+
+static Eo_Op_Description _evas_grid_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_grid_eo_base_constructor),
+     EO_OP_FUNC(evas_obj_grid_mirrored_set, _evas_grid_mirrored_set, "Sets the mirrored mode of the grid. In mirrored mode the grid items go"),
+     EO_OP_FUNC(evas_obj_grid_mirrored_get, _evas_grid_mirrored_get, "Gets the mirrored mode of the grid."),
+     EO_OP_FUNC(evas_obj_grid_size_set, _evas_grid_size_set, "Set the virtual resolution for the grid"),
+     EO_OP_FUNC(evas_obj_grid_size_get, _evas_grid_size_get, "Get the current virtual resolution"),
+     EO_OP_FUNC(evas_obj_grid_children_get, _evas_grid_children_get, "Get the list of children for the grid."),
+     EO_OP_FUNC(evas_obj_grid_accessor_new, _evas_grid_accessor_new, "Get an accessor to get random access to the list of children for the grid."),
+     EO_OP_FUNC(evas_obj_grid_clear, _evas_grid_clear, "Faster way to remove all child objects from a grid object."),
+     EO_OP_FUNC(evas_obj_grid_iterator_new, _evas_grid_iterator_new, "Get an iterator to walk the list of children for the grid."),
+     EO_OP_FUNC(evas_obj_grid_add_to, _evas_grid_add_to, "Create a grid that is child of a given element @a parent."),
+     EO_OP_FUNC(evas_obj_grid_unpack, _evas_grid_unpack, "Remove child from grid."),
+     EO_OP_FUNC(evas_obj_grid_pack_get, _evas_grid_pack_get, "Get the pack options for a grid child"),
+     EO_OP_FUNC(evas_obj_grid_pack, _evas_grid_pack, "Add a new child to a grid object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_grid_class_desc = {
+     EO_VERSION,
+     "Evas_Grid",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_grid_op_desc),
+     NULL,
+     sizeof(Evas_Grid_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_grid_class_get, &_evas_grid_class_desc, EVAS_SMART_CLIPPED_CLASS, NULL);
+EAPI void
+evas_object_grid_mirrored_set(Evas_Grid *obj, Eina_Bool mirrored)
+{
+   eo_do((Evas_Grid *)obj, evas_obj_grid_mirrored_set(mirrored));
+}
+
+EAPI Eina_Bool
+evas_object_grid_mirrored_get(const Evas_Grid *obj)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_mirrored_get());
+}
+
+EAPI void
+evas_object_grid_size_set(Evas_Grid *obj, int w, int h)
+{
+   eo_do((Evas_Grid *)obj, evas_obj_grid_size_set(w, h));
+}
+
+EAPI void
+evas_object_grid_size_get(const Evas_Grid *obj, int *w, int *h)
+{
+   eo_do((Evas_Grid *)obj, evas_obj_grid_size_get(w, h));
+}
+
+EAPI Eina_List *
+evas_object_grid_children_get(const Evas_Grid *obj)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_children_get());
+}
+
+EAPI Eina_Accessor *
+evas_object_grid_accessor_new(const Evas_Grid *obj)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_accessor_new());
+}
+
+EAPI void
+evas_object_grid_clear(Evas_Grid *obj, Eina_Bool clear)
+{
+   eo_do((Evas_Grid *)obj, evas_obj_grid_clear(clear));
+}
+
+EAPI Eina_Iterator *
+evas_object_grid_iterator_new(const Evas_Grid *obj)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_iterator_new());
+}
+
+EAPI Evas_Object *
+evas_object_grid_add_to(Evas_Grid *obj)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_add_to());
+}
+
+EAPI Eina_Bool
+evas_object_grid_unpack(Evas_Grid *obj, Evas_Object *child)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_unpack(child));
+}
+
+EAPI Eina_Bool
+evas_object_grid_pack_get(const Evas_Grid *obj, Evas_Object *child, int *x, int *y, int *w, int *h)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_pack_get(child, x, y, w, h));
+}
+
+EAPI Eina_Bool
+evas_object_grid_pack(Evas_Grid *obj, Evas_Object *child, int x, int y, int w, int h)
+{
+   return eo_do((Evas_Grid *)obj, evas_obj_grid_pack(child, x, y, w, h));
+}
diff -Naur a/src/lib/evas/canvas/evas_grid.eo.h b/src/lib/evas/canvas/evas_grid.eo.h
--- a/src/lib/evas/canvas/evas_grid.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_grid.eo.h	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,186 @@
+#ifndef _EVAS_GRID_EO_H_
+#define _EVAS_GRID_EO_H_
+
+#ifndef _EVAS_GRID_EO_CLASS_TYPE
+#define _EVAS_GRID_EO_CLASS_TYPE
+
+typedef Eo Evas_Grid;
+
+#endif
+
+#ifndef _EVAS_GRID_EO_TYPES
+#define _EVAS_GRID_EO_TYPES
+
+
+#endif
+#define EVAS_GRID_CLASS evas_grid_class_get()
+
+const Eo_Class *evas_grid_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Sets the mirrored mode of the grid. In mirrored mode the grid items go
+ * from right to left instead of left to right. That is, 0,0 is top right, not
+ * to left.
+ *
+ * @since 1.1
+ *
+ * @param[in] mirrored the mirrored mode to set
+ *
+ */
+EOAPI void  evas_obj_grid_mirrored_set(Eina_Bool mirrored);
+
+/**
+ *
+ * Gets the mirrored mode of the grid.
+ *
+ * @return @c EINA_TRUE if it's a mirrored grid, @c EINA_FALSE otherwise.
+ * @see evas_object_grid_mirrored_set()
+ * @since 1.1
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_grid_mirrored_get(void);
+
+/**
+ *
+ * Set the virtual resolution for the grid
+ *
+ * @since 1.1
+ *
+ * @param[in] w The virtual horizontal size (resolution) in integer units
+ * @param[in] h The virtual vertical size (resolution) in integer units
+ *
+ */
+EOAPI void  evas_obj_grid_size_set(int w, int h);
+
+/**
+ *
+ * Get the current virtual resolution
+ *
+ * @see evas_object_grid_size_set()
+ * @since 1.1
+ *
+ * @param[out] w The virtual horizontal size (resolution) in integer units
+ * @param[out] h The virtual vertical size (resolution) in integer units
+ *
+ */
+EOAPI void  evas_obj_grid_size_get(int *w, int *h);
+
+/**
+ *
+ * Get the list of children for the grid.
+ *
+ * @note This is a duplicate of the list kept by the grid internally.
+ * It's up to the user to destroy it when it no longer needs it.
+ * It's possible to remove objects from the grid when walking this
+ * list, but these removals won't be reflected on it.
+ * @since 1.1
+ *
+ *
+ */
+EOAPI Eina_List * evas_obj_grid_children_get(void);
+
+/**
+ *
+ * Get an accessor to get random access to the list of children for the grid.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * @since 1.1
+ * 
+ *
+ *
+ */
+EOAPI Eina_Accessor * evas_obj_grid_accessor_new(void);
+
+/**
+ *
+ * Faster way to remove all child objects from a grid object.
+ *
+ * @since 1.1
+ * 
+ *
+ * @param[in] clear if true, it will delete just removed children.
+ *
+ */
+EOAPI void  evas_obj_grid_clear(Eina_Bool clear);
+
+/**
+ *
+ * Get an iterator to walk the list of children for the grid.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * @since 1.1
+ * 
+ *
+ *
+ */
+EOAPI Eina_Iterator * evas_obj_grid_iterator_new(void);
+
+/**
+ *
+ * Create a grid that is child of a given element @a parent.
+ *
+ * @see evas_object_grid_add()
+ * @since 1.1
+ * 
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_grid_add_to(void);
+
+/**
+ *
+ * Remove child from grid.
+ *
+ * @note removing a child will immediately call a walk over children in order
+ * to recalculate numbers of columns and rows. If you plan to remove
+ * all children, use evas_object_grid_clear() instead.
+ *
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child No description supplied.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_grid_unpack(Evas_Object *child);
+
+/**
+ *
+ * Get the pack options for a grid child
+ *
+ * Get the pack x, y, width and height in virtual coordinates set by
+ * evas_object_grid_pack()
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child The grid child to query for coordinates
+ * @param[out] x The pointer to where the x coordinate will be returned
+ * @param[out] y The pointer to where the y coordinate will be returned
+ * @param[out] w The pointer to where the width will be returned
+ * @param[out] h The pointer to where the height will be returned
+ *
+ */
+EOAPI Eina_Bool  evas_obj_grid_pack_get(Evas_Object *child, int *x, int *y, int *w, int *h);
+
+/**
+ *
+ * Add a new child to a grid object.
+ *
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child The child object to add.
+ * @param[in] x The virtual x coordinate of the child
+ * @param[in] y The virtual y coordinate of the child
+ * @param[in] w The virtual width of the child
+ * @param[in] h The virtual height of the child
+ *
+ */
+EOAPI Eina_Bool  evas_obj_grid_pack(Evas_Object *child, int x, int y, int w, int h);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_grid.eo.hh b/src/lib/evas/canvas/evas_grid.eo.hh
--- a/src/lib/evas/canvas/evas_grid.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_grid.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,627 @@
+#ifndef EFL_GENERATED_EVAS_GRID_HH
+#define EFL_GENERATED_EVAS_GRID_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_grid.eo.h"
+}
+
+#include "evas_smart_clipped.eo.hh"
+#include <canvas/evas_object.eo.hh>
+
+namespace evas {
+
+struct grid
+      : evas::smart_clipped
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit grid(Eo* eo)
+      : evas::smart_clipped(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit grid(std::nullptr_t)
+      : evas::smart_clipped(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   grid(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : grid(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   grid(grid const& other)
+      : evas::smart_clipped(eo_ref(other._eo_ptr()))
+   {}
+
+   ~grid() {}
+
+   /// @brief Gets the mirrored mode of the grid.
+   ///
+   /// @return @c EINA_TRUE if it's a mirrored grid, @c EINA_FALSE otherwise.
+   /// @see evas_object_grid_mirrored_set()
+   /// @since 1.1
+   ///
+   /// @param mirrored the mirrored mode to set
+   ///
+   bool mirrored_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_mirrored_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets the mirrored mode of the grid. In mirrored mode the grid items go
+   /// from right to left instead of left to right. That is, 0,0 is top right, not
+   /// to left.
+   ///
+   /// @since 1.1
+   ///
+   /// @param mirrored the mirrored mode to set
+   ///
+   void mirrored_set(bool mirrored_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_grid_mirrored_set(efl::eolian::to_c(mirrored_)));
+   }
+
+   /// @brief Get the current virtual resolution
+   ///
+   /// @see evas_object_grid_size_set()
+   /// @since 1.1
+   ///
+   /// @param w The virtual horizontal size (resolution) in integer units
+   /// @param h The virtual vertical size (resolution) in integer units
+   ///
+   void size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_grid_size_get(w_, h_));
+   }
+
+   /// @brief Set the virtual resolution for the grid
+   ///
+   /// @since 1.1
+   ///
+   /// @param w The virtual horizontal size (resolution) in integer units
+   /// @param h The virtual vertical size (resolution) in integer units
+   ///
+   void size_set(int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_grid_size_set(w_, h_));
+   }
+
+   /// @brief Get the list of children for the grid.
+   ///
+   /// @note This is a duplicate of the list kept by the grid internally.
+   /// It's up to the user to destroy it when it no longer needs it.
+   /// It's possible to remove objects from the grid when walking this
+   /// list, but these removals won't be reflected on it.
+   /// @since 1.1
+   ///
+   efl::eina::list< evas::object > children_get() const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_children_get());
+      return efl::eolian::to_cxx<efl::eina::list< evas::object >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+   }
+
+   /// @brief Get an accessor to get random access to the list of children for the grid.
+   ///
+   /// @note Do not remove or delete objects while walking the list.
+   /// @since 1.1
+   ///
+   Eina_Accessor * accessor_new() const
+   {
+      Eina_Accessor * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_accessor_new());
+      return _tmp_ret;
+   }
+
+   /// @brief Faster way to remove all child objects from a grid object.
+   ///
+   /// @since 1.1
+   ///
+   /// @param clear if true, it will delete just removed children.
+   ///
+   void clear(bool clear_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_grid_clear(efl::eolian::to_c(clear_)));
+   }
+
+   /// @brief Get an iterator to walk the list of children for the grid.
+   ///
+   /// @note Do not remove or delete objects while walking the list.
+   /// @since 1.1
+   ///
+   Eina_Iterator * iterator_new() const
+   {
+      Eina_Iterator * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_iterator_new());
+      return _tmp_ret;
+   }
+
+   /// @brief Create a grid that is child of a given element @a parent.
+   ///
+   /// @see evas_object_grid_add()
+   /// @since 1.1
+   ///
+   evas::object add_to() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_add_to());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Remove child from grid.
+   ///
+   /// @note removing a child will immediately call a walk over children in order
+   /// to recalculate numbers of columns and rows. If you plan to remove
+   /// all children, use evas_object_grid_clear() instead.
+   ///
+   /// @return 1 on success, 0 on failure.
+   /// @since 1.1
+   ///
+   /// @param child 
+   ///
+   bool unpack(evas::object child_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_unpack(efl::eolian::to_c(child_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the pack options for a grid child
+   ///
+   /// Get the pack x, y, width and height in virtual coordinates set by
+   /// evas_object_grid_pack()
+   /// @return 1 on success, 0 on failure.
+   /// @since 1.1
+   ///
+   /// @param child The grid child to query for coordinates
+   /// @param[out] x The pointer to where the x coordinate will be returned
+   /// @param[out] y The pointer to where the y coordinate will be returned
+   /// @param[out] w The pointer to where the width will be returned
+   /// @param[out] h The pointer to where the height will be returned
+   ///
+   bool pack_get(evas::object child_, int* x_, int* y_, int* w_, int* h_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_pack_get(efl::eolian::to_c(child_), x_, y_, w_, h_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Add a new child to a grid object.
+   ///
+   /// @return 1 on success, 0 on failure.
+   /// @since 1.1
+   ///
+   /// @param child The child object to add.
+   /// @param x The virtual x coordinate of the child
+   /// @param y The virtual y coordinate of the child
+   /// @param w The virtual width of the child
+   /// @param h The virtual height of the child
+   ///
+   bool pack(evas::object child_, int x_, int y_, int w_, int h_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_grid_pack(efl::eolian::to_c(child_), x_, y_, w_, h_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_GRID_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_GRID_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+bool evas_grid_mirrored_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->mirrored_get();
+}
+
+template <typename T>
+void evas_grid_mirrored_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool mirrored_)
+{
+   static_cast<T*>(self->this_)->mirrored_set(efl::eolian::to_cxx<bool>(mirrored_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_grid_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->size_get(w_, h_);
+}
+
+template <typename T>
+void evas_grid_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->size_set(w_, h_);
+}
+
+template <typename T>
+efl::eina::list< evas::object > evas_grid_children_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->children_get();
+}
+
+template <typename T>
+Eina_Accessor * evas_grid_accessor_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->accessor_new();
+}
+
+template <typename T>
+void evas_grid_clear_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool clear_)
+{
+   static_cast<T*>(self->this_)->clear(efl::eolian::to_cxx<bool>(clear_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Eina_Iterator * evas_grid_iterator_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->iterator_new();
+}
+
+template <typename T>
+evas::object evas_grid_add_to_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->add_to();
+}
+
+template <typename T>
+bool evas_grid_unpack_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->unpack(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_grid_pack_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, int* x_, int* y_, int* w_, int* h_)
+{
+   return static_cast<T*>(self->this_)->pack_get(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), x_, y_, w_, h_);
+}
+
+template <typename T>
+bool evas_grid_pack_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, int x_, int y_, int w_, int h_)
+{
+   return static_cast<T*>(self->this_)->pack(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), x_, y_, w_, h_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::grid >
+{
+   template <typename T>
+   struct type
+   {
+      virtual bool mirrored_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_mirrored_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void mirrored_set(bool mirrored_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_grid_mirrored_set(efl::eolian::to_c(mirrored_)));
+      }
+
+      virtual void size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_grid_size_get(w_, h_));
+      }
+
+      virtual void size_set(int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_grid_size_set(w_, h_));
+      }
+
+      virtual efl::eina::list< evas::object > children_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_children_get());
+            return efl::eolian::to_cxx<efl::eina::list< evas::object >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+      }
+
+      virtual Eina_Accessor * accessor_new()
+      {
+         Eina_Accessor * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_accessor_new());
+            return _tmp_ret;
+      }
+
+      virtual void clear(bool clear_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_grid_clear(efl::eolian::to_c(clear_)));
+      }
+
+      virtual Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_iterator_new());
+            return _tmp_ret;
+      }
+
+      virtual evas::object add_to()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_add_to());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool unpack(evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_unpack(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool pack_get(evas::object child_, int* x_, int* y_, int* w_, int* h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_pack_get(efl::eolian::to_c(child_), x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool pack(evas::object child_, int x_, int y_, int w_, int h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_grid_pack(efl::eolian::to_c(child_), x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::grid >
+{
+   static const int value = 12;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::grid>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_grid_mirrored_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_mirrored_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_grid_mirrored_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_mirrored_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_grid_size_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_size_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_grid_size_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_size_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_grid_children_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_children_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_grid_accessor_new_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_accessor_new);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_grid_clear_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_clear);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_grid_iterator_new_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_iterator_new);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_grid_add_to_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_add_to);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_grid_unpack_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_unpack);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_grid_pack_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_pack_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_grid_pack_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_grid_pack);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::grid >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::grid, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::grid >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::grid, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::grid>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::grid() const
+      {
+         return evas::grid(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      bool mirrored_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_mirrored_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void mirrored_set(bool mirrored_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_grid_mirrored_set(efl::eolian::to_c(mirrored_)));
+      }
+
+      void size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_grid_size_get(w_, h_));
+      }
+
+      void size_set(int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_grid_size_set(w_, h_));
+      }
+
+      efl::eina::list< evas::object > children_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_children_get());
+            return efl::eolian::to_cxx<efl::eina::list< evas::object >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+      }
+
+      Eina_Accessor * accessor_new()
+      {
+         Eina_Accessor * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_accessor_new());
+            return _tmp_ret;
+      }
+
+      void clear(bool clear_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_grid_clear(efl::eolian::to_c(clear_)));
+      }
+
+      Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_iterator_new());
+            return _tmp_ret;
+      }
+
+      evas::object add_to()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_add_to());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool unpack(evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_unpack(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool pack_get(evas::object child_, int* x_, int* y_, int* w_, int* h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_pack_get(efl::eolian::to_c(child_), x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool pack(evas::object child_, int x_, int y_, int w_, int h_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_grid_pack(efl::eolian::to_c(child_), x_, y_, w_, h_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::grid>)
+{
+   return (EVAS_GRID_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_GRID_HH
+
diff -Naur a/src/lib/evas/canvas/evas_grid.eo.legacy.h b/src/lib/evas/canvas/evas_grid.eo.legacy.h
--- a/src/lib/evas/canvas/evas_grid.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_grid.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,170 @@
+#ifndef _EVAS_GRID_EO_LEGACY_H_
+#define _EVAS_GRID_EO_LEGACY_H_
+
+#ifndef _EVAS_GRID_EO_CLASS_TYPE
+#define _EVAS_GRID_EO_CLASS_TYPE
+
+typedef Eo Evas_Grid;
+
+#endif
+
+#ifndef _EVAS_GRID_EO_TYPES
+#define _EVAS_GRID_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Sets the mirrored mode of the grid. In mirrored mode the grid items go
+ * from right to left instead of left to right. That is, 0,0 is top right, not
+ * to left.
+ *
+ * @since 1.1
+ *
+ * @param[in] mirrored the mirrored mode to set
+ */
+EAPI void evas_object_grid_mirrored_set(Evas_Grid *obj, Eina_Bool mirrored);
+
+/**
+ *
+ * Gets the mirrored mode of the grid.
+ *
+ * @return @c EINA_TRUE if it's a mirrored grid, @c EINA_FALSE otherwise.
+ * @see evas_object_grid_mirrored_set()
+ * @since 1.1
+ *
+ */
+EAPI Eina_Bool evas_object_grid_mirrored_get(const Evas_Grid *obj);
+
+/**
+ *
+ * Set the virtual resolution for the grid
+ *
+ * @since 1.1
+ *
+ * @param[in] w The virtual horizontal size (resolution) in integer units
+ * @param[in] h The virtual vertical size (resolution) in integer units
+ */
+EAPI void evas_object_grid_size_set(Evas_Grid *obj, int w, int h);
+
+/**
+ *
+ * Get the current virtual resolution
+ *
+ * @see evas_object_grid_size_set()
+ * @since 1.1
+ *
+ * @param[out] w The virtual horizontal size (resolution) in integer units
+ * @param[out] h The virtual vertical size (resolution) in integer units
+ */
+EAPI void evas_object_grid_size_get(const Evas_Grid *obj, int *w, int *h);
+
+/**
+ *
+ * Get the list of children for the grid.
+ *
+ * @note This is a duplicate of the list kept by the grid internally.
+ * It's up to the user to destroy it when it no longer needs it.
+ * It's possible to remove objects from the grid when walking this
+ * list, but these removals won't be reflected on it.
+ * @since 1.1
+ *
+ */
+EAPI Eina_List *evas_object_grid_children_get(const Evas_Grid *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get an accessor to get random access to the list of children for the grid.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * @since 1.1
+ * 
+ *
+ */
+EAPI Eina_Accessor *evas_object_grid_accessor_new(const Evas_Grid *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Faster way to remove all child objects from a grid object.
+ *
+ * @since 1.1
+ * 
+ *
+ * @param[in] clear if true, it will delete just removed children.
+ */
+EAPI void evas_object_grid_clear(Evas_Grid *obj, Eina_Bool clear);
+
+/**
+ *
+ * Get an iterator to walk the list of children for the grid.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * @since 1.1
+ * 
+ *
+ */
+EAPI Eina_Iterator *evas_object_grid_iterator_new(const Evas_Grid *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Create a grid that is child of a given element @a parent.
+ *
+ * @see evas_object_grid_add()
+ * @since 1.1
+ * 
+ *
+ */
+EAPI Evas_Object *evas_object_grid_add_to(Evas_Grid *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Remove child from grid.
+ *
+ * @note removing a child will immediately call a walk over children in order
+ * to recalculate numbers of columns and rows. If you plan to remove
+ * all children, use evas_object_grid_clear() instead.
+ *
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child No description supplied.
+ */
+EAPI Eina_Bool evas_object_grid_unpack(Evas_Grid *obj, Evas_Object *child) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Get the pack options for a grid child
+ *
+ * Get the pack x, y, width and height in virtual coordinates set by
+ * evas_object_grid_pack()
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child The grid child to query for coordinates
+ * @param[out] x The pointer to where the x coordinate will be returned
+ * @param[out] y The pointer to where the y coordinate will be returned
+ * @param[out] w The pointer to where the width will be returned
+ * @param[out] h The pointer to where the height will be returned
+ */
+EAPI Eina_Bool evas_object_grid_pack_get(const Evas_Grid *obj, Evas_Object *child, int *x, int *y, int *w, int *h);
+
+/**
+ *
+ * Add a new child to a grid object.
+ *
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child The child object to add.
+ * @param[in] x The virtual x coordinate of the child
+ * @param[in] y The virtual y coordinate of the child
+ * @param[in] w The virtual width of the child
+ * @param[in] h The virtual height of the child
+ */
+EAPI Eina_Bool evas_object_grid_pack(Evas_Grid *obj, Evas_Object *child, int x, int y, int w, int h) EINA_ARG_NONNULL(2);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_image.eo.c b/src/lib/evas/canvas/evas_image.eo.c
--- a/src/lib/evas/canvas/evas_image.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_image.eo.c	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,793 @@
+
+void _evas_image_load_dpi_set(Eo *obj, Evas_Image_Data *pd, double dpi);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_load_dpi_set, EO_FUNC_CALL(dpi), double dpi);
+
+double _evas_image_load_dpi_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_load_dpi_get, double, 0);
+
+void _evas_image_source_clip_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool source_clip);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_source_clip_set, EO_FUNC_CALL(source_clip), Eina_Bool source_clip);
+
+Eina_Bool _evas_image_source_clip_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_source_clip_get, Eina_Bool, 0);
+
+Eina_Bool _evas_image_source_set(Eo *obj, Evas_Image_Data *pd, Evas_Object *src);
+
+EOAPI EO_FUNC_BODYV(evas_obj_image_source_set, Eina_Bool, 0, EO_FUNC_CALL(src), Evas_Object *src);
+
+Evas_Object * _evas_image_source_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_source_get, Evas_Object *, 0);
+
+void _evas_image_filled_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool filled);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_filled_set, EO_FUNC_CALL(filled), Eina_Bool filled);
+
+Eina_Bool _evas_image_filled_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_filled_get, Eina_Bool, 0);
+
+void _evas_image_content_hint_set(Eo *obj, Evas_Image_Data *pd, Evas_Image_Content_Hint hint);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_content_hint_set, EO_FUNC_CALL(hint), Evas_Image_Content_Hint hint);
+
+Evas_Image_Content_Hint _evas_image_content_hint_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_content_hint_get, Evas_Image_Content_Hint, 0);
+
+void _evas_image_load_region_set(Eo *obj, Evas_Image_Data *pd, int x, int y, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_load_region_set, EO_FUNC_CALL(x, y, w, h), int x, int y, int w, int h);
+
+void _evas_image_load_region_get(Eo *obj, Evas_Image_Data *pd, int *x, int *y, int *w, int *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_load_region_get, EO_FUNC_CALL(x, y, w, h), int *x, int *y, int *w, int *h);
+
+void _evas_image_alpha_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool alpha);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_alpha_set, EO_FUNC_CALL(alpha), Eina_Bool alpha);
+
+Eina_Bool _evas_image_alpha_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_alpha_get, Eina_Bool, 0);
+
+void _evas_image_border_set(Eo *obj, Evas_Image_Data *pd, int l, int r, int t, int b);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_border_set, EO_FUNC_CALL(l, r, t, b), int l, int r, int t, int b);
+
+void _evas_image_border_get(Eo *obj, Evas_Image_Data *pd, int *l, int *r, int *t, int *b);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_border_get, EO_FUNC_CALL(l, r, t, b), int *l, int *r, int *t, int *b);
+
+void _evas_image_border_scale_set(Eo *obj, Evas_Image_Data *pd, double scale);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_border_scale_set, EO_FUNC_CALL(scale), double scale);
+
+double _evas_image_border_scale_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_border_scale_get, double, 0);
+
+void _evas_image_pixels_dirty_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool dirty);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_pixels_dirty_set, EO_FUNC_CALL(dirty), Eina_Bool dirty);
+
+Eina_Bool _evas_image_pixels_dirty_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_pixels_dirty_get, Eina_Bool, 0);
+
+void _evas_image_video_surface_set(Eo *obj, Evas_Image_Data *pd, Evas_Video_Surface *surf);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_video_surface_set, EO_FUNC_CALL(surf), Evas_Video_Surface *surf);
+
+const Evas_Video_Surface * _evas_image_video_surface_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_video_surface_get, const Evas_Video_Surface *, 0);
+
+void _evas_image_video_surface_caps_set(Eo *obj, Evas_Image_Data *pd, unsigned int caps);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_video_surface_caps_set, EO_FUNC_CALL(caps), unsigned int caps);
+
+unsigned int _evas_image_video_surface_caps_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_video_surface_caps_get, unsigned int, 0);
+
+void _evas_image_load_orientation_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool enable);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_load_orientation_set, EO_FUNC_CALL(enable), Eina_Bool enable);
+
+Eina_Bool _evas_image_load_orientation_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_load_orientation_get, Eina_Bool, 0);
+
+void _evas_image_fill_spread_set(Eo *obj, Evas_Image_Data *pd, Evas_Fill_Spread spread);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_fill_spread_set, EO_FUNC_CALL(spread), Evas_Fill_Spread spread);
+
+Evas_Fill_Spread _evas_image_fill_spread_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_fill_spread_get, Evas_Fill_Spread, 0);
+
+void _evas_image_border_center_fill_set(Eo *obj, Evas_Image_Data *pd, Evas_Border_Fill_Mode fill);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_border_center_fill_set, EO_FUNC_CALL(fill), Evas_Border_Fill_Mode fill);
+
+Evas_Border_Fill_Mode _evas_image_border_center_fill_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_border_center_fill_get, Evas_Border_Fill_Mode, 0);
+
+void _evas_image_size_set(Eo *obj, Evas_Image_Data *pd, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_size_set, EO_FUNC_CALL(w, h), int w, int h);
+
+void _evas_image_size_get(Eo *obj, Evas_Image_Data *pd, int *w, int *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_size_get, EO_FUNC_CALL(w, h), int *w, int *h);
+
+void _evas_image_source_visible_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool visible);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_source_visible_set, EO_FUNC_CALL(visible), Eina_Bool visible);
+
+Eina_Bool _evas_image_source_visible_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_source_visible_get, Eina_Bool, 0);
+
+void _evas_image_fill_set(Eo *obj, Evas_Image_Data *pd, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_fill_set, EO_FUNC_CALL(x, y, w, h), Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+void _evas_image_fill_get(Eo *obj, Evas_Image_Data *pd, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_fill_get, EO_FUNC_CALL(x, y, w, h), Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+void _evas_image_native_surface_set(Eo *obj, Evas_Image_Data *pd, Evas_Native_Surface *surf);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_native_surface_set, EO_FUNC_CALL(surf), Evas_Native_Surface *surf);
+
+Evas_Native_Surface * _evas_image_native_surface_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_native_surface_get, Evas_Native_Surface *, 0);
+
+void _evas_image_load_scale_down_set(Eo *obj, Evas_Image_Data *pd, int scale_down);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_load_scale_down_set, EO_FUNC_CALL(scale_down), int scale_down);
+
+int _evas_image_load_scale_down_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_load_scale_down_get, int, 0);
+
+void _evas_image_scale_hint_set(Eo *obj, Evas_Image_Data *pd, Evas_Image_Scale_Hint hint);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_scale_hint_set, EO_FUNC_CALL(hint), Evas_Image_Scale_Hint hint);
+
+Evas_Image_Scale_Hint _evas_image_scale_hint_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_scale_hint_get, Evas_Image_Scale_Hint, 0);
+
+void _evas_image_source_events_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool source);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_source_events_set, EO_FUNC_CALL(source), Eina_Bool source);
+
+Eina_Bool _evas_image_source_events_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_source_events_get, Eina_Bool, 0);
+
+void _evas_image_colorspace_set(Eo *obj, Evas_Image_Data *pd, Evas_Colorspace cspace);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_colorspace_set, EO_FUNC_CALL(cspace), Evas_Colorspace cspace);
+
+Evas_Colorspace _evas_image_colorspace_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_colorspace_get, Evas_Colorspace, 0);
+
+void _evas_image_pixels_get_callback_set(Eo *obj, Evas_Image_Data *pd, Evas_Object_Image_Pixels_Get_Cb func, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_pixels_get_callback_set, EO_FUNC_CALL(func, data), Evas_Object_Image_Pixels_Get_Cb func, void *data);
+
+void _evas_image_mmap_set(Eo *obj, Evas_Image_Data *pd, const Eina_File *f, const char *key);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_mmap_set, EO_FUNC_CALL(f, key), const Eina_File *f, const char *key);
+
+void _evas_image_mmap_get(Eo *obj, Evas_Image_Data *pd, const Eina_File **f, const char **key);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_mmap_get, EO_FUNC_CALL(f, key), const Eina_File **f, const char **key);
+
+void _evas_image_data_copy_set(Eo *obj, Evas_Image_Data *pd, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_data_copy_set, EO_FUNC_CALL(data), void *data);
+
+void _evas_image_animated_frame_set(Eo *obj, Evas_Image_Data *pd, int frame_index);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_animated_frame_set, EO_FUNC_CALL(frame_index), int frame_index);
+
+Eina_Bool _evas_image_region_support_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_region_support_get, Eina_Bool, 0);
+
+Evas_Load_Error _evas_image_load_error_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_load_error_get, Evas_Load_Error, 0);
+
+int _evas_image_animated_frame_count_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_animated_frame_count_get, int, 0);
+
+int _evas_image_stride_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_stride_get, int, 0);
+
+Evas_Image_Animated_Loop_Hint _evas_image_animated_loop_type_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_animated_loop_type_get, Evas_Image_Animated_Loop_Hint, 0);
+
+int _evas_image_animated_loop_count_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_animated_loop_count_get, int, 0);
+
+void _evas_image_scene_set(Eo *obj, Evas_Image_Data *pd, Evas_3D_Scene *scene);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_scene_set, EO_FUNC_CALL(scene), Evas_3D_Scene *scene);
+
+Evas_3D_Scene * _evas_image_scene_get(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_image_scene_get, Evas_3D_Scene *, 0);
+
+void _evas_image_filter_program_set(Eo *obj, Evas_Image_Data *pd, const char *program);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_filter_program_set, EO_FUNC_CALL(program), const char *program);
+
+void _evas_image_filter_source_set(Eo *obj, Evas_Image_Data *pd, const char *name, Eo *eobj);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_filter_source_set, EO_FUNC_CALL(name, eobj), const char *name, Eo *eobj);
+
+Eina_Bool _evas_image_filter_padding_get(Eo *obj, Evas_Image_Data *pd, int *l, int *r, int *t, int *b);
+
+EOAPI EO_FUNC_BODYV(evas_obj_image_filter_padding_get, Eina_Bool, 0, EO_FUNC_CALL(l, r, t, b), int *l, int *r, int *t, int *b);
+
+void _evas_image_preload_begin(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_image_preload_begin);
+
+void _evas_image_data_update_add(Eo *obj, Evas_Image_Data *pd, int x, int y, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_data_update_add, EO_FUNC_CALL(x, y, w, h), int x, int y, int w, int h);
+
+double _evas_image_animated_frame_duration_get(Eo *obj, Evas_Image_Data *pd, int start_frame, int frame_num);
+
+EOAPI EO_FUNC_BODYV(evas_obj_image_animated_frame_duration_get, double, 0, EO_FUNC_CALL(start_frame, frame_num), int start_frame, int frame_num);
+
+void _evas_image_data_set(Eo *obj, Evas_Image_Data *pd, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_image_data_set, EO_FUNC_CALL(data), void *data);
+
+void * _evas_image_data_get(Eo *obj, Evas_Image_Data *pd, Eina_Bool for_writing);
+
+EOAPI EO_FUNC_BODYV(evas_obj_image_data_get, void *, 0, EO_FUNC_CALL(for_writing), Eina_Bool for_writing);
+
+void _evas_image_preload_cancel(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_image_preload_cancel);
+
+void * _evas_image_data_convert(Eo *obj, Evas_Image_Data *pd, Evas_Colorspace to_cspace);
+
+EOAPI EO_FUNC_BODYV(evas_obj_image_data_convert, void *, 0, EO_FUNC_CALL(to_cspace), Evas_Colorspace to_cspace);
+
+Eina_Bool _evas_image_pixels_import(Eo *obj, Evas_Image_Data *pd, Evas_Pixel_Import_Source *pixels);
+
+EOAPI EO_FUNC_BODYV(evas_obj_image_pixels_import, Eina_Bool, 0, EO_FUNC_CALL(pixels), Evas_Pixel_Import_Source *pixels);
+
+void _evas_image_reload(Eo *obj, Evas_Image_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_image_reload);
+
+void _evas_image_eo_base_constructor(Eo *obj, Evas_Image_Data *pd);
+
+
+void _evas_image_eo_base_destructor(Eo *obj, Evas_Image_Data *pd);
+
+
+void _evas_image_eo_base_dbg_info_get(Eo *obj, Evas_Image_Data *pd, Eo_Dbg_Info *root_node);
+
+
+Eina_Bool _evas_image_efl_file_file_set(Eo *obj, Evas_Image_Data *pd, const char *file, const char *key);
+
+
+void _evas_image_efl_file_file_get(Eo *obj, Evas_Image_Data *pd, const char **file, const char **key);
+
+
+Eina_Bool _evas_image_efl_file_save(Eo *obj, Evas_Image_Data *pd, const char *file, const char *key, const char *flags);
+
+
+Eina_Bool _evas_image_efl_image_animated_get(Eo *obj, Evas_Image_Data *pd);
+
+
+void _evas_image_efl_image_load_size_set(Eo *obj, Evas_Image_Data *pd, int w, int h);
+
+
+void _evas_image_efl_image_load_size_get(Eo *obj, Evas_Image_Data *pd, int *w, int *h);
+
+
+void _evas_image_efl_image_smooth_scale_set(Eo *obj, Evas_Image_Data *pd, Eina_Bool smooth_scale);
+
+
+Eina_Bool _evas_image_efl_image_smooth_scale_get(Eo *obj, Evas_Image_Data *pd);
+
+
+static Eo_Op_Description _evas_image_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_image_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_image_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_dbg_info_get, _evas_image_eo_base_dbg_info_get),
+     EO_OP_FUNC_OVERRIDE(efl_file_set, _evas_image_efl_file_file_set),
+     EO_OP_FUNC_OVERRIDE(efl_file_get, _evas_image_efl_file_file_get),
+     EO_OP_FUNC_OVERRIDE(efl_file_save, _evas_image_efl_file_save),
+     EO_OP_FUNC_OVERRIDE(efl_image_animated_get, _evas_image_efl_image_animated_get),
+     EO_OP_FUNC_OVERRIDE(efl_image_load_size_set, _evas_image_efl_image_load_size_set),
+     EO_OP_FUNC_OVERRIDE(efl_image_load_size_get, _evas_image_efl_image_load_size_get),
+     EO_OP_FUNC_OVERRIDE(efl_image_smooth_scale_set, _evas_image_efl_image_smooth_scale_set),
+     EO_OP_FUNC_OVERRIDE(efl_image_smooth_scale_get, _evas_image_efl_image_smooth_scale_get),
+     EO_OP_FUNC(evas_obj_image_load_dpi_set, _evas_image_load_dpi_set, "Set the DPI resolution of an image object's source image."),
+     EO_OP_FUNC(evas_obj_image_load_dpi_get, _evas_image_load_dpi_get, "Get the DPI resolution of a loaded image object in the canvas."),
+     EO_OP_FUNC(evas_obj_image_source_clip_set, _evas_image_source_clip_set, "Clip the proxy object with the source object's clipper."),
+     EO_OP_FUNC(evas_obj_image_source_clip_get, _evas_image_source_clip_get, "Determine whether an object is clipped by source object's clipper."),
+     EO_OP_FUNC(evas_obj_image_source_set, _evas_image_source_set, "Set the source object on an image object to used as a @b proxy."),
+     EO_OP_FUNC(evas_obj_image_source_get, _evas_image_source_get, "Get the current source object of an image object."),
+     EO_OP_FUNC(evas_obj_image_filled_set, _evas_image_filled_set, "Set whether the image object's fill property should track the"),
+     EO_OP_FUNC(evas_obj_image_filled_get, _evas_image_filled_get, "Retrieve whether the image object's fill property should track the"),
+     EO_OP_FUNC(evas_obj_image_content_hint_set, _evas_image_content_hint_set, "Set the content hint setting of a given image object of the canvas."),
+     EO_OP_FUNC(evas_obj_image_content_hint_get, _evas_image_content_hint_get, "Get the content hint setting of a given image object of the canvas."),
+     EO_OP_FUNC(evas_obj_image_load_region_set, _evas_image_load_region_set, "Inform a given image object to load a selective region of its"),
+     EO_OP_FUNC(evas_obj_image_load_region_get, _evas_image_load_region_get, "Retrieve the coordinates of a given image object's selective"),
+     EO_OP_FUNC(evas_obj_image_alpha_set, _evas_image_alpha_set, "Enable or disable alpha channel usage on the given image object."),
+     EO_OP_FUNC(evas_obj_image_alpha_get, _evas_image_alpha_get, "Retrieve whether alpha channel data is being used on the given"),
+     EO_OP_FUNC(evas_obj_image_border_set, _evas_image_border_set, "Set the dimensions for an image object's border, a region which @b"),
+     EO_OP_FUNC(evas_obj_image_border_get, _evas_image_border_get, "Retrieve the dimensions for an image object's border, a region"),
+     EO_OP_FUNC(evas_obj_image_border_scale_set, _evas_image_border_scale_set, "Sets the scaling factor (multiplier) for the borders of an image"),
+     EO_OP_FUNC(evas_obj_image_border_scale_get, _evas_image_border_scale_get, "Retrieves the scaling factor (multiplier) for the borders of an"),
+     EO_OP_FUNC(evas_obj_image_pixels_dirty_set, _evas_image_pixels_dirty_set, "Mark whether the given image object is dirty and needs to request its pixels."),
+     EO_OP_FUNC(evas_obj_image_pixels_dirty_get, _evas_image_pixels_dirty_get, "Retrieves whether the given image object is dirty (needs to be redrawn)."),
+     EO_OP_FUNC(evas_obj_image_video_surface_set, _evas_image_video_surface_set, "Set the video surface linked to a given image of the canvas"),
+     EO_OP_FUNC(evas_obj_image_video_surface_get, _evas_image_video_surface_get, "Get the video surface linekd to a given image of the canvas"),
+     EO_OP_FUNC(evas_obj_image_video_surface_caps_set, _evas_image_video_surface_caps_set, "Set the video surface capabilities to a given image of the canvas"),
+     EO_OP_FUNC(evas_obj_image_video_surface_caps_get, _evas_image_video_surface_caps_get, "Get the video surface capabilities to a given image of the canvas"),
+     EO_OP_FUNC(evas_obj_image_load_orientation_set, _evas_image_load_orientation_set, "Define if the orientation information in the image file should be honored."),
+     EO_OP_FUNC(evas_obj_image_load_orientation_get, _evas_image_load_orientation_get, "Get if the orientation information in the image file should be honored."),
+     EO_OP_FUNC(evas_obj_image_fill_spread_set, _evas_image_fill_spread_set, "Sets the tiling mode for the given evas image object's fill."),
+     EO_OP_FUNC(evas_obj_image_fill_spread_get, _evas_image_fill_spread_get, "Retrieves the spread (tiling mode) for the given image object's"),
+     EO_OP_FUNC(evas_obj_image_border_center_fill_set, _evas_image_border_center_fill_set, "Sets @b how the center part of the given image object (not the"),
+     EO_OP_FUNC(evas_obj_image_border_center_fill_get, _evas_image_border_center_fill_get, "Retrieves @b how the center part of the given image object (not the"),
+     EO_OP_FUNC(evas_obj_image_size_set, _evas_image_size_set, "Sets the size of the given image object."),
+     EO_OP_FUNC(evas_obj_image_size_get, _evas_image_size_get, "Retrieves the size of the given image object."),
+     EO_OP_FUNC(evas_obj_image_source_visible_set, _evas_image_source_visible_set, "Set the source object to be visible or not."),
+     EO_OP_FUNC(evas_obj_image_source_visible_get, _evas_image_source_visible_get, "Get the state of the source object visibility."),
+     EO_OP_FUNC(evas_obj_image_fill_set, _evas_image_fill_set, "Set how to fill an image object's drawing rectangle given the"),
+     EO_OP_FUNC(evas_obj_image_fill_get, _evas_image_fill_get, "Retrieve how an image object is to fill its drawing rectangle,"),
+     EO_OP_FUNC(evas_obj_image_native_surface_set, _evas_image_native_surface_set, "Set the native surface of a given image of the canvas"),
+     EO_OP_FUNC(evas_obj_image_native_surface_get, _evas_image_native_surface_get, "Get the native surface of a given image of the canvas"),
+     EO_OP_FUNC(evas_obj_image_load_scale_down_set, _evas_image_load_scale_down_set, "Set the scale down factor of a given image object's source image,"),
+     EO_OP_FUNC(evas_obj_image_load_scale_down_get, _evas_image_load_scale_down_get, "get the scale down factor of a given image object's source image,"),
+     EO_OP_FUNC(evas_obj_image_scale_hint_set, _evas_image_scale_hint_set, "Set the scale hint of a given image of the canvas."),
+     EO_OP_FUNC(evas_obj_image_scale_hint_get, _evas_image_scale_hint_get, "Get the scale hint of a given image of the canvas."),
+     EO_OP_FUNC(evas_obj_image_source_events_set, _evas_image_source_events_set, "Set whether an Evas object is to source events."),
+     EO_OP_FUNC(evas_obj_image_source_events_get, _evas_image_source_events_get, "Determine whether an object is set to source events."),
+     EO_OP_FUNC(evas_obj_image_colorspace_set, _evas_image_colorspace_set, "Set the colorspace of a given image of the canvas."),
+     EO_OP_FUNC(evas_obj_image_colorspace_get, _evas_image_colorspace_get, "Get the colorspace of a given image of the canvas."),
+     EO_OP_FUNC(evas_obj_image_pixels_get_callback_set, _evas_image_pixels_get_callback_set, "Set the callback function to get pixels from a canvas' image."),
+     EO_OP_FUNC(evas_obj_image_mmap_set, _evas_image_mmap_set, "Set the source mmaped file from where an image object must fetch the real"),
+     EO_OP_FUNC(evas_obj_image_mmap_get, _evas_image_mmap_get, "Get the source mmaped file from where an image object must fetch the real"),
+     EO_OP_FUNC(evas_obj_image_data_copy_set, _evas_image_data_copy_set, "Replaces the raw image data of the given image object."),
+     EO_OP_FUNC(evas_obj_image_animated_frame_set, _evas_image_animated_frame_set, "Set the frame to current frame of an image object"),
+     EO_OP_FUNC(evas_obj_image_region_support_get, _evas_image_region_support_get, "Get the support state of a given image"),
+     EO_OP_FUNC(evas_obj_image_load_error_get, _evas_image_load_error_get, "Retrieves a number representing any error that occurred during the"),
+     EO_OP_FUNC(evas_obj_image_animated_frame_count_get, _evas_image_animated_frame_count_get, "Get the total number of frames of the image object."),
+     EO_OP_FUNC(evas_obj_image_stride_get, _evas_image_stride_get, "Retrieves the row stride of the given image object."),
+     EO_OP_FUNC(evas_obj_image_animated_loop_type_get, _evas_image_animated_loop_type_get, "Get the kind of looping the image object does."),
+     EO_OP_FUNC(evas_obj_image_animated_loop_count_get, _evas_image_animated_loop_count_get, "Get the number times the animation of the object loops."),
+     EO_OP_FUNC(evas_obj_image_scene_set, _evas_image_scene_set, "Set the 3D scene of a given image of the canvas."),
+     EO_OP_FUNC(evas_obj_image_scene_get, _evas_image_scene_get, "Get the 3D scene of a given image of the canvas."),
+     EO_OP_FUNC(evas_obj_image_filter_program_set, _evas_image_filter_program_set, "Set an Evas filter program on this Text Object."),
+     EO_OP_FUNC(evas_obj_image_filter_source_set, _evas_image_filter_source_set, "Bind an object to use as a mask or texture with Evas Filters."),
+     EO_OP_FUNC(evas_obj_image_filter_padding_get, _evas_image_filter_padding_get, "Get the value of the extra padding set when a filter is used."),
+     EO_OP_FUNC(evas_obj_image_preload_begin, _evas_image_preload_begin, "Begin preloading an image object's image data in the background"),
+     EO_OP_FUNC(evas_obj_image_data_update_add, _evas_image_data_update_add, "Mark a sub-region of the given image object to be redrawn."),
+     EO_OP_FUNC(evas_obj_image_animated_frame_duration_get, _evas_image_animated_frame_duration_get, "Get the duration of a sequence of frames."),
+     EO_OP_FUNC(evas_obj_image_data_set, _evas_image_data_set, "Sets the raw image data of the given image object."),
+     EO_OP_FUNC(evas_obj_image_data_get, _evas_image_data_get, "Get a pointer to the raw image data of the given image object."),
+     EO_OP_FUNC(evas_obj_image_preload_cancel, _evas_image_preload_cancel, "Cancel preloading an image object's image data in the background"),
+     EO_OP_FUNC(evas_obj_image_data_convert, _evas_image_data_convert, "Converts the raw image data of the given image object to the"),
+     EO_OP_FUNC(evas_obj_image_pixels_import, _evas_image_pixels_import, "Import pixels from given source to a given canvas image object."),
+     EO_OP_FUNC(evas_obj_image_reload, _evas_image_reload, "Reload an image object's image data."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_image_class_desc = {
+     EO_VERSION,
+     "Evas_Image",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_image_op_desc),
+     NULL,
+     sizeof(Evas_Image_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_image_class_get, &_evas_image_class_desc, EVAS_OBJECT_CLASS, EFL_FILE_INTERFACE, EFL_IMAGE_INTERFACE, NULL);
+EAPI void
+evas_object_image_load_dpi_set(Evas_Image *obj, double dpi)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_load_dpi_set(dpi));
+}
+
+EAPI double
+evas_object_image_load_dpi_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_load_dpi_get());
+}
+
+EAPI void
+evas_object_image_source_clip_set(Evas_Image *obj, Eina_Bool source_clip)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_source_clip_set(source_clip));
+}
+
+EAPI Eina_Bool
+evas_object_image_source_clip_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_source_clip_get());
+}
+
+EAPI Eina_Bool
+evas_object_image_source_set(Evas_Image *obj, Evas_Object *src)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_source_set(src));
+}
+
+EAPI Evas_Object *
+evas_object_image_source_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_source_get());
+}
+
+EAPI void
+evas_object_image_filled_set(Evas_Image *obj, Eina_Bool filled)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_filled_set(filled));
+}
+
+EAPI Eina_Bool
+evas_object_image_filled_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_filled_get());
+}
+
+EAPI void
+evas_object_image_content_hint_set(Evas_Image *obj, Evas_Image_Content_Hint hint)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_content_hint_set(hint));
+}
+
+EAPI Evas_Image_Content_Hint
+evas_object_image_content_hint_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_content_hint_get());
+}
+
+EAPI void
+evas_object_image_load_region_set(Evas_Image *obj, int x, int y, int w, int h)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_load_region_set(x, y, w, h));
+}
+
+EAPI void
+evas_object_image_load_region_get(const Evas_Image *obj, int *x, int *y, int *w, int *h)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_load_region_get(x, y, w, h));
+}
+
+EAPI void
+evas_object_image_alpha_set(Evas_Image *obj, Eina_Bool alpha)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_alpha_set(alpha));
+}
+
+EAPI Eina_Bool
+evas_object_image_alpha_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_alpha_get());
+}
+
+EAPI void
+evas_object_image_border_set(Evas_Image *obj, int l, int r, int t, int b)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_border_set(l, r, t, b));
+}
+
+EAPI void
+evas_object_image_border_get(const Evas_Image *obj, int *l, int *r, int *t, int *b)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_border_get(l, r, t, b));
+}
+
+EAPI void
+evas_object_image_border_scale_set(Evas_Image *obj, double scale)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_border_scale_set(scale));
+}
+
+EAPI double
+evas_object_image_border_scale_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_border_scale_get());
+}
+
+EAPI void
+evas_object_image_pixels_dirty_set(Evas_Image *obj, Eina_Bool dirty)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_pixels_dirty_set(dirty));
+}
+
+EAPI Eina_Bool
+evas_object_image_pixels_dirty_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_pixels_dirty_get());
+}
+
+EAPI void
+evas_object_image_video_surface_set(Evas_Image *obj, Evas_Video_Surface *surf)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_video_surface_set(surf));
+}
+
+EAPI const Evas_Video_Surface *
+evas_object_image_video_surface_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_video_surface_get());
+}
+
+EAPI void
+evas_object_image_video_surface_caps_set(Evas_Image *obj, unsigned int caps)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_video_surface_caps_set(caps));
+}
+
+EAPI unsigned int
+evas_object_image_video_surface_caps_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_video_surface_caps_get());
+}
+
+EAPI void
+evas_object_image_load_orientation_set(Evas_Image *obj, Eina_Bool enable)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_load_orientation_set(enable));
+}
+
+EAPI Eina_Bool
+evas_object_image_load_orientation_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_load_orientation_get());
+}
+
+EAPI void
+evas_object_image_fill_spread_set(Evas_Image *obj, Evas_Fill_Spread spread)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_fill_spread_set(spread));
+}
+
+EAPI Evas_Fill_Spread
+evas_object_image_fill_spread_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_fill_spread_get());
+}
+
+EAPI void
+evas_object_image_border_center_fill_set(Evas_Image *obj, Evas_Border_Fill_Mode fill)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_border_center_fill_set(fill));
+}
+
+EAPI Evas_Border_Fill_Mode
+evas_object_image_border_center_fill_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_border_center_fill_get());
+}
+
+EAPI void
+evas_object_image_size_set(Evas_Image *obj, int w, int h)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_size_set(w, h));
+}
+
+EAPI void
+evas_object_image_size_get(const Evas_Image *obj, int *w, int *h)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_size_get(w, h));
+}
+
+EAPI void
+evas_object_image_source_visible_set(Evas_Image *obj, Eina_Bool visible)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_source_visible_set(visible));
+}
+
+EAPI Eina_Bool
+evas_object_image_source_visible_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_source_visible_get());
+}
+
+EAPI void
+evas_object_image_fill_set(Evas_Image *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_fill_set(x, y, w, h));
+}
+
+EAPI void
+evas_object_image_fill_get(const Evas_Image *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_fill_get(x, y, w, h));
+}
+
+EAPI Evas_Native_Surface *
+evas_object_image_native_surface_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_native_surface_get());
+}
+
+EAPI void
+evas_object_image_load_scale_down_set(Evas_Image *obj, int scale_down)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_load_scale_down_set(scale_down));
+}
+
+EAPI int
+evas_object_image_load_scale_down_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_load_scale_down_get());
+}
+
+EAPI void
+evas_object_image_scale_hint_set(Evas_Image *obj, Evas_Image_Scale_Hint hint)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_scale_hint_set(hint));
+}
+
+EAPI Evas_Image_Scale_Hint
+evas_object_image_scale_hint_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_scale_hint_get());
+}
+
+EAPI void
+evas_object_image_source_events_set(Evas_Image *obj, Eina_Bool source)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_source_events_set(source));
+}
+
+EAPI Eina_Bool
+evas_object_image_source_events_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_source_events_get());
+}
+
+EAPI void
+evas_object_image_colorspace_set(Evas_Image *obj, Evas_Colorspace cspace)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_colorspace_set(cspace));
+}
+
+EAPI Evas_Colorspace
+evas_object_image_colorspace_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_colorspace_get());
+}
+
+EAPI void
+evas_object_image_pixels_get_callback_set(Evas_Image *obj, Evas_Object_Image_Pixels_Get_Cb func, void *data)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_pixels_get_callback_set(func, data));
+}
+
+EAPI void
+evas_object_image_mmap_set(Evas_Image *obj, const Eina_File *f, const char *key)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_mmap_set(f, key));
+}
+
+EAPI void
+evas_object_image_mmap_get(const Evas_Image *obj, const Eina_File **f, const char **key)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_mmap_get(f, key));
+}
+
+EAPI void
+evas_object_image_data_copy_set(Evas_Image *obj, void *data)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_data_copy_set(data));
+}
+
+EAPI void
+evas_object_image_animated_frame_set(Evas_Image *obj, int frame_index)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_animated_frame_set(frame_index));
+}
+
+EAPI Eina_Bool
+evas_object_image_region_support_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_region_support_get());
+}
+
+EAPI Evas_Load_Error
+evas_object_image_load_error_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_load_error_get());
+}
+
+EAPI int
+evas_object_image_animated_frame_count_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_animated_frame_count_get());
+}
+
+EAPI int
+evas_object_image_stride_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_stride_get());
+}
+
+EAPI Evas_Image_Animated_Loop_Hint
+evas_object_image_animated_loop_type_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_animated_loop_type_get());
+}
+
+EAPI int
+evas_object_image_animated_loop_count_get(const Evas_Image *obj)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_animated_loop_count_get());
+}
+
+EAPI void
+evas_object_image_data_update_add(Evas_Image *obj, int x, int y, int w, int h)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_data_update_add(x, y, w, h));
+}
+
+EAPI double
+evas_object_image_animated_frame_duration_get(const Evas_Image *obj, int start_frame, int frame_num)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_animated_frame_duration_get(start_frame, frame_num));
+}
+
+EAPI void
+evas_object_image_data_set(Evas_Image *obj, void *data)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_data_set(data));
+}
+
+EAPI void *
+evas_object_image_data_get(const Evas_Image *obj, Eina_Bool for_writing)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_data_get(for_writing));
+}
+
+EAPI void *
+evas_object_image_data_convert(Evas_Image *obj, Evas_Colorspace to_cspace)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_data_convert(to_cspace));
+}
+
+EAPI Eina_Bool
+evas_object_image_pixels_import(Evas_Image *obj, Evas_Pixel_Import_Source *pixels)
+{
+   return eo_do((Evas_Image *)obj, evas_obj_image_pixels_import(pixels));
+}
+
+EAPI void
+evas_object_image_reload(Evas_Image *obj)
+{
+   eo_do((Evas_Image *)obj, evas_obj_image_reload());
+}
diff -Naur a/src/lib/evas/canvas/evas_image.eo.h b/src/lib/evas/canvas/evas_image.eo.h
--- a/src/lib/evas/canvas/evas_image.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_image.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,1217 @@
+#ifndef _EVAS_IMAGE_EO_H_
+#define _EVAS_IMAGE_EO_H_
+
+#ifndef _EVAS_IMAGE_EO_CLASS_TYPE
+#define _EVAS_IMAGE_EO_CLASS_TYPE
+
+typedef Eo Evas_Image;
+
+#endif
+
+#ifndef _EVAS_IMAGE_EO_TYPES
+#define _EVAS_IMAGE_EO_TYPES
+
+
+#endif
+#define EVAS_IMAGE_CLASS evas_image_class_get()
+
+const Eo_Class *evas_image_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Set the DPI resolution of an image object's source image.
+ *
+ * This function sets the DPI resolution of a given loaded canvas
+ * image. Most useful for the SVG image loader.
+ *
+ * @see evas_object_image_load_dpi_get()
+ *
+ * @param[in] dpi The new DPI resolution.
+ *
+ */
+EOAPI void  evas_obj_image_load_dpi_set(double dpi);
+
+/**
+ *
+ * Get the DPI resolution of a loaded image object in the canvas.
+ *
+ * @return The DPI resolution of the given canvas image.
+ *
+ * This function returns the DPI resolution of the given canvas image.
+ *
+ * @see evas_object_image_load_dpi_set() for more details
+ *
+ *
+ */
+EOAPI double  evas_obj_image_load_dpi_get(void);
+
+/**
+ *
+ * Clip the proxy object with the source object's clipper.
+ *
+ * @see evas_object_clip_set()
+ * @see evas_object_image_source_set()
+ * @since 1.8
+ *
+ * @param[in] source_clip whether @p obj is clipped by the source clipper.
+(@c EINA_TRUE) or not (@c EINA_FALSE)
+ *
+ */
+EOAPI void  evas_obj_image_source_clip_set(Eina_Bool source_clip);
+
+/**
+ *
+ * Determine whether an object is clipped by source object's clipper.
+ *
+ * @return @c EINA_TRUE if source clip is enabled, @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_clip_set()
+ * @see evas_object_image_source_set()
+ * @see evas_object_image_source_clip_set()
+ * @since 1.8
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_source_clip_get(void);
+
+/**
+ *
+ * Set the source object on an image object to used as a @b proxy.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE on error.
+ *
+ * If an image object is set to behave as a @b proxy, it will mirror
+ * the rendering contents of a given @b source object in its drawing
+ * region, without affecting that source in any way. The source must
+ * be another valid Evas object. Other effects may be applied to the
+ * proxy, such as a map (see evas_object_map_set()) to create a
+ * reflection of the original object (for example).
+ *
+ * Any existing source object on @p obj will be removed after this
+ * call. Setting @p src to @c NULL clears the proxy object (not in
+ * "proxy state" anymore).
+ *
+ * @warning You cannot set a proxy as another proxy's source.
+ *
+ * @see evas_object_image_source_get()
+ * @see evas_object_image_source_unset()
+ * @see evas_object_image_source_visible_set()
+ *
+ * @param[in] src Source object to use for the proxy.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_source_set(Evas_Object *src);
+
+/**
+ *
+ * Get the current source object of an image object.
+ *
+ * @return Source object (if any), or @c NULL, if not in "proxy mode"
+ * (or on errors).
+ *
+ * @see evas_object_image_source_set() for more details
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_image_source_get(void);
+
+/**
+ *
+ * Set whether the image object's fill property should track the
+ * object's size.
+ *
+ * If @p setting is @c EINA_TRUE, then every evas_object_resize() will
+ * @b automatically trigger a call to evas_object_image_fill_set()
+ * with the that new size (and @c 0, @c 0 as source image's origin),
+ * so the bound image will fill the whole object's area.
+ *
+ * @see evas_object_image_filled_add()
+ * @see evas_object_image_fill_get()
+ *
+ * @param[in] filled @c EINA_TRUE, to make the fill property follow
+object size or @c EINA_FALSE, otherwise.
+ *
+ */
+EOAPI void  evas_obj_image_filled_set(Eina_Bool filled);
+
+/**
+ *
+ * Retrieve whether the image object's fill property should track the
+ * object's size.
+ *
+ * @return @c EINA_TRUE if it is tracking, @c EINA_FALSE, if not (and
+ * evas_object_fill_set() must be called manually).
+ *
+ * @see evas_object_image_filled_set() for more information
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_filled_get(void);
+
+/**
+ *
+ * Set the content hint setting of a given image object of the canvas.
+ *
+ * This function sets the content hint value of the given image of the
+ * canvas. For example, if you're on the GL engine and your driver
+ * implementation supports it, setting this hint to
+ * #EVAS_IMAGE_CONTENT_HINT_DYNAMIC will make it need @b zero copies
+ * at texture upload time, which is an "expensive" operation.
+ *
+ * @see evas_object_image_content_hint_get()
+ *
+ * @param[in] hint The content hint value, one of the
+#Evas_Image_Content_Hint ones.
+ *
+ */
+EOAPI void  evas_obj_image_content_hint_set(Evas_Image_Content_Hint hint);
+
+/**
+ *
+ * Get the content hint setting of a given image object of the canvas.
+ *
+ * @return hint The content hint value set on it, one of the
+ * #Evas_Image_Content_Hint ones (#EVAS_IMAGE_CONTENT_HINT_NONE means
+ * an error).
+ *
+ * This function returns the content hint value of the given image of
+ * the canvas.
+ *
+ * @see evas_object_image_content_hint_set()
+ *
+ *
+ */
+EOAPI Evas_Image_Content_Hint  evas_obj_image_content_hint_get(void);
+
+/**
+ *
+ * Inform a given image object to load a selective region of its
+ * source image.
+ *
+ * This function is useful when one is not showing all of an image's
+ * area on its image object.
+ *
+ * @note The image loader for the image format in question has to
+ * support selective region loading in order to this function to take
+ * effect.
+ *
+ * @see evas_object_image_load_region_get()
+ *
+ * @param[in] x X-offset of the region to be loaded.
+ * @param[in] y Y-offset of the region to be loaded.
+ * @param[in] w Width of the region to be loaded.
+ * @param[in] h Height of the region to be loaded.
+ *
+ */
+EOAPI void  evas_obj_image_load_region_set(int x, int y, int w, int h);
+
+/**
+ *
+ * Retrieve the coordinates of a given image object's selective
+ * (source image) load region.
+ *
+ * @note Use @c NULL pointers on the coordinates you're not interested
+ * in: they'll be ignored by the function.
+ *
+ * @see evas_object_image_load_region_get()
+ *
+ * @param[out] x X-offset of the region to be loaded.
+ * @param[out] y Y-offset of the region to be loaded.
+ * @param[out] w Width of the region to be loaded.
+ * @param[out] h Height of the region to be loaded.
+ *
+ */
+EOAPI void  evas_obj_image_load_region_get(int *x, int *y, int *w, int *h);
+
+/**
+ *
+ * Enable or disable alpha channel usage on the given image object.
+ *
+ * This function sets a flag on an image object indicating whether or
+ * not to use alpha channel data. A value of @c EINA_TRUE makes it use
+ * alpha channel data, and @c EINA_FALSE makes it ignore that
+ * data. Note that this has nothing to do with an object's color as
+ * manipulated by evas_object_color_set().
+ *
+ * @see evas_object_image_alpha_get()
+ *
+ * @param[in] alpha Whether to use alpha channel (@c EINA_TRUE) data
+or not (@c EINA_FALSE).
+ *
+ */
+EOAPI void  evas_obj_image_alpha_set(Eina_Bool alpha);
+
+/**
+ *
+ * Retrieve whether alpha channel data is being used on the given
+ * image object.
+ *
+ * @return Whether the alpha channel data is being used (@c EINA_TRUE)
+ * or not (@c EINA_FALSE).
+ *
+ * This function returns @c EINA_TRUE if the image object's alpha
+ * channel is being used, or @c EINA_FALSE otherwise.
+ *
+ * See @ref evas_object_image_alpha_set() for more details.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_alpha_get(void);
+
+/**
+ *
+ * Set the dimensions for an image object's border, a region which @b
+ * won't ever be scaled together with its center.
+ *
+ * When Evas is rendering, an image source may be scaled to fit the
+ * size of its image object. This function sets an area from the
+ * borders of the image inwards which is @b not to be scaled. This
+ * function is useful for making frames and for widget theming, where,
+ * for example, buttons may be of varying sizes, but their border size
+ * must remain constant.
+ *
+ * The units used for @p l, @p r, @p t and @p b are canvas units.
+ *
+ * @note The border region itself @b may be scaled by the
+ * evas_object_image_border_scale_set() function.
+ *
+ * @note By default, image objects have no borders set, i. e. @c l, @c
+ * r, @c t and @c b start as @c 0.
+ *
+ * See the following figures for visual explanation:\n
+ * @htmlonly
+ * <img src="image-borders.png" style="max-width: 100%;" />
+ * <a href="image-borders.png">Full-size</a>
+ * @endhtmlonly
+ * @image rtf image-borders.png
+ * @image latex image-borders.eps width=\textwidth
+ * @htmlonly
+ * <img src="border-effect.png" style="max-width: 100%;" />
+ * <a href="border-effect.png">Full-size</a>
+ * @endhtmlonly
+ * @image rtf border-effect.png
+ * @image latex border-effect.eps width=\textwidth
+ *
+ * @see evas_object_image_border_get()
+ * @see evas_object_image_border_center_fill_set()
+ *
+ * @param[in] l The border's left width.
+ * @param[in] r The border's right width.
+ * @param[in] t The border's top width.
+ * @param[in] b The border's bottom width.
+ *
+ */
+EOAPI void  evas_obj_image_border_set(int l, int r, int t, int b);
+
+/**
+ *
+ * Retrieve the dimensions for an image object's border, a region
+ * which @b won't ever be scaled together with its center.
+ *
+ * @note Use @c NULL pointers on the border components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * See @ref evas_object_image_border_set() for more details.
+ *
+ * @param[out] l The border's left width.
+ * @param[out] r The border's right width.
+ * @param[out] t The border's top width.
+ * @param[out] b The border's bottom width.
+ *
+ */
+EOAPI void  evas_obj_image_border_get(int *l, int *r, int *t, int *b);
+
+/**
+ *
+ * Sets the scaling factor (multiplier) for the borders of an image
+ * object.
+ *
+ * @see evas_object_image_border_set()
+ * @see evas_object_image_border_scale_get()
+ *
+ * @param[in] scale The scale factor (default is @c 1.0 - i.e. no scaling)
+ *
+ */
+EOAPI void  evas_obj_image_border_scale_set(double scale);
+
+/**
+ *
+ * Retrieves the scaling factor (multiplier) for the borders of an
+ * image object.
+ *
+ * @return The scale factor set for its borders
+ *
+ * @see evas_object_image_border_set()
+ * @see evas_object_image_border_scale_set()
+ *
+ *
+ */
+EOAPI double  evas_obj_image_border_scale_get(void);
+
+/**
+ *
+ * Mark whether the given image object is dirty and needs to request its pixels.
+ *
+ * This function will only properly work if a pixels get callback has been set.
+ *
+ * @warning use this function if you really know what you are doing.
+ *
+ * @see evas_object_image_pixels_get_callback_set()
+ *
+ * @param[in] dirty Whether the image is dirty.
+ *
+ */
+EOAPI void  evas_obj_image_pixels_dirty_set(Eina_Bool dirty);
+
+/**
+ *
+ * Retrieves whether the given image object is dirty (needs to be redrawn).
+ *
+ * @return Whether the image is dirty.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_pixels_dirty_get(void);
+
+/**
+ *
+ * Set the video surface linked to a given image of the canvas
+ *
+ * This function links a video surface to a given canvas image.
+ *
+ * @param[in] surf The new video surface.
+@since 1.1
+ *
+ */
+EOAPI void  evas_obj_image_video_surface_set(Evas_Video_Surface *surf);
+
+/**
+ *
+ * Get the video surface linekd to a given image of the canvas
+ *
+ * @return The video surface of the given canvas image.
+ * @since 1.1
+ *
+ * This function returns the video surface linked to a given canvas image.
+ *
+ *
+ */
+EOAPI const Evas_Video_Surface * evas_obj_image_video_surface_get(void);
+
+/**
+ *
+ * Set the video surface capabilities to a given image of the canvas
+ *
+ * @param[in] caps in
+ *
+ */
+EOAPI void  evas_obj_image_video_surface_caps_set(unsigned int caps);
+
+/**
+ *
+ * Get the video surface capabilities to a given image of the canvas
+ *
+ *
+ */
+EOAPI unsigned int  evas_obj_image_video_surface_caps_get(void);
+
+/**
+ *
+ * Define if the orientation information in the image file should be honored.
+ *
+ * @since 1.1
+ *
+ * @param[in] enable @c EINA_TRUE means that it should honor the orientation information
+ *
+ */
+EOAPI void  evas_obj_image_load_orientation_set(Eina_Bool enable);
+
+/**
+ *
+ * Get if the orientation information in the image file should be honored.
+ *
+ * @since 1.1
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_load_orientation_get(void);
+
+/**
+ *
+ * Sets the tiling mode for the given evas image object's fill.
+ * EVAS_TEXTURE_RESTRICT, or EVAS_TEXTURE_PAD.
+ *
+ * @param[in] spread One of EVAS_TEXTURE_REFLECT, EVAS_TEXTURE_REPEAT,
+ *
+ */
+EOAPI void  evas_obj_image_fill_spread_set(Evas_Fill_Spread spread);
+
+/**
+ *
+ * Retrieves the spread (tiling mode) for the given image object's
+ * fill.
+ *
+ * @return  The current spread mode of the image object.
+ *
+ *
+ */
+EOAPI Evas_Fill_Spread  evas_obj_image_fill_spread_get(void);
+
+/**
+ *
+ * Sets @b how the center part of the given image object (not the
+ * borders) should be drawn when Evas is rendering it.
+ *
+ * This function sets how the center part of the image object's source
+ * image is to be drawn, which must be one of the values in
+ * #Evas_Border_Fill_Mode. By center we mean the complementary part of
+ * that defined by evas_object_image_border_set(). This one is very
+ * useful for making frames and decorations. You would most probably
+ * also be using a filled image (as in evas_object_image_filled_set())
+ * to use as a frame.
+ *
+ * @see evas_object_image_border_center_fill_get()
+ *
+ * @param[in] fill Fill mode of the center region of @p obj (a value in
+#Evas_Border_Fill_Mode).
+ *
+ */
+EOAPI void  evas_obj_image_border_center_fill_set(Evas_Border_Fill_Mode fill);
+
+/**
+ *
+ * Retrieves @b how the center part of the given image object (not the
+ * borders) is to be drawn when Evas is rendering it.
+ *
+ * @return fill Fill mode of the center region of @p obj (a value in
+ * #Evas_Border_Fill_Mode).
+ *
+ * See @ref evas_object_image_fill_set() for more details.
+ *
+ *
+ */
+EOAPI Evas_Border_Fill_Mode  evas_obj_image_border_center_fill_get(void);
+
+/**
+ *
+ * Sets the size of the given image object.
+ *
+ * This function will scale down or crop the image so that it is
+ * treated as if it were at the given size. If the size given is
+ * smaller than the image, it will be cropped. If the size given is
+ * larger, then the image will be treated as if it were in the upper
+ * left hand corner of a larger image that is otherwise transparent.
+ *
+ * @param[in] w The new width of the image.
+ * @param[in] h The new height of the image.
+ *
+ */
+EOAPI void  evas_obj_image_size_set(int w, int h);
+
+/**
+ *
+ * Retrieves the size of the given image object.
+ *
+ * See @ref evas_object_image_size_set() for more details.
+ *
+ * @param[out] w The new width of the image.
+ * @param[out] h The new height of the image.
+ *
+ */
+EOAPI void  evas_obj_image_size_get(int *w, int *h);
+
+/**
+ *
+ * Set the source object to be visible or not.
+ *
+ * If the @p visible set to @c EINA_FALSE, the source object of the proxy(@p obj
+ * ) will be invisible.
+ *
+ * This API works differently to evas_object_show() and evas_object_hide().
+ * Once source object is hidden by evas_object_hide() then the proxy object will
+ * be hidden as well. Actually in this case both objects are excluded from the
+ * Evas internal update circle.
+ *
+ * By this API, instead, one can toggle the visibility of a proxy's source
+ * object remaining the proxy visibility untouched.
+ *
+ * @warning If the all of proxies are deleted, then the source visibility of the
+ * source object will be cancelled.
+ *
+ * @see evas_object_image_source_visible_get()
+ * @see evas_object_image_source_set()
+ * @see evas_object_show()
+ * @see evas_object_hide()
+ * @since 1.8
+ *
+ * @param[in] visible @c EINA_TRUE is source object to be shown, @c EINA_FALSE
+otherwise.
+ *
+ */
+EOAPI void  evas_obj_image_source_visible_set(Eina_Bool visible);
+
+/**
+ *
+ * Get the state of the source object visibility.
+ *
+ * @return @c EINA_TRUE if source object is visible, @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_image_source_visible_set()
+ * @see evas_object_image_source_set()
+ * @see evas_object_show()
+ * @see evas_object_hide()
+ * @since 1.8
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_source_visible_get(void);
+
+/**
+ *
+ * Set how to fill an image object's drawing rectangle given the
+ * (real) image bound to it.
+ *
+ * Note that if @p w or @p h are smaller than the dimensions of
+ * @p obj, the displayed image will be @b tiled around the object's
+ * area. To have only one copy of the bound image drawn, @p x and @p y
+ * must be 0 and @p w and @p h need to be the exact width and height
+ * of the image object itself, respectively.
+ *
+ * See the following image to better understand the effects of this
+ * call. On this diagram, both image object and original image source
+ * have @c a x @c a dimensions and the image itself is a circle, with
+ * empty space around it:
+ *
+ * @image html image-fill.png
+ * @image rtf image-fill.png
+ * @image latex image-fill.eps
+ *
+ * @warning The default values for the fill parameters are @p x = 0,
+ * @p y = 0, @p w = 0 and @p h = 0. Thus, if you're not using the
+ * evas_object_image_filled_add() helper and want your image
+ * displayed, you'll have to set valid values with this function on
+ * your object.
+ *
+ * @note evas_object_image_filled_set() is a helper function which
+ * will @b override the values set here automatically, for you, in a
+ * given way.
+ *
+ * @param[in] x The x coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[in] y The y coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[in] w The width the bound image will be displayed at.
+ * @param[in] h The height the bound image will be displayed at.
+ *
+ */
+EOAPI void  evas_obj_image_fill_set(Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieve how an image object is to fill its drawing rectangle,
+ * given the (real) image bound to it.
+ *
+ * @note Use @c NULL pointers on the fill components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * See @ref evas_object_image_fill_set() for more details.
+ *
+ * @param[out] x The x coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[out] y The y coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[out] w The width the bound image will be displayed at.
+ * @param[out] h The height the bound image will be displayed at.
+ *
+ */
+EOAPI void  evas_obj_image_fill_get(Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Set the native surface of a given image of the canvas
+ *
+ * This function sets a native surface of a given canvas image.
+ *
+ * @param[in] surf The new native surface.
+ *
+ */
+EOAPI void  evas_obj_image_native_surface_set(Evas_Native_Surface *surf);
+
+/**
+ *
+ * Get the native surface of a given image of the canvas
+ *
+ * @return The native surface of the given canvas image.
+ *
+ * This function returns the native surface of a given canvas image.
+ *
+ *
+ */
+EOAPI Evas_Native_Surface * evas_obj_image_native_surface_get(void);
+
+/**
+ *
+ * Set the scale down factor of a given image object's source image,
+ * when loading it.
+ *
+ * This function sets the scale down factor of a given canvas
+ * image. Most useful for the SVG image loader.
+ *
+ * @see evas_object_image_load_scale_down_get()
+ *
+ * @param[in] scale_down The scale down factor.
+ *
+ */
+EOAPI void  evas_obj_image_load_scale_down_set(int scale_down);
+
+/**
+ *
+ * get the scale down factor of a given image object's source image,
+ * when loading it.
+ *
+ * @see evas_object_image_load_scale_down_set() for more details
+ *
+ *
+ */
+EOAPI int  evas_obj_image_load_scale_down_get(void);
+
+/**
+ *
+ * Set the scale hint of a given image of the canvas.
+ *
+ * This function sets the scale hint value of the given image object
+ * in the canvas, which will affect how Evas is to cache scaled
+ * versions of its original source image.
+ *
+ * @see evas_object_image_scale_hint_get()
+ *
+ * @param[in] hint The scale hint, a value in
+#Evas_Image_Scale_Hint.
+ *
+ */
+EOAPI void  evas_obj_image_scale_hint_set(Evas_Image_Scale_Hint hint);
+
+/**
+ *
+ * Get the scale hint of a given image of the canvas.
+ *
+ * @return The scale hint value set on @p obj, a value in
+ * #Evas_Image_Scale_Hint.
+ *
+ * This function returns the scale hint value of the given image
+ * object of the canvas.
+ *
+ * @see evas_object_image_scale_hint_set() for more details.
+ *
+ *
+ */
+EOAPI Evas_Image_Scale_Hint  evas_obj_image_scale_hint_get(void);
+
+/**
+ *
+ * Set whether an Evas object is to source events.
+ *
+ * Set whether an Evas object is to repeat events to source.
+ *
+ * If @p source is @c EINA_TRUE, it will make events on @p obj to also be
+ * repeated for the source object (see evas_object_image_source_set()). Even the
+ * @p obj and source geometries are different, the event position will be
+ * transformed to the source object's space.
+ *
+ * If @p source is @c EINA_FALSE, events occurring on @p obj will be
+ * processed only on it.
+ *
+ * @see evas_object_image_source_get()
+ * @see evas_object_image_source_visible_set()
+ * @see evas_object_image_source_events_get()
+ * @since 1.8
+ *
+ * @param[in] source whether @p obj is to pass events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ *
+ */
+EOAPI void  evas_obj_image_source_events_set(Eina_Bool source);
+
+/**
+ *
+ * Determine whether an object is set to source events.
+ *
+ * @return @c EINA_TRUE if source object has events, @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_image_source_set()
+ * @see evas_object_image_source_visible_set()
+ * @see evas_object_image_source_events_set()
+ * @since 1.8
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_source_events_get(void);
+
+/**
+ *
+ * Set the colorspace of a given image of the canvas.
+ *
+ * This function sets the colorspace of given canvas image.
+ *
+ * @param[in] cspace The new color space.
+ *
+ */
+EOAPI void  evas_obj_image_colorspace_set(Evas_Colorspace cspace);
+
+/**
+ *
+ * Get the colorspace of a given image of the canvas.
+ *
+ * @return The colorspace of the image.
+ *
+ * This function returns the colorspace of given canvas image.
+ *
+ *
+ */
+EOAPI Evas_Colorspace  evas_obj_image_colorspace_get(void);
+
+/**
+ *
+ * Set the callback function to get pixels from a canvas' image.
+ *
+ * This functions sets a function to be the callback function that get
+ * pixels from a image of the canvas.
+ *
+ * @param[in] func The callback function.
+ * @param[in] data The data pointer to be passed to @a func.
+ *
+ */
+EOAPI void  evas_obj_image_pixels_get_callback_set(Evas_Object_Image_Pixels_Get_Cb func, void *data);
+
+/**
+ *
+ * Set the source mmaped file from where an image object must fetch the real
+ * image data (it must be an Eina_File).
+ *
+ * If the file supports multiple data stored in it (as Eet files do),
+ * you can specify the key to be used as the index of the image in
+ * this file.
+ *
+ * @since 1.8
+ *
+ * @param[in] f The mmaped file
+ * @param[in] key The image key in @p file (if its an Eet one), or @c
+NULL, otherwise.
+ *
+ */
+EOAPI void  evas_obj_image_mmap_set(const Eina_File *f, const char *key);
+
+/**
+ *
+ * Get the source mmaped file from where an image object must fetch the real
+ * image data (it must be an Eina_File).
+ *
+ * If the file supports multiple data stored in it (as Eet files do),
+ * you can get the key to be used as the index of the image in
+ * this file.
+ *
+ * @since 1.10
+ *
+ * @param[out] f The mmaped file
+ * @param[out] key The image key in @p file (if its an Eet one), or @c
+NULL, otherwise.
+ *
+ */
+EOAPI void  evas_obj_image_mmap_get(const Eina_File **f, const char **key);
+
+/**
+ *
+ * Replaces the raw image data of the given image object.
+ *
+ * This function lets the application replace an image object's
+ * internal pixel buffer with an user-allocated one. For best results,
+ * you should generally first call evas_object_image_size_set() with
+ * the width and height for the new buffer.
+ *
+ * This call is best suited for when you will be using image data with
+ * different dimensions than the existing image data, if any. If you
+ * only need to modify the existing image in some fashion, then using
+ * evas_object_image_data_get() is probably what you are after.
+ *
+ * Note that the caller is responsible for freeing the buffer when
+ * finished with it, as user-set image data will not be automatically
+ * freed when the image object is deleted.
+ *
+ * See @ref evas_object_image_data_get() for more details.
+ *
+ * @param[in] data The raw data to replace.
+ *
+ */
+EOAPI void  evas_obj_image_data_copy_set(void *data);
+
+/**
+ *
+ * Set the frame to current frame of an image object
+ *
+ * This set image object's current frame to frame_num with 1 being the first
+ * frame.
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ * @param[in] frame_index The index of current frame
+ *
+ */
+EOAPI void  evas_obj_image_animated_frame_set(int frame_index);
+
+/**
+ *
+ * Get the support state of a given image
+ *
+ * @return The region support state
+ * @since 1.2
+ *
+ * This function returns the state of the region support of given image
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_region_support_get(void);
+
+/**
+ *
+ * Retrieves a number representing any error that occurred during the
+ * last loading of the given image object's source image.
+ *
+ * @return A value giving the last error that occurred. It should be
+ * one of the #Evas_Load_Error values. #EVAS_LOAD_ERROR_NONE
+ * is returned if there was no error.
+ *
+ *
+ */
+EOAPI Evas_Load_Error  evas_obj_image_load_error_get(void);
+
+/**
+ *
+ * Get the total number of frames of the image object.
+ *
+ * @return The number of frames
+ *
+ * This returns total number of frames the image object supports (if animated)
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ *
+ */
+EOAPI int  evas_obj_image_animated_frame_count_get(void);
+
+/**
+ *
+ * Retrieves the row stride of the given image object.
+ *
+ * @return The stride of the image (<b>in bytes</b>).
+ *
+ * The row stride is the number of bytes between the start of a row
+ * and the start of the next row for image data.
+ *
+ *
+ */
+EOAPI int  evas_obj_image_stride_get(void);
+
+/**
+ *
+ * Get the kind of looping the image object does.
+ *
+ * @return Loop type of the image object
+ *
+ * This returns the kind of looping the image object wants to do.
+ *
+ * If it returns EVAS_IMAGE_ANIMATED_HINT_LOOP, you should display frames in a sequence like:
+ * 1->2->3->1->2->3->1...
+ * If it returns EVAS_IMAGE_ANIMATED_HINT_PINGPONG, it is better to
+ * display frames in a sequence like: 1->2->3->2->1->2->3->1...
+ *
+ * The default type is EVAS_IMAGE_ANIMATED_HINT_LOOP.
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ *
+ */
+EOAPI Evas_Image_Animated_Loop_Hint  evas_obj_image_animated_loop_type_get(void);
+
+/**
+ *
+ * Get the number times the animation of the object loops.
+ *
+ * @return The number of loop of an animated image object
+ *
+ * This returns loop count of image. The loop count is the number of times
+ * the animation will play fully from first to last frame until the animation
+ * should stop (at the final frame).
+ *
+ * If 0 is returned, then looping should happen indefinitely (no limit to
+ * the number of times it loops).
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ *
+ */
+EOAPI int  evas_obj_image_animated_loop_count_get(void);
+
+/**
+ *
+ * Set the 3D scene of a given image of the canvas.
+ *
+ * This function sets a 3d scene of a given canvas image.
+ *
+ * @see evas_object_image_scene_set
+ * @since 1.10
+ *
+ * @param[in] scene 3D scene on an image object.
+ *
+ */
+EOAPI void  evas_obj_image_scene_set(Evas_3D_Scene *scene);
+
+/**
+ *
+ * Get the 3D scene of a given image of the canvas.
+ *
+ * @return The 3d scene of the given canvas image.
+ *
+ * This function returns the 3d scene of a given canvas image.
+ *
+ * @see evas_object_image_scene_get
+ * @since 1.10
+ *
+ *
+ */
+EOAPI Evas_3D_Scene * evas_obj_image_scene_get(void);
+
+/**
+ *
+ * Set an Evas filter program on this Text Object.
+ *
+ * If the program fails to compile (syntax error, invalid
+ * buffer name, etc...), the standard text effects will be
+ * applied instead (SHADOW, etc...). switch back to the
+ * standard text effects.
+ *
+ * @since 1.9
+ * @note EXPERIMENTAL FEATURE. This is an unstable API,
+ * please use only for testing purposes.
+ * @see @ref evasfiltersref "Evas filters reference"
+ *
+ * @param[in] program The program code, as defined
+by the @ref evasfiltersref "Evas filters script language".
+Pass NULL to remove the former program and switch back
+to the standard text effect
+
+@since 1.9
+@note EXPERIMENTAL FEATURE. This is an unstable API,
+please use only for testing purposes.
+@see @ref evasfiltersref "Evas filters reference"
+ *
+ */
+EOAPI void  evas_obj_image_filter_program_set(const char *program);
+
+/**
+ *
+ * Bind an object to use as a mask or texture with Evas Filters.
+ *
+ * This will create automatically a new RGBA buffer containing
+ * the source object's pixels (as it is rendered).
+ *
+ * @param[in] name Object name as used in the program code
+ * @param[in] eobj Eo object to use through proxy rendering
+ *
+ */
+EOAPI void  evas_obj_image_filter_source_set(const char *name, Eo *eobj);
+
+/**
+ *
+ * Get the value of the extra padding set when a filter is used.
+ *
+ * @param[out] l Left padding in pixels
+ * @param[out] r Right padding in pixels
+ * @param[out] t Top padding in pixels
+ * @param[out] b Bottom padding in pixels
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_filter_padding_get(int *l, int *r, int *t, int *b);
+
+/**
+ *
+ * Begin preloading an image object's image data in the background
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_image_preload_begin(void);
+
+/**
+ *
+ * Mark a sub-region of the given image object to be redrawn.
+ *
+ * This function schedules a particular rectangular region of an image
+ * object to be updated (redrawn) at the next rendering cycle.
+ * 
+ *
+ * @param[in] x X-offset of the region to be updated.
+ * @param[in] y Y-offset of the region to be updated.
+ * @param[in] w Width of the region to be updated.
+ * @param[in] h Height of the region to be updated.
+ *
+ */
+EOAPI void  evas_obj_image_data_update_add(int x, int y, int w, int h);
+
+/**
+ *
+ * Get the duration of a sequence of frames.
+ *
+ * This returns total duration that the specified sequence of frames should
+ * take in seconds.
+ *
+ * If you set start_frame to 1 and frame_num 0, you get frame 1's duration
+ * If you set start_frame to 1 and frame_num 1, you get frame 1's duration +
+ * frame2's duration
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ * 
+ *
+ * @param[in] start_frame The first frame
+ * @param[in] frame_num Number of frames in the sequence
+ *
+ */
+EOAPI double  evas_obj_image_animated_frame_duration_get(int start_frame, int frame_num);
+
+/**
+ *
+ * Sets the raw image data of the given image object.
+ *
+ * Note that the raw data must be of the same size (see
+ * evas_object_image_size_set(), which has to be called @b before this
+ * one) and colorspace (see evas_object_image_colorspace_set()) of the
+ * image. If data is @c NULL, the current image data will be
+ * freed. Naturally, if one does not set an image object's data
+ * manually, it will still have one, allocated by Evas.
+ *
+ * @see evas_object_image_data_get()
+ * 
+ *
+ * @param[in] data The raw data, or @c NULL.
+ *
+ */
+EOAPI void  evas_obj_image_data_set(void *data);
+
+/**
+ *
+ * Get a pointer to the raw image data of the given image object.
+ *
+ * @return The raw image data.
+ *
+ * This function returns a pointer to an image object's internal pixel
+ * buffer, for reading only or read/write. If you request it for
+ * writing, the image will be marked dirty so that it gets redrawn at
+ * the next update.
+ *
+ * Each time you call this function on an image object, its data
+ * buffer will have an internal reference counter
+ * incremented. Decrement it back by using
+ * evas_object_image_data_set().
+ *
+ * This is best suited for when you want to modify an existing image,
+ * without changing its dimensions.
+ *
+ * @note The contents' format returned by it depend on the color
+ * space of the given image object.
+ *
+ * @note You may want to use evas_object_image_data_update_add() to
+ * inform data changes, if you did any.
+ *
+ * @see evas_object_image_data_set()
+ * 
+ *
+ * @param[in] for_writing Whether the data being retrieved will be
+modified (@c EINA_TRUE) or not (@c EINA_FALSE).
+ *
+ */
+EOAPI void * evas_obj_image_data_get(Eina_Bool for_writing);
+
+/**
+ *
+ * Cancel preloading an image object's image data in the background
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_image_preload_cancel(void);
+
+/**
+ *
+ * Converts the raw image data of the given image object to the
+ * specified colorspace.
+ *
+ * Note that this function does not modify the raw image data.  If the
+ * requested colorspace is the same as the image colorspace nothing is
+ * done and @c NULL is returned. You should use
+ * evas_object_image_colorspace_get() to check the current image
+ * colorspace.
+ *
+ * See @ref evas_object_image_colorspace_get.
+ *
+ * @return data A newly allocated data in the format specified by to_cspace.
+ * 
+ *
+ * @param[in] to_cspace The colorspace to which the image raw data will be converted.
+ *
+ */
+EOAPI void * evas_obj_image_data_convert(Evas_Colorspace to_cspace);
+
+/**
+ *
+ * Import pixels from given source to a given canvas image object.
+ *
+ * This function imports pixels from a given source to a given canvas image.
+ * 
+ *
+ * @param[in] pixels The pixel's source to be imported.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_image_pixels_import(Evas_Pixel_Import_Source *pixels);
+
+/**
+ *
+ * Reload an image object's image data.
+ *
+ * This function reloads the image data bound to image object @p obj.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_image_reload(void);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_image.eo.hh b/src/lib/evas/canvas/evas_image.eo.hh
--- a/src/lib/evas/canvas/evas_image.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_image.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,3628 @@
+#ifndef EFL_GENERATED_EVAS_IMAGE_HH
+#define EFL_GENERATED_EVAS_IMAGE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_image.eo.h"
+}
+
+#include "evas_object.eo.hh"
+#include "efl_file.eo.hh"
+#include "efl_image.eo.hh"
+#include <canvas/evas_object.eo.hh>
+#include <eo_base.hh>
+#include <string>
+
+namespace evas {
+
+struct image
+      : evas::object,
+      efl::eo::detail::extension_inheritance<efl::file>::template type< ::evas::image>,
+      efl::eo::detail::extension_inheritance<efl::image>::template type< ::evas::image>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit image(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit image(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   image(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : image(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   image(image const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~image() {}
+
+   /// @brief Get dbg information from the object.
+   ///
+   /// @param root_node node of the tree
+   ///
+   void dbg_info_get(Eo_Dbg_Info * root_node_) const
+   {
+      eo_do(_eo_ptr(), ::eo_dbg_info_get(root_node_));
+   }
+
+   /// @brief Set the source file from where an image object must fetch the real
+   /// image data (it may be an Eet file, besides pure image ones).
+   ///
+   /// If the file supports multiple data stored in it (as Eet files do),
+   /// you can specify the key to be used as the index of the image in
+   /// this file.
+   ///
+   /// Example:
+   /// @code
+   /// img = evas_object_image_add(canvas);
+   /// evas_object_image_file_set(img, "/path/to/img", NULL);
+   /// err = evas_object_image_load_error_get(img);
+   /// if (err != EVAS_LOAD_ERROR_NONE)
+   /// {
+   /// fprintf(stderr, "could not load image '%s'. error string is \"%s\"\n",
+   /// valid_path, evas_load_error_str(err));
+   /// }
+   /// else
+   /// {
+   /// evas_object_image_fill_set(img, 0, 0, w, h);
+   /// evas_object_resize(img, w, h);
+   /// evas_object_show(img);
+   /// }
+   /// @endcode
+   ///
+   /// @param file The image file path.
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   bool file_set(std::string file_, std::string key_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve the source file from where an image object is to fetch the
+   /// real image data (it may be an Eet file, besides pure image ones).
+   ///
+   /// You must @b not modify the strings on the returned pointers.
+   ///
+   /// @note Use @c NULL pointers on the file components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @param file The image file path.
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   void file_get(const char ** file_, const char ** key_) const
+   {
+      eo_do(_eo_ptr(), ::efl_file_get(file_, key_));
+   }
+
+   /// @brief Save the given image object's contents to an (image) file.
+   ///
+   /// The extension suffix on @p file will determine which <b>saver
+   /// module</b> Evas is to use when saving, thus the final file's
+   /// format. If the file supports multiple data stored in it (Eet ones),
+   /// you can specify the key to be used as the index of the image in it.
+   ///
+   /// You can specify some flags when saving the image.  Currently
+   /// acceptable flags are @c quality and @c compress. Eg.: @c
+   /// "quality=100 compress=9"
+   ///
+   /// @param file The filename to be used to save the image (extension
+   /// obligatory).
+   /// @param key The image key in the file (if an Eet one), or @c NULL,
+   /// otherwise.
+   /// @param flags String containing the flags to be used (@c NULL for
+   /// none).
+   ///
+   bool save(std::string file_, std::string key_, std::string flags_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_file_save(efl::eolian::to_c(file_), efl::eolian::to_c(key_), efl::eolian::to_c(flags_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Check if an image  can be animated (have multiple frames)
+   ///
+   /// @return whether the image support animation
+   ///
+   /// @param is_animated If it's animated or not.
+   ///
+   bool animated_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_image_animated_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the loading size of an image. The image will be loaded into memory as if it was
+   /// the set size instead of the original size. This can save a lot of memory, and is
+   /// important for scalable types like svg.
+   ///
+   /// @param w The new width of the image's load size.
+   /// @param h The new height of the image's load size.
+   ///
+   void load_size_set(int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::efl_image_load_size_set(w_, h_));
+   }
+
+   /// @param w The new width of the image's load size.
+   /// @param h The new height of the image's load size.
+   ///
+   void load_size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::efl_image_load_size_get(w_, h_));
+   }
+
+   /// @brief Sets whether to use high-quality image scaling algorithm on the
+   /// given image.
+   ///
+   /// When enabled, a higher quality image scaling algorithm is used when
+   /// scaling images to sizes other than the source image's original
+   /// one. This gives better results but is more computationally
+   /// expensive.
+   ///
+   /// @param smooth_scale Whether to use smooth scale or not.
+   ///
+   void smooth_scale_set(bool smooth_scale_) const
+   {
+      eo_do(_eo_ptr(), ::efl_image_smooth_scale_set(efl::eolian::to_c(smooth_scale_)));
+   }
+
+   /// @brief Retrieves whether the given image is using high-quality
+   /// image scaling algorithm.
+   ///
+   /// @return Whether smooth scale is being used.
+   ///
+   /// @param smooth_scale Whether to use smooth scale or not.
+   ///
+   bool smooth_scale_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_image_smooth_scale_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the DPI resolution of a loaded image object in the canvas.
+   ///
+   /// @return The DPI resolution of the given canvas image.
+   ///
+   /// This function returns the DPI resolution of the given canvas image.
+   ///
+   /// @see evas_object_image_load_dpi_set() for more details
+   ///
+   /// @param dpi The new DPI resolution.
+   ///
+   double load_dpi_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_load_dpi_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the DPI resolution of an image object's source image.
+   ///
+   /// This function sets the DPI resolution of a given loaded canvas
+   /// image. Most useful for the SVG image loader.
+   ///
+   /// @see evas_object_image_load_dpi_get()
+   ///
+   /// @param dpi The new DPI resolution.
+   ///
+   void load_dpi_set(double dpi_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_load_dpi_set(dpi_));
+   }
+
+   /// @brief Determine whether an object is clipped by source object's clipper.
+   ///
+   /// @return @c EINA_TRUE if source clip is enabled, @c EINA_FALSE otherwise.
+   ///
+   /// @see evas_object_clip_set()
+   /// @see evas_object_image_source_set()
+   /// @see evas_object_image_source_clip_set()
+   /// @since 1.8
+   ///
+   /// @param source_clip whether @p obj is clipped by the source clipper.
+   /// (@c EINA_TRUE) or not (@c EINA_FALSE)
+   ///
+   bool source_clip_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_source_clip_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Clip the proxy object with the source object's clipper.
+   ///
+   /// @see evas_object_clip_set()
+   /// @see evas_object_image_source_set()
+   /// @since 1.8
+   ///
+   /// @param source_clip whether @p obj is clipped by the source clipper.
+   /// (@c EINA_TRUE) or not (@c EINA_FALSE)
+   ///
+   void source_clip_set(bool source_clip_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_source_clip_set(efl::eolian::to_c(source_clip_)));
+   }
+
+   /// @brief Get the current source object of an image object.
+   ///
+   /// @return Source object (if any), or @c NULL, if not in "proxy mode"
+   /// (or on errors).
+   ///
+   /// @see evas_object_image_source_set() for more details
+   ///
+   /// @param src Source object to use for the proxy.
+   ///
+   evas::object source_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_source_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the source object on an image object to used as a @b proxy.
+   ///
+   /// @return @c EINA_TRUE on success, @c EINA_FALSE on error.
+   ///
+   /// If an image object is set to behave as a @b proxy, it will mirror
+   /// the rendering contents of a given @b source object in its drawing
+   /// region, without affecting that source in any way. The source must
+   /// be another valid Evas object. Other effects may be applied to the
+   /// proxy, such as a map (see evas_object_map_set()) to create a
+   /// reflection of the original object (for example).
+   ///
+   /// Any existing source object on @p obj will be removed after this
+   /// call. Setting @p src to @c NULL clears the proxy object (not in
+   /// "proxy state" anymore).
+   ///
+   /// @warning You cannot set a proxy as another proxy's source.
+   ///
+   /// @see evas_object_image_source_get()
+   /// @see evas_object_image_source_unset()
+   /// @see evas_object_image_source_visible_set()
+   ///
+   /// @param src Source object to use for the proxy.
+   ///
+   bool source_set(evas::object src_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_source_set(efl::eolian::to_c(src_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve whether the image object's fill property should track the
+   /// object's size.
+   ///
+   /// @return @c EINA_TRUE if it is tracking, @c EINA_FALSE, if not (and
+   /// evas_object_fill_set() must be called manually).
+   ///
+   /// @see evas_object_image_filled_set() for more information
+   ///
+   /// @param filled @c EINA_TRUE, to make the fill property follow
+   /// object size or @c EINA_FALSE, otherwise.
+   ///
+   bool filled_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_filled_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set whether the image object's fill property should track the
+   /// object's size.
+   ///
+   /// If @p setting is @c EINA_TRUE, then every evas_object_resize() will
+   /// @b automatically trigger a call to evas_object_image_fill_set()
+   /// with the that new size (and @c 0, @c 0 as source image's origin),
+   /// so the bound image will fill the whole object's area.
+   ///
+   /// @see evas_object_image_filled_add()
+   /// @see evas_object_image_fill_get()
+   ///
+   /// @param filled @c EINA_TRUE, to make the fill property follow
+   /// object size or @c EINA_FALSE, otherwise.
+   ///
+   void filled_set(bool filled_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_filled_set(efl::eolian::to_c(filled_)));
+   }
+
+   /// @brief Get the content hint setting of a given image object of the canvas.
+   ///
+   /// @return hint The content hint value set on it, one of the
+   /// #Evas_Image_Content_Hint ones (#EVAS_IMAGE_CONTENT_HINT_NONE means
+   /// an error).
+   ///
+   /// This function returns the content hint value of the given image of
+   /// the canvas.
+   ///
+   /// @see evas_object_image_content_hint_set()
+   ///
+   /// @param hint The content hint value, one of the
+   /// #Evas_Image_Content_Hint ones.
+   ///
+   Evas_Image_Content_Hint content_hint_get() const
+   {
+      Evas_Image_Content_Hint _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_content_hint_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the content hint setting of a given image object of the canvas.
+   ///
+   /// This function sets the content hint value of the given image of the
+   /// canvas. For example, if you're on the GL engine and your driver
+   /// implementation supports it, setting this hint to
+   /// #EVAS_IMAGE_CONTENT_HINT_DYNAMIC will make it need @b zero copies
+   /// at texture upload time, which is an "expensive" operation.
+   ///
+   /// @see evas_object_image_content_hint_get()
+   ///
+   /// @param hint The content hint value, one of the
+   /// #Evas_Image_Content_Hint ones.
+   ///
+   void content_hint_set(Evas_Image_Content_Hint hint_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_content_hint_set(hint_));
+   }
+
+   /// @brief Retrieve the coordinates of a given image object's selective
+   /// (source image) load region.
+   ///
+   /// @note Use @c NULL pointers on the coordinates you're not interested
+   /// in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_image_load_region_get()
+   ///
+   /// @param x X-offset of the region to be loaded.
+   /// @param y Y-offset of the region to be loaded.
+   /// @param w Width of the region to be loaded.
+   /// @param h Height of the region to be loaded.
+   ///
+   void load_region_get(int* x_, int* y_, int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_load_region_get(x_, y_, w_, h_));
+   }
+
+   /// @brief Inform a given image object to load a selective region of its
+   /// source image.
+   ///
+   /// This function is useful when one is not showing all of an image's
+   /// area on its image object.
+   ///
+   /// @note The image loader for the image format in question has to
+   /// support selective region loading in order to this function to take
+   /// effect.
+   ///
+   /// @see evas_object_image_load_region_get()
+   ///
+   /// @param x X-offset of the region to be loaded.
+   /// @param y Y-offset of the region to be loaded.
+   /// @param w Width of the region to be loaded.
+   /// @param h Height of the region to be loaded.
+   ///
+   void load_region_set(int x_, int y_, int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_load_region_set(x_, y_, w_, h_));
+   }
+
+   /// @brief Retrieve whether alpha channel data is being used on the given
+   /// image object.
+   ///
+   /// @return Whether the alpha channel data is being used (@c EINA_TRUE)
+   /// or not (@c EINA_FALSE).
+   ///
+   /// This function returns @c EINA_TRUE if the image object's alpha
+   /// channel is being used, or @c EINA_FALSE otherwise.
+   ///
+   /// See @ref evas_object_image_alpha_set() for more details.
+   ///
+   /// @param alpha Whether to use alpha channel (@c EINA_TRUE) data
+   /// or not (@c EINA_FALSE).
+   ///
+   bool alpha_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_alpha_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Enable or disable alpha channel usage on the given image object.
+   ///
+   /// This function sets a flag on an image object indicating whether or
+   /// not to use alpha channel data. A value of @c EINA_TRUE makes it use
+   /// alpha channel data, and @c EINA_FALSE makes it ignore that
+   /// data. Note that this has nothing to do with an object's color as
+   /// manipulated by evas_object_color_set().
+   ///
+   /// @see evas_object_image_alpha_get()
+   ///
+   /// @param alpha Whether to use alpha channel (@c EINA_TRUE) data
+   /// or not (@c EINA_FALSE).
+   ///
+   void alpha_set(bool alpha_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_alpha_set(efl::eolian::to_c(alpha_)));
+   }
+
+   /// @brief Retrieve the dimensions for an image object's border, a region
+   /// which @b won't ever be scaled together with its center.
+   ///
+   /// @note Use @c NULL pointers on the border components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// See @ref evas_object_image_border_set() for more details.
+   ///
+   /// @param l The border's left width.
+   /// @param r The border's right width.
+   /// @param t The border's top width.
+   /// @param b The border's bottom width.
+   ///
+   void border_get(int* l_, int* r_, int* t_, int* b_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_border_get(l_, r_, t_, b_));
+   }
+
+   /// @brief Set the dimensions for an image object's border, a region which @b
+   /// won't ever be scaled together with its center.
+   ///
+   /// When Evas is rendering, an image source may be scaled to fit the
+   /// size of its image object. This function sets an area from the
+   /// borders of the image inwards which is @b not to be scaled. This
+   /// function is useful for making frames and for widget theming, where,
+   /// for example, buttons may be of varying sizes, but their border size
+   /// must remain constant.
+   ///
+   /// The units used for @p l, @p r, @p t and @p b are canvas units.
+   ///
+   /// @note The border region itself @b may be scaled by the
+   /// evas_object_image_border_scale_set() function.
+   ///
+   /// @note By default, image objects have no borders set, i. e. @c l, @c
+   /// r, @c t and @c b start as @c 0.
+   ///
+   /// See the following figures for visual explanation:\n
+   /// @htmlonly
+   /// <img src="image-borders.png" style="max-width: 100%;" />
+   /// <a href="image-borders.png">Full-size</a>
+   /// @endhtmlonly
+   /// @image rtf image-borders.png
+   /// @image latex image-borders.eps width=\textwidth
+   /// @htmlonly
+   /// <img src="border-effect.png" style="max-width: 100%;" />
+   /// <a href="border-effect.png">Full-size</a>
+   /// @endhtmlonly
+   /// @image rtf border-effect.png
+   /// @image latex border-effect.eps width=\textwidth
+   ///
+   /// @see evas_object_image_border_get()
+   /// @see evas_object_image_border_center_fill_set()
+   ///
+   /// @param l The border's left width.
+   /// @param r The border's right width.
+   /// @param t The border's top width.
+   /// @param b The border's bottom width.
+   ///
+   void border_set(int l_, int r_, int t_, int b_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_border_set(l_, r_, t_, b_));
+   }
+
+   /// @brief Retrieves the scaling factor (multiplier) for the borders of an
+   /// image object.
+   ///
+   /// @return The scale factor set for its borders
+   ///
+   /// @see evas_object_image_border_set()
+   /// @see evas_object_image_border_scale_set()
+   ///
+   /// @param scale The scale factor (default is @c 1.0 - i.e. no scaling)
+   ///
+   double border_scale_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_border_scale_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the scaling factor (multiplier) for the borders of an image
+   /// object.
+   ///
+   /// @see evas_object_image_border_set()
+   /// @see evas_object_image_border_scale_get()
+   ///
+   /// @param scale The scale factor (default is @c 1.0 - i.e. no scaling)
+   ///
+   void border_scale_set(double scale_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_border_scale_set(scale_));
+   }
+
+   /// @brief Retrieves whether the given image object is dirty (needs to be redrawn).
+   ///
+   /// @return Whether the image is dirty.
+   ///
+   /// @param dirty Whether the image is dirty.
+   ///
+   bool pixels_dirty_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_pixels_dirty_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Mark whether the given image object is dirty and needs to request its pixels.
+   ///
+   /// This function will only properly work if a pixels get callback has been set.
+   ///
+   /// @warning use this function if you really know what you are doing.
+   ///
+   /// @see evas_object_image_pixels_get_callback_set()
+   ///
+   /// @param dirty Whether the image is dirty.
+   ///
+   void pixels_dirty_set(bool dirty_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_pixels_dirty_set(efl::eolian::to_c(dirty_)));
+   }
+
+   /// @brief Get the video surface linekd to a given image of the canvas
+   ///
+   /// @return The video surface of the given canvas image.
+   /// @since 1.1
+   ///
+   /// This function returns the video surface linked to a given canvas image.
+   ///
+   /// @param surf The new video surface.
+   /// @since 1.1
+   ///
+   const Evas_Video_Surface * video_surface_get() const
+   {
+      const Evas_Video_Surface * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_video_surface_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the video surface linked to a given image of the canvas
+   ///
+   /// This function links a video surface to a given canvas image.
+   ///
+   /// @param surf The new video surface.
+   /// @since 1.1
+   ///
+   void video_surface_set(Evas_Video_Surface * surf_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_video_surface_set(surf_));
+   }
+
+   /// @brief Get the video surface capabilities to a given image of the canvas
+   ///
+   /// @param caps in
+   ///
+   unsigned int video_surface_caps_get() const
+   {
+      unsigned int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_video_surface_caps_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the video surface capabilities to a given image of the canvas
+   ///
+   /// @param caps in
+   ///
+   void video_surface_caps_set(unsigned int caps_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_video_surface_caps_set(caps_));
+   }
+
+   /// @brief Get if the orientation information in the image file should be honored.
+   ///
+   /// @since 1.1
+   ///
+   /// @param enable @c EINA_TRUE means that it should honor the orientation information
+   ///
+   bool load_orientation_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_load_orientation_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Define if the orientation information in the image file should be honored.
+   ///
+   /// @since 1.1
+   ///
+   /// @param enable @c EINA_TRUE means that it should honor the orientation information
+   ///
+   void load_orientation_set(bool enable_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_load_orientation_set(efl::eolian::to_c(enable_)));
+   }
+
+   /// @brief Retrieves the spread (tiling mode) for the given image object's
+   /// fill.
+   ///
+   /// @return  The current spread mode of the image object.
+   ///
+   /// @param spread One of EVAS_TEXTURE_REFLECT, EVAS_TEXTURE_REPEAT,
+   ///
+   Evas_Fill_Spread fill_spread_get() const
+   {
+      Evas_Fill_Spread _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_fill_spread_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the tiling mode for the given evas image object's fill.
+   /// EVAS_TEXTURE_RESTRICT, or EVAS_TEXTURE_PAD.
+   ///
+   /// @param spread One of EVAS_TEXTURE_REFLECT, EVAS_TEXTURE_REPEAT,
+   ///
+   void fill_spread_set(Evas_Fill_Spread spread_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_fill_spread_set(spread_));
+   }
+
+   /// @brief Retrieves @b how the center part of the given image object (not the
+   /// borders) is to be drawn when Evas is rendering it.
+   ///
+   /// @return fill Fill mode of the center region of @p obj (a value in
+   /// #Evas_Border_Fill_Mode).
+   ///
+   /// See @ref evas_object_image_fill_set() for more details.
+   ///
+   /// @param fill Fill mode of the center region of @p obj (a value in
+   /// #Evas_Border_Fill_Mode).
+   ///
+   Evas_Border_Fill_Mode border_center_fill_get() const
+   {
+      Evas_Border_Fill_Mode _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_border_center_fill_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets @b how the center part of the given image object (not the
+   /// borders) should be drawn when Evas is rendering it.
+   ///
+   /// This function sets how the center part of the image object's source
+   /// image is to be drawn, which must be one of the values in
+   /// #Evas_Border_Fill_Mode. By center we mean the complementary part of
+   /// that defined by evas_object_image_border_set(). This one is very
+   /// useful for making frames and decorations. You would most probably
+   /// also be using a filled image (as in evas_object_image_filled_set())
+   /// to use as a frame.
+   ///
+   /// @see evas_object_image_border_center_fill_get()
+   ///
+   /// @param fill Fill mode of the center region of @p obj (a value in
+   /// #Evas_Border_Fill_Mode).
+   ///
+   void border_center_fill_set(Evas_Border_Fill_Mode fill_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_border_center_fill_set(fill_));
+   }
+
+   /// @brief Retrieves the size of the given image object.
+   ///
+   /// See @ref evas_object_image_size_set() for more details.
+   ///
+   /// @param w The new width of the image.
+   /// @param h The new height of the image.
+   ///
+   void size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_size_get(w_, h_));
+   }
+
+   /// @brief Sets the size of the given image object.
+   ///
+   /// This function will scale down or crop the image so that it is
+   /// treated as if it were at the given size. If the size given is
+   /// smaller than the image, it will be cropped. If the size given is
+   /// larger, then the image will be treated as if it were in the upper
+   /// left hand corner of a larger image that is otherwise transparent.
+   ///
+   /// @param w The new width of the image.
+   /// @param h The new height of the image.
+   ///
+   void size_set(int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_size_set(w_, h_));
+   }
+
+   /// @brief Get the state of the source object visibility.
+   ///
+   /// @return @c EINA_TRUE if source object is visible, @c EINA_FALSE otherwise.
+   ///
+   /// @see evas_object_image_source_visible_set()
+   /// @see evas_object_image_source_set()
+   /// @see evas_object_show()
+   /// @see evas_object_hide()
+   /// @since 1.8
+   ///
+   /// @param visible @c EINA_TRUE is source object to be shown, @c EINA_FALSE
+   /// otherwise.
+   ///
+   bool source_visible_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_source_visible_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the source object to be visible or not.
+   ///
+   /// If the @p visible set to @c EINA_FALSE, the source object of the proxy(@p obj
+   /// ) will be invisible.
+   ///
+   /// This API works differently to evas_object_show() and evas_object_hide().
+   /// Once source object is hidden by evas_object_hide() then the proxy object will
+   /// be hidden as well. Actually in this case both objects are excluded from the
+   /// Evas internal update circle.
+   ///
+   /// By this API, instead, one can toggle the visibility of a proxy's source
+   /// object remaining the proxy visibility untouched.
+   ///
+   /// @warning If the all of proxies are deleted, then the source visibility of the
+   /// source object will be cancelled.
+   ///
+   /// @see evas_object_image_source_visible_get()
+   /// @see evas_object_image_source_set()
+   /// @see evas_object_show()
+   /// @see evas_object_hide()
+   /// @since 1.8
+   ///
+   /// @param visible @c EINA_TRUE is source object to be shown, @c EINA_FALSE
+   /// otherwise.
+   ///
+   void source_visible_set(bool visible_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_source_visible_set(efl::eolian::to_c(visible_)));
+   }
+
+   /// @brief Retrieve how an image object is to fill its drawing rectangle,
+   /// given the (real) image bound to it.
+   ///
+   /// @note Use @c NULL pointers on the fill components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// See @ref evas_object_image_fill_set() for more details.
+   ///
+   /// @param x The x coordinate (from the top left corner of the bound
+   /// image) to start drawing from.
+   /// @param y The y coordinate (from the top left corner of the bound
+   /// image) to start drawing from.
+   /// @param w The width the bound image will be displayed at.
+   /// @param h The height the bound image will be displayed at.
+   ///
+   void fill_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_fill_get(x_, y_, w_, h_));
+   }
+
+   /// @brief Set how to fill an image object's drawing rectangle given the
+   /// (real) image bound to it.
+   ///
+   /// Note that if @p w or @p h are smaller than the dimensions of
+   /// @p obj, the displayed image will be @b tiled around the object's
+   /// area. To have only one copy of the bound image drawn, @p x and @p y
+   /// must be 0 and @p w and @p h need to be the exact width and height
+   /// of the image object itself, respectively.
+   ///
+   /// See the following image to better understand the effects of this
+   /// call. On this diagram, both image object and original image source
+   /// have @c a x @c a dimensions and the image itself is a circle, with
+   /// empty space around it:
+   ///
+   /// @image html image-fill.png
+   /// @image rtf image-fill.png
+   /// @image latex image-fill.eps
+   ///
+   /// @warning The default values for the fill parameters are @p x = 0,
+   /// @p y = 0, @p w = 0 and @p h = 0. Thus, if you're not using the
+   /// evas_object_image_filled_add() helper and want your image
+   /// displayed, you'll have to set valid values with this function on
+   /// your object.
+   ///
+   /// @note evas_object_image_filled_set() is a helper function which
+   /// will @b override the values set here automatically, for you, in a
+   /// given way.
+   ///
+   /// @param x The x coordinate (from the top left corner of the bound
+   /// image) to start drawing from.
+   /// @param y The y coordinate (from the top left corner of the bound
+   /// image) to start drawing from.
+   /// @param w The width the bound image will be displayed at.
+   /// @param h The height the bound image will be displayed at.
+   ///
+   void fill_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_fill_set(x_, y_, w_, h_));
+   }
+
+   /// @brief Get the native surface of a given image of the canvas
+   ///
+   /// @return The native surface of the given canvas image.
+   ///
+   /// This function returns the native surface of a given canvas image.
+   ///
+   /// @param surf The new native surface.
+   ///
+   Evas_Native_Surface * native_surface_get() const
+   {
+      Evas_Native_Surface * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_native_surface_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the native surface of a given image of the canvas
+   ///
+   /// This function sets a native surface of a given canvas image.
+   ///
+   /// @param surf The new native surface.
+   ///
+   void native_surface_set(Evas_Native_Surface * surf_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_native_surface_set(surf_));
+   }
+
+   /// @brief get the scale down factor of a given image object's source image,
+   /// when loading it.
+   ///
+   /// @see evas_object_image_load_scale_down_set() for more details
+   ///
+   /// @param scale_down The scale down factor.
+   ///
+   int load_scale_down_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_load_scale_down_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the scale down factor of a given image object's source image,
+   /// when loading it.
+   ///
+   /// This function sets the scale down factor of a given canvas
+   /// image. Most useful for the SVG image loader.
+   ///
+   /// @see evas_object_image_load_scale_down_get()
+   ///
+   /// @param scale_down The scale down factor.
+   ///
+   void load_scale_down_set(int scale_down_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_load_scale_down_set(scale_down_));
+   }
+
+   /// @brief Get the scale hint of a given image of the canvas.
+   ///
+   /// @return The scale hint value set on @p obj, a value in
+   /// #Evas_Image_Scale_Hint.
+   ///
+   /// This function returns the scale hint value of the given image
+   /// object of the canvas.
+   ///
+   /// @see evas_object_image_scale_hint_set() for more details.
+   ///
+   /// @param hint The scale hint, a value in
+   /// #Evas_Image_Scale_Hint.
+   ///
+   Evas_Image_Scale_Hint scale_hint_get() const
+   {
+      Evas_Image_Scale_Hint _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_scale_hint_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the scale hint of a given image of the canvas.
+   ///
+   /// This function sets the scale hint value of the given image object
+   /// in the canvas, which will affect how Evas is to cache scaled
+   /// versions of its original source image.
+   ///
+   /// @see evas_object_image_scale_hint_get()
+   ///
+   /// @param hint The scale hint, a value in
+   /// #Evas_Image_Scale_Hint.
+   ///
+   void scale_hint_set(Evas_Image_Scale_Hint hint_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_scale_hint_set(hint_));
+   }
+
+   /// @brief Determine whether an object is set to source events.
+   ///
+   /// @return @c EINA_TRUE if source object has events, @c EINA_FALSE otherwise.
+   ///
+   /// @see evas_object_image_source_set()
+   /// @see evas_object_image_source_visible_set()
+   /// @see evas_object_image_source_events_set()
+   /// @since 1.8
+   ///
+   /// @param source whether @p obj is to pass events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   bool source_events_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_source_events_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set whether an Evas object is to source events.
+   ///
+   /// Set whether an Evas object is to repeat events to source.
+   ///
+   /// If @p source is @c EINA_TRUE, it will make events on @p obj to also be
+   /// repeated for the source object (see evas_object_image_source_set()). Even the
+   /// @p obj and source geometries are different, the event position will be
+   /// transformed to the source object's space.
+   ///
+   /// If @p source is @c EINA_FALSE, events occurring on @p obj will be
+   /// processed only on it.
+   ///
+   /// @see evas_object_image_source_get()
+   /// @see evas_object_image_source_visible_set()
+   /// @see evas_object_image_source_events_get()
+   /// @since 1.8
+   ///
+   /// @param source whether @p obj is to pass events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   void source_events_set(bool source_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_source_events_set(efl::eolian::to_c(source_)));
+   }
+
+   /// @brief Get the colorspace of a given image of the canvas.
+   ///
+   /// @return The colorspace of the image.
+   ///
+   /// This function returns the colorspace of given canvas image.
+   ///
+   /// @param cspace The new color space.
+   ///
+   Evas_Colorspace colorspace_get() const
+   {
+      Evas_Colorspace _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_colorspace_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the colorspace of a given image of the canvas.
+   ///
+   /// This function sets the colorspace of given canvas image.
+   ///
+   /// @param cspace The new color space.
+   ///
+   void colorspace_set(Evas_Colorspace cspace_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_colorspace_set(cspace_));
+   }
+
+   /// @brief Set the callback function to get pixels from a canvas' image.
+   ///
+   /// This functions sets a function to be the callback function that get
+   /// pixels from a image of the canvas.
+   ///
+   /// @param func The callback function.
+   /// @param data The data pointer to be passed to @a func.
+   ///
+   void pixels_get_callback_set(Evas_Object_Image_Pixels_Get_Cb func_, void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_pixels_get_callback_set(func_, data_));
+   }
+
+   /// @brief Get the source mmaped file from where an image object must fetch the real
+   /// image data (it must be an Eina_File).
+   ///
+   /// If the file supports multiple data stored in it (as Eet files do),
+   /// you can get the key to be used as the index of the image in
+   /// this file.
+   ///
+   /// @since 1.10
+   ///
+   /// @param f The mmaped file
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   void mmap_get(const Eina_File ** f_, const char ** key_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_mmap_get(f_, key_));
+   }
+
+   /// @brief Set the source mmaped file from where an image object must fetch the real
+   /// image data (it must be an Eina_File).
+   ///
+   /// If the file supports multiple data stored in it (as Eet files do),
+   /// you can specify the key to be used as the index of the image in
+   /// this file.
+   ///
+   /// @since 1.8
+   ///
+   /// @param f The mmaped file
+   /// @param key The image key in @p file (if its an Eet one), or @c
+   /// NULL, otherwise.
+   ///
+   void mmap_set(const Eina_File * f_, std::string key_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_mmap_set(f_, efl::eolian::to_c(key_)));
+   }
+
+   /// @brief Replaces the raw image data of the given image object.
+   ///
+   /// This function lets the application replace an image object's
+   /// internal pixel buffer with an user-allocated one. For best results,
+   /// you should generally first call evas_object_image_size_set() with
+   /// the width and height for the new buffer.
+   ///
+   /// This call is best suited for when you will be using image data with
+   /// different dimensions than the existing image data, if any. If you
+   /// only need to modify the existing image in some fashion, then using
+   /// evas_object_image_data_get() is probably what you are after.
+   ///
+   /// Note that the caller is responsible for freeing the buffer when
+   /// finished with it, as user-set image data will not be automatically
+   /// freed when the image object is deleted.
+   ///
+   /// See @ref evas_object_image_data_get() for more details.
+   ///
+   /// @param data The raw data to replace.
+   ///
+   void data_copy_set(void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_data_copy_set(data_));
+   }
+
+   /// @brief Set the frame to current frame of an image object
+   ///
+   /// This set image object's current frame to frame_num with 1 being the first
+   /// frame.
+   ///
+   /// @see evas_object_image_animated_get()
+   /// @see evas_object_image_animated_frame_count_get()
+   /// @see evas_object_image_animated_loop_type_get()
+   /// @see evas_object_image_animated_loop_count_get()
+   /// @see evas_object_image_animated_frame_duration_get()
+   /// @see evas_object_image_animated_frame_set()
+   /// @since 1.1
+   ///
+   /// @param frame_index The index of current frame
+   ///
+   void animated_frame_set(int frame_index_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_animated_frame_set(frame_index_));
+   }
+
+   /// @brief Get the support state of a given image
+   ///
+   /// @return The region support state
+   /// @since 1.2
+   ///
+   /// This function returns the state of the region support of given image
+   ///
+   bool region_support_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_region_support_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieves a number representing any error that occurred during the
+   /// last loading of the given image object's source image.
+   ///
+   /// @return A value giving the last error that occurred. It should be
+   /// one of the #Evas_Load_Error values. #EVAS_LOAD_ERROR_NONE
+   /// is returned if there was no error.
+   ///
+   Evas_Load_Error load_error_get() const
+   {
+      Evas_Load_Error _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_load_error_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the total number of frames of the image object.
+   ///
+   /// @return The number of frames
+   ///
+   /// This returns total number of frames the image object supports (if animated)
+   ///
+   /// @see evas_object_image_animated_get()
+   /// @see evas_object_image_animated_frame_count_get()
+   /// @see evas_object_image_animated_loop_type_get()
+   /// @see evas_object_image_animated_loop_count_get()
+   /// @see evas_object_image_animated_frame_duration_get()
+   /// @see evas_object_image_animated_frame_set()
+   /// @since 1.1
+   ///
+   int animated_frame_count_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_frame_count_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Retrieves the row stride of the given image object.
+   ///
+   /// @return The stride of the image (<b>in bytes</b>).
+   ///
+   /// The row stride is the number of bytes between the start of a row
+   /// and the start of the next row for image data.
+   ///
+   int stride_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_stride_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the kind of looping the image object does.
+   ///
+   /// @return Loop type of the image object
+   ///
+   /// This returns the kind of looping the image object wants to do.
+   ///
+   /// If it returns EVAS_IMAGE_ANIMATED_HINT_LOOP, you should display frames in a sequence like:
+   /// 1->2->3->1->2->3->1...
+   /// If it returns EVAS_IMAGE_ANIMATED_HINT_PINGPONG, it is better to
+   /// display frames in a sequence like: 1->2->3->2->1->2->3->1...
+   ///
+   /// The default type is EVAS_IMAGE_ANIMATED_HINT_LOOP.
+   ///
+   /// @see evas_object_image_animated_get()
+   /// @see evas_object_image_animated_frame_count_get()
+   /// @see evas_object_image_animated_loop_type_get()
+   /// @see evas_object_image_animated_loop_count_get()
+   /// @see evas_object_image_animated_frame_duration_get()
+   /// @see evas_object_image_animated_frame_set()
+   /// @since 1.1
+   ///
+   Evas_Image_Animated_Loop_Hint animated_loop_type_get() const
+   {
+      Evas_Image_Animated_Loop_Hint _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_loop_type_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the number times the animation of the object loops.
+   ///
+   /// @return The number of loop of an animated image object
+   ///
+   /// This returns loop count of image. The loop count is the number of times
+   /// the animation will play fully from first to last frame until the animation
+   /// should stop (at the final frame).
+   ///
+   /// If 0 is returned, then looping should happen indefinitely (no limit to
+   /// the number of times it loops).
+   ///
+   /// @see evas_object_image_animated_get()
+   /// @see evas_object_image_animated_frame_count_get()
+   /// @see evas_object_image_animated_loop_type_get()
+   /// @see evas_object_image_animated_loop_count_get()
+   /// @see evas_object_image_animated_frame_duration_get()
+   /// @see evas_object_image_animated_frame_set()
+   /// @since 1.1
+   ///
+   int animated_loop_count_get() const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_loop_count_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the 3D scene of a given image of the canvas.
+   ///
+   /// @return The 3d scene of the given canvas image.
+   ///
+   /// This function returns the 3d scene of a given canvas image.
+   ///
+   /// @see evas_object_image_scene_get
+   /// @since 1.10
+   ///
+   /// @param scene 3D scene on an image object.
+   ///
+   Evas_3D_Scene * scene_get() const
+   {
+      Evas_3D_Scene * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_scene_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the 3D scene of a given image of the canvas.
+   ///
+   /// This function sets a 3d scene of a given canvas image.
+   ///
+   /// @see evas_object_image_scene_set
+   /// @since 1.10
+   ///
+   /// @param scene 3D scene on an image object.
+   ///
+   void scene_set(Evas_3D_Scene * scene_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_scene_set(scene_));
+   }
+
+   /// @brief Set an Evas filter program on this Text Object.
+   ///
+   /// If the program fails to compile (syntax error, invalid
+   /// buffer name, etc...), the standard text effects will be
+   /// applied instead (SHADOW, etc...). switch back to the
+   /// standard text effects.
+   ///
+   /// @since 1.9
+   /// @note EXPERIMENTAL FEATURE. This is an unstable API,
+   /// please use only for testing purposes.
+   /// @see @ref evasfiltersref "Evas filters reference"
+   ///
+   /// @param program The program code, as defined
+   /// by the @ref evasfiltersref "Evas filters script language".
+   /// Pass NULL to remove the former program and switch back
+   /// to the standard text effect
+   ///
+   /// @since 1.9
+   /// @note EXPERIMENTAL FEATURE. This is an unstable API,
+   /// please use only for testing purposes.
+   /// @see @ref evasfiltersref "Evas filters reference"
+   ///
+   void filter_program_set(std::string program_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_filter_program_set(efl::eolian::to_c(program_)));
+   }
+
+   /// @brief Bind an object to use as a mask or texture with Evas Filters.
+   ///
+   /// This will create automatically a new RGBA buffer containing
+   /// the source object's pixels (as it is rendered).
+   ///
+   /// @param name Object name as used in the program code
+   /// @param eobj Eo object to use through proxy rendering
+   ///
+   void filter_source_set(std::string name_, efl::eo::base eobj_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_filter_source_set(efl::eolian::to_c(name_), efl::eolian::to_c(eobj_)));
+   }
+
+   /// @brief Get the value of the extra padding set when a filter is used.
+   ///
+   /// @param l Left padding in pixels
+   /// @param r Right padding in pixels
+   /// @param t Top padding in pixels
+   /// @param b Bottom padding in pixels
+   ///
+   /// @return Returns false if the filter is invalid and padding is 0
+   bool filter_padding_get(int* l_, int* r_, int* t_, int* b_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_filter_padding_get(l_, r_, t_, b_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Begin preloading an image object's image data in the background
+   ///
+   void preload_begin() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_preload_begin());
+   }
+
+   /// @brief Mark a sub-region of the given image object to be redrawn.
+   ///
+   /// This function schedules a particular rectangular region of an image
+   /// object to be updated (redrawn) at the next rendering cycle.
+   ///
+   /// @param x X-offset of the region to be updated.
+   /// @param y Y-offset of the region to be updated.
+   /// @param w Width of the region to be updated.
+   /// @param h Height of the region to be updated.
+   ///
+   void data_update_add(int x_, int y_, int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_data_update_add(x_, y_, w_, h_));
+   }
+
+   /// @brief Get the duration of a sequence of frames.
+   ///
+   /// This returns total duration that the specified sequence of frames should
+   /// take in seconds.
+   ///
+   /// If you set start_frame to 1 and frame_num 0, you get frame 1's duration
+   /// If you set start_frame to 1 and frame_num 1, you get frame 1's duration +
+   /// frame2's duration
+   ///
+   /// @see evas_object_image_animated_get()
+   /// @see evas_object_image_animated_frame_count_get()
+   /// @see evas_object_image_animated_loop_type_get()
+   /// @see evas_object_image_animated_loop_count_get()
+   /// @see evas_object_image_animated_frame_duration_get()
+   /// @see evas_object_image_animated_frame_set()
+   /// @since 1.1
+   ///
+   /// @param start_frame The first frame
+   /// @param frame_num Number of frames in the sequence
+   ///
+   double animated_frame_duration_get(int start_frame_, int frame_num_) const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_frame_duration_get(start_frame_, frame_num_));
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the raw image data of the given image object.
+   ///
+   /// Note that the raw data must be of the same size (see
+   /// evas_object_image_size_set(), which has to be called @b before this
+   /// one) and colorspace (see evas_object_image_colorspace_set()) of the
+   /// image. If data is @c NULL, the current image data will be
+   /// freed. Naturally, if one does not set an image object's data
+   /// manually, it will still have one, allocated by Evas.
+   ///
+   /// @see evas_object_image_data_get()
+   ///
+   /// @param data The raw data, or @c NULL.
+   ///
+   void data_set(void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_data_set(data_));
+   }
+
+   /// @brief Get a pointer to the raw image data of the given image object.
+   ///
+   /// @return The raw image data.
+   ///
+   /// This function returns a pointer to an image object's internal pixel
+   /// buffer, for reading only or read/write. If you request it for
+   /// writing, the image will be marked dirty so that it gets redrawn at
+   /// the next update.
+   ///
+   /// Each time you call this function on an image object, its data
+   /// buffer will have an internal reference counter
+   /// incremented. Decrement it back by using
+   /// evas_object_image_data_set().
+   ///
+   /// This is best suited for when you want to modify an existing image,
+   /// without changing its dimensions.
+   ///
+   /// @note The contents' format returned by it depend on the color
+   /// space of the given image object.
+   ///
+   /// @note You may want to use evas_object_image_data_update_add() to
+   /// inform data changes, if you did any.
+   ///
+   /// @see evas_object_image_data_set()
+   ///
+   /// @param for_writing Whether the data being retrieved will be
+   /// modified (@c EINA_TRUE) or not (@c EINA_FALSE).
+   ///
+   void * data_get(bool for_writing_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_data_get(efl::eolian::to_c(for_writing_)));
+      return _tmp_ret;
+   }
+
+   /// @brief Cancel preloading an image object's image data in the background
+   ///
+   void preload_cancel() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_preload_cancel());
+   }
+
+   /// @brief Converts the raw image data of the given image object to the
+   /// specified colorspace.
+   ///
+   /// Note that this function does not modify the raw image data.  If the
+   /// requested colorspace is the same as the image colorspace nothing is
+   /// done and @c NULL is returned. You should use
+   /// evas_object_image_colorspace_get() to check the current image
+   /// colorspace.
+   ///
+   /// See @ref evas_object_image_colorspace_get.
+   ///
+   /// @return data A newly allocated data in the format specified by to_cspace.
+   ///
+   /// @param to_cspace The colorspace to which the image raw data will be converted.
+   ///
+   void * data_convert(Evas_Colorspace to_cspace_) const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_data_convert(to_cspace_));
+      return _tmp_ret;
+   }
+
+   /// @brief Import pixels from given source to a given canvas image object.
+   ///
+   /// This function imports pixels from a given source to a given canvas image.
+   ///
+   /// @param pixels The pixel's source to be imported.
+   ///
+   bool pixels_import(Evas_Pixel_Import_Source * pixels_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_image_pixels_import(pixels_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Reload an image object's image data.
+   ///
+   /// This function reloads the image data bound to image object @p obj.
+   ///
+   void reload() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_image_reload());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_IMAGE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_IMAGE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_image_dbg_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo_Dbg_Info * root_node_)
+{
+   static_cast<T*>(self->this_)->dbg_info_get(root_node_);
+}
+
+template <typename T>
+bool evas_image_file_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * file_, const char * key_)
+{
+   return static_cast<T*>(self->this_)->file_set(efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_image_file_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char ** file_, const char ** key_)
+{
+   static_cast<T*>(self->this_)->file_get(file_, key_);
+}
+
+template <typename T>
+bool evas_image_save_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * file_, const char * key_, const char * flags_)
+{
+   return static_cast<T*>(self->this_)->save(efl::eolian::to_cxx<std::string>(file_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()), efl::eolian::to_cxx<std::string>(flags_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_image_animated_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->animated_get();
+}
+
+template <typename T>
+void evas_image_load_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->load_size_set(w_, h_);
+}
+
+template <typename T>
+void evas_image_load_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->load_size_get(w_, h_);
+}
+
+template <typename T>
+void evas_image_smooth_scale_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool smooth_scale_)
+{
+   static_cast<T*>(self->this_)->smooth_scale_set(efl::eolian::to_cxx<bool>(smooth_scale_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_image_smooth_scale_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smooth_scale_get();
+}
+
+template <typename T>
+double evas_image_load_dpi_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->load_dpi_get();
+}
+
+template <typename T>
+void evas_image_load_dpi_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double dpi_)
+{
+   static_cast<T*>(self->this_)->load_dpi_set(dpi_);
+}
+
+template <typename T>
+bool evas_image_source_clip_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_clip_get();
+}
+
+template <typename T>
+void evas_image_source_clip_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool source_clip_)
+{
+   static_cast<T*>(self->this_)->source_clip_set(efl::eolian::to_cxx<bool>(source_clip_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+evas::object evas_image_source_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_get();
+}
+
+template <typename T>
+bool evas_image_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * src_)
+{
+   return static_cast<T*>(self->this_)->source_set(efl::eolian::to_cxx<evas::object>(src_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_image_filled_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->filled_get();
+}
+
+template <typename T>
+void evas_image_filled_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool filled_)
+{
+   static_cast<T*>(self->this_)->filled_set(efl::eolian::to_cxx<bool>(filled_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Image_Content_Hint evas_image_content_hint_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->content_hint_get();
+}
+
+template <typename T>
+void evas_image_content_hint_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Image_Content_Hint hint_)
+{
+   static_cast<T*>(self->this_)->content_hint_set(hint_);
+}
+
+template <typename T>
+void evas_image_load_region_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* x_, int* y_, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->load_region_get(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_image_load_region_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_, int y_, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->load_region_set(x_, y_, w_, h_);
+}
+
+template <typename T>
+bool evas_image_alpha_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->alpha_get();
+}
+
+template <typename T>
+void evas_image_alpha_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool alpha_)
+{
+   static_cast<T*>(self->this_)->alpha_set(efl::eolian::to_cxx<bool>(alpha_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_image_border_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* l_, int* r_, int* t_, int* b_)
+{
+   static_cast<T*>(self->this_)->border_get(l_, r_, t_, b_);
+}
+
+template <typename T>
+void evas_image_border_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int l_, int r_, int t_, int b_)
+{
+   static_cast<T*>(self->this_)->border_set(l_, r_, t_, b_);
+}
+
+template <typename T>
+double evas_image_border_scale_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->border_scale_get();
+}
+
+template <typename T>
+void evas_image_border_scale_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double scale_)
+{
+   static_cast<T*>(self->this_)->border_scale_set(scale_);
+}
+
+template <typename T>
+bool evas_image_pixels_dirty_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->pixels_dirty_get();
+}
+
+template <typename T>
+void evas_image_pixels_dirty_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool dirty_)
+{
+   static_cast<T*>(self->this_)->pixels_dirty_set(efl::eolian::to_cxx<bool>(dirty_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+const Evas_Video_Surface * evas_image_video_surface_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->video_surface_get();
+}
+
+template <typename T>
+void evas_image_video_surface_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Video_Surface * surf_)
+{
+   static_cast<T*>(self->this_)->video_surface_set(surf_);
+}
+
+template <typename T>
+unsigned int evas_image_video_surface_caps_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->video_surface_caps_get();
+}
+
+template <typename T>
+void evas_image_video_surface_caps_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned int caps_)
+{
+   static_cast<T*>(self->this_)->video_surface_caps_set(caps_);
+}
+
+template <typename T>
+bool evas_image_load_orientation_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->load_orientation_get();
+}
+
+template <typename T>
+void evas_image_load_orientation_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool enable_)
+{
+   static_cast<T*>(self->this_)->load_orientation_set(efl::eolian::to_cxx<bool>(enable_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Fill_Spread evas_image_fill_spread_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->fill_spread_get();
+}
+
+template <typename T>
+void evas_image_fill_spread_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Fill_Spread spread_)
+{
+   static_cast<T*>(self->this_)->fill_spread_set(spread_);
+}
+
+template <typename T>
+Evas_Border_Fill_Mode evas_image_border_center_fill_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->border_center_fill_get();
+}
+
+template <typename T>
+void evas_image_border_center_fill_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Border_Fill_Mode fill_)
+{
+   static_cast<T*>(self->this_)->border_center_fill_set(fill_);
+}
+
+template <typename T>
+void evas_image_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->size_get(w_, h_);
+}
+
+template <typename T>
+void evas_image_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->size_set(w_, h_);
+}
+
+template <typename T>
+bool evas_image_source_visible_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_visible_get();
+}
+
+template <typename T>
+void evas_image_source_visible_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool visible_)
+{
+   static_cast<T*>(self->this_)->source_visible_set(efl::eolian::to_cxx<bool>(visible_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_image_fill_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->fill_get(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_image_fill_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->fill_set(x_, y_, w_, h_);
+}
+
+template <typename T>
+Evas_Native_Surface * evas_image_native_surface_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->native_surface_get();
+}
+
+template <typename T>
+void evas_image_native_surface_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Native_Surface * surf_)
+{
+   static_cast<T*>(self->this_)->native_surface_set(surf_);
+}
+
+template <typename T>
+int evas_image_load_scale_down_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->load_scale_down_get();
+}
+
+template <typename T>
+void evas_image_load_scale_down_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int scale_down_)
+{
+   static_cast<T*>(self->this_)->load_scale_down_set(scale_down_);
+}
+
+template <typename T>
+Evas_Image_Scale_Hint evas_image_scale_hint_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->scale_hint_get();
+}
+
+template <typename T>
+void evas_image_scale_hint_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Image_Scale_Hint hint_)
+{
+   static_cast<T*>(self->this_)->scale_hint_set(hint_);
+}
+
+template <typename T>
+bool evas_image_source_events_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->source_events_get();
+}
+
+template <typename T>
+void evas_image_source_events_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool source_)
+{
+   static_cast<T*>(self->this_)->source_events_set(efl::eolian::to_cxx<bool>(source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Colorspace evas_image_colorspace_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->colorspace_get();
+}
+
+template <typename T>
+void evas_image_colorspace_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Colorspace cspace_)
+{
+   static_cast<T*>(self->this_)->colorspace_set(cspace_);
+}
+
+template <typename T>
+void evas_image_pixels_get_callback_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Image_Pixels_Get_Cb func_, void * data_)
+{
+   static_cast<T*>(self->this_)->pixels_get_callback_set(func_, data_);
+}
+
+template <typename T>
+void evas_image_mmap_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Eina_File ** f_, const char ** key_)
+{
+   static_cast<T*>(self->this_)->mmap_get(f_, key_);
+}
+
+template <typename T>
+void evas_image_mmap_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Eina_File * f_, const char * key_)
+{
+   static_cast<T*>(self->this_)->mmap_set(f_, efl::eolian::to_cxx<std::string>(key_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_image_data_copy_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * data_)
+{
+   static_cast<T*>(self->this_)->data_copy_set(data_);
+}
+
+template <typename T>
+void evas_image_animated_frame_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int frame_index_)
+{
+   static_cast<T*>(self->this_)->animated_frame_set(frame_index_);
+}
+
+template <typename T>
+bool evas_image_region_support_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->region_support_get();
+}
+
+template <typename T>
+Evas_Load_Error evas_image_load_error_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->load_error_get();
+}
+
+template <typename T>
+int evas_image_animated_frame_count_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->animated_frame_count_get();
+}
+
+template <typename T>
+int evas_image_stride_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->stride_get();
+}
+
+template <typename T>
+Evas_Image_Animated_Loop_Hint evas_image_animated_loop_type_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->animated_loop_type_get();
+}
+
+template <typename T>
+int evas_image_animated_loop_count_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->animated_loop_count_get();
+}
+
+template <typename T>
+Evas_3D_Scene * evas_image_scene_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->scene_get();
+}
+
+template <typename T>
+void evas_image_scene_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_3D_Scene * scene_)
+{
+   static_cast<T*>(self->this_)->scene_set(scene_);
+}
+
+template <typename T>
+void evas_image_filter_program_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * program_)
+{
+   static_cast<T*>(self->this_)->filter_program_set(efl::eolian::to_cxx<std::string>(program_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_image_filter_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_, Eo * eobj_)
+{
+   static_cast<T*>(self->this_)->filter_source_set(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()), efl::eolian::to_cxx<efl::eo::base>(eobj_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_image_filter_padding_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* l_, int* r_, int* t_, int* b_)
+{
+   return static_cast<T*>(self->this_)->filter_padding_get(l_, r_, t_, b_);
+}
+
+template <typename T>
+void evas_image_preload_begin_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->preload_begin();
+}
+
+template <typename T>
+void evas_image_data_update_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_, int y_, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->data_update_add(x_, y_, w_, h_);
+}
+
+template <typename T>
+double evas_image_animated_frame_duration_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int start_frame_, int frame_num_)
+{
+   return static_cast<T*>(self->this_)->animated_frame_duration_get(start_frame_, frame_num_);
+}
+
+template <typename T>
+void evas_image_data_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * data_)
+{
+   static_cast<T*>(self->this_)->data_set(data_);
+}
+
+template <typename T>
+void * evas_image_data_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool for_writing_)
+{
+   return static_cast<T*>(self->this_)->data_get(efl::eolian::to_cxx<bool>(for_writing_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_image_preload_cancel_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->preload_cancel();
+}
+
+template <typename T>
+void * evas_image_data_convert_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Colorspace to_cspace_)
+{
+   return static_cast<T*>(self->this_)->data_convert(to_cspace_);
+}
+
+template <typename T>
+bool evas_image_pixels_import_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Pixel_Import_Source * pixels_)
+{
+   return static_cast<T*>(self->this_)->pixels_import(pixels_);
+}
+
+template <typename T>
+void evas_image_reload_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->reload();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::image >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_dbg_info_get(root_node_));
+      }
+
+      virtual bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void file_get(const char ** file_, const char ** key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_file_get(file_, key_));
+      }
+
+      virtual bool save(std::string file_, std::string key_, std::string flags_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_file_save(efl::eolian::to_c(file_), efl::eolian::to_c(key_), efl::eolian::to_c(flags_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool animated_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_image_animated_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void load_size_set(int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_image_load_size_set(w_, h_));
+      }
+
+      virtual void load_size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_image_load_size_get(w_, h_));
+      }
+
+      virtual void smooth_scale_set(bool smooth_scale_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_image_smooth_scale_set(efl::eolian::to_c(smooth_scale_)));
+      }
+
+      virtual bool smooth_scale_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_image_smooth_scale_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual double load_dpi_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_load_dpi_get());
+            return _tmp_ret;
+      }
+
+      virtual void load_dpi_set(double dpi_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_load_dpi_set(dpi_));
+      }
+
+      virtual bool source_clip_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_source_clip_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void source_clip_set(bool source_clip_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_source_clip_set(efl::eolian::to_c(source_clip_)));
+      }
+
+      virtual evas::object source_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_source_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool source_set(evas::object src_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_source_set(efl::eolian::to_c(src_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool filled_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_filled_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void filled_set(bool filled_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_filled_set(efl::eolian::to_c(filled_)));
+      }
+
+      virtual Evas_Image_Content_Hint content_hint_get()
+      {
+         Evas_Image_Content_Hint _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_content_hint_get());
+            return _tmp_ret;
+      }
+
+      virtual void content_hint_set(Evas_Image_Content_Hint hint_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_content_hint_set(hint_));
+      }
+
+      virtual void load_region_get(int* x_, int* y_, int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_load_region_get(x_, y_, w_, h_));
+      }
+
+      virtual void load_region_set(int x_, int y_, int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_load_region_set(x_, y_, w_, h_));
+      }
+
+      virtual bool alpha_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_alpha_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void alpha_set(bool alpha_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_alpha_set(efl::eolian::to_c(alpha_)));
+      }
+
+      virtual void border_get(int* l_, int* r_, int* t_, int* b_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_border_get(l_, r_, t_, b_));
+      }
+
+      virtual void border_set(int l_, int r_, int t_, int b_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_border_set(l_, r_, t_, b_));
+      }
+
+      virtual double border_scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_border_scale_get());
+            return _tmp_ret;
+      }
+
+      virtual void border_scale_set(double scale_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_border_scale_set(scale_));
+      }
+
+      virtual bool pixels_dirty_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_pixels_dirty_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void pixels_dirty_set(bool dirty_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_pixels_dirty_set(efl::eolian::to_c(dirty_)));
+      }
+
+      virtual const Evas_Video_Surface * video_surface_get()
+      {
+         const Evas_Video_Surface * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_video_surface_get());
+            return _tmp_ret;
+      }
+
+      virtual void video_surface_set(Evas_Video_Surface * surf_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_video_surface_set(surf_));
+      }
+
+      virtual unsigned int video_surface_caps_get()
+      {
+         unsigned int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_video_surface_caps_get());
+            return _tmp_ret;
+      }
+
+      virtual void video_surface_caps_set(unsigned int caps_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_video_surface_caps_set(caps_));
+      }
+
+      virtual bool load_orientation_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_load_orientation_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void load_orientation_set(bool enable_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_load_orientation_set(efl::eolian::to_c(enable_)));
+      }
+
+      virtual Evas_Fill_Spread fill_spread_get()
+      {
+         Evas_Fill_Spread _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_fill_spread_get());
+            return _tmp_ret;
+      }
+
+      virtual void fill_spread_set(Evas_Fill_Spread spread_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_fill_spread_set(spread_));
+      }
+
+      virtual Evas_Border_Fill_Mode border_center_fill_get()
+      {
+         Evas_Border_Fill_Mode _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_border_center_fill_get());
+            return _tmp_ret;
+      }
+
+      virtual void border_center_fill_set(Evas_Border_Fill_Mode fill_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_border_center_fill_set(fill_));
+      }
+
+      virtual void size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_size_get(w_, h_));
+      }
+
+      virtual void size_set(int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_size_set(w_, h_));
+      }
+
+      virtual bool source_visible_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_source_visible_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void source_visible_set(bool visible_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_source_visible_set(efl::eolian::to_c(visible_)));
+      }
+
+      virtual void fill_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_fill_get(x_, y_, w_, h_));
+      }
+
+      virtual void fill_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_fill_set(x_, y_, w_, h_));
+      }
+
+      virtual Evas_Native_Surface * native_surface_get()
+      {
+         Evas_Native_Surface * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_native_surface_get());
+            return _tmp_ret;
+      }
+
+      virtual void native_surface_set(Evas_Native_Surface * surf_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_native_surface_set(surf_));
+      }
+
+      virtual int load_scale_down_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_load_scale_down_get());
+            return _tmp_ret;
+      }
+
+      virtual void load_scale_down_set(int scale_down_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_load_scale_down_set(scale_down_));
+      }
+
+      virtual Evas_Image_Scale_Hint scale_hint_get()
+      {
+         Evas_Image_Scale_Hint _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_scale_hint_get());
+            return _tmp_ret;
+      }
+
+      virtual void scale_hint_set(Evas_Image_Scale_Hint hint_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_scale_hint_set(hint_));
+      }
+
+      virtual bool source_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_source_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void source_events_set(bool source_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_source_events_set(efl::eolian::to_c(source_)));
+      }
+
+      virtual Evas_Colorspace colorspace_get()
+      {
+         Evas_Colorspace _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_colorspace_get());
+            return _tmp_ret;
+      }
+
+      virtual void colorspace_set(Evas_Colorspace cspace_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_colorspace_set(cspace_));
+      }
+
+      virtual void pixels_get_callback_set(Evas_Object_Image_Pixels_Get_Cb func_, void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_pixels_get_callback_set(func_, data_));
+      }
+
+      virtual void mmap_get(const Eina_File ** f_, const char ** key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_mmap_get(f_, key_));
+      }
+
+      virtual void mmap_set(const Eina_File * f_, std::string key_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_mmap_set(f_, efl::eolian::to_c(key_)));
+      }
+
+      virtual void data_copy_set(void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_data_copy_set(data_));
+      }
+
+      virtual void animated_frame_set(int frame_index_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_animated_frame_set(frame_index_));
+      }
+
+      virtual bool region_support_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_region_support_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Evas_Load_Error load_error_get()
+      {
+         Evas_Load_Error _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_load_error_get());
+            return _tmp_ret;
+      }
+
+      virtual int animated_frame_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_animated_frame_count_get());
+            return _tmp_ret;
+      }
+
+      virtual int stride_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_stride_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Image_Animated_Loop_Hint animated_loop_type_get()
+      {
+         Evas_Image_Animated_Loop_Hint _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_animated_loop_type_get());
+            return _tmp_ret;
+      }
+
+      virtual int animated_loop_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_animated_loop_count_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_3D_Scene * scene_get()
+      {
+         Evas_3D_Scene * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_scene_get());
+            return _tmp_ret;
+      }
+
+      virtual void scene_set(Evas_3D_Scene * scene_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_scene_set(scene_));
+      }
+
+      virtual void filter_program_set(std::string program_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_filter_program_set(efl::eolian::to_c(program_)));
+      }
+
+      virtual void filter_source_set(std::string name_, efl::eo::base eobj_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_filter_source_set(efl::eolian::to_c(name_), efl::eolian::to_c(eobj_)));
+      }
+
+      virtual bool filter_padding_get(int* l_, int* r_, int* t_, int* b_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_filter_padding_get(l_, r_, t_, b_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void preload_begin()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_preload_begin());
+      }
+
+      virtual void data_update_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_data_update_add(x_, y_, w_, h_));
+      }
+
+      virtual double animated_frame_duration_get(int start_frame_, int frame_num_)
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_animated_frame_duration_get(start_frame_, frame_num_));
+            return _tmp_ret;
+      }
+
+      virtual void data_set(void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_data_set(data_));
+      }
+
+      virtual void * data_get(bool for_writing_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_data_get(efl::eolian::to_c(for_writing_)));
+            return _tmp_ret;
+      }
+
+      virtual void preload_cancel()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_preload_cancel());
+      }
+
+      virtual void * data_convert(Evas_Colorspace to_cspace_)
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_data_convert(to_cspace_));
+            return _tmp_ret;
+      }
+
+      virtual bool pixels_import(Evas_Pixel_Import_Source * pixels_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_image_pixels_import(pixels_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void reload()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_image_reload());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::image >
+{
+   static const int value = 80;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::image>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_image_dbg_info_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_dbg_info_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_image_file_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_file_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_image_file_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_file_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_image_save_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_file_save);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_image_animated_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::efl_image_animated_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_image_load_size_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::efl_image_load_size_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_image_load_size_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::efl_image_load_size_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_image_smooth_scale_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::efl_image_smooth_scale_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_image_smooth_scale_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::efl_image_smooth_scale_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_image_load_dpi_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_dpi_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_image_load_dpi_set_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_dpi_set);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_image_source_clip_get_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_clip_get);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_image_source_clip_set_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_clip_set);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_image_source_get_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_get);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_image_source_set_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_set);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_image_filled_get_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_obj_image_filled_get);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_image_filled_set_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_obj_image_filled_set);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_image_content_hint_get_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_obj_image_content_hint_get);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_image_content_hint_set_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_obj_image_content_hint_set);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_image_load_region_get_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_region_get);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_image_load_region_set_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_region_set);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_image_alpha_get_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_obj_image_alpha_get);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::evas_image_alpha_set_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_obj_image_alpha_set);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::evas_image_border_get_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_obj_image_border_get);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::evas_image_border_set_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_obj_image_border_set);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::evas_image_border_scale_get_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_obj_image_border_scale_get);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::evas_image_border_scale_set_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_obj_image_border_scale_set);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::evas_image_pixels_dirty_get_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::evas_obj_image_pixels_dirty_get);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::evas_image_pixels_dirty_set_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::evas_obj_image_pixels_dirty_set);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   ops[29].func = reinterpret_cast<void*>(& ::evas_image_video_surface_get_wrapper<T>);
+   ops[29].api_func = reinterpret_cast<void*>(& ::evas_obj_image_video_surface_get);
+   ops[29].op = EO_OP_OVERRIDE;
+   ops[29].op_type = EO_OP_TYPE_REGULAR;
+   ops[29].doc = NULL;
+
+   ops[30].func = reinterpret_cast<void*>(& ::evas_image_video_surface_set_wrapper<T>);
+   ops[30].api_func = reinterpret_cast<void*>(& ::evas_obj_image_video_surface_set);
+   ops[30].op = EO_OP_OVERRIDE;
+   ops[30].op_type = EO_OP_TYPE_REGULAR;
+   ops[30].doc = NULL;
+
+   ops[31].func = reinterpret_cast<void*>(& ::evas_image_video_surface_caps_get_wrapper<T>);
+   ops[31].api_func = reinterpret_cast<void*>(& ::evas_obj_image_video_surface_caps_get);
+   ops[31].op = EO_OP_OVERRIDE;
+   ops[31].op_type = EO_OP_TYPE_REGULAR;
+   ops[31].doc = NULL;
+
+   ops[32].func = reinterpret_cast<void*>(& ::evas_image_video_surface_caps_set_wrapper<T>);
+   ops[32].api_func = reinterpret_cast<void*>(& ::evas_obj_image_video_surface_caps_set);
+   ops[32].op = EO_OP_OVERRIDE;
+   ops[32].op_type = EO_OP_TYPE_REGULAR;
+   ops[32].doc = NULL;
+
+   ops[33].func = reinterpret_cast<void*>(& ::evas_image_load_orientation_get_wrapper<T>);
+   ops[33].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_orientation_get);
+   ops[33].op = EO_OP_OVERRIDE;
+   ops[33].op_type = EO_OP_TYPE_REGULAR;
+   ops[33].doc = NULL;
+
+   ops[34].func = reinterpret_cast<void*>(& ::evas_image_load_orientation_set_wrapper<T>);
+   ops[34].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_orientation_set);
+   ops[34].op = EO_OP_OVERRIDE;
+   ops[34].op_type = EO_OP_TYPE_REGULAR;
+   ops[34].doc = NULL;
+
+   ops[35].func = reinterpret_cast<void*>(& ::evas_image_fill_spread_get_wrapper<T>);
+   ops[35].api_func = reinterpret_cast<void*>(& ::evas_obj_image_fill_spread_get);
+   ops[35].op = EO_OP_OVERRIDE;
+   ops[35].op_type = EO_OP_TYPE_REGULAR;
+   ops[35].doc = NULL;
+
+   ops[36].func = reinterpret_cast<void*>(& ::evas_image_fill_spread_set_wrapper<T>);
+   ops[36].api_func = reinterpret_cast<void*>(& ::evas_obj_image_fill_spread_set);
+   ops[36].op = EO_OP_OVERRIDE;
+   ops[36].op_type = EO_OP_TYPE_REGULAR;
+   ops[36].doc = NULL;
+
+   ops[37].func = reinterpret_cast<void*>(& ::evas_image_border_center_fill_get_wrapper<T>);
+   ops[37].api_func = reinterpret_cast<void*>(& ::evas_obj_image_border_center_fill_get);
+   ops[37].op = EO_OP_OVERRIDE;
+   ops[37].op_type = EO_OP_TYPE_REGULAR;
+   ops[37].doc = NULL;
+
+   ops[38].func = reinterpret_cast<void*>(& ::evas_image_border_center_fill_set_wrapper<T>);
+   ops[38].api_func = reinterpret_cast<void*>(& ::evas_obj_image_border_center_fill_set);
+   ops[38].op = EO_OP_OVERRIDE;
+   ops[38].op_type = EO_OP_TYPE_REGULAR;
+   ops[38].doc = NULL;
+
+   ops[39].func = reinterpret_cast<void*>(& ::evas_image_size_get_wrapper<T>);
+   ops[39].api_func = reinterpret_cast<void*>(& ::evas_obj_image_size_get);
+   ops[39].op = EO_OP_OVERRIDE;
+   ops[39].op_type = EO_OP_TYPE_REGULAR;
+   ops[39].doc = NULL;
+
+   ops[40].func = reinterpret_cast<void*>(& ::evas_image_size_set_wrapper<T>);
+   ops[40].api_func = reinterpret_cast<void*>(& ::evas_obj_image_size_set);
+   ops[40].op = EO_OP_OVERRIDE;
+   ops[40].op_type = EO_OP_TYPE_REGULAR;
+   ops[40].doc = NULL;
+
+   ops[41].func = reinterpret_cast<void*>(& ::evas_image_source_visible_get_wrapper<T>);
+   ops[41].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_visible_get);
+   ops[41].op = EO_OP_OVERRIDE;
+   ops[41].op_type = EO_OP_TYPE_REGULAR;
+   ops[41].doc = NULL;
+
+   ops[42].func = reinterpret_cast<void*>(& ::evas_image_source_visible_set_wrapper<T>);
+   ops[42].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_visible_set);
+   ops[42].op = EO_OP_OVERRIDE;
+   ops[42].op_type = EO_OP_TYPE_REGULAR;
+   ops[42].doc = NULL;
+
+   ops[43].func = reinterpret_cast<void*>(& ::evas_image_fill_get_wrapper<T>);
+   ops[43].api_func = reinterpret_cast<void*>(& ::evas_obj_image_fill_get);
+   ops[43].op = EO_OP_OVERRIDE;
+   ops[43].op_type = EO_OP_TYPE_REGULAR;
+   ops[43].doc = NULL;
+
+   ops[44].func = reinterpret_cast<void*>(& ::evas_image_fill_set_wrapper<T>);
+   ops[44].api_func = reinterpret_cast<void*>(& ::evas_obj_image_fill_set);
+   ops[44].op = EO_OP_OVERRIDE;
+   ops[44].op_type = EO_OP_TYPE_REGULAR;
+   ops[44].doc = NULL;
+
+   ops[45].func = reinterpret_cast<void*>(& ::evas_image_native_surface_get_wrapper<T>);
+   ops[45].api_func = reinterpret_cast<void*>(& ::evas_obj_image_native_surface_get);
+   ops[45].op = EO_OP_OVERRIDE;
+   ops[45].op_type = EO_OP_TYPE_REGULAR;
+   ops[45].doc = NULL;
+
+   ops[46].func = reinterpret_cast<void*>(& ::evas_image_native_surface_set_wrapper<T>);
+   ops[46].api_func = reinterpret_cast<void*>(& ::evas_obj_image_native_surface_set);
+   ops[46].op = EO_OP_OVERRIDE;
+   ops[46].op_type = EO_OP_TYPE_REGULAR;
+   ops[46].doc = NULL;
+
+   ops[47].func = reinterpret_cast<void*>(& ::evas_image_load_scale_down_get_wrapper<T>);
+   ops[47].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_scale_down_get);
+   ops[47].op = EO_OP_OVERRIDE;
+   ops[47].op_type = EO_OP_TYPE_REGULAR;
+   ops[47].doc = NULL;
+
+   ops[48].func = reinterpret_cast<void*>(& ::evas_image_load_scale_down_set_wrapper<T>);
+   ops[48].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_scale_down_set);
+   ops[48].op = EO_OP_OVERRIDE;
+   ops[48].op_type = EO_OP_TYPE_REGULAR;
+   ops[48].doc = NULL;
+
+   ops[49].func = reinterpret_cast<void*>(& ::evas_image_scale_hint_get_wrapper<T>);
+   ops[49].api_func = reinterpret_cast<void*>(& ::evas_obj_image_scale_hint_get);
+   ops[49].op = EO_OP_OVERRIDE;
+   ops[49].op_type = EO_OP_TYPE_REGULAR;
+   ops[49].doc = NULL;
+
+   ops[50].func = reinterpret_cast<void*>(& ::evas_image_scale_hint_set_wrapper<T>);
+   ops[50].api_func = reinterpret_cast<void*>(& ::evas_obj_image_scale_hint_set);
+   ops[50].op = EO_OP_OVERRIDE;
+   ops[50].op_type = EO_OP_TYPE_REGULAR;
+   ops[50].doc = NULL;
+
+   ops[51].func = reinterpret_cast<void*>(& ::evas_image_source_events_get_wrapper<T>);
+   ops[51].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_events_get);
+   ops[51].op = EO_OP_OVERRIDE;
+   ops[51].op_type = EO_OP_TYPE_REGULAR;
+   ops[51].doc = NULL;
+
+   ops[52].func = reinterpret_cast<void*>(& ::evas_image_source_events_set_wrapper<T>);
+   ops[52].api_func = reinterpret_cast<void*>(& ::evas_obj_image_source_events_set);
+   ops[52].op = EO_OP_OVERRIDE;
+   ops[52].op_type = EO_OP_TYPE_REGULAR;
+   ops[52].doc = NULL;
+
+   ops[53].func = reinterpret_cast<void*>(& ::evas_image_colorspace_get_wrapper<T>);
+   ops[53].api_func = reinterpret_cast<void*>(& ::evas_obj_image_colorspace_get);
+   ops[53].op = EO_OP_OVERRIDE;
+   ops[53].op_type = EO_OP_TYPE_REGULAR;
+   ops[53].doc = NULL;
+
+   ops[54].func = reinterpret_cast<void*>(& ::evas_image_colorspace_set_wrapper<T>);
+   ops[54].api_func = reinterpret_cast<void*>(& ::evas_obj_image_colorspace_set);
+   ops[54].op = EO_OP_OVERRIDE;
+   ops[54].op_type = EO_OP_TYPE_REGULAR;
+   ops[54].doc = NULL;
+
+   ops[55].func = reinterpret_cast<void*>(& ::evas_image_pixels_get_callback_set_wrapper<T>);
+   ops[55].api_func = reinterpret_cast<void*>(& ::evas_obj_image_pixels_get_callback_set);
+   ops[55].op = EO_OP_OVERRIDE;
+   ops[55].op_type = EO_OP_TYPE_REGULAR;
+   ops[55].doc = NULL;
+
+   ops[56].func = reinterpret_cast<void*>(& ::evas_image_mmap_get_wrapper<T>);
+   ops[56].api_func = reinterpret_cast<void*>(& ::evas_obj_image_mmap_get);
+   ops[56].op = EO_OP_OVERRIDE;
+   ops[56].op_type = EO_OP_TYPE_REGULAR;
+   ops[56].doc = NULL;
+
+   ops[57].func = reinterpret_cast<void*>(& ::evas_image_mmap_set_wrapper<T>);
+   ops[57].api_func = reinterpret_cast<void*>(& ::evas_obj_image_mmap_set);
+   ops[57].op = EO_OP_OVERRIDE;
+   ops[57].op_type = EO_OP_TYPE_REGULAR;
+   ops[57].doc = NULL;
+
+   ops[58].func = reinterpret_cast<void*>(& ::evas_image_data_copy_set_wrapper<T>);
+   ops[58].api_func = reinterpret_cast<void*>(& ::evas_obj_image_data_copy_set);
+   ops[58].op = EO_OP_OVERRIDE;
+   ops[58].op_type = EO_OP_TYPE_REGULAR;
+   ops[58].doc = NULL;
+
+   ops[59].func = reinterpret_cast<void*>(& ::evas_image_animated_frame_set_wrapper<T>);
+   ops[59].api_func = reinterpret_cast<void*>(& ::evas_obj_image_animated_frame_set);
+   ops[59].op = EO_OP_OVERRIDE;
+   ops[59].op_type = EO_OP_TYPE_REGULAR;
+   ops[59].doc = NULL;
+
+   ops[60].func = reinterpret_cast<void*>(& ::evas_image_region_support_get_wrapper<T>);
+   ops[60].api_func = reinterpret_cast<void*>(& ::evas_obj_image_region_support_get);
+   ops[60].op = EO_OP_OVERRIDE;
+   ops[60].op_type = EO_OP_TYPE_REGULAR;
+   ops[60].doc = NULL;
+
+   ops[61].func = reinterpret_cast<void*>(& ::evas_image_load_error_get_wrapper<T>);
+   ops[61].api_func = reinterpret_cast<void*>(& ::evas_obj_image_load_error_get);
+   ops[61].op = EO_OP_OVERRIDE;
+   ops[61].op_type = EO_OP_TYPE_REGULAR;
+   ops[61].doc = NULL;
+
+   ops[62].func = reinterpret_cast<void*>(& ::evas_image_animated_frame_count_get_wrapper<T>);
+   ops[62].api_func = reinterpret_cast<void*>(& ::evas_obj_image_animated_frame_count_get);
+   ops[62].op = EO_OP_OVERRIDE;
+   ops[62].op_type = EO_OP_TYPE_REGULAR;
+   ops[62].doc = NULL;
+
+   ops[63].func = reinterpret_cast<void*>(& ::evas_image_stride_get_wrapper<T>);
+   ops[63].api_func = reinterpret_cast<void*>(& ::evas_obj_image_stride_get);
+   ops[63].op = EO_OP_OVERRIDE;
+   ops[63].op_type = EO_OP_TYPE_REGULAR;
+   ops[63].doc = NULL;
+
+   ops[64].func = reinterpret_cast<void*>(& ::evas_image_animated_loop_type_get_wrapper<T>);
+   ops[64].api_func = reinterpret_cast<void*>(& ::evas_obj_image_animated_loop_type_get);
+   ops[64].op = EO_OP_OVERRIDE;
+   ops[64].op_type = EO_OP_TYPE_REGULAR;
+   ops[64].doc = NULL;
+
+   ops[65].func = reinterpret_cast<void*>(& ::evas_image_animated_loop_count_get_wrapper<T>);
+   ops[65].api_func = reinterpret_cast<void*>(& ::evas_obj_image_animated_loop_count_get);
+   ops[65].op = EO_OP_OVERRIDE;
+   ops[65].op_type = EO_OP_TYPE_REGULAR;
+   ops[65].doc = NULL;
+
+   ops[66].func = reinterpret_cast<void*>(& ::evas_image_scene_get_wrapper<T>);
+   ops[66].api_func = reinterpret_cast<void*>(& ::evas_obj_image_scene_get);
+   ops[66].op = EO_OP_OVERRIDE;
+   ops[66].op_type = EO_OP_TYPE_REGULAR;
+   ops[66].doc = NULL;
+
+   ops[67].func = reinterpret_cast<void*>(& ::evas_image_scene_set_wrapper<T>);
+   ops[67].api_func = reinterpret_cast<void*>(& ::evas_obj_image_scene_set);
+   ops[67].op = EO_OP_OVERRIDE;
+   ops[67].op_type = EO_OP_TYPE_REGULAR;
+   ops[67].doc = NULL;
+
+   ops[68].func = reinterpret_cast<void*>(& ::evas_image_filter_program_set_wrapper<T>);
+   ops[68].api_func = reinterpret_cast<void*>(& ::evas_obj_image_filter_program_set);
+   ops[68].op = EO_OP_OVERRIDE;
+   ops[68].op_type = EO_OP_TYPE_REGULAR;
+   ops[68].doc = NULL;
+
+   ops[69].func = reinterpret_cast<void*>(& ::evas_image_filter_source_set_wrapper<T>);
+   ops[69].api_func = reinterpret_cast<void*>(& ::evas_obj_image_filter_source_set);
+   ops[69].op = EO_OP_OVERRIDE;
+   ops[69].op_type = EO_OP_TYPE_REGULAR;
+   ops[69].doc = NULL;
+
+   ops[70].func = reinterpret_cast<void*>(& ::evas_image_filter_padding_get_wrapper<T>);
+   ops[70].api_func = reinterpret_cast<void*>(& ::evas_obj_image_filter_padding_get);
+   ops[70].op = EO_OP_OVERRIDE;
+   ops[70].op_type = EO_OP_TYPE_REGULAR;
+   ops[70].doc = NULL;
+
+   ops[71].func = reinterpret_cast<void*>(& ::evas_image_preload_begin_wrapper<T>);
+   ops[71].api_func = reinterpret_cast<void*>(& ::evas_obj_image_preload_begin);
+   ops[71].op = EO_OP_OVERRIDE;
+   ops[71].op_type = EO_OP_TYPE_REGULAR;
+   ops[71].doc = NULL;
+
+   ops[72].func = reinterpret_cast<void*>(& ::evas_image_data_update_add_wrapper<T>);
+   ops[72].api_func = reinterpret_cast<void*>(& ::evas_obj_image_data_update_add);
+   ops[72].op = EO_OP_OVERRIDE;
+   ops[72].op_type = EO_OP_TYPE_REGULAR;
+   ops[72].doc = NULL;
+
+   ops[73].func = reinterpret_cast<void*>(& ::evas_image_animated_frame_duration_get_wrapper<T>);
+   ops[73].api_func = reinterpret_cast<void*>(& ::evas_obj_image_animated_frame_duration_get);
+   ops[73].op = EO_OP_OVERRIDE;
+   ops[73].op_type = EO_OP_TYPE_REGULAR;
+   ops[73].doc = NULL;
+
+   ops[74].func = reinterpret_cast<void*>(& ::evas_image_data_set_wrapper<T>);
+   ops[74].api_func = reinterpret_cast<void*>(& ::evas_obj_image_data_set);
+   ops[74].op = EO_OP_OVERRIDE;
+   ops[74].op_type = EO_OP_TYPE_REGULAR;
+   ops[74].doc = NULL;
+
+   ops[75].func = reinterpret_cast<void*>(& ::evas_image_data_get_wrapper<T>);
+   ops[75].api_func = reinterpret_cast<void*>(& ::evas_obj_image_data_get);
+   ops[75].op = EO_OP_OVERRIDE;
+   ops[75].op_type = EO_OP_TYPE_REGULAR;
+   ops[75].doc = NULL;
+
+   ops[76].func = reinterpret_cast<void*>(& ::evas_image_preload_cancel_wrapper<T>);
+   ops[76].api_func = reinterpret_cast<void*>(& ::evas_obj_image_preload_cancel);
+   ops[76].op = EO_OP_OVERRIDE;
+   ops[76].op_type = EO_OP_TYPE_REGULAR;
+   ops[76].doc = NULL;
+
+   ops[77].func = reinterpret_cast<void*>(& ::evas_image_data_convert_wrapper<T>);
+   ops[77].api_func = reinterpret_cast<void*>(& ::evas_obj_image_data_convert);
+   ops[77].op = EO_OP_OVERRIDE;
+   ops[77].op_type = EO_OP_TYPE_REGULAR;
+   ops[77].doc = NULL;
+
+   ops[78].func = reinterpret_cast<void*>(& ::evas_image_pixels_import_wrapper<T>);
+   ops[78].api_func = reinterpret_cast<void*>(& ::evas_obj_image_pixels_import);
+   ops[78].op = EO_OP_OVERRIDE;
+   ops[78].op_type = EO_OP_TYPE_REGULAR;
+   ops[78].doc = NULL;
+
+   ops[79].func = reinterpret_cast<void*>(& ::evas_image_reload_wrapper<T>);
+   ops[79].api_func = reinterpret_cast<void*>(& ::evas_obj_image_reload);
+   ops[79].op = EO_OP_OVERRIDE;
+   ops[79].op_type = EO_OP_TYPE_REGULAR;
+   ops[79].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::image >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::image, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::image >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::image, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::image>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::image() const
+      {
+         return evas::image(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_dbg_info_get(root_node_));
+      }
+
+      bool file_set(std::string file_, std::string key_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_file_set(efl::eolian::to_c(file_), efl::eolian::to_c(key_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void file_get(const char ** file_, const char ** key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_file_get(file_, key_));
+      }
+
+      bool save(std::string file_, std::string key_, std::string flags_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_file_save(efl::eolian::to_c(file_), efl::eolian::to_c(key_), efl::eolian::to_c(flags_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool animated_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_image_animated_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void load_size_set(int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_image_load_size_set(w_, h_));
+      }
+
+      void load_size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_image_load_size_get(w_, h_));
+      }
+
+      void smooth_scale_set(bool smooth_scale_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_image_smooth_scale_set(efl::eolian::to_c(smooth_scale_)));
+      }
+
+      bool smooth_scale_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_image_smooth_scale_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      double load_dpi_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_load_dpi_get());
+            return _tmp_ret;
+      }
+
+      void load_dpi_set(double dpi_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_load_dpi_set(dpi_));
+      }
+
+      bool source_clip_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_source_clip_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void source_clip_set(bool source_clip_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_source_clip_set(efl::eolian::to_c(source_clip_)));
+      }
+
+      evas::object source_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_source_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool source_set(evas::object src_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_source_set(efl::eolian::to_c(src_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool filled_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_filled_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void filled_set(bool filled_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_filled_set(efl::eolian::to_c(filled_)));
+      }
+
+      Evas_Image_Content_Hint content_hint_get()
+      {
+         Evas_Image_Content_Hint _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_content_hint_get());
+            return _tmp_ret;
+      }
+
+      void content_hint_set(Evas_Image_Content_Hint hint_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_content_hint_set(hint_));
+      }
+
+      void load_region_get(int* x_, int* y_, int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_load_region_get(x_, y_, w_, h_));
+      }
+
+      void load_region_set(int x_, int y_, int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_load_region_set(x_, y_, w_, h_));
+      }
+
+      bool alpha_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_alpha_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void alpha_set(bool alpha_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_alpha_set(efl::eolian::to_c(alpha_)));
+      }
+
+      void border_get(int* l_, int* r_, int* t_, int* b_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_border_get(l_, r_, t_, b_));
+      }
+
+      void border_set(int l_, int r_, int t_, int b_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_border_set(l_, r_, t_, b_));
+      }
+
+      double border_scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_border_scale_get());
+            return _tmp_ret;
+      }
+
+      void border_scale_set(double scale_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_border_scale_set(scale_));
+      }
+
+      bool pixels_dirty_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_pixels_dirty_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void pixels_dirty_set(bool dirty_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_pixels_dirty_set(efl::eolian::to_c(dirty_)));
+      }
+
+      const Evas_Video_Surface * video_surface_get()
+      {
+         const Evas_Video_Surface * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_video_surface_get());
+            return _tmp_ret;
+      }
+
+      void video_surface_set(Evas_Video_Surface * surf_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_video_surface_set(surf_));
+      }
+
+      unsigned int video_surface_caps_get()
+      {
+         unsigned int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_video_surface_caps_get());
+            return _tmp_ret;
+      }
+
+      void video_surface_caps_set(unsigned int caps_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_video_surface_caps_set(caps_));
+      }
+
+      bool load_orientation_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_load_orientation_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void load_orientation_set(bool enable_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_load_orientation_set(efl::eolian::to_c(enable_)));
+      }
+
+      Evas_Fill_Spread fill_spread_get()
+      {
+         Evas_Fill_Spread _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_fill_spread_get());
+            return _tmp_ret;
+      }
+
+      void fill_spread_set(Evas_Fill_Spread spread_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_fill_spread_set(spread_));
+      }
+
+      Evas_Border_Fill_Mode border_center_fill_get()
+      {
+         Evas_Border_Fill_Mode _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_border_center_fill_get());
+            return _tmp_ret;
+      }
+
+      void border_center_fill_set(Evas_Border_Fill_Mode fill_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_border_center_fill_set(fill_));
+      }
+
+      void size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_size_get(w_, h_));
+      }
+
+      void size_set(int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_size_set(w_, h_));
+      }
+
+      bool source_visible_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_source_visible_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void source_visible_set(bool visible_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_source_visible_set(efl::eolian::to_c(visible_)));
+      }
+
+      void fill_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_fill_get(x_, y_, w_, h_));
+      }
+
+      void fill_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_fill_set(x_, y_, w_, h_));
+      }
+
+      Evas_Native_Surface * native_surface_get()
+      {
+         Evas_Native_Surface * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_native_surface_get());
+            return _tmp_ret;
+      }
+
+      void native_surface_set(Evas_Native_Surface * surf_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_native_surface_set(surf_));
+      }
+
+      int load_scale_down_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_load_scale_down_get());
+            return _tmp_ret;
+      }
+
+      void load_scale_down_set(int scale_down_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_load_scale_down_set(scale_down_));
+      }
+
+      Evas_Image_Scale_Hint scale_hint_get()
+      {
+         Evas_Image_Scale_Hint _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_scale_hint_get());
+            return _tmp_ret;
+      }
+
+      void scale_hint_set(Evas_Image_Scale_Hint hint_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_scale_hint_set(hint_));
+      }
+
+      bool source_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_source_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void source_events_set(bool source_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_source_events_set(efl::eolian::to_c(source_)));
+      }
+
+      Evas_Colorspace colorspace_get()
+      {
+         Evas_Colorspace _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_colorspace_get());
+            return _tmp_ret;
+      }
+
+      void colorspace_set(Evas_Colorspace cspace_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_colorspace_set(cspace_));
+      }
+
+      void pixels_get_callback_set(Evas_Object_Image_Pixels_Get_Cb func_, void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_pixels_get_callback_set(func_, data_));
+      }
+
+      void mmap_get(const Eina_File ** f_, const char ** key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_mmap_get(f_, key_));
+      }
+
+      void mmap_set(const Eina_File * f_, std::string key_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_mmap_set(f_, efl::eolian::to_c(key_)));
+      }
+
+      void data_copy_set(void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_data_copy_set(data_));
+      }
+
+      void animated_frame_set(int frame_index_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_animated_frame_set(frame_index_));
+      }
+
+      bool region_support_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_region_support_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Evas_Load_Error load_error_get()
+      {
+         Evas_Load_Error _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_load_error_get());
+            return _tmp_ret;
+      }
+
+      int animated_frame_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_frame_count_get());
+            return _tmp_ret;
+      }
+
+      int stride_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_stride_get());
+            return _tmp_ret;
+      }
+
+      Evas_Image_Animated_Loop_Hint animated_loop_type_get()
+      {
+         Evas_Image_Animated_Loop_Hint _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_loop_type_get());
+            return _tmp_ret;
+      }
+
+      int animated_loop_count_get()
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_loop_count_get());
+            return _tmp_ret;
+      }
+
+      Evas_3D_Scene * scene_get()
+      {
+         Evas_3D_Scene * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_scene_get());
+            return _tmp_ret;
+      }
+
+      void scene_set(Evas_3D_Scene * scene_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_scene_set(scene_));
+      }
+
+      void filter_program_set(std::string program_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_filter_program_set(efl::eolian::to_c(program_)));
+      }
+
+      void filter_source_set(std::string name_, efl::eo::base eobj_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_filter_source_set(efl::eolian::to_c(name_), efl::eolian::to_c(eobj_)));
+      }
+
+      bool filter_padding_get(int* l_, int* r_, int* t_, int* b_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_filter_padding_get(l_, r_, t_, b_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void preload_begin()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_preload_begin());
+      }
+
+      void data_update_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_data_update_add(x_, y_, w_, h_));
+      }
+
+      double animated_frame_duration_get(int start_frame_, int frame_num_)
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_animated_frame_duration_get(start_frame_, frame_num_));
+            return _tmp_ret;
+      }
+
+      void data_set(void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_data_set(data_));
+      }
+
+      void * data_get(bool for_writing_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_data_get(efl::eolian::to_c(for_writing_)));
+            return _tmp_ret;
+      }
+
+      void preload_cancel()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_preload_cancel());
+      }
+
+      void * data_convert(Evas_Colorspace to_cspace_)
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_data_convert(to_cspace_));
+            return _tmp_ret;
+      }
+
+      bool pixels_import(Evas_Pixel_Import_Source * pixels_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_image_pixels_import(pixels_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void reload()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_image_reload());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::image>)
+{
+   return (EVAS_IMAGE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_IMAGE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_image.eo.legacy.h b/src/lib/evas/canvas/evas_image.eo.legacy.h
--- a/src/lib/evas/canvas/evas_image.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_image.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,1040 @@
+#ifndef _EVAS_IMAGE_EO_LEGACY_H_
+#define _EVAS_IMAGE_EO_LEGACY_H_
+
+#ifndef _EVAS_IMAGE_EO_CLASS_TYPE
+#define _EVAS_IMAGE_EO_CLASS_TYPE
+
+typedef Eo Evas_Image;
+
+#endif
+
+#ifndef _EVAS_IMAGE_EO_TYPES
+#define _EVAS_IMAGE_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Set the DPI resolution of an image object's source image.
+ *
+ * This function sets the DPI resolution of a given loaded canvas
+ * image. Most useful for the SVG image loader.
+ *
+ * @see evas_object_image_load_dpi_get()
+ *
+ * @param[in] dpi The new DPI resolution.
+ */
+EAPI void evas_object_image_load_dpi_set(Evas_Image *obj, double dpi);
+
+/**
+ *
+ * Get the DPI resolution of a loaded image object in the canvas.
+ *
+ * @return The DPI resolution of the given canvas image.
+ *
+ * This function returns the DPI resolution of the given canvas image.
+ *
+ * @see evas_object_image_load_dpi_set() for more details
+ *
+ */
+EAPI double evas_object_image_load_dpi_get(const Evas_Image *obj);
+
+/**
+ *
+ * Clip the proxy object with the source object's clipper.
+ *
+ * @see evas_object_clip_set()
+ * @see evas_object_image_source_set()
+ * @since 1.8
+ *
+ * @param[in] source_clip whether @p obj is clipped by the source clipper.
+(@c EINA_TRUE) or not (@c EINA_FALSE)
+ */
+EAPI void evas_object_image_source_clip_set(Evas_Image *obj, Eina_Bool source_clip);
+
+/**
+ *
+ * Determine whether an object is clipped by source object's clipper.
+ *
+ * @return @c EINA_TRUE if source clip is enabled, @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_clip_set()
+ * @see evas_object_image_source_set()
+ * @see evas_object_image_source_clip_set()
+ * @since 1.8
+ *
+ */
+EAPI Eina_Bool evas_object_image_source_clip_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the source object on an image object to used as a @b proxy.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE on error.
+ *
+ * If an image object is set to behave as a @b proxy, it will mirror
+ * the rendering contents of a given @b source object in its drawing
+ * region, without affecting that source in any way. The source must
+ * be another valid Evas object. Other effects may be applied to the
+ * proxy, such as a map (see evas_object_map_set()) to create a
+ * reflection of the original object (for example).
+ *
+ * Any existing source object on @p obj will be removed after this
+ * call. Setting @p src to @c NULL clears the proxy object (not in
+ * "proxy state" anymore).
+ *
+ * @warning You cannot set a proxy as another proxy's source.
+ *
+ * @see evas_object_image_source_get()
+ * @see evas_object_image_source_unset()
+ * @see evas_object_image_source_visible_set()
+ *
+ * @param[in] src Source object to use for the proxy.
+ */
+EAPI Eina_Bool evas_object_image_source_set(Evas_Image *obj, Evas_Object *src);
+
+/**
+ *
+ * Get the current source object of an image object.
+ *
+ * @return Source object (if any), or @c NULL, if not in "proxy mode"
+ * (or on errors).
+ *
+ * @see evas_object_image_source_set() for more details
+ *
+ */
+EAPI Evas_Object *evas_object_image_source_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set whether the image object's fill property should track the
+ * object's size.
+ *
+ * If @p setting is @c EINA_TRUE, then every evas_object_resize() will
+ * @b automatically trigger a call to evas_object_image_fill_set()
+ * with the that new size (and @c 0, @c 0 as source image's origin),
+ * so the bound image will fill the whole object's area.
+ *
+ * @see evas_object_image_filled_add()
+ * @see evas_object_image_fill_get()
+ *
+ * @param[in] filled @c EINA_TRUE, to make the fill property follow
+object size or @c EINA_FALSE, otherwise.
+ */
+EAPI void evas_object_image_filled_set(Evas_Image *obj, Eina_Bool filled);
+
+/**
+ *
+ * Retrieve whether the image object's fill property should track the
+ * object's size.
+ *
+ * @return @c EINA_TRUE if it is tracking, @c EINA_FALSE, if not (and
+ * evas_object_fill_set() must be called manually).
+ *
+ * @see evas_object_image_filled_set() for more information
+ *
+ */
+EAPI Eina_Bool evas_object_image_filled_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the content hint setting of a given image object of the canvas.
+ *
+ * This function sets the content hint value of the given image of the
+ * canvas. For example, if you're on the GL engine and your driver
+ * implementation supports it, setting this hint to
+ * #EVAS_IMAGE_CONTENT_HINT_DYNAMIC will make it need @b zero copies
+ * at texture upload time, which is an "expensive" operation.
+ *
+ * @see evas_object_image_content_hint_get()
+ *
+ * @param[in] hint The content hint value, one of the
+#Evas_Image_Content_Hint ones.
+ */
+EAPI void evas_object_image_content_hint_set(Evas_Image *obj, Evas_Image_Content_Hint hint);
+
+/**
+ *
+ * Get the content hint setting of a given image object of the canvas.
+ *
+ * @return hint The content hint value set on it, one of the
+ * #Evas_Image_Content_Hint ones (#EVAS_IMAGE_CONTENT_HINT_NONE means
+ * an error).
+ *
+ * This function returns the content hint value of the given image of
+ * the canvas.
+ *
+ * @see evas_object_image_content_hint_set()
+ *
+ */
+EAPI Evas_Image_Content_Hint evas_object_image_content_hint_get(const Evas_Image *obj);
+
+/**
+ *
+ * Inform a given image object to load a selective region of its
+ * source image.
+ *
+ * This function is useful when one is not showing all of an image's
+ * area on its image object.
+ *
+ * @note The image loader for the image format in question has to
+ * support selective region loading in order to this function to take
+ * effect.
+ *
+ * @see evas_object_image_load_region_get()
+ *
+ * @param[in] x X-offset of the region to be loaded.
+ * @param[in] y Y-offset of the region to be loaded.
+ * @param[in] w Width of the region to be loaded.
+ * @param[in] h Height of the region to be loaded.
+ */
+EAPI void evas_object_image_load_region_set(Evas_Image *obj, int x, int y, int w, int h);
+
+/**
+ *
+ * Retrieve the coordinates of a given image object's selective
+ * (source image) load region.
+ *
+ * @note Use @c NULL pointers on the coordinates you're not interested
+ * in: they'll be ignored by the function.
+ *
+ * @see evas_object_image_load_region_get()
+ *
+ * @param[out] x X-offset of the region to be loaded.
+ * @param[out] y Y-offset of the region to be loaded.
+ * @param[out] w Width of the region to be loaded.
+ * @param[out] h Height of the region to be loaded.
+ */
+EAPI void evas_object_image_load_region_get(const Evas_Image *obj, int *x, int *y, int *w, int *h);
+
+/**
+ *
+ * Enable or disable alpha channel usage on the given image object.
+ *
+ * This function sets a flag on an image object indicating whether or
+ * not to use alpha channel data. A value of @c EINA_TRUE makes it use
+ * alpha channel data, and @c EINA_FALSE makes it ignore that
+ * data. Note that this has nothing to do with an object's color as
+ * manipulated by evas_object_color_set().
+ *
+ * @see evas_object_image_alpha_get()
+ *
+ * @param[in] alpha Whether to use alpha channel (@c EINA_TRUE) data
+or not (@c EINA_FALSE).
+ */
+EAPI void evas_object_image_alpha_set(Evas_Image *obj, Eina_Bool alpha);
+
+/**
+ *
+ * Retrieve whether alpha channel data is being used on the given
+ * image object.
+ *
+ * @return Whether the alpha channel data is being used (@c EINA_TRUE)
+ * or not (@c EINA_FALSE).
+ *
+ * This function returns @c EINA_TRUE if the image object's alpha
+ * channel is being used, or @c EINA_FALSE otherwise.
+ *
+ * See @ref evas_object_image_alpha_set() for more details.
+ *
+ */
+EAPI Eina_Bool evas_object_image_alpha_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the dimensions for an image object's border, a region which @b
+ * won't ever be scaled together with its center.
+ *
+ * When Evas is rendering, an image source may be scaled to fit the
+ * size of its image object. This function sets an area from the
+ * borders of the image inwards which is @b not to be scaled. This
+ * function is useful for making frames and for widget theming, where,
+ * for example, buttons may be of varying sizes, but their border size
+ * must remain constant.
+ *
+ * The units used for @p l, @p r, @p t and @p b are canvas units.
+ *
+ * @note The border region itself @b may be scaled by the
+ * evas_object_image_border_scale_set() function.
+ *
+ * @note By default, image objects have no borders set, i. e. @c l, @c
+ * r, @c t and @c b start as @c 0.
+ *
+ * See the following figures for visual explanation:\n
+ * @htmlonly
+ * <img src="image-borders.png" style="max-width: 100%;" />
+ * <a href="image-borders.png">Full-size</a>
+ * @endhtmlonly
+ * @image rtf image-borders.png
+ * @image latex image-borders.eps width=\textwidth
+ * @htmlonly
+ * <img src="border-effect.png" style="max-width: 100%;" />
+ * <a href="border-effect.png">Full-size</a>
+ * @endhtmlonly
+ * @image rtf border-effect.png
+ * @image latex border-effect.eps width=\textwidth
+ *
+ * @see evas_object_image_border_get()
+ * @see evas_object_image_border_center_fill_set()
+ *
+ * @param[in] l The border's left width.
+ * @param[in] r The border's right width.
+ * @param[in] t The border's top width.
+ * @param[in] b The border's bottom width.
+ */
+EAPI void evas_object_image_border_set(Evas_Image *obj, int l, int r, int t, int b);
+
+/**
+ *
+ * Retrieve the dimensions for an image object's border, a region
+ * which @b won't ever be scaled together with its center.
+ *
+ * @note Use @c NULL pointers on the border components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * See @ref evas_object_image_border_set() for more details.
+ *
+ * @param[out] l The border's left width.
+ * @param[out] r The border's right width.
+ * @param[out] t The border's top width.
+ * @param[out] b The border's bottom width.
+ */
+EAPI void evas_object_image_border_get(const Evas_Image *obj, int *l, int *r, int *t, int *b);
+
+/**
+ *
+ * Sets the scaling factor (multiplier) for the borders of an image
+ * object.
+ *
+ * @see evas_object_image_border_set()
+ * @see evas_object_image_border_scale_get()
+ *
+ * @param[in] scale The scale factor (default is @c 1.0 - i.e. no scaling)
+ */
+EAPI void evas_object_image_border_scale_set(Evas_Image *obj, double scale);
+
+/**
+ *
+ * Retrieves the scaling factor (multiplier) for the borders of an
+ * image object.
+ *
+ * @return The scale factor set for its borders
+ *
+ * @see evas_object_image_border_set()
+ * @see evas_object_image_border_scale_set()
+ *
+ */
+EAPI double evas_object_image_border_scale_get(const Evas_Image *obj);
+
+/**
+ *
+ * Mark whether the given image object is dirty and needs to request its pixels.
+ *
+ * This function will only properly work if a pixels get callback has been set.
+ *
+ * @warning use this function if you really know what you are doing.
+ *
+ * @see evas_object_image_pixels_get_callback_set()
+ *
+ * @param[in] dirty Whether the image is dirty.
+ */
+EAPI void evas_object_image_pixels_dirty_set(Evas_Image *obj, Eina_Bool dirty);
+
+/**
+ *
+ * Retrieves whether the given image object is dirty (needs to be redrawn).
+ *
+ * @return Whether the image is dirty.
+ *
+ */
+EAPI Eina_Bool evas_object_image_pixels_dirty_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the video surface linked to a given image of the canvas
+ *
+ * This function links a video surface to a given canvas image.
+ *
+ * @param[in] surf The new video surface.
+@since 1.1
+ */
+EAPI void evas_object_image_video_surface_set(Evas_Image *obj, Evas_Video_Surface *surf);
+
+/**
+ *
+ * Get the video surface linekd to a given image of the canvas
+ *
+ * @return The video surface of the given canvas image.
+ * @since 1.1
+ *
+ * This function returns the video surface linked to a given canvas image.
+ *
+ */
+EAPI const Evas_Video_Surface *evas_object_image_video_surface_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the video surface capabilities to a given image of the canvas
+ *
+ * @param[in] caps in
+ */
+EAPI void evas_object_image_video_surface_caps_set(Evas_Image *obj, unsigned int caps);
+
+/**
+ *
+ * Get the video surface capabilities to a given image of the canvas
+ *
+ */
+EAPI unsigned int evas_object_image_video_surface_caps_get(const Evas_Image *obj);
+
+/**
+ *
+ * Define if the orientation information in the image file should be honored.
+ *
+ * @since 1.1
+ *
+ * @param[in] enable @c EINA_TRUE means that it should honor the orientation information
+ */
+EAPI void evas_object_image_load_orientation_set(Evas_Image *obj, Eina_Bool enable);
+
+/**
+ *
+ * Get if the orientation information in the image file should be honored.
+ *
+ * @since 1.1
+ *
+ */
+EAPI Eina_Bool evas_object_image_load_orientation_get(const Evas_Image *obj);
+
+/**
+ *
+ * Sets the tiling mode for the given evas image object's fill.
+ * EVAS_TEXTURE_RESTRICT, or EVAS_TEXTURE_PAD.
+ *
+ * @param[in] spread One of EVAS_TEXTURE_REFLECT, EVAS_TEXTURE_REPEAT,
+ */
+EAPI void evas_object_image_fill_spread_set(Evas_Image *obj, Evas_Fill_Spread spread);
+
+/**
+ *
+ * Retrieves the spread (tiling mode) for the given image object's
+ * fill.
+ *
+ * @return  The current spread mode of the image object.
+ *
+ */
+EAPI Evas_Fill_Spread evas_object_image_fill_spread_get(const Evas_Image *obj);
+
+/**
+ *
+ * Sets @b how the center part of the given image object (not the
+ * borders) should be drawn when Evas is rendering it.
+ *
+ * This function sets how the center part of the image object's source
+ * image is to be drawn, which must be one of the values in
+ * #Evas_Border_Fill_Mode. By center we mean the complementary part of
+ * that defined by evas_object_image_border_set(). This one is very
+ * useful for making frames and decorations. You would most probably
+ * also be using a filled image (as in evas_object_image_filled_set())
+ * to use as a frame.
+ *
+ * @see evas_object_image_border_center_fill_get()
+ *
+ * @param[in] fill Fill mode of the center region of @p obj (a value in
+#Evas_Border_Fill_Mode).
+ */
+EAPI void evas_object_image_border_center_fill_set(Evas_Image *obj, Evas_Border_Fill_Mode fill);
+
+/**
+ *
+ * Retrieves @b how the center part of the given image object (not the
+ * borders) is to be drawn when Evas is rendering it.
+ *
+ * @return fill Fill mode of the center region of @p obj (a value in
+ * #Evas_Border_Fill_Mode).
+ *
+ * See @ref evas_object_image_fill_set() for more details.
+ *
+ */
+EAPI Evas_Border_Fill_Mode evas_object_image_border_center_fill_get(const Evas_Image *obj);
+
+/**
+ *
+ * Sets the size of the given image object.
+ *
+ * This function will scale down or crop the image so that it is
+ * treated as if it were at the given size. If the size given is
+ * smaller than the image, it will be cropped. If the size given is
+ * larger, then the image will be treated as if it were in the upper
+ * left hand corner of a larger image that is otherwise transparent.
+ *
+ * @param[in] w The new width of the image.
+ * @param[in] h The new height of the image.
+ */
+EAPI void evas_object_image_size_set(Evas_Image *obj, int w, int h);
+
+/**
+ *
+ * Retrieves the size of the given image object.
+ *
+ * See @ref evas_object_image_size_set() for more details.
+ *
+ * @param[out] w The new width of the image.
+ * @param[out] h The new height of the image.
+ */
+EAPI void evas_object_image_size_get(const Evas_Image *obj, int *w, int *h);
+
+/**
+ *
+ * Set the source object to be visible or not.
+ *
+ * If the @p visible set to @c EINA_FALSE, the source object of the proxy(@p obj
+ * ) will be invisible.
+ *
+ * This API works differently to evas_object_show() and evas_object_hide().
+ * Once source object is hidden by evas_object_hide() then the proxy object will
+ * be hidden as well. Actually in this case both objects are excluded from the
+ * Evas internal update circle.
+ *
+ * By this API, instead, one can toggle the visibility of a proxy's source
+ * object remaining the proxy visibility untouched.
+ *
+ * @warning If the all of proxies are deleted, then the source visibility of the
+ * source object will be cancelled.
+ *
+ * @see evas_object_image_source_visible_get()
+ * @see evas_object_image_source_set()
+ * @see evas_object_show()
+ * @see evas_object_hide()
+ * @since 1.8
+ *
+ * @param[in] visible @c EINA_TRUE is source object to be shown, @c EINA_FALSE
+otherwise.
+ */
+EAPI void evas_object_image_source_visible_set(Evas_Image *obj, Eina_Bool visible);
+
+/**
+ *
+ * Get the state of the source object visibility.
+ *
+ * @return @c EINA_TRUE if source object is visible, @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_image_source_visible_set()
+ * @see evas_object_image_source_set()
+ * @see evas_object_show()
+ * @see evas_object_hide()
+ * @since 1.8
+ *
+ */
+EAPI Eina_Bool evas_object_image_source_visible_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set how to fill an image object's drawing rectangle given the
+ * (real) image bound to it.
+ *
+ * Note that if @p w or @p h are smaller than the dimensions of
+ * @p obj, the displayed image will be @b tiled around the object's
+ * area. To have only one copy of the bound image drawn, @p x and @p y
+ * must be 0 and @p w and @p h need to be the exact width and height
+ * of the image object itself, respectively.
+ *
+ * See the following image to better understand the effects of this
+ * call. On this diagram, both image object and original image source
+ * have @c a x @c a dimensions and the image itself is a circle, with
+ * empty space around it:
+ *
+ * @image html image-fill.png
+ * @image rtf image-fill.png
+ * @image latex image-fill.eps
+ *
+ * @warning The default values for the fill parameters are @p x = 0,
+ * @p y = 0, @p w = 0 and @p h = 0. Thus, if you're not using the
+ * evas_object_image_filled_add() helper and want your image
+ * displayed, you'll have to set valid values with this function on
+ * your object.
+ *
+ * @note evas_object_image_filled_set() is a helper function which
+ * will @b override the values set here automatically, for you, in a
+ * given way.
+ *
+ * @param[in] x The x coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[in] y The y coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[in] w The width the bound image will be displayed at.
+ * @param[in] h The height the bound image will be displayed at.
+ */
+EAPI void evas_object_image_fill_set(Evas_Image *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieve how an image object is to fill its drawing rectangle,
+ * given the (real) image bound to it.
+ *
+ * @note Use @c NULL pointers on the fill components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * See @ref evas_object_image_fill_set() for more details.
+ *
+ * @param[out] x The x coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[out] y The y coordinate (from the top left corner of the bound
+image) to start drawing from.
+ * @param[out] w The width the bound image will be displayed at.
+ * @param[out] h The height the bound image will be displayed at.
+ */
+EAPI void evas_object_image_fill_get(const Evas_Image *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Get the native surface of a given image of the canvas
+ *
+ * @return The native surface of the given canvas image.
+ *
+ * This function returns the native surface of a given canvas image.
+ *
+ */
+EAPI Evas_Native_Surface *evas_object_image_native_surface_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the scale down factor of a given image object's source image,
+ * when loading it.
+ *
+ * This function sets the scale down factor of a given canvas
+ * image. Most useful for the SVG image loader.
+ *
+ * @see evas_object_image_load_scale_down_get()
+ *
+ * @param[in] scale_down The scale down factor.
+ */
+EAPI void evas_object_image_load_scale_down_set(Evas_Image *obj, int scale_down);
+
+/**
+ *
+ * get the scale down factor of a given image object's source image,
+ * when loading it.
+ *
+ * @see evas_object_image_load_scale_down_set() for more details
+ *
+ */
+EAPI int evas_object_image_load_scale_down_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the scale hint of a given image of the canvas.
+ *
+ * This function sets the scale hint value of the given image object
+ * in the canvas, which will affect how Evas is to cache scaled
+ * versions of its original source image.
+ *
+ * @see evas_object_image_scale_hint_get()
+ *
+ * @param[in] hint The scale hint, a value in
+#Evas_Image_Scale_Hint.
+ */
+EAPI void evas_object_image_scale_hint_set(Evas_Image *obj, Evas_Image_Scale_Hint hint);
+
+/**
+ *
+ * Get the scale hint of a given image of the canvas.
+ *
+ * @return The scale hint value set on @p obj, a value in
+ * #Evas_Image_Scale_Hint.
+ *
+ * This function returns the scale hint value of the given image
+ * object of the canvas.
+ *
+ * @see evas_object_image_scale_hint_set() for more details.
+ *
+ */
+EAPI Evas_Image_Scale_Hint evas_object_image_scale_hint_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set whether an Evas object is to source events.
+ *
+ * Set whether an Evas object is to repeat events to source.
+ *
+ * If @p source is @c EINA_TRUE, it will make events on @p obj to also be
+ * repeated for the source object (see evas_object_image_source_set()). Even the
+ * @p obj and source geometries are different, the event position will be
+ * transformed to the source object's space.
+ *
+ * If @p source is @c EINA_FALSE, events occurring on @p obj will be
+ * processed only on it.
+ *
+ * @see evas_object_image_source_get()
+ * @see evas_object_image_source_visible_set()
+ * @see evas_object_image_source_events_get()
+ * @since 1.8
+ *
+ * @param[in] source whether @p obj is to pass events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ */
+EAPI void evas_object_image_source_events_set(Evas_Image *obj, Eina_Bool source);
+
+/**
+ *
+ * Determine whether an object is set to source events.
+ *
+ * @return @c EINA_TRUE if source object has events, @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_image_source_set()
+ * @see evas_object_image_source_visible_set()
+ * @see evas_object_image_source_events_set()
+ * @since 1.8
+ *
+ */
+EAPI Eina_Bool evas_object_image_source_events_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the colorspace of a given image of the canvas.
+ *
+ * This function sets the colorspace of given canvas image.
+ *
+ * @param[in] cspace The new color space.
+ */
+EAPI void evas_object_image_colorspace_set(Evas_Image *obj, Evas_Colorspace cspace);
+
+/**
+ *
+ * Get the colorspace of a given image of the canvas.
+ *
+ * @return The colorspace of the image.
+ *
+ * This function returns the colorspace of given canvas image.
+ *
+ */
+EAPI Evas_Colorspace evas_object_image_colorspace_get(const Evas_Image *obj);
+
+/**
+ *
+ * Set the callback function to get pixels from a canvas' image.
+ *
+ * This functions sets a function to be the callback function that get
+ * pixels from a image of the canvas.
+ *
+ * @param[in] func The callback function.
+ * @param[in] data The data pointer to be passed to @a func.
+ */
+EAPI void evas_object_image_pixels_get_callback_set(Evas_Image *obj, Evas_Object_Image_Pixels_Get_Cb func, void *data) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Set the source mmaped file from where an image object must fetch the real
+ * image data (it must be an Eina_File).
+ *
+ * If the file supports multiple data stored in it (as Eet files do),
+ * you can specify the key to be used as the index of the image in
+ * this file.
+ *
+ * @since 1.8
+ *
+ * @param[in] f The mmaped file
+ * @param[in] key The image key in @p file (if its an Eet one), or @c
+NULL, otherwise.
+ */
+EAPI void evas_object_image_mmap_set(Evas_Image *obj, const Eina_File *f, const char *key);
+
+/**
+ *
+ * Get the source mmaped file from where an image object must fetch the real
+ * image data (it must be an Eina_File).
+ *
+ * If the file supports multiple data stored in it (as Eet files do),
+ * you can get the key to be used as the index of the image in
+ * this file.
+ *
+ * @since 1.10
+ *
+ * @param[out] f The mmaped file
+ * @param[out] key The image key in @p file (if its an Eet one), or @c
+NULL, otherwise.
+ */
+EAPI void evas_object_image_mmap_get(const Evas_Image *obj, const Eina_File **f, const char **key);
+
+/**
+ *
+ * Replaces the raw image data of the given image object.
+ *
+ * This function lets the application replace an image object's
+ * internal pixel buffer with an user-allocated one. For best results,
+ * you should generally first call evas_object_image_size_set() with
+ * the width and height for the new buffer.
+ *
+ * This call is best suited for when you will be using image data with
+ * different dimensions than the existing image data, if any. If you
+ * only need to modify the existing image in some fashion, then using
+ * evas_object_image_data_get() is probably what you are after.
+ *
+ * Note that the caller is responsible for freeing the buffer when
+ * finished with it, as user-set image data will not be automatically
+ * freed when the image object is deleted.
+ *
+ * See @ref evas_object_image_data_get() for more details.
+ *
+ * @param[in] data The raw data to replace.
+ */
+EAPI void evas_object_image_data_copy_set(Evas_Image *obj, void *data);
+
+/**
+ *
+ * Set the frame to current frame of an image object
+ *
+ * This set image object's current frame to frame_num with 1 being the first
+ * frame.
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ * @param[in] frame_index The index of current frame
+ */
+EAPI void evas_object_image_animated_frame_set(Evas_Image *obj, int frame_index);
+
+/**
+ *
+ * Get the support state of a given image
+ *
+ * @return The region support state
+ * @since 1.2
+ *
+ * This function returns the state of the region support of given image
+ *
+ */
+EAPI Eina_Bool evas_object_image_region_support_get(const Evas_Image *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Retrieves a number representing any error that occurred during the
+ * last loading of the given image object's source image.
+ *
+ * @return A value giving the last error that occurred. It should be
+ * one of the #Evas_Load_Error values. #EVAS_LOAD_ERROR_NONE
+ * is returned if there was no error.
+ *
+ */
+EAPI Evas_Load_Error evas_object_image_load_error_get(const Evas_Image *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the total number of frames of the image object.
+ *
+ * @return The number of frames
+ *
+ * This returns total number of frames the image object supports (if animated)
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ */
+EAPI int evas_object_image_animated_frame_count_get(const Evas_Image *obj);
+
+/**
+ *
+ * Retrieves the row stride of the given image object.
+ *
+ * @return The stride of the image (<b>in bytes</b>).
+ *
+ * The row stride is the number of bytes between the start of a row
+ * and the start of the next row for image data.
+ *
+ */
+EAPI int evas_object_image_stride_get(const Evas_Image *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the kind of looping the image object does.
+ *
+ * @return Loop type of the image object
+ *
+ * This returns the kind of looping the image object wants to do.
+ *
+ * If it returns EVAS_IMAGE_ANIMATED_HINT_LOOP, you should display frames in a sequence like:
+ * 1->2->3->1->2->3->1...
+ * If it returns EVAS_IMAGE_ANIMATED_HINT_PINGPONG, it is better to
+ * display frames in a sequence like: 1->2->3->2->1->2->3->1...
+ *
+ * The default type is EVAS_IMAGE_ANIMATED_HINT_LOOP.
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ */
+EAPI Evas_Image_Animated_Loop_Hint evas_object_image_animated_loop_type_get(const Evas_Image *obj);
+
+/**
+ *
+ * Get the number times the animation of the object loops.
+ *
+ * @return The number of loop of an animated image object
+ *
+ * This returns loop count of image. The loop count is the number of times
+ * the animation will play fully from first to last frame until the animation
+ * should stop (at the final frame).
+ *
+ * If 0 is returned, then looping should happen indefinitely (no limit to
+ * the number of times it loops).
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ *
+ */
+EAPI int evas_object_image_animated_loop_count_get(const Evas_Image *obj);
+
+/**
+ *
+ * Mark a sub-region of the given image object to be redrawn.
+ *
+ * This function schedules a particular rectangular region of an image
+ * object to be updated (redrawn) at the next rendering cycle.
+ * 
+ *
+ * @param[in] x X-offset of the region to be updated.
+ * @param[in] y Y-offset of the region to be updated.
+ * @param[in] w Width of the region to be updated.
+ * @param[in] h Height of the region to be updated.
+ */
+EAPI void evas_object_image_data_update_add(Evas_Image *obj, int x, int y, int w, int h);
+
+/**
+ *
+ * Get the duration of a sequence of frames.
+ *
+ * This returns total duration that the specified sequence of frames should
+ * take in seconds.
+ *
+ * If you set start_frame to 1 and frame_num 0, you get frame 1's duration
+ * If you set start_frame to 1 and frame_num 1, you get frame 1's duration +
+ * frame2's duration
+ *
+ * @see evas_object_image_animated_get()
+ * @see evas_object_image_animated_frame_count_get()
+ * @see evas_object_image_animated_loop_type_get()
+ * @see evas_object_image_animated_loop_count_get()
+ * @see evas_object_image_animated_frame_duration_get()
+ * @see evas_object_image_animated_frame_set()
+ * @since 1.1
+ * 
+ *
+ * @param[in] start_frame The first frame
+ * @param[in] frame_num Number of frames in the sequence
+ */
+EAPI double evas_object_image_animated_frame_duration_get(const Evas_Image *obj, int start_frame, int frame_num);
+
+/**
+ *
+ * Sets the raw image data of the given image object.
+ *
+ * Note that the raw data must be of the same size (see
+ * evas_object_image_size_set(), which has to be called @b before this
+ * one) and colorspace (see evas_object_image_colorspace_set()) of the
+ * image. If data is @c NULL, the current image data will be
+ * freed. Naturally, if one does not set an image object's data
+ * manually, it will still have one, allocated by Evas.
+ *
+ * @see evas_object_image_data_get()
+ * 
+ *
+ * @param[in] data The raw data, or @c NULL.
+ */
+EAPI void evas_object_image_data_set(Evas_Image *obj, void *data);
+
+/**
+ *
+ * Get a pointer to the raw image data of the given image object.
+ *
+ * @return The raw image data.
+ *
+ * This function returns a pointer to an image object's internal pixel
+ * buffer, for reading only or read/write. If you request it for
+ * writing, the image will be marked dirty so that it gets redrawn at
+ * the next update.
+ *
+ * Each time you call this function on an image object, its data
+ * buffer will have an internal reference counter
+ * incremented. Decrement it back by using
+ * evas_object_image_data_set().
+ *
+ * This is best suited for when you want to modify an existing image,
+ * without changing its dimensions.
+ *
+ * @note The contents' format returned by it depend on the color
+ * space of the given image object.
+ *
+ * @note You may want to use evas_object_image_data_update_add() to
+ * inform data changes, if you did any.
+ *
+ * @see evas_object_image_data_set()
+ * 
+ *
+ * @param[in] for_writing Whether the data being retrieved will be
+modified (@c EINA_TRUE) or not (@c EINA_FALSE).
+ */
+EAPI void *evas_object_image_data_get(const Evas_Image *obj, Eina_Bool for_writing) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Converts the raw image data of the given image object to the
+ * specified colorspace.
+ *
+ * Note that this function does not modify the raw image data.  If the
+ * requested colorspace is the same as the image colorspace nothing is
+ * done and @c NULL is returned. You should use
+ * evas_object_image_colorspace_get() to check the current image
+ * colorspace.
+ *
+ * See @ref evas_object_image_colorspace_get.
+ *
+ * @return data A newly allocated data in the format specified by to_cspace.
+ * 
+ *
+ * @param[in] to_cspace The colorspace to which the image raw data will be converted.
+ */
+EAPI void *evas_object_image_data_convert(Evas_Image *obj, Evas_Colorspace to_cspace) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Import pixels from given source to a given canvas image object.
+ *
+ * This function imports pixels from a given source to a given canvas image.
+ * 
+ *
+ * @param[in] pixels The pixel's source to be imported.
+ */
+EAPI Eina_Bool evas_object_image_pixels_import(Evas_Image *obj, Evas_Pixel_Import_Source *pixels) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Reload an image object's image data.
+ *
+ * This function reloads the image data bound to image object @p obj.
+ * 
+ *
+ */
+EAPI void evas_object_image_reload(Evas_Image *obj);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_line.eo.c b/src/lib/evas/canvas/evas_line.eo.c
--- a/src/lib/evas/canvas/evas_line.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_line.eo.c	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,49 @@
+
+void _evas_line_xy_set(Eo *obj, Evas_Line_Data *pd, Evas_Coord x1, Evas_Coord y1, Evas_Coord x2, Evas_Coord y2);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_line_xy_set, EO_FUNC_CALL(x1, y1, x2, y2), Evas_Coord x1, Evas_Coord y1, Evas_Coord x2, Evas_Coord y2);
+
+void _evas_line_xy_get(Eo *obj, Evas_Line_Data *pd, Evas_Coord *x1, Evas_Coord *y1, Evas_Coord *x2, Evas_Coord *y2);
+
+static void __eolian_evas_line_xy_get(Eo *obj, Evas_Line_Data *pd, Evas_Coord *x1, Evas_Coord *y1, Evas_Coord *x2, Evas_Coord *y2)
+{
+   if (x1) *x1 = 0;
+   if (y1) *y1 = 3;
+   _evas_line_xy_get(obj, pd, x1, y1, x2, y2);
+}
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_line_xy_get, EO_FUNC_CALL(x1, y1, x2, y2), Evas_Coord *x1, Evas_Coord *y1, Evas_Coord *x2, Evas_Coord *y2);
+
+void _evas_line_eo_base_constructor(Eo *obj, Evas_Line_Data *pd);
+
+
+static Eo_Op_Description _evas_line_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_line_eo_base_constructor),
+     EO_OP_FUNC(evas_obj_line_xy_set, _evas_line_xy_set, "@since 1.8"),
+     EO_OP_FUNC(evas_obj_line_xy_get, __eolian_evas_line_xy_get, "Retrieves the coordinates of the end points of the given evas line object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_line_class_desc = {
+     EO_VERSION,
+     "Evas_Line",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_line_op_desc),
+     NULL,
+     sizeof(Evas_Line_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_line_class_get, &_evas_line_class_desc, EVAS_OBJECT_CLASS, NULL);
+EAPI void
+evas_object_line_xy_set(Evas_Line *obj, Evas_Coord x1, Evas_Coord y1, Evas_Coord x2, Evas_Coord y2)
+{
+   eo_do((Evas_Line *)obj, evas_obj_line_xy_set(x1, y1, x2, y2));
+}
+
+EAPI void
+evas_object_line_xy_get(const Evas_Line *obj, Evas_Coord *x1, Evas_Coord *y1, Evas_Coord *x2, Evas_Coord *y2)
+{
+   eo_do((Evas_Line *)obj, evas_obj_line_xy_get(x1, y1, x2, y2));
+}
diff -Naur a/src/lib/evas/canvas/evas_line.eo.h b/src/lib/evas/canvas/evas_line.eo.h
--- a/src/lib/evas/canvas/evas_line.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_line.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,48 @@
+#ifndef _EVAS_LINE_EO_H_
+#define _EVAS_LINE_EO_H_
+
+#ifndef _EVAS_LINE_EO_CLASS_TYPE
+#define _EVAS_LINE_EO_CLASS_TYPE
+
+typedef Eo Evas_Line;
+
+#endif
+
+#ifndef _EVAS_LINE_EO_TYPES
+#define _EVAS_LINE_EO_TYPES
+
+
+#endif
+#define EVAS_LINE_CLASS evas_line_class_get()
+
+const Eo_Class *evas_line_class_get(void) EINA_CONST;
+
+/**
+ *
+ * @since 1.8
+ *
+ * Sets the coordinates of the end points of the given evas line object.
+ *
+ * @param[in] x1 The X coordinate of the first point.
+ * @param[in] y1 The Y coordinate of the first point.
+ * @param[in] x2 The X coordinate of the second point.
+ * @param[in] y2 The Y coordinate of the second point.
+ *
+ */
+EOAPI void  evas_obj_line_xy_set(Evas_Coord x1, Evas_Coord y1, Evas_Coord x2, Evas_Coord y2);
+
+/**
+ *
+ * Retrieves the coordinates of the end points of the given evas line object.
+ * second end point.
+ *
+ * @param[out] x1 The X coordinate of the first point.
+ * @param[out] y1 The Y coordinate of the first point.
+ * @param[out] x2 The X coordinate of the second point.
+ * @param[out] y2 The Y coordinate of the second point.
+ *
+ */
+EOAPI void  evas_obj_line_xy_get(Evas_Coord *x1, Evas_Coord *y1, Evas_Coord *x2, Evas_Coord *y2);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_line.eo.hh b/src/lib/evas/canvas/evas_line.eo.hh
--- a/src/lib/evas/canvas/evas_line.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_line.eo.hh	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,210 @@
+#ifndef EFL_GENERATED_EVAS_LINE_HH
+#define EFL_GENERATED_EVAS_LINE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_line.eo.h"
+}
+
+#include "evas_object.eo.hh"
+
+namespace evas {
+
+struct line
+      : evas::object
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit line(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit line(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   line(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : line(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   line(line const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~line() {}
+
+   /// @brief Retrieves the coordinates of the end points of the given evas line object.
+   /// second end point.
+   ///
+   /// @param x1 The X coordinate of the first point.
+   /// @param y1 The Y coordinate of the first point.
+   /// @param x2 The X coordinate of the second point.
+   /// @param y2 The Y coordinate of the second point.
+   ///
+   void xy_get(Evas_Coord* x1_, Evas_Coord* y1_, Evas_Coord* x2_, Evas_Coord* y2_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_line_xy_get(x1_, y1_, x2_, y2_));
+   }
+
+   /// @brief @since 1.8
+   ///
+   /// Sets the coordinates of the end points of the given evas line object.
+   ///
+   /// @param x1 The X coordinate of the first point.
+   /// @param y1 The Y coordinate of the first point.
+   /// @param x2 The X coordinate of the second point.
+   /// @param y2 The Y coordinate of the second point.
+   ///
+   void xy_set(Evas_Coord x1_, Evas_Coord y1_, Evas_Coord x2_, Evas_Coord y2_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_line_xy_set(x1_, y1_, x2_, y2_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_LINE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_LINE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_line_xy_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x1_, Evas_Coord* y1_, Evas_Coord* x2_, Evas_Coord* y2_)
+{
+   static_cast<T*>(self->this_)->xy_get(x1_, y1_, x2_, y2_);
+}
+
+template <typename T>
+void evas_line_xy_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x1_, Evas_Coord y1_, Evas_Coord x2_, Evas_Coord y2_)
+{
+   static_cast<T*>(self->this_)->xy_set(x1_, y1_, x2_, y2_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::line >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void xy_get(Evas_Coord* x1_, Evas_Coord* y1_, Evas_Coord* x2_, Evas_Coord* y2_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_line_xy_get(x1_, y1_, x2_, y2_));
+      }
+
+      virtual void xy_set(Evas_Coord x1_, Evas_Coord y1_, Evas_Coord x2_, Evas_Coord y2_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_line_xy_set(x1_, y1_, x2_, y2_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::line >
+{
+   static const int value = 2;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::line>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_line_xy_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_line_xy_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_line_xy_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_line_xy_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::line >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::line, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::line >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::line, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::line>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::line() const
+      {
+         return evas::line(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void xy_get(Evas_Coord* x1_, Evas_Coord* y1_, Evas_Coord* x2_, Evas_Coord* y2_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_line_xy_get(x1_, y1_, x2_, y2_));
+      }
+
+      void xy_set(Evas_Coord x1_, Evas_Coord y1_, Evas_Coord x2_, Evas_Coord y2_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_line_xy_set(x1_, y1_, x2_, y2_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::line>)
+{
+   return (EVAS_LINE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_LINE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_line.eo.legacy.h b/src/lib/evas/canvas/evas_line.eo.legacy.h
--- a/src/lib/evas/canvas/evas_line.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_line.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,42 @@
+#ifndef _EVAS_LINE_EO_LEGACY_H_
+#define _EVAS_LINE_EO_LEGACY_H_
+
+#ifndef _EVAS_LINE_EO_CLASS_TYPE
+#define _EVAS_LINE_EO_CLASS_TYPE
+
+typedef Eo Evas_Line;
+
+#endif
+
+#ifndef _EVAS_LINE_EO_TYPES
+#define _EVAS_LINE_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * @since 1.8
+ *
+ * Sets the coordinates of the end points of the given evas line object.
+ *
+ * @param[in] x1 The X coordinate of the first point.
+ * @param[in] y1 The Y coordinate of the first point.
+ * @param[in] x2 The X coordinate of the second point.
+ * @param[in] y2 The Y coordinate of the second point.
+ */
+EAPI void evas_object_line_xy_set(Evas_Line *obj, Evas_Coord x1, Evas_Coord y1, Evas_Coord x2, Evas_Coord y2);
+
+/**
+ *
+ * Retrieves the coordinates of the end points of the given evas line object.
+ * second end point.
+ *
+ * @param[out] x1 The X coordinate of the first point.
+ * @param[out] y1 The Y coordinate of the first point.
+ * @param[out] x2 The X coordinate of the second point.
+ * @param[out] y2 The Y coordinate of the second point.
+ */
+EAPI void evas_object_line_xy_get(const Evas_Line *obj, Evas_Coord *x1, Evas_Coord *y1, Evas_Coord *x2, Evas_Coord *y2);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_object.eo.c b/src/lib/evas/canvas/evas_object.eo.c
--- a/src/lib/evas/canvas/evas_object.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object.eo.c	2014-11-27 00:57:33.490380314 +0200
@@ -0,0 +1,945 @@
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_IN =
+   EO_EVENT_DESCRIPTION("mouse,in", "Mouse In Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_OUT =
+   EO_EVENT_DESCRIPTION("mouse,out", "Mouse Out Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_DOWN =
+   EO_EVENT_DESCRIPTION("mouse,down", "Mouse Button Down Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_UP =
+   EO_EVENT_DESCRIPTION("mouse,up", "Mouse Button Up Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_MOVE =
+   EO_EVENT_DESCRIPTION("mouse,move", "Mouse Move Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_WHEEL =
+   EO_EVENT_DESCRIPTION("mouse,wheel", "Mouse Wheel Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MULTI_DOWN =
+   EO_EVENT_DESCRIPTION("multi,down", "Mouse-touch Down Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MULTI_UP =
+   EO_EVENT_DESCRIPTION("multi,up", "Mouse-touch Up Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MULTI_MOVE =
+   EO_EVENT_DESCRIPTION("multi,move", "Multi-touch Move Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_FREE =
+   EO_EVENT_DESCRIPTION("free", "Object Being Freed (Called after Del)");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_KEY_DOWN =
+   EO_EVENT_DESCRIPTION("key,down", "Key Press Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_KEY_UP =
+   EO_EVENT_DESCRIPTION("key,up", "Key Release Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_FOCUS_IN =
+   EO_EVENT_DESCRIPTION("focus,in", "Focus In Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_FOCUS_OUT =
+   EO_EVENT_DESCRIPTION("focus,out", "Focus Out Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_SHOW =
+   EO_EVENT_DESCRIPTION("show", "Show Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_HIDE =
+   EO_EVENT_DESCRIPTION("hide", "Hide Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_MOVE =
+   EO_EVENT_DESCRIPTION("move", "Move Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_RESIZE =
+   EO_EVENT_DESCRIPTION("resize", "Resize Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_RESTACK =
+   EO_EVENT_DESCRIPTION("restack", "Restack Event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_DEL =
+   EO_EVENT_DESCRIPTION("del", "Object Being Deleted (called before Free)");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_HOLD =
+   EO_EVENT_DESCRIPTION("hold", "Events go on/off hold");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS =
+   EO_EVENT_DESCRIPTION("changed,size,hints", "Size hints changed event");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_IMAGE_PRELOADED =
+   EO_EVENT_DESCRIPTION("image,preloaded", "Image has been preloaded");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_IMAGE_RESIZE =
+   EO_EVENT_DESCRIPTION("image,resize", "Image resize");
+EOAPI const Eo_Event_Description _EVAS_OBJECT_EVENT_IMAGE_UNLOADED =
+   EO_EVENT_DESCRIPTION("image,unloaded", "Image data has been unloaded (by some mechanism in Evas that throw out original image data)");
+
+void _evas_object_size_hint_max_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_max_set, EO_FUNC_CALL(w, h), Evas_Coord w, Evas_Coord h);
+
+void _evas_object_size_hint_max_get(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_max_get, EO_FUNC_CALL(w, h), Evas_Coord *w, Evas_Coord *h);
+
+void _evas_object_size_hint_request_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_request_set, EO_FUNC_CALL(w, h), Evas_Coord w, Evas_Coord h);
+
+void _evas_object_size_hint_request_get(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_request_get, EO_FUNC_CALL(w, h), Evas_Coord *w, Evas_Coord *h);
+
+void _evas_object_visibility_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool v);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_visibility_set, EO_FUNC_CALL(v), Eina_Bool v);
+
+Eina_Bool _evas_object_visibility_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_visibility_get, Eina_Bool, 0);
+
+void _evas_object_type_set(Eo *obj, Evas_Object_Protected_Data *pd, const char *type);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_type_set, EO_FUNC_CALL(type), const char *type);
+
+const char * _evas_object_type_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_type_get, const char *, 0);
+
+void _evas_object_size_hint_min_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_min_set, EO_FUNC_CALL(w, h), Evas_Coord w, Evas_Coord h);
+
+void _evas_object_size_hint_min_get(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_min_get, EO_FUNC_CALL(w, h), Evas_Coord *w, Evas_Coord *h);
+
+void _evas_object_pointer_mode_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Object_Pointer_Mode pointer_mode);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_pointer_mode_set, EO_FUNC_CALL(pointer_mode), Evas_Object_Pointer_Mode pointer_mode);
+
+Evas_Object_Pointer_Mode _evas_object_pointer_mode_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_pointer_mode_get, Evas_Object_Pointer_Mode, 0);
+
+void _evas_object_render_op_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Render_Op render_op);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_render_op_set, EO_FUNC_CALL(render_op), Evas_Render_Op render_op);
+
+Evas_Render_Op _evas_object_render_op_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_render_op_get, Evas_Render_Op, 0);
+
+void _evas_object_freeze_events_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool freeze);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_freeze_events_set, EO_FUNC_CALL(freeze), Eina_Bool freeze);
+
+Eina_Bool _evas_object_freeze_events_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_freeze_events_get, Eina_Bool, 0);
+
+void _evas_object_map_set(Eo *obj, Evas_Object_Protected_Data *pd, const Evas_Map *map);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_map_set, EO_FUNC_CALL(map), const Evas_Map *map);
+
+const Evas_Map * _evas_object_map_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_map_get, const Evas_Map *, 0);
+
+void _evas_object_size_hint_aspect_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Aspect_Control aspect, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_aspect_set, EO_FUNC_CALL(aspect, w, h), Evas_Aspect_Control aspect, Evas_Coord w, Evas_Coord h);
+
+void _evas_object_size_hint_aspect_get(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Aspect_Control *aspect, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_aspect_get, EO_FUNC_CALL(aspect, w, h), Evas_Aspect_Control *aspect, Evas_Coord *w, Evas_Coord *h);
+
+void _evas_object_layer_set(Eo *obj, Evas_Object_Protected_Data *pd, short l);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_layer_set, EO_FUNC_CALL(l), short l);
+
+short _evas_object_layer_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_layer_get, short, 0);
+
+void _evas_object_clip_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Object *clip);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_clip_set, EO_FUNC_CALL(clip), Evas_Object *clip);
+
+Evas_Object * _evas_object_clip_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_clip_get, Evas_Object *, 0);
+
+void _evas_object_size_hint_padding_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord l, Evas_Coord r, Evas_Coord t, Evas_Coord b);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_padding_set, EO_FUNC_CALL(l, r, t, b), Evas_Coord l, Evas_Coord r, Evas_Coord t, Evas_Coord b);
+
+void _evas_object_size_hint_padding_get(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_padding_get, EO_FUNC_CALL(l, r, t, b), Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+void _evas_object_repeat_events_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool repeat);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_repeat_events_set, EO_FUNC_CALL(repeat), Eina_Bool repeat);
+
+Eina_Bool _evas_object_repeat_events_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_repeat_events_get, Eina_Bool, 0);
+
+void _evas_object_size_hint_weight_set(Eo *obj, Evas_Object_Protected_Data *pd, double x, double y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_weight_set, EO_FUNC_CALL(x, y), double x, double y);
+
+void _evas_object_size_hint_weight_get(Eo *obj, Evas_Object_Protected_Data *pd, double *x, double *y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_weight_get, EO_FUNC_CALL(x, y), double *x, double *y);
+
+void _evas_object_name_set(Eo *obj, Evas_Object_Protected_Data *pd, const char *name);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_name_set, EO_FUNC_CALL(name), const char *name);
+
+const char * _evas_object_name_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_name_get, const char *, 0);
+
+void _evas_object_scale_set(Eo *obj, Evas_Object_Protected_Data *pd, double scale);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_scale_set, EO_FUNC_CALL(scale), double scale);
+
+double _evas_object_scale_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_scale_get, double, 0);
+
+void _evas_object_static_clip_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool is_static_clip);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_static_clip_set, EO_FUNC_CALL(is_static_clip), Eina_Bool is_static_clip);
+
+Eina_Bool _evas_object_static_clip_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_static_clip_get, Eina_Bool, 0);
+
+void _evas_object_size_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_set, EO_FUNC_CALL(w, h), Evas_Coord w, Evas_Coord h);
+
+void _evas_object_size_get(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_get, EO_FUNC_CALL(w, h), Evas_Coord *w, Evas_Coord *h);
+
+void _evas_object_focus_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool focus);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_focus_set, EO_FUNC_CALL(focus), Eina_Bool focus);
+
+Eina_Bool _evas_object_focus_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_focus_get, Eina_Bool, 0);
+
+void _evas_object_is_frame_object_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool is_frame);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_is_frame_object_set, EO_FUNC_CALL(is_frame), Eina_Bool is_frame);
+
+Eina_Bool _evas_object_is_frame_object_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_is_frame_object_get, Eina_Bool, 0);
+
+void _evas_object_map_enable_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool enabled);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_map_enable_set, EO_FUNC_CALL(enabled), Eina_Bool enabled);
+
+Eina_Bool _evas_object_map_enable_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_map_enable_get, Eina_Bool, 0);
+
+void _evas_object_precise_is_inside_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool precise);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_precise_is_inside_set, EO_FUNC_CALL(precise), Eina_Bool precise);
+
+Eina_Bool _evas_object_precise_is_inside_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_precise_is_inside_get, Eina_Bool, 0);
+
+void _evas_object_size_hint_align_set(Eo *obj, Evas_Object_Protected_Data *pd, double x, double y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_align_set, EO_FUNC_CALL(x, y), double x, double y);
+
+void _evas_object_size_hint_align_get(Eo *obj, Evas_Object_Protected_Data *pd, double *x, double *y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_align_get, EO_FUNC_CALL(x, y), double *x, double *y);
+
+void _evas_object_propagate_events_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool propagate);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_propagate_events_set, EO_FUNC_CALL(propagate), Eina_Bool propagate);
+
+Eina_Bool _evas_object_propagate_events_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_propagate_events_get, Eina_Bool, 0);
+
+void _evas_object_pass_events_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool pass);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_pass_events_set, EO_FUNC_CALL(pass), Eina_Bool pass);
+
+Eina_Bool _evas_object_pass_events_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_pass_events_get, Eina_Bool, 0);
+
+void _evas_object_position_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord x, Evas_Coord y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_position_set, EO_FUNC_CALL(x, y), Evas_Coord x, Evas_Coord y);
+
+void _evas_object_position_get(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord *x, Evas_Coord *y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_position_get, EO_FUNC_CALL(x, y), Evas_Coord *x, Evas_Coord *y);
+
+void _evas_object_anti_alias_set(Eo *obj, Evas_Object_Protected_Data *pd, Eina_Bool anti_alias);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_anti_alias_set, EO_FUNC_CALL(anti_alias), Eina_Bool anti_alias);
+
+Eina_Bool _evas_object_anti_alias_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_anti_alias_get, Eina_Bool, 0);
+
+void _evas_object_color_set(Eo *obj, Evas_Object_Protected_Data *pd, int r, int g, int b, int a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_color_set, EO_FUNC_CALL(r, g, b, a), int r, int g, int b, int a);
+
+void _evas_object_color_get(Eo *obj, Evas_Object_Protected_Data *pd, int *r, int *g, int *b, int *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_color_get, EO_FUNC_CALL(r, g, b, a), int *r, int *g, int *b, int *a);
+
+void * _evas_object_smart_data_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_smart_data_get, void *, 0);
+
+Evas_Object * _evas_object_smart_clipped_clipper_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_smart_clipped_clipper_get, Evas_Object *, 0);
+
+Evas_Object * _evas_object_below_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_below_get, Evas_Object *, 0);
+
+const Eina_List * _evas_object_clipees_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_clipees_get, const Eina_List *, 0);
+
+Evas_Object * _evas_object_smart_parent_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_smart_parent_get, Evas_Object *, 0);
+
+Evas_Object * _evas_object_above_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_above_get, Evas_Object *, 0);
+
+void _evas_object_size_hint_display_mode_set(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Display_Mode dispmode);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_size_hint_display_mode_set, EO_FUNC_CALL(dispmode), Evas_Display_Mode dispmode);
+
+Evas_Display_Mode _evas_object_size_hint_display_mode_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_size_hint_display_mode_get, Evas_Display_Mode, 0);
+
+Eina_Bool _evas_object_clipees_has(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_clipees_has, Eina_Bool, 0);
+
+Eina_Bool _evas_object_key_grab(Eo *obj, Evas_Object_Protected_Data *pd, const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers, Eina_Bool exclusive);
+
+EOAPI EO_FUNC_BODYV(evas_obj_key_grab, Eina_Bool, 0, EO_FUNC_CALL(keyname, modifiers, not_modifiers, exclusive), const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers, Eina_Bool exclusive);
+
+void _evas_object_stack_below(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Object *below);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_stack_below, EO_FUNC_CALL(below), Evas_Object *below);
+
+void _evas_object_raise(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_raise);
+
+void _evas_object_stack_above(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Object *above);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_stack_above, EO_FUNC_CALL(above), Evas_Object *above);
+
+Eina_Bool _evas_object_smart_type_check(Eo *obj, Evas_Object_Protected_Data *pd, const char *type);
+
+EOAPI EO_FUNC_BODYV(evas_obj_smart_type_check, Eina_Bool, 0, EO_FUNC_CALL(type), const char *type);
+
+Evas_Object * _evas_object_name_child_find(Eo *obj, Evas_Object_Protected_Data *pd, const char *name, int recurse);
+
+EOAPI EO_FUNC_BODYV(evas_obj_name_child_find, Evas_Object *, 0, EO_FUNC_CALL(name, recurse), const char *name, int recurse);
+
+void _evas_object_key_ungrab(Eo *obj, Evas_Object_Protected_Data *pd, const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_key_ungrab, EO_FUNC_CALL(keyname, modifiers, not_modifiers), const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers);
+
+void _evas_object_lower(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_lower);
+
+void _evas_object_clip_unset(Eo *obj, Evas_Object_Protected_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_clip_unset);
+
+void _evas_object_smart_move_children_relative(Eo *obj, Evas_Object_Protected_Data *pd, Evas_Coord dx, Evas_Coord dy);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_move_children_relative, EO_FUNC_CALL(dx, dy), Evas_Coord dx, Evas_Coord dy);
+
+Eina_Bool _evas_object_smart_type_check_ptr(Eo *obj, Evas_Object_Protected_Data *pd, const char *type);
+
+EOAPI EO_FUNC_BODYV(evas_obj_smart_type_check_ptr, Eina_Bool, 0, EO_FUNC_CALL(type), const char *type);
+
+void _evas_object_eo_base_constructor(Eo *obj, Evas_Object_Protected_Data *pd);
+
+
+void _evas_object_eo_base_destructor(Eo *obj, Evas_Object_Protected_Data *pd);
+
+
+void _evas_object_eo_base_dbg_info_get(Eo *obj, Evas_Object_Protected_Data *pd, Eo_Dbg_Info *root_node);
+
+
+Evas * _evas_object_evas_common_interface_evas_get(Eo *obj, Evas_Object_Protected_Data *pd);
+
+
+static Eo_Op_Description _evas_object_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_object_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_object_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_dbg_info_get, _evas_object_eo_base_dbg_info_get),
+     EO_OP_FUNC_OVERRIDE(evas_common_evas_get, _evas_object_evas_common_interface_evas_get),
+     EO_OP_FUNC(evas_obj_size_hint_max_set, _evas_object_size_hint_max_set, "Sets the hints for an object's maximum size."),
+     EO_OP_FUNC(evas_obj_size_hint_max_get, _evas_object_size_hint_max_get, "Retrieves the hints for an object's maximum size."),
+     EO_OP_FUNC(evas_obj_size_hint_request_set, _evas_object_size_hint_request_set, "Sets the hints for an object's optimum size."),
+     EO_OP_FUNC(evas_obj_size_hint_request_get, _evas_object_size_hint_request_get, "Retrieves the hints for an object's optimum size."),
+     EO_OP_FUNC(evas_obj_visibility_set, _evas_object_visibility_set, "Makes the given Evas object visible or invisible."),
+     EO_OP_FUNC(evas_obj_visibility_get, _evas_object_visibility_get, "Retrieves whether or not the given Evas object is visible."),
+     EO_OP_FUNC(evas_obj_type_set, _evas_object_type_set, "Sets the type of the given Evas object."),
+     EO_OP_FUNC(evas_obj_type_get, _evas_object_type_get, "Retrieves the type of the given Evas object."),
+     EO_OP_FUNC(evas_obj_size_hint_min_set, _evas_object_size_hint_min_set, "Sets the hints for an object's minimum size."),
+     EO_OP_FUNC(evas_obj_size_hint_min_get, _evas_object_size_hint_min_get, "Retrieves the hints for an object's minimum size."),
+     EO_OP_FUNC(evas_obj_pointer_mode_set, _evas_object_pointer_mode_set, "Set pointer behavior."),
+     EO_OP_FUNC(evas_obj_pointer_mode_get, _evas_object_pointer_mode_get, "Determine how pointer will behave."),
+     EO_OP_FUNC(evas_obj_render_op_set, _evas_object_render_op_set, "Sets the render_op to be used for rendering the Evas object."),
+     EO_OP_FUNC(evas_obj_render_op_get, _evas_object_render_op_get, "Retrieves the current value of the operation used for rendering the Evas object."),
+     EO_OP_FUNC(evas_obj_freeze_events_set, _evas_object_freeze_events_set, "Set whether an Evas object is to freeze (discard) events."),
+     EO_OP_FUNC(evas_obj_freeze_events_get, _evas_object_freeze_events_get, "Determine whether an object is set to freeze (discard) events."),
+     EO_OP_FUNC(evas_obj_map_set, _evas_object_map_set, "Set current object transformation map."),
+     EO_OP_FUNC(evas_obj_map_get, _evas_object_map_get, "Get current object transformation map."),
+     EO_OP_FUNC(evas_obj_size_hint_aspect_set, _evas_object_size_hint_aspect_set, "Sets the hints for an object's aspect ratio."),
+     EO_OP_FUNC(evas_obj_size_hint_aspect_get, _evas_object_size_hint_aspect_get, "Retrieves the hints for an object's aspect ratio."),
+     EO_OP_FUNC(evas_obj_layer_set, _evas_object_layer_set, "Sets the layer of its canvas that the given object will be part of."),
+     EO_OP_FUNC(evas_obj_layer_get, _evas_object_layer_get, "Retrieves the layer of its canvas that the given object is part of."),
+     EO_OP_FUNC(evas_obj_clip_set, _evas_object_clip_set, "Clip one object to another."),
+     EO_OP_FUNC(evas_obj_clip_get, _evas_object_clip_get, "Get the object clipping @p obj (if any)."),
+     EO_OP_FUNC(evas_obj_size_hint_padding_set, _evas_object_size_hint_padding_set, "Sets the hints for an object's padding space."),
+     EO_OP_FUNC(evas_obj_size_hint_padding_get, _evas_object_size_hint_padding_get, "Retrieves the hints for an object's padding space."),
+     EO_OP_FUNC(evas_obj_repeat_events_set, _evas_object_repeat_events_set, "Set whether an Evas object is to repeat events."),
+     EO_OP_FUNC(evas_obj_repeat_events_get, _evas_object_repeat_events_get, "Determine whether an object is set to repeat events."),
+     EO_OP_FUNC(evas_obj_size_hint_weight_set, _evas_object_size_hint_weight_set, "Sets the hints for an object's weight."),
+     EO_OP_FUNC(evas_obj_size_hint_weight_get, _evas_object_size_hint_weight_get, "Retrieves the hints for an object's weight."),
+     EO_OP_FUNC(evas_obj_name_set, _evas_object_name_set, "Sets the name of the given Evas object to the given name."),
+     EO_OP_FUNC(evas_obj_name_get, _evas_object_name_get, "Retrieves the name of the given Evas object."),
+     EO_OP_FUNC(evas_obj_scale_set, _evas_object_scale_set, "Sets the scaling factor for an Evas object. Does not affect all"),
+     EO_OP_FUNC(evas_obj_scale_get, _evas_object_scale_get, "Retrieves the scaling factor for the given Evas object."),
+     EO_OP_FUNC(evas_obj_static_clip_set, _evas_object_static_clip_set, "Set a hint flag on the given Evas object that it's used as a \"static"),
+     EO_OP_FUNC(evas_obj_static_clip_get, _evas_object_static_clip_get, "Get the \"static clipper\" hint flag for a given Evas object."),
+     EO_OP_FUNC(evas_obj_size_set, _evas_object_size_set, "Changes the size of the given Evas object."),
+     EO_OP_FUNC(evas_obj_size_get, _evas_object_size_get, "Retrieves the (rectangular) size of the given Evas object."),
+     EO_OP_FUNC(evas_obj_focus_set, _evas_object_focus_set, "Sets or unsets a given object as the currently focused one on its"),
+     EO_OP_FUNC(evas_obj_focus_get, _evas_object_focus_get, "Retrieve whether an object has the focus."),
+     EO_OP_FUNC(evas_obj_is_frame_object_set, _evas_object_is_frame_object_set, "@since 1.2"),
+     EO_OP_FUNC(evas_obj_is_frame_object_get, _evas_object_is_frame_object_get, "@since 1.2"),
+     EO_OP_FUNC(evas_obj_map_enable_set, _evas_object_map_enable_set, "Enable or disable the map that is set."),
+     EO_OP_FUNC(evas_obj_map_enable_get, _evas_object_map_enable_get, "Get the map enabled state"),
+     EO_OP_FUNC(evas_obj_precise_is_inside_set, _evas_object_precise_is_inside_set, "Set whether to use precise (usually expensive) point collision"),
+     EO_OP_FUNC(evas_obj_precise_is_inside_get, _evas_object_precise_is_inside_get, "Determine whether an object is set to use precise point collision"),
+     EO_OP_FUNC(evas_obj_size_hint_align_set, _evas_object_size_hint_align_set, "Sets the hints for an object's alignment."),
+     EO_OP_FUNC(evas_obj_size_hint_align_get, _evas_object_size_hint_align_get, "Retrieves the hints for on object's alignment."),
+     EO_OP_FUNC(evas_obj_propagate_events_set, _evas_object_propagate_events_set, "Set whether events on a smart object's member should get propagated"),
+     EO_OP_FUNC(evas_obj_propagate_events_get, _evas_object_propagate_events_get, "Retrieve whether an Evas object is set to propagate events."),
+     EO_OP_FUNC(evas_obj_pass_events_set, _evas_object_pass_events_set, "Set whether an Evas object is to pass (ignore) events."),
+     EO_OP_FUNC(evas_obj_pass_events_get, _evas_object_pass_events_get, "Determine whether an object is set to pass (ignore) events."),
+     EO_OP_FUNC(evas_obj_position_set, _evas_object_position_set, "Move the given Evas object to the given location inside its canvas' viewport."),
+     EO_OP_FUNC(evas_obj_position_get, _evas_object_position_get, "Retrieves the position of the given Evas object."),
+     EO_OP_FUNC(evas_obj_anti_alias_set, _evas_object_anti_alias_set, "Sets whether or not the given Evas object is to be drawn anti-aliased."),
+     EO_OP_FUNC(evas_obj_anti_alias_get, _evas_object_anti_alias_get, "Retrieves whether or not the given Evas object is to be drawn anti_aliased."),
+     EO_OP_FUNC(evas_obj_color_set, _evas_object_color_set, "Sets the general/main color of the given Evas object to the given"),
+     EO_OP_FUNC(evas_obj_color_get, _evas_object_color_get, "Retrieves the general/main color of the given Evas object."),
+     EO_OP_FUNC(evas_obj_smart_data_get, _evas_object_smart_data_get, "Retrieve user data stored on a given smart object."),
+     EO_OP_FUNC(evas_obj_smart_clipped_clipper_get, _evas_object_smart_clipped_clipper_get, "Get the clipper object for the given clipped smart object."),
+     EO_OP_FUNC(evas_obj_below_get, _evas_object_below_get, "Get the Evas object stacked right below @p obj"),
+     EO_OP_FUNC(evas_obj_clipees_get, _evas_object_clipees_get, "Return a list of objects currently clipped by @p obj."),
+     EO_OP_FUNC(evas_obj_smart_parent_get, _evas_object_smart_parent_get, "Gets the parent smart object of a given Evas object, if it has one."),
+     EO_OP_FUNC(evas_obj_above_get, _evas_object_above_get, "Get the Evas object stacked right above @p obj"),
+     EO_OP_FUNC(evas_obj_size_hint_display_mode_set, _evas_object_size_hint_display_mode_set, "Sets the hints for an object's disply mode"),
+     EO_OP_FUNC(evas_obj_size_hint_display_mode_get, _evas_object_size_hint_display_mode_get, "Retrieves the hints for an object's display mode"),
+     EO_OP_FUNC(evas_obj_clipees_has, _evas_object_clipees_has, "Test if any object is clipped by @p obj."),
+     EO_OP_FUNC(evas_obj_key_grab, _evas_object_key_grab, "Requests @p keyname key events be directed to @p obj."),
+     EO_OP_FUNC(evas_obj_stack_below, _evas_object_stack_below, "Stack @p obj immediately below @p below"),
+     EO_OP_FUNC(evas_obj_raise, _evas_object_raise, "Raise @p obj to the top of its layer."),
+     EO_OP_FUNC(evas_obj_stack_above, _evas_object_stack_above, "Stack @p obj immediately above @p above"),
+     EO_OP_FUNC(evas_obj_smart_type_check, _evas_object_smart_type_check, "Checks whether a given smart object or any of its smart object"),
+     EO_OP_FUNC(evas_obj_name_child_find, _evas_object_name_child_find, "Retrieves the object from children of the given object with the given name."),
+     EO_OP_FUNC(evas_obj_key_ungrab, _evas_object_key_ungrab, "Removes the grab on @p keyname key events by @p obj."),
+     EO_OP_FUNC(evas_obj_lower, _evas_object_lower, "Lower @p obj to the bottom of its layer."),
+     EO_OP_FUNC(evas_obj_clip_unset, _evas_object_clip_unset, "Disable/cease clipping on a clipped @p obj object."),
+     EO_OP_FUNC(evas_obj_smart_move_children_relative, _evas_object_smart_move_children_relative, "Moves all children objects of a given smart object relative to a"),
+     EO_OP_FUNC(evas_obj_smart_type_check_ptr, _evas_object_smart_type_check_ptr, "Checks whether a given smart object or any of its smart object"),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Event_Description *_evas_object_event_desc[] = {
+     EVAS_OBJECT_EVENT_MOUSE_IN,
+     EVAS_OBJECT_EVENT_MOUSE_OUT,
+     EVAS_OBJECT_EVENT_MOUSE_DOWN,
+     EVAS_OBJECT_EVENT_MOUSE_UP,
+     EVAS_OBJECT_EVENT_MOUSE_MOVE,
+     EVAS_OBJECT_EVENT_MOUSE_WHEEL,
+     EVAS_OBJECT_EVENT_MULTI_DOWN,
+     EVAS_OBJECT_EVENT_MULTI_UP,
+     EVAS_OBJECT_EVENT_MULTI_MOVE,
+     EVAS_OBJECT_EVENT_FREE,
+     EVAS_OBJECT_EVENT_KEY_DOWN,
+     EVAS_OBJECT_EVENT_KEY_UP,
+     EVAS_OBJECT_EVENT_FOCUS_IN,
+     EVAS_OBJECT_EVENT_FOCUS_OUT,
+     EVAS_OBJECT_EVENT_SHOW,
+     EVAS_OBJECT_EVENT_HIDE,
+     EVAS_OBJECT_EVENT_MOVE,
+     EVAS_OBJECT_EVENT_RESIZE,
+     EVAS_OBJECT_EVENT_RESTACK,
+     EVAS_OBJECT_EVENT_DEL,
+     EVAS_OBJECT_EVENT_HOLD,
+     EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS,
+     EVAS_OBJECT_EVENT_IMAGE_PRELOADED,
+     EVAS_OBJECT_EVENT_IMAGE_RESIZE,
+     EVAS_OBJECT_EVENT_IMAGE_UNLOADED,
+     NULL
+};
+
+static const Eo_Class_Description _evas_object_class_desc = {
+     EO_VERSION,
+     "Evas_Object",
+     EO_CLASS_TYPE_REGULAR_NO_INSTANT,
+     EO_CLASS_DESCRIPTION_OPS(_evas_object_op_desc),
+     _evas_object_event_desc,
+     sizeof(Evas_Object_Protected_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_object_class_get, &_evas_object_class_desc, EO_BASE_CLASS, EVAS_COMMON_INTERFACE_INTERFACE, NULL);
+EAPI void
+evas_object_size_hint_max_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_max_set(w, h));
+}
+
+EAPI void
+evas_object_size_hint_max_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_max_get(w, h));
+}
+
+EAPI void
+evas_object_size_hint_request_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_request_set(w, h));
+}
+
+EAPI void
+evas_object_size_hint_request_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_request_get(w, h));
+}
+
+EAPI Eina_Bool
+evas_object_visible_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_visibility_get());
+}
+
+EAPI const char *
+evas_object_type_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_type_get());
+}
+
+EAPI void
+evas_object_size_hint_min_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_min_set(w, h));
+}
+
+EAPI void
+evas_object_size_hint_min_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_min_get(w, h));
+}
+
+EAPI void
+evas_object_pointer_mode_set(Evas_Object *obj, Evas_Object_Pointer_Mode pointer_mode)
+{
+   eo_do((Evas_Object *)obj, evas_obj_pointer_mode_set(pointer_mode));
+}
+
+EAPI Evas_Object_Pointer_Mode
+evas_object_pointer_mode_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_pointer_mode_get());
+}
+
+EAPI void
+evas_object_render_op_set(Evas_Object *obj, Evas_Render_Op render_op)
+{
+   eo_do((Evas_Object *)obj, evas_obj_render_op_set(render_op));
+}
+
+EAPI Evas_Render_Op
+evas_object_render_op_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_render_op_get());
+}
+
+EAPI void
+evas_object_freeze_events_set(Evas_Object *obj, Eina_Bool freeze)
+{
+   eo_do((Evas_Object *)obj, evas_obj_freeze_events_set(freeze));
+}
+
+EAPI Eina_Bool
+evas_object_freeze_events_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_freeze_events_get());
+}
+
+EAPI void
+evas_object_map_set(Evas_Object *obj, const Evas_Map *map)
+{
+   eo_do((Evas_Object *)obj, evas_obj_map_set(map));
+}
+
+EAPI const Evas_Map *
+evas_object_map_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_map_get());
+}
+
+EAPI void
+evas_object_size_hint_aspect_set(Evas_Object *obj, Evas_Aspect_Control aspect, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_aspect_set(aspect, w, h));
+}
+
+EAPI void
+evas_object_size_hint_aspect_get(const Evas_Object *obj, Evas_Aspect_Control *aspect, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_aspect_get(aspect, w, h));
+}
+
+EAPI void
+evas_object_layer_set(Evas_Object *obj, short l)
+{
+   eo_do((Evas_Object *)obj, evas_obj_layer_set(l));
+}
+
+EAPI short
+evas_object_layer_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_layer_get());
+}
+
+EAPI void
+evas_object_clip_set(Evas_Object *obj, Evas_Object *clip)
+{
+   eo_do((Evas_Object *)obj, evas_obj_clip_set(clip));
+}
+
+EAPI Evas_Object *
+evas_object_clip_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_clip_get());
+}
+
+EAPI void
+evas_object_size_hint_padding_set(Evas_Object *obj, Evas_Coord l, Evas_Coord r, Evas_Coord t, Evas_Coord b)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_padding_set(l, r, t, b));
+}
+
+EAPI void
+evas_object_size_hint_padding_get(const Evas_Object *obj, Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_padding_get(l, r, t, b));
+}
+
+EAPI void
+evas_object_repeat_events_set(Evas_Object *obj, Eina_Bool repeat)
+{
+   eo_do((Evas_Object *)obj, evas_obj_repeat_events_set(repeat));
+}
+
+EAPI Eina_Bool
+evas_object_repeat_events_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_repeat_events_get());
+}
+
+EAPI void
+evas_object_size_hint_weight_set(Evas_Object *obj, double x, double y)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_weight_set(x, y));
+}
+
+EAPI void
+evas_object_size_hint_weight_get(const Evas_Object *obj, double *x, double *y)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_weight_get(x, y));
+}
+
+EAPI void
+evas_object_name_set(Evas_Object *obj, const char *name)
+{
+   eo_do((Evas_Object *)obj, evas_obj_name_set(name));
+}
+
+EAPI const char *
+evas_object_name_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_name_get());
+}
+
+EAPI void
+evas_object_scale_set(Evas_Object *obj, double scale)
+{
+   eo_do((Evas_Object *)obj, evas_obj_scale_set(scale));
+}
+
+EAPI double
+evas_object_scale_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_scale_get());
+}
+
+EAPI void
+evas_object_static_clip_set(Evas_Object *obj, Eina_Bool is_static_clip)
+{
+   eo_do((Evas_Object *)obj, evas_obj_static_clip_set(is_static_clip));
+}
+
+EAPI Eina_Bool
+evas_object_static_clip_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_static_clip_get());
+}
+
+EAPI void
+evas_object_resize(Evas_Object *obj, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_set(w, h));
+}
+
+EAPI void
+evas_object_focus_set(Evas_Object *obj, Eina_Bool focus)
+{
+   eo_do((Evas_Object *)obj, evas_obj_focus_set(focus));
+}
+
+EAPI Eina_Bool
+evas_object_focus_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_focus_get());
+}
+
+EAPI void
+evas_object_is_frame_object_set(Evas_Object *obj, Eina_Bool is_frame)
+{
+   eo_do((Evas_Object *)obj, evas_obj_is_frame_object_set(is_frame));
+}
+
+EAPI Eina_Bool
+evas_object_is_frame_object_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_is_frame_object_get());
+}
+
+EAPI void
+evas_object_map_enable_set(Evas_Object *obj, Eina_Bool enabled)
+{
+   eo_do((Evas_Object *)obj, evas_obj_map_enable_set(enabled));
+}
+
+EAPI Eina_Bool
+evas_object_map_enable_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_map_enable_get());
+}
+
+EAPI void
+evas_object_precise_is_inside_set(Evas_Object *obj, Eina_Bool precise)
+{
+   eo_do((Evas_Object *)obj, evas_obj_precise_is_inside_set(precise));
+}
+
+EAPI Eina_Bool
+evas_object_precise_is_inside_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_precise_is_inside_get());
+}
+
+EAPI void
+evas_object_size_hint_align_set(Evas_Object *obj, double x, double y)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_align_set(x, y));
+}
+
+EAPI void
+evas_object_size_hint_align_get(const Evas_Object *obj, double *x, double *y)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_align_get(x, y));
+}
+
+EAPI void
+evas_object_propagate_events_set(Evas_Object *obj, Eina_Bool propagate)
+{
+   eo_do((Evas_Object *)obj, evas_obj_propagate_events_set(propagate));
+}
+
+EAPI Eina_Bool
+evas_object_propagate_events_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_propagate_events_get());
+}
+
+EAPI void
+evas_object_pass_events_set(Evas_Object *obj, Eina_Bool pass)
+{
+   eo_do((Evas_Object *)obj, evas_obj_pass_events_set(pass));
+}
+
+EAPI Eina_Bool
+evas_object_pass_events_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_pass_events_get());
+}
+
+EAPI void
+evas_object_move(Evas_Object *obj, Evas_Coord x, Evas_Coord y)
+{
+   eo_do((Evas_Object *)obj, evas_obj_position_set(x, y));
+}
+
+EAPI void
+evas_object_anti_alias_set(Evas_Object *obj, Eina_Bool anti_alias)
+{
+   eo_do((Evas_Object *)obj, evas_obj_anti_alias_set(anti_alias));
+}
+
+EAPI Eina_Bool
+evas_object_anti_alias_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_anti_alias_get());
+}
+
+EAPI void
+evas_object_color_set(Evas_Object *obj, int r, int g, int b, int a)
+{
+   eo_do((Evas_Object *)obj, evas_obj_color_set(r, g, b, a));
+}
+
+EAPI void
+evas_object_color_get(const Evas_Object *obj, int *r, int *g, int *b, int *a)
+{
+   eo_do((Evas_Object *)obj, evas_obj_color_get(r, g, b, a));
+}
+
+EAPI void *
+evas_object_smart_data_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_smart_data_get());
+}
+
+EAPI Evas_Object *
+evas_object_smart_clipped_clipper_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_smart_clipped_clipper_get());
+}
+
+EAPI Evas_Object *
+evas_object_below_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_below_get());
+}
+
+EAPI const Eina_List *
+evas_object_clipees_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_clipees_get());
+}
+
+EAPI Evas_Object *
+evas_object_smart_parent_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_smart_parent_get());
+}
+
+EAPI Evas_Object *
+evas_object_above_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_above_get());
+}
+
+EAPI void
+evas_object_size_hint_display_mode_set(Evas_Object *obj, Evas_Display_Mode dispmode)
+{
+   eo_do((Evas_Object *)obj, evas_obj_size_hint_display_mode_set(dispmode));
+}
+
+EAPI Evas_Display_Mode
+evas_object_size_hint_display_mode_get(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_size_hint_display_mode_get());
+}
+
+EAPI Eina_Bool
+evas_object_clipees_has(const Evas_Object *obj)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_clipees_has());
+}
+
+EAPI Eina_Bool
+evas_object_key_grab(Evas_Object *obj, const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers, Eina_Bool exclusive)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_key_grab(keyname, modifiers, not_modifiers, exclusive));
+}
+
+EAPI void
+evas_object_stack_below(Evas_Object *obj, Evas_Object *below)
+{
+   eo_do((Evas_Object *)obj, evas_obj_stack_below(below));
+}
+
+EAPI void
+evas_object_raise(Evas_Object *obj)
+{
+   eo_do((Evas_Object *)obj, evas_obj_raise());
+}
+
+EAPI void
+evas_object_stack_above(Evas_Object *obj, Evas_Object *above)
+{
+   eo_do((Evas_Object *)obj, evas_obj_stack_above(above));
+}
+
+EAPI Eina_Bool
+evas_object_smart_type_check(const Evas_Object *obj, const char *type)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_smart_type_check(type));
+}
+
+EAPI Evas_Object *
+evas_object_name_child_find(const Evas_Object *obj, const char *name, int recurse)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_name_child_find(name, recurse));
+}
+
+EAPI void
+evas_object_key_ungrab(Evas_Object *obj, const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers)
+{
+   eo_do((Evas_Object *)obj, evas_obj_key_ungrab(keyname, modifiers, not_modifiers));
+}
+
+EAPI void
+evas_object_lower(Evas_Object *obj)
+{
+   eo_do((Evas_Object *)obj, evas_obj_lower());
+}
+
+EAPI void
+evas_object_clip_unset(Evas_Object *obj)
+{
+   eo_do((Evas_Object *)obj, evas_obj_clip_unset());
+}
+
+EAPI void
+evas_object_smart_move_children_relative(Evas_Object *obj, Evas_Coord dx, Evas_Coord dy)
+{
+   eo_do((Evas_Object *)obj, evas_obj_smart_move_children_relative(dx, dy));
+}
+
+EAPI Eina_Bool
+evas_object_smart_type_check_ptr(const Evas_Object *obj, const char *type)
+{
+   return eo_do((Evas_Object *)obj, evas_obj_smart_type_check_ptr(type));
+}
diff -Naur a/src/lib/evas/canvas/evas_object.eo.h b/src/lib/evas/canvas/evas_object.eo.h
--- a/src/lib/evas/canvas/evas_object.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,1853 @@
+#ifndef _EVAS_OBJECT_EO_H_
+#define _EVAS_OBJECT_EO_H_
+
+#ifndef _EVAS_OBJECT_EO_CLASS_TYPE
+#define _EVAS_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Evas_Object;
+
+#endif
+
+#ifndef _EVAS_OBJECT_EO_TYPES
+#define _EVAS_OBJECT_EO_TYPES
+
+
+#endif
+#define EVAS_OBJECT_CLASS evas_object_class_get()
+
+const Eo_Class *evas_object_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Sets the hints for an object's maximum size.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * Values @c -1 will be treated as unset hint components, when queried
+ * by managers.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_max_set
+ * @until return
+ *
+ * In this example the maximum size hints change the behavior of an
+ * Evas box when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_max_get()
+ *
+ * @param[in] w Integer to use as the maximum width hint.
+ * @param[in] h Integer to use as the maximum height hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_max_set(Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's maximum size.
+ *
+ * These are hints on the maximum sizes @p obj should have. This is
+ * not a size enforcement in any way, it's just a hint that should be
+ * used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_size_hint_max_set()
+ *
+ * @param[out] w Integer to use as the maximum width hint.
+ * @param[out] h Integer to use as the maximum height hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_max_get(Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the hints for an object's optimum size.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * Values @c 0 will be treated as unset hint components, when queried
+ * by managers.
+ *
+ * @see evas_object_size_hint_request_get()
+ *
+ * @param[in] w Integer to use as the preferred width hint.
+ * @param[in] h Integer to use as the preferred height hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_request_set(Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's optimum size.
+ *
+ * These are hints on the optimum sizes @p obj should have. This is
+ * not a size enforcement in any way, it's just a hint that should be
+ * used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_size_hint_request_set()
+ *
+ * @param[out] w Integer to use as the preferred width hint.
+ * @param[out] h Integer to use as the preferred height hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_request_get(Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Makes the given Evas object visible or invisible.
+ *
+ * @param[in] v @c EINA_TRUE if to make the object visible, @c EINA_FALSE otherwise
+ *
+ */
+EOAPI void  evas_obj_visibility_set(Eina_Bool v);
+
+/**
+ *
+ * Retrieves whether or not the given Evas object is visible.
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_visibility_get(void);
+
+/**
+ *
+ * Sets the type of the given Evas object.
+ *
+ * @param[in] type in
+ *
+ */
+EOAPI void  evas_obj_type_set(const char *type);
+
+/**
+ *
+ * Retrieves the type of the given Evas object.
+ *
+ * @return The type of the object.
+ *
+ * For Evas' builtin types, the return strings will be one of:
+ * - <c>"rectangle"</c>,
+ * - <c>"line"</c>,
+ * - <c>"polygon"</c>,
+ * - <c>"text"</c>,
+ * - <c>"textblock"</c> and
+ * - <c>"image"</c>.
+ *
+ * For Evas smart objects (see @ref Evas_Smart_Group), the name of the
+ * smart class itself is returned on this call. For the built-in smart
+ * objects, these names are:
+ * - <c>"EvasObjectSmartClipped"</c>, for the clipped smart object
+ * - <c>"Evas_Object_Box"</c>, for the box object and
+ * - <c>"Evas_Object_Table"</c>, for the table object.
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip d.img = evas_object_image_filled_add(d.canvas);
+ * @until border on the
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ *
+ */
+EOAPI const char * evas_obj_type_get(void);
+
+/**
+ *
+ * Sets the hints for an object's minimum size.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * Values @c 0 will be treated as unset hint components, when queried
+ * by managers.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_min_set
+ * @until return
+ *
+ * In this example the minimum size hints change the behavior of an
+ * Evas box when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_min_get()
+ *
+ * @param[in] w Integer to use as the minimum width hint.
+ * @param[in] h Integer to use as the minimum height hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_min_set(Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's minimum size.
+ *
+ * These are hints on the minimum sizes @p obj should have. This is
+ * not a size enforcement in any way, it's just a hint that should be
+ * used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_size_hint_min_set() for an example
+ *
+ * @param[out] w Integer to use as the minimum width hint.
+ * @param[out] h Integer to use as the minimum height hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_min_get(Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Set pointer behavior.
+ *
+ * This function has direct effect on event callbacks related to
+ * mouse.
+ *
+ * If @p setting is EVAS_OBJECT_POINTER_MODE_AUTOGRAB, then when mouse
+ * is down at this object, events will be restricted to it as source,
+ * mouse moves, for example, will be emitted even if outside this
+ * object area.
+ *
+ * If @p setting is EVAS_OBJECT_POINTER_MODE_NOGRAB, then events will
+ * be emitted just when inside this object area.
+ *
+ * The default value is EVAS_OBJECT_POINTER_MODE_AUTOGRAB.
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] pointer_mode desired behavior.
+ *
+ */
+EOAPI void  evas_obj_pointer_mode_set(Evas_Object_Pointer_Mode pointer_mode);
+
+/**
+ *
+ * Determine how pointer will behave.
+ * @return pointer behavior.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ *
+ */
+EOAPI Evas_Object_Pointer_Mode  evas_obj_pointer_mode_get(void);
+
+/**
+ *
+ * Sets the render_op to be used for rendering the Evas object.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] render_op one of the Evas_Render_Op values.
+ *
+ */
+EOAPI void  evas_obj_render_op_set(Evas_Render_Op render_op);
+
+/**
+ *
+ * Retrieves the current value of the operation used for rendering the Evas object.
+ * @return  one of the enumerated values in Evas_Render_Op.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ *
+ */
+EOAPI Evas_Render_Op  evas_obj_render_op_get(void);
+
+/**
+ *
+ * Set whether an Evas object is to freeze (discard) events.
+ *
+ * If @p freeze is @c EINA_TRUE, it will make events on @p obj to be @b
+ * discarded. Unlike evas_object_pass_events_set(), events will not be
+ * passed to @b next lower object. This API can be used for blocking
+ * events while @p obj is on transiting.
+ *
+ * If @p freeze is @c EINA_FALSE, events will be processed on that
+ * object as normal.
+ *
+ * @warning If you block only key/mouse up events with this API, we won't
+ * guarantee the state of the object, that only had key/mouse down
+ * events, will be.
+ *
+ * @see evas_object_freeze_events_get()
+ * @see evas_object_pass_events_set()
+ * @see evas_object_repeat_events_set()
+ * @see evas_object_propagate_events_set()
+ * @since 1.1
+ *
+ * @param[in] freeze pass whether @p obj is to freeze events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ *
+ */
+EOAPI void  evas_obj_freeze_events_set(Eina_Bool freeze);
+
+/**
+ *
+ * Determine whether an object is set to freeze (discard) events.
+ *
+ * @return freeze whether @p obj is set to freeze events (@c EINA_TRUE) or
+ * not (@c EINA_FALSE)
+ *
+ * @see evas_object_freeze_events_set()
+ * @see evas_object_pass_events_get()
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_propagate_events_get()
+ * @since 1.1
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_freeze_events_get(void);
+
+/**
+ *
+ * Set current object transformation map.
+ *
+ * This sets the map on a given object. It is copied from the @p map pointer,
+ * so there is no need to keep the @p map object if you don't need it anymore.
+ *
+ * A map is a set of 4 points which have canvas x, y coordinates per point,
+ * with an optional z point value as a hint for perspective correction, if it
+ * is available. As well each point has u and v coordinates. These are like
+ * "texture coordinates" in OpenGL in that they define a point in the source
+ * image that is mapped to that map vertex/point. The u corresponds to the x
+ * coordinate of this mapped point and v, the y coordinate. Note that these
+ * coordinates describe a bounding region to sample. If you have a 200x100
+ * source image and want to display it at 200x100 with proper pixel
+ * precision, then do:
+ *
+ * @code
+ * Evas_Map *m = evas_map_new(4);
+ * evas_map_point_coord_set(m, 0,   0,   0, 0);
+ * evas_map_point_coord_set(m, 1, 200,   0, 0);
+ * evas_map_point_coord_set(m, 2, 200, 100, 0);
+ * evas_map_point_coord_set(m, 3,   0, 100, 0);
+ * evas_map_point_image_uv_set(m, 0,   0,   0);
+ * evas_map_point_image_uv_set(m, 1, 200,   0);
+ * evas_map_point_image_uv_set(m, 2, 200, 100);
+ * evas_map_point_image_uv_set(m, 3,   0, 100);
+ * evas_object_map_set(obj, m);
+ * evas_map_free(m);
+ * @endcode
+ *
+ * Note that the map points a uv coordinates match the image geometry. If
+ * the @p map parameter is NULL, the stored map will be freed and geometry
+ * prior to enabling/setting a map will be restored.
+ *
+ * @see evas_map_new()
+ *
+ * @param[in] map new map to use
+ *
+ */
+EOAPI void  evas_obj_map_set(const Evas_Map *map);
+
+/**
+ *
+ * Get current object transformation map.
+ *
+ * This returns the current internal map set on the indicated object. It is
+ * intended for read-only access and is only valid as long as the object is
+ * not deleted or the map on the object is not changed. If you wish to modify
+ * the map and set it back do the following:
+ *
+ * @code
+ * const Evas_Map *m = evas_object_map_get(obj);
+ * Evas_Map *m2 = evas_map_dup(m);
+ * evas_map_util_rotate(m2, 30.0, 0, 0);
+ * evas_object_map_set(obj, m2);
+ * evas_map_free(m2);
+ * @endcode
+ *
+ * @return map reference to map in use. This is an internal data structure, so
+ * do not modify it.
+ *
+ * @see evas_object_map_set()
+ *
+ *
+ */
+EOAPI const Evas_Map * evas_obj_map_get(void);
+
+/**
+ *
+ * Sets the hints for an object's aspect ratio.
+ *
+ * This is not a size enforcement in any way, it's just a hint that should
+ * be used whenever appropriate.
+ *
+ * If any of the given aspect ratio terms are @c 0,
+ * the object's container will ignore the aspect and scale @p obj to
+ * occupy the whole available area, for any given policy.
+ *
+ * @see evas_object_size_hint_aspect_get() for more information.
+ *
+ * @param[in] aspect The policy/type of aspect ratio to apply to @p obj.
+ * @param[in] w Integer to use as aspect width ratio term.
+ * @param[in] h Integer to use as aspect height ratio term.
+ *
+ */
+EOAPI void  evas_obj_size_hint_aspect_set(Evas_Aspect_Control aspect, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's aspect ratio.
+ *
+ * The different aspect ratio policies are documented in the
+ * #Evas_Aspect_Control type. A container respecting these size hints
+ * would @b resize its children accordingly to those policies.
+ *
+ * For any policy, if any of the given aspect ratio terms are @c 0,
+ * the object's container should ignore the aspect and scale @p obj to
+ * occupy the whole available area. If they are both positive
+ * integers, that proportion will be respected, under each scaling
+ * policy.
+ *
+ * These images illustrate some of the #Evas_Aspect_Control policies:
+ *
+ * @image html any-policy.png
+ * @image rtf any-policy.png
+ * @image latex any-policy.eps
+ *
+ * @image html aspect-control-none-neither.png
+ * @image rtf aspect-control-none-neither.png
+ * @image latex aspect-control-none-neither.eps
+ *
+ * @image html aspect-control-both.png
+ * @image rtf aspect-control-both.png
+ * @image latex aspect-control-both.eps
+ *
+ * @image html aspect-control-horizontal.png
+ * @image rtf aspect-control-horizontal.png
+ * @image latex aspect-control-horizontal.eps
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * Example:
+ * @dontinclude evas-aspect-hints.c
+ * @skip if (strcmp(ev->key, "c") == 0)
+ * @until }
+ *
+ * See the full @ref Example_Evas_Aspect_Hints "example".
+ *
+ * @see evas_object_size_hint_aspect_set()
+ *
+ * @param[out] aspect The policy/type of aspect ratio to apply to @p obj.
+ * @param[out] w Integer to use as aspect width ratio term.
+ * @param[out] h Integer to use as aspect height ratio term.
+ *
+ */
+EOAPI void  evas_obj_size_hint_aspect_get(Evas_Aspect_Control *aspect, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the layer of its canvas that the given object will be part of.
+ *
+ * If you don't use this function, you'll be dealing with an @b unique
+ * layer of objects, the default one. Additional layers are handy when
+ * you don't want a set of objects to interfere with another set with
+ * regard to @b stacking. Two layers are completely disjoint in that
+ * matter.
+ *
+ * This is a low-level function, which you'd be using when something
+ * should be always on top, for example.
+ *
+ * @warning Be careful, it doesn't make sense to change the layer of
+ * smart objects' children. Smart objects have a layer of their own,
+ * which should contain all their children objects.
+ *
+ * @see evas_object_layer_get()
+ *
+ * @param[in] l The number of the layer to place the object on.
+Must be between #EVAS_LAYER_MIN and #EVAS_LAYER_MAX.
+ *
+ */
+EOAPI void  evas_obj_layer_set(short l);
+
+/**
+ *
+ * Retrieves the layer of its canvas that the given object is part of.
+ *
+ * @return  Number of its layer
+ *
+ * @see evas_object_layer_set()
+ *
+ *
+ */
+EOAPI short  evas_obj_layer_get(void);
+
+/**
+ *
+ * Clip one object to another.
+ *
+ * This function will clip the object @p obj to the area occupied by
+ * the object @p clip. This means the object @p obj will only be
+ * visible within the area occupied by the clipping object (@p clip).
+ *
+ * The color of the object being clipped will be multiplied by the
+ * color of the clipping one, so the resulting color for the former
+ * will be <code>RESULT = (OBJ * CLIP) / (255 * 255)</code>, per color
+ * element (red, green, blue and alpha).
+ *
+ * Clipping is recursive, so clipping objects may be clipped by
+ * others, and their color will in term be multiplied. You may @b not
+ * set up circular clipping lists (i.e. object 1 clips object 2, which
+ * clips object 1): the behavior of Evas is undefined in this case.
+ *
+ * Objects which do not clip others are visible in the canvas as
+ * normal; <b>those that clip one or more objects become invisible
+ * themselves</b>, only affecting what they clip. If an object ceases
+ * to have other objects being clipped by it, it will become visible
+ * again.
+ *
+ * The visibility of an object affects the objects that are clipped by
+ * it, so if the object clipping others is not shown (as in
+ * evas_object_show()), the objects clipped by it will not be shown
+ * either.
+ *
+ * If @p obj was being clipped by another object when this function is
+ * called, it gets implicitly removed from the old clipper's domain
+ * and is made now to be clipped by its new clipper.
+ *
+ * The following figure illustrates some clipping in Evas:
+ *
+ * @image html clipping.png
+ * @image rtf clipping.png
+ * @image latex clipping.eps
+ *
+ * @note At the moment the <b>only objects that can validly be used to
+ * clip other objects are rectangle objects</b>. All other object
+ * types are invalid and the result of using them is undefined. The
+ * clip object @p clip must be a valid object, but can also be @c
+ * NULL, in which case the effect of this function is the same as
+ * calling evas_object_clip_unset() on the @p obj object.
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip solid white clipper (note that it's the default color for a
+ * @until evas_object_show(d.clipper);
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ * @param[in] clip The object to clip @p obj by
+ *
+ */
+EOAPI void  evas_obj_clip_set(Evas_Object *clip);
+
+/**
+ *
+ * Get the object clipping @p obj (if any).
+ *
+ * This function returns the object clipping @p obj. If @p obj is
+ * not being clipped at all, @c NULL is returned. The object @p obj
+ * must be a valid .Evas_Object.
+ *
+ * See also evas_object_clip_set(), evas_object_clip_unset() and
+ * evas_object_clipees_get().
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip if (evas_object_clip_get(d.img) == d.clipper)
+ * @until return
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_clip_get(void);
+
+/**
+ *
+ * Sets the hints for an object's padding space.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @see evas_object_size_hint_padding_get() for more information
+ *
+ * @param[in] l Integer to specify left padding.
+ * @param[in] r Integer to specify right padding.
+ * @param[in] t Integer to specify top padding.
+ * @param[in] b Integer to specify bottom padding.
+ *
+ */
+EOAPI void  evas_obj_size_hint_padding_set(Evas_Coord l, Evas_Coord r, Evas_Coord t, Evas_Coord b);
+
+/**
+ *
+ * Retrieves the hints for an object's padding space.
+ *
+ * Padding is extra space an object takes on each of its delimiting
+ * rectangle sides, in canvas units. This space will be rendered
+ * transparent, naturally, as in the following figure:
+ *
+ * @image html padding-hints.png
+ * @image rtf padding-hints.png
+ * @image latex padding-hints.eps
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_padding_set
+ * @until return
+ *
+ * In this example the padding hints change the behavior of an Evas box
+ * when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_padding_set()
+ *
+ * @param[out] l Integer to specify left padding.
+ * @param[out] r Integer to specify right padding.
+ * @param[out] t Integer to specify top padding.
+ * @param[out] b Integer to specify bottom padding.
+ *
+ */
+EOAPI void  evas_obj_size_hint_padding_get(Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+/**
+ *
+ * Set whether an Evas object is to repeat events.
+ *
+ * If @p repeat is @c EINA_TRUE, it will make events on @p obj to also
+ * be repeated for the @b next lower object in the objects' stack (see
+ * see evas_object_below_get()).
+ *
+ * If @p repeat is @c EINA_FALSE, events occurring on @p obj will be
+ * processed only on it.
+ *
+ * Example:
+ * @dontinclude evas-stacking.c
+ * @skip if (strcmp(ev->key, "r") == 0)
+ * @until }
+ *
+ * See the full @ref Example_Evas_Stacking "example".
+ *
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_pass_events_set()
+ * @see evas_object_propagate_events_set()
+ * @see evas_object_freeze_events_set()
+ *
+ * @param[in] repeat whether @p obj is to repeat events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ *
+ */
+EOAPI void  evas_obj_repeat_events_set(Eina_Bool repeat);
+
+/**
+ *
+ * Determine whether an object is set to repeat events.
+ *
+ * @return whether @p obj is set to repeat events (@c EINA_TRUE)
+ * or not (@c EINA_FALSE)
+ *
+ * @see evas_object_repeat_events_set() for an example
+ * @see evas_object_pass_events_get()
+ * @see evas_object_propagate_events_get()
+ * @see evas_object_freeze_events_get()
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_repeat_events_get(void);
+
+/**
+ *
+ * Sets the hints for an object's weight.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * This is a hint on how a container object should @b resize a given
+ * child within its area. Containers may adhere to the simpler logic
+ * of just expanding the child object's dimensions to fit its own (see
+ * the #EVAS_HINT_EXPAND helper weight macro) or the complete one of
+ * taking each child's weight hint as real @b weights to how much of
+ * its size to allocate for them in each axis. A container is supposed
+ * to, after @b normalizing the weights of its children (with weight
+ * hints), distribute the space it has to layout them by those factors
+ * -- most weighted children get larger in this process than the least
+ * ones.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_weight_set
+ * @until return
+ *
+ * In this example the weight hints change the behavior of an Evas box
+ * when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @note Default weight hint values are 0.0, for both axis.
+ *
+ * @see evas_object_size_hint_weight_get() for more information
+ *
+ * @param[in] x Nonnegative double value to use as horizontal weight hint.
+ * @param[in] y Nonnegative double value to use as vertical weight hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_weight_set(double x, double y);
+
+/**
+ *
+ * Retrieves the hints for an object's weight.
+ *
+ * Accepted values are zero or positive values. Some users might use
+ * this hint as a boolean, but some might consider it as a @b
+ * proportion, see documentation of possible users, which in Evas are
+ * the @ref Evas_Object_Box "box" and @ref Evas_Object_Table "table"
+ * smart objects.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ * @note If @c obj is invalid, then the hint components will be set with 0.0
+ *
+ * @see evas_object_size_hint_weight_set() for an example
+ *
+ * @param[out] x Nonnegative double value to use as horizontal weight hint.
+ * @param[out] y Nonnegative double value to use as vertical weight hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_weight_get(double *x, double *y);
+
+/**
+ *
+ * Sets the name of the given Evas object to the given name.
+ *
+ * There might be occasions where one would like to name his/her
+ * objects.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip d.bg = evas_object_rectangle_add(d.canvas);
+ * @until evas_object_name_set(d.bg, "our dear rectangle");
+ *
+ * See the full @ref Example_Evas_Events "example".
+ *
+ * @param[in] name The given name.
+ *
+ */
+EOAPI void  evas_obj_name_set(const char *name);
+
+/**
+ *
+ * Retrieves the name of the given Evas object.
+ *
+ * @return  The name of the object or @c NULL, if no name has been given
+ * to it.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip fprintf(stdout, "An object got focused: %s\n",
+ * @until evas_focus_get
+ *
+ * See the full @ref Example_Evas_Events "example".
+ *
+ *
+ */
+EOAPI const char * evas_obj_name_get(void);
+
+/**
+ *
+ * Sets the scaling factor for an Evas object. Does not affect all
+ * objects.
+ *
+ * This will multiply the object's dimension by the given factor, thus
+ * altering its geometry (width and height). Useful when you want
+ * scalable UI elements, possibly at run time.
+ *
+ * @note Only text and textblock objects have scaling change
+ * handlers. Other objects won't change visually on this call.
+ *
+ * @see evas_object_scale_get()
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] scale The scaling factor. <c>1.0</c> means no scaling,
+default size.
+ *
+ */
+EOAPI void  evas_obj_scale_set(double scale);
+
+/**
+ *
+ * Retrieves the scaling factor for the given Evas object.
+ *
+ * @return  The scaling factor.
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @see evas_object_scale_set()
+ *
+ *
+ */
+EOAPI double  evas_obj_scale_get(void);
+
+/**
+ *
+ * Set a hint flag on the given Evas object that it's used as a "static
+ * clipper".
+ *
+ * This is a hint to Evas that this object is used as a big static
+ * clipper and shouldn't be moved with children and otherwise
+ * considered specially. The default value for new objects is
+ * @c EINA_FALSE.
+ *
+ * @see evas_object_static_clip_get()
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] is_static_clip @c EINA_TRUE if it's to be used as a static
+clipper, @c EINA_FALSE otherwise.
+ *
+ */
+EOAPI void  evas_obj_static_clip_set(Eina_Bool is_static_clip);
+
+/**
+ *
+ * Get the "static clipper" hint flag for a given Evas object.
+ *
+ * @return @c EINA_TRUE if it's set as a static clipper,
+ * @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_static_clip_set() for more details
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_static_clip_get(void);
+
+/**
+ *
+ * Changes the size of the given Evas object.
+ *
+ * @param[in] w in
+ * @param[in] h in
+ *
+ */
+EOAPI void  evas_obj_size_set(Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the (rectangular) size of the given Evas object.
+ *
+ * @param[out] w in
+ * @param[out] h in
+ *
+ */
+EOAPI void  evas_obj_size_get(Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets or unsets a given object as the currently focused one on its
+ * canvas.
+ *
+ * Changing focus only affects where (key) input events go. There can
+ * be only one object focused at any time. If @p focus is @c EINA_TRUE,
+ * @p obj will be set as the currently focused object and it will
+ * receive all keyboard events that are not exclusive key grabs on
+ * other objects.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip evas_object_focus_set
+ * @until evas_object_focus_set
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_focus_get
+ * @see evas_focus_get
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ *
+ * @param[in] focus @c EINA_TRUE, to set it as focused or @c EINA_FALSE,
+to take away the focus from it.
+ *
+ */
+EOAPI void  evas_obj_focus_set(Eina_Bool focus);
+
+/**
+ *
+ * Retrieve whether an object has the focus.
+ *
+ * @return @c EINA_TRUE if the object has the focus, @c EINA_FALSE otherwise.
+ *
+ * If the passed object is the currently focused one, @c EINA_TRUE is
+ * returned. @c EINA_FALSE is returned, otherwise.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip And again
+ * @until something is bad
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_focus_set
+ * @see evas_focus_get
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_focus_get(void);
+
+/**
+ *
+ * @since 1.2
+ *
+ * @param[in] is_frame in
+ *
+ */
+EOAPI void  evas_obj_is_frame_object_set(Eina_Bool is_frame);
+
+/**
+ *
+ * @since 1.2
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_is_frame_object_get(void);
+
+/**
+ *
+ * Enable or disable the map that is set.
+ *
+ * Enable or disable the use of map for the object @p obj.
+ * On enable, the object geometry will be saved, and the new geometry will
+ * change (position and size) to reflect the map geometry set.
+ *
+ * If the object doesn't have a map set (with evas_object_map_set()), the
+ * initial geometry will be undefined. It is advised to always set a map
+ * to the object first, and then call this function to enable its use.
+ *
+ * @param[in] enabled enabled state
+ *
+ */
+EOAPI void  evas_obj_map_enable_set(Eina_Bool enabled);
+
+/**
+ *
+ * Get the map enabled state
+ *
+ * This returns the currently enabled state of the map on the object indicated.
+ * The default map enable state is off. You can enable and disable it with
+ * evas_object_map_enable_set().
+ *
+ * @return the map enabled state
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_map_enable_get(void);
+
+/**
+ *
+ * Set whether to use precise (usually expensive) point collision
+ * detection for a given Evas object.
+ *
+ * Use this function to make Evas treat objects' transparent areas as
+ * @b not belonging to it with regard to mouse pointer events. By
+ * default, all of the object's boundary rectangle will be taken in
+ * account for them.
+ *
+ * @warning By using precise point collision detection you'll be
+ * making Evas more resource intensive.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip if (strcmp(ev->key, "p") == 0)
+ * @until }
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_precise_is_inside_get()
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] precise Whether to use precise point collision detection or
+not. The default value is false.
+ *
+ */
+EOAPI void  evas_obj_precise_is_inside_set(Eina_Bool precise);
+
+/**
+ *
+ * Determine whether an object is set to use precise point collision
+ * detection.
+ *
+ * @return whether @p obj is set to use precise point collision
+ * detection or not The default value is false.
+ *
+ * @see evas_object_precise_is_inside_set() for an example
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_precise_is_inside_get(void);
+
+/**
+ *
+ * Sets the hints for an object's alignment.
+ *
+ * These are hints on how to align an object <b>inside the boundaries
+ * of a container/manager</b>. Accepted values are in the @c 0.0 to @c
+ * 1.0 range, with the special value #EVAS_HINT_FILL used to specify
+ * "justify" or "fill" by some users. In this case, maximum size hints
+ * should be enforced with higher priority, if they are set. Also, any
+ * padding hint set on objects should add up to the alignment space on
+ * the final scene composition.
+ *
+ * See documentation of possible users: in Evas, they are the @ref
+ * Evas_Object_Box "box" and @ref Evas_Object_Table "table" smart
+ * objects.
+ *
+ * For the horizontal component, @c 0.0 means to the left, @c 1.0
+ * means to the right. Analogously, for the vertical component, @c 0.0
+ * to the top, @c 1.0 means to the bottom.
+ *
+ * See the following figure:
+ *
+ * @image html alignment-hints.png
+ * @image rtf alignment-hints.png
+ * @image latex alignment-hints.eps
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Default alignment hint values are 0.5, for both axis.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_align_set
+ * @until return
+ *
+ * In this example the alignment hints change the behavior of an Evas
+ * box when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_align_get()
+ * @see evas_object_size_hint_max_set()
+ * @see evas_object_size_hint_padding_set()
+ *
+ * @param[in] x Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as horizontal alignment hint.
+ * @param[in] y Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as vertical alignment hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_align_set(double x, double y);
+
+/**
+ *
+ * Retrieves the hints for on object's alignment.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ * @note If @c obj is invalid, then the hint components will be set with 0.5
+ *
+ * @see evas_object_size_hint_align_set() for more information
+ *
+ * @param[out] x Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as horizontal alignment hint.
+ * @param[out] y Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as vertical alignment hint.
+ *
+ */
+EOAPI void  evas_obj_size_hint_align_get(double *x, double *y);
+
+/**
+ *
+ * Set whether events on a smart object's member should get propagated
+ * up to its parent.
+ *
+ * This function has @b no effect if @p obj is not a member of a smart
+ * object.
+ *
+ * If @p prop is @c EINA_TRUE, events occurring on this object will be
+ * propagated on to the smart object of which @p obj is a member.  If
+ * @p prop is @c EINA_FALSE, events occurring on this object will @b
+ * not be propagated on to the smart object of which @p obj is a
+ * member.  The default value is @c EINA_TRUE.
+ *
+ * @see evas_object_propagate_events_get()
+ * @see evas_object_repeat_events_set()
+ * @see evas_object_pass_events_set()
+ * @see evas_object_freeze_events_set()
+ *
+ * @param[in] propagate whether to propagate events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ *
+ */
+EOAPI void  evas_obj_propagate_events_set(Eina_Bool propagate);
+
+/**
+ *
+ * Retrieve whether an Evas object is set to propagate events.
+ *
+ * @return whether @p obj is set to propagate events (@c EINA_TRUE)
+ * or not (@c EINA_FALSE)
+ *
+ * @see evas_object_propagate_events_set()
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_pass_events_get()
+ * @see evas_object_freeze_events_get()
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_propagate_events_get(void);
+
+/**
+ *
+ * Set whether an Evas object is to pass (ignore) events.
+ *
+ * If @p pass is @c EINA_TRUE, it will make events on @p obj to be @b
+ * ignored. They will be triggered on the @b next lower object (that
+ * is not set to pass events), instead (see evas_object_below_get()).
+ *
+ * If @p pass is @c EINA_FALSE, events will be processed on that
+ * object as normal.
+ *
+ * @see evas_object_pass_events_get() for an example
+ * @see evas_object_repeat_events_set()
+ * @see evas_object_propagate_events_set()
+ * @see evas_object_freeze_events_set()
+ *
+ * @param[in] pass whether @p obj is to pass events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ *
+ */
+EOAPI void  evas_obj_pass_events_set(Eina_Bool pass);
+
+/**
+ *
+ * Determine whether an object is set to pass (ignore) events.
+ *
+ * @return pass whether @p obj is set to pass events (@c EINA_TRUE) or not
+ * (@c EINA_FALSE)
+ *
+ * Example:
+ * @dontinclude evas-stacking.c
+ * @skip if (strcmp(ev->key, "p") == 0)
+ * @until }
+ *
+ * See the full @ref Example_Evas_Stacking "example".
+ *
+ * @see evas_object_pass_events_set()
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_propagate_events_get()
+ * @see evas_object_freeze_events_get()
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_pass_events_get(void);
+
+/**
+ *
+ * Move the given Evas object to the given location inside its canvas' viewport.
+ *
+ * @param[in] x in
+ * @param[in] y in
+ *
+ */
+EOAPI void  evas_obj_position_set(Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * Retrieves the position of the given Evas object.
+ *
+ * @param[out] x in
+ * @param[out] y in
+ *
+ */
+EOAPI void  evas_obj_position_get(Evas_Coord *x, Evas_Coord *y);
+
+/**
+ *
+ * Sets whether or not the given Evas object is to be drawn anti-aliased.
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] anti_alias (@c EINA_TRUE) if the object is to be anti_aliased, (@c EINA_FALSE) otherwise.
+ *
+ */
+EOAPI void  evas_obj_anti_alias_set(Eina_Bool anti_alias);
+
+/**
+ *
+ * Retrieves whether or not the given Evas object is to be drawn anti_aliased.
+ * @return  (@c EINA_TRUE) if the object is to be anti_aliased.  (@c EINA_FALSE) otherwise.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_anti_alias_get(void);
+
+/**
+ *
+ * Sets the general/main color of the given Evas object to the given
+ * one.
+ *
+ * @see evas_object_color_get() (for an example)
+ * @note These color values are expected to be premultiplied by @p a.
+ *
+ * @ingroup Evas_Object_Group_Basic
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_color_set(int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the general/main color of the given Evas object.
+ *
+ * Retrieves the main color's RGB component (and alpha channel)
+ * values, <b>which range from 0 to 255</b>. For the alpha channel,
+ * which defines the object's transparency level, 0 means totally
+ * transparent, while 255 means opaque. These color values are
+ * premultiplied by the alpha value.
+ *
+ * Usually youll use this attribute for text and rectangle objects,
+ * where the main color is their unique one. If set for objects
+ * which themselves have colors, like the images one, those colors get
+ * modulated by this one.
+ *
+ * @note All newly created Evas rectangles get the default color
+ * values of <code>255 255 255 255</code> (opaque white).
+ *
+ * @note Use @c NULL pointers on the components you're not interested
+ * in: they'll be ignored by the function.
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip int alpha, r, g, b;
+ * @until return
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ * @ingroup Evas_Object_Group_Basic
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_color_get(int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * Retrieve user data stored on a given smart object.
+ *
+ * @return A pointer to data stored using
+ * evas_object_smart_data_set(), or @c NULL, if none has been
+ * set.
+ *
+ * @see evas_object_smart_data_set()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ *
+ */
+EOAPI void * evas_obj_smart_data_get(void);
+
+/**
+ *
+ * Get the clipper object for the given clipped smart object.
+ *
+ * @return the clipper object.
+ *
+ * Use this function if you want to change any of this clipper's
+ * properties, like colors.
+ *
+ * @see evas_object_smart_clipped_smart_add()
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_smart_clipped_clipper_get(void);
+
+/**
+ *
+ * Get the Evas object stacked right below @p obj
+ *
+ * @return the #Evas_Object directly below @p obj, if any, or @c NULL,
+ * if none
+ *
+ * This function will traverse layers in its search, if there are
+ * objects on layers below the one @p obj is placed at.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_below_get(void);
+
+/**
+ *
+ * Return a list of objects currently clipped by @p obj.
+ *
+ * @return a list of objects being clipped by @p obj
+ *
+ * This returns the internal list handle that contains all objects
+ * clipped by the object @p obj. If none are clipped by it, the call
+ * returns @c NULL. This list is only valid until the clip list is
+ * changed and should be fetched again with another call to
+ * evas_object_clipees_get() if any objects being clipped by this
+ * object are unclipped, clipped by a new object, deleted or get the
+ * clipper deleted. These operations will invalidate the list
+ * returned, so it should not be used anymore after that point. Any
+ * use of the list after this may have undefined results, possibly
+ * leading to crashes. The object @p obj must be a valid
+ * .Evas_Object.
+ *
+ * See also evas_object_clip_set(), evas_object_clip_unset() and
+ * evas_object_clip_get().
+ *
+ * Example:
+ * @code
+ * extern Evas_Object *obj;
+ * Evas_Object *clipper;
+ *
+ * clipper = evas_object_clip_get(obj);
+ * if (clipper)
+ * {
+ * Eina_List *clippees, *l;
+ * Evas_Object *obj_tmp;
+ *
+ * clippees = evas_object_clipees_get(clipper);
+ * printf("Clipper clips %i objects\n", eina_list_count(clippees));
+ * EINA_LIST_FOREACH(clippees, l, obj_tmp)
+ * evas_object_show(obj_tmp);
+ * }
+ * @endcode
+ *
+ *
+ */
+EOAPI const Eina_List * evas_obj_clipees_get(void);
+
+/**
+ *
+ * Gets the parent smart object of a given Evas object, if it has one.
+ *
+ * @return Returns the parent smart object of @a obj or @c NULL, if @a
+ * obj is not a smart member of any
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_smart_parent_get(void);
+
+/**
+ *
+ * Get the Evas object stacked right above @p obj
+ *
+ * @return the #Evas_Object directly above @p obj, if any, or @c NULL,
+ * if none
+ *
+ * This function will traverse layers in its search, if there are
+ * objects on layers above the one @p obj is placed at.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_above_get(void);
+
+/**
+ *
+ * Sets the hints for an object's disply mode
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * can be used whenever appropriate.
+ *
+ * @param[in] dispmode display mode hint
+ *
+ */
+EOAPI void  evas_obj_size_hint_display_mode_set(Evas_Display_Mode dispmode);
+
+/**
+ *
+ * Retrieves the hints for an object's display mode
+ *
+ * These are hints on the display mode @p obj. This is
+ * not a size enforcement in any way, it's just a hint that can be
+ * used whenever appropriate.
+ * This mode can be used object's display mode like commpress or expand
+ *
+ *
+ */
+EOAPI Evas_Display_Mode  evas_obj_size_hint_display_mode_get(void);
+
+/**
+ *
+ * Test if any object is clipped by @p obj.
+ *
+ * @return EINA_TRUE if @p obj clip any object.
+ * @since 1.8
+ * 
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_clipees_has(void);
+
+/**
+ *
+ * Requests @p keyname key events be directed to @p obj.
+ *
+ * @return @c EINA_TRUE, if the call succeeded, @c EINA_FALSE otherwise.
+ *
+ * Key grabs allow one or more objects to receive key events for
+ * specific key strokes even if other objects have focus. Whenever a
+ * key is grabbed, only the objects grabbing it will get the events
+ * for the given keys.
+ *
+ * @p keyname is a platform dependent symbolic name for the key
+ * pressed (see @ref Evas_Keys for more information).
+ *
+ * @p modifiers and @p not_modifiers are bit masks of all the
+ * modifiers that must and mustn't, respectively, be pressed along
+ * with @p keyname key in order to trigger this new key
+ * grab. Modifiers can be things such as Shift and Ctrl as well as
+ * user defined types via evas_key_modifier_add(). Retrieve them with
+ * evas_key_modifier_mask_get() or use @c 0 for empty masks.
+ *
+ * @p exclusive will make the given object the only one permitted to
+ * grab the given key. If given @c EINA_TRUE, subsequent calls on this
+ * function with different @p obj arguments will fail, unless the key
+ * is ungrabbed again.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip if (d.focus)
+ * @until else
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @warning Providing impossible modifier sets creates undefined behavior
+ *
+ * @see evas_object_key_ungrab
+ * @see evas_object_focus_set
+ * @see evas_object_focus_get
+ * @see evas_focus_get
+ * @see evas_key_modifier_add
+ * 
+ *
+ * @param[in] keyname the key to request events for.
+ * @param[in] modifiers a mask of modifiers that must be present to
+trigger the event.
+ * @param[in] not_modifiers a mask of modifiers that must @b not be present
+to trigger the event.
+ * @param[in] exclusive request that the @p obj is the only object
+receiving the @p keyname events.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_key_grab(const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers, Eina_Bool exclusive);
+
+/**
+ *
+ * Stack @p obj immediately below @p below
+ *
+ * Objects, in a given canvas, are stacked in the order they get added
+ * to it.  This means that, if they overlap, the highest ones will
+ * cover the lowest ones, in that order. This function is a way to
+ * change the stacking order for the objects.
+ *
+ * This function is intended to be used with <b>objects belonging to
+ * the same layer</b> in a given canvas, otherwise it will fail (and
+ * accomplish nothing).
+ *
+ * If you have smart objects on your canvas and @p obj is a member of
+ * one of them, then @p below must also be a member of the same
+ * smart object.
+ *
+ * Similarly, if @p obj is not a member of a smart object, @p below
+ * must not be either.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_stack_below()
+ * 
+ *
+ * @param[in] below the object below which to stack
+ *
+ */
+EOAPI void  evas_obj_stack_below(Evas_Object *below);
+
+/**
+ *
+ * Raise @p obj to the top of its layer.
+ *
+ * @p obj will, then, be the highest one in the layer it belongs
+ * to. Object on other layers won't get touched.
+ *
+ * @see evas_object_stack_above()
+ * @see evas_object_stack_below()
+ * @see evas_object_lower()
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_raise(void);
+
+/**
+ *
+ * Stack @p obj immediately above @p above
+ *
+ * Objects, in a given canvas, are stacked in the order they get added
+ * to it.  This means that, if they overlap, the highest ones will
+ * cover the lowest ones, in that order. This function is a way to
+ * change the stacking order for the objects.
+ *
+ * This function is intended to be used with <b>objects belonging to
+ * the same layer</b> in a given canvas, otherwise it will fail (and
+ * accomplish nothing).
+ *
+ * If you have smart objects on your canvas and @p obj is a member of
+ * one of them, then @p above must also be a member of the same
+ * smart object.
+ *
+ * Similarly, if @p obj is not a member of a smart object, @p above
+ * must not be either.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_stack_below()
+ * 
+ *
+ * @param[in] above the object above which to stack
+ *
+ */
+EOAPI void  evas_obj_stack_above(Evas_Object *above);
+
+/**
+ *
+ * Checks whether a given smart object or any of its smart object
+ * parents is of a given smart class.
+ *
+ * @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+ * type, @c EINA_FALSE otherwise
+ *
+ * If @p obj is not a smart object, this call will fail
+ * immediately.
+ *
+ * This function supports Eo and legacy inheritance mechanisms. However,
+ * it is recommended to use eo_isa instead if your object is using Eo from
+ * top to bottom.
+ *
+ * The checks use smart classes names and <b>string
+ * comparison</b>. There is a version of this same check using
+ * <b>pointer comparison</b>, since a smart class' name is a single
+ * string in Evas.
+ *
+ * @see evas_object_smart_type_check_ptr()
+ * @see eo_isa
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[in] type The @b name (type) of the smart class to check for
+ *
+ */
+EOAPI Eina_Bool  evas_obj_smart_type_check(const char *type);
+
+/**
+ *
+ * Retrieves the object from children of the given object with the given name.
+ * @return  If successful, the Evas object with the given name.  Otherwise,
+ * @c NULL.
+ *
+ * This looks for the evas object given a name by evas_object_name_set(), but
+ * it ONLY looks at the children of the object *p obj, and will only recurse
+ * into those children if @p recurse is greater than 0. If the name is not
+ * unique within immediate children (or the whole child tree) then it is not
+ * defined which child object will be returned. If @p recurse is set to -1 then
+ * it will recurse without limit.
+ *
+ * @since 1.2
+ *
+ * @ingroup Evas_Object_Group_Find
+ * 
+ *
+ * @param[in] name The given name.
+ * @param[in] recurse Set to the number of child levels to recurse (0 == don't recurse, 1 == only look at the children of @p obj or their immediate children, but no further etc.).
+ *
+ */
+EOAPI Evas_Object * evas_obj_name_child_find(const char *name, int recurse);
+
+/**
+ *
+ * Removes the grab on @p keyname key events by @p obj.
+ *
+ * Removes a key grab on @p obj if @p keyname, @p modifiers, and @p
+ * not_modifiers match.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip got here by key grabs
+ * @until }
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_key_grab
+ * @see evas_object_focus_set
+ * @see evas_object_focus_get
+ * @see evas_focus_get
+ * 
+ *
+ * @param[in] keyname the key the grab is set for.
+ * @param[in] modifiers a mask of modifiers that must be present to
+trigger the event.
+ * @param[in] not_modifiers a mask of modifiers that must not not be
+present to trigger the event.
+ *
+ */
+EOAPI void  evas_obj_key_ungrab(const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers);
+
+/**
+ *
+ * Lower @p obj to the bottom of its layer.
+ *
+ * @p obj will, then, be the lowest one in the layer it belongs
+ * to. Objects on other layers won't get touched.
+ *
+ * @see evas_object_stack_above()
+ * @see evas_object_stack_below()
+ * @see evas_object_raise()
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_lower(void);
+
+/**
+ *
+ * Disable/cease clipping on a clipped @p obj object.
+ *
+ * This function disables clipping for the object @p obj, if it was
+ * already clipped, i.e., its visibility and color get detached from
+ * the previous clipper. If it wasn't, this has no effect. The object
+ * @p obj must be a valid .Evas_Object.
+ *
+ * See also evas_object_clip_set() (for an example),
+ * evas_object_clipees_get() and evas_object_clip_get().
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_clip_unset(void);
+
+/**
+ *
+ * Moves all children objects of a given smart object relative to a
+ * given offset.
+ *
+ * This will make each of @p obj object's children to move, from where
+ * they before, with those delta values (offsets) on both directions.
+ *
+ * @note This is most useful on custom smart @c move() functions.
+ *
+ * @note Clipped smart objects already make use of this function on
+ * their @c move() smart function definition.
+ * 
+ *
+ * @param[in] dx horizontal offset (delta).
+ * @param[in] dy vertical offset (delta).
+ *
+ */
+EOAPI void  evas_obj_smart_move_children_relative(Evas_Coord dx, Evas_Coord dy);
+
+/**
+ *
+ * Checks whether a given smart object or any of its smart object
+ * parents is of a given smart class, <b>using pointer comparison</b>.
+ *
+ * @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+ * type, @c EINA_FALSE otherwise
+ *
+ * @see evas_object_smart_type_check() for more details
+ * @see eo_isa
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[in] type The type (name string) to check for. Must be the name
+ *
+ */
+EOAPI Eina_Bool  evas_obj_smart_type_check_ptr(const char *type);
+
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_IN;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_OUT;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_DOWN;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_UP;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_MOVE;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MOUSE_WHEEL;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MULTI_DOWN;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MULTI_UP;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MULTI_MOVE;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_FREE;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_KEY_DOWN;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_KEY_UP;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_FOCUS_IN;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_FOCUS_OUT;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_SHOW;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_HIDE;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_MOVE;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_RESIZE;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_RESTACK;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_DEL;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_HOLD;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_IMAGE_PRELOADED;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_IMAGE_RESIZE;
+EOAPI extern const Eo_Event_Description _EVAS_OBJECT_EVENT_IMAGE_UNLOADED;
+
+/**
+ * Mouse In Event
+ */
+#define EVAS_OBJECT_EVENT_MOUSE_IN (&(_EVAS_OBJECT_EVENT_MOUSE_IN))
+
+/**
+ * Mouse Out Event
+ */
+#define EVAS_OBJECT_EVENT_MOUSE_OUT (&(_EVAS_OBJECT_EVENT_MOUSE_OUT))
+
+/**
+ * Mouse Button Down Event
+ */
+#define EVAS_OBJECT_EVENT_MOUSE_DOWN (&(_EVAS_OBJECT_EVENT_MOUSE_DOWN))
+
+/**
+ * Mouse Button Up Event
+ */
+#define EVAS_OBJECT_EVENT_MOUSE_UP (&(_EVAS_OBJECT_EVENT_MOUSE_UP))
+
+/**
+ * Mouse Move Event
+ */
+#define EVAS_OBJECT_EVENT_MOUSE_MOVE (&(_EVAS_OBJECT_EVENT_MOUSE_MOVE))
+
+/**
+ * Mouse Wheel Event
+ */
+#define EVAS_OBJECT_EVENT_MOUSE_WHEEL (&(_EVAS_OBJECT_EVENT_MOUSE_WHEEL))
+
+/**
+ * Mouse-touch Down Event
+ */
+#define EVAS_OBJECT_EVENT_MULTI_DOWN (&(_EVAS_OBJECT_EVENT_MULTI_DOWN))
+
+/**
+ * Mouse-touch Up Event
+ */
+#define EVAS_OBJECT_EVENT_MULTI_UP (&(_EVAS_OBJECT_EVENT_MULTI_UP))
+
+/**
+ * Multi-touch Move Event
+ */
+#define EVAS_OBJECT_EVENT_MULTI_MOVE (&(_EVAS_OBJECT_EVENT_MULTI_MOVE))
+
+/**
+ * Object Being Freed (Called after Del)
+ */
+#define EVAS_OBJECT_EVENT_FREE (&(_EVAS_OBJECT_EVENT_FREE))
+
+/**
+ * Key Press Event
+ */
+#define EVAS_OBJECT_EVENT_KEY_DOWN (&(_EVAS_OBJECT_EVENT_KEY_DOWN))
+
+/**
+ * Key Release Event
+ */
+#define EVAS_OBJECT_EVENT_KEY_UP (&(_EVAS_OBJECT_EVENT_KEY_UP))
+
+/**
+ * Focus In Event
+ */
+#define EVAS_OBJECT_EVENT_FOCUS_IN (&(_EVAS_OBJECT_EVENT_FOCUS_IN))
+
+/**
+ * Focus Out Event
+ */
+#define EVAS_OBJECT_EVENT_FOCUS_OUT (&(_EVAS_OBJECT_EVENT_FOCUS_OUT))
+
+/**
+ * Show Event
+ */
+#define EVAS_OBJECT_EVENT_SHOW (&(_EVAS_OBJECT_EVENT_SHOW))
+
+/**
+ * Hide Event
+ */
+#define EVAS_OBJECT_EVENT_HIDE (&(_EVAS_OBJECT_EVENT_HIDE))
+
+/**
+ * Move Event
+ */
+#define EVAS_OBJECT_EVENT_MOVE (&(_EVAS_OBJECT_EVENT_MOVE))
+
+/**
+ * Resize Event
+ */
+#define EVAS_OBJECT_EVENT_RESIZE (&(_EVAS_OBJECT_EVENT_RESIZE))
+
+/**
+ * Restack Event
+ */
+#define EVAS_OBJECT_EVENT_RESTACK (&(_EVAS_OBJECT_EVENT_RESTACK))
+
+/**
+ * Object Being Deleted (called before Free)
+ */
+#define EVAS_OBJECT_EVENT_DEL (&(_EVAS_OBJECT_EVENT_DEL))
+
+/**
+ * Events go on/off hold
+ */
+#define EVAS_OBJECT_EVENT_HOLD (&(_EVAS_OBJECT_EVENT_HOLD))
+
+/**
+ * Size hints changed event
+ */
+#define EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS (&(_EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS))
+
+/**
+ * Image has been preloaded
+ */
+#define EVAS_OBJECT_EVENT_IMAGE_PRELOADED (&(_EVAS_OBJECT_EVENT_IMAGE_PRELOADED))
+
+/**
+ * Image resize
+ */
+#define EVAS_OBJECT_EVENT_IMAGE_RESIZE (&(_EVAS_OBJECT_EVENT_IMAGE_RESIZE))
+
+/**
+ * Image data has been unloaded (by some mechanism in Evas that throw out original image data)
+ */
+#define EVAS_OBJECT_EVENT_IMAGE_UNLOADED (&(_EVAS_OBJECT_EVENT_IMAGE_UNLOADED))
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_object.eo.hh b/src/lib/evas/canvas/evas_object.eo.hh
--- a/src/lib/evas/canvas/evas_object.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,5158 @@
+#ifndef EFL_GENERATED_EVAS_OBJECT_HH
+#define EFL_GENERATED_EVAS_OBJECT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_object.eo.h"
+}
+
+#include "evas_common_interface.eo.hh"
+#include <canvas/evas_object.eo.hh>
+#include <string>
+
+namespace evas {
+
+struct object
+      : efl::eo::base,
+      efl::eo::detail::extension_inheritance<evas::common_interface>::template type< ::evas::object>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit object(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit object(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   object(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : object(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   object(object const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~object() {}
+
+   /// @brief Get dbg information from the object.
+   ///
+   /// @param root_node node of the tree
+   ///
+   void dbg_info_get(Eo_Dbg_Info * root_node_) const
+   {
+      eo_do(_eo_ptr(), ::eo_dbg_info_get(root_node_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param ret 
+   ///
+   Evas * evas_get() const
+   {
+      Evas * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Retrieves the hints for an object's maximum size.
+   ///
+   /// These are hints on the maximum sizes @p obj should have. This is
+   /// not a size enforcement in any way, it's just a hint that should be
+   /// used whenever appropriate.
+   ///
+   /// @note Use @c NULL pointers on the hint components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_size_hint_max_set()
+   ///
+   /// @param w Integer to use as the maximum width hint.
+   /// @param h Integer to use as the maximum height hint.
+   ///
+   void size_hint_max_get(Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_max_get(w_, h_));
+   }
+
+   /// @brief Sets the hints for an object's maximum size.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// Values @c -1 will be treated as unset hint components, when queried
+   /// by managers.
+   ///
+   /// Example:
+   /// @dontinclude evas-hints.c
+   /// @skip evas_object_size_hint_max_set
+   /// @until return
+   ///
+   /// In this example the maximum size hints change the behavior of an
+   /// Evas box when layouting its children. See the full @ref
+   /// Example_Evas_Size_Hints "example".
+   ///
+   /// @see evas_object_size_hint_max_get()
+   ///
+   /// @param w Integer to use as the maximum width hint.
+   /// @param h Integer to use as the maximum height hint.
+   ///
+   void size_hint_max_set(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_max_set(w_, h_));
+   }
+
+   /// @brief Retrieves the hints for an object's optimum size.
+   ///
+   /// These are hints on the optimum sizes @p obj should have. This is
+   /// not a size enforcement in any way, it's just a hint that should be
+   /// used whenever appropriate.
+   ///
+   /// @note Use @c NULL pointers on the hint components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_size_hint_request_set()
+   ///
+   /// @param w Integer to use as the preferred width hint.
+   /// @param h Integer to use as the preferred height hint.
+   ///
+   void size_hint_request_get(Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_request_get(w_, h_));
+   }
+
+   /// @brief Sets the hints for an object's optimum size.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// Values @c 0 will be treated as unset hint components, when queried
+   /// by managers.
+   ///
+   /// @see evas_object_size_hint_request_get()
+   ///
+   /// @param w Integer to use as the preferred width hint.
+   /// @param h Integer to use as the preferred height hint.
+   ///
+   void size_hint_request_set(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_request_set(w_, h_));
+   }
+
+   /// @brief Retrieves whether or not the given Evas object is visible.
+   ///
+   /// @param v @c EINA_TRUE if to make the object visible, @c EINA_FALSE otherwise
+   ///
+   bool visibility_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_visibility_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Makes the given Evas object visible or invisible.
+   ///
+   /// @param v @c EINA_TRUE if to make the object visible, @c EINA_FALSE otherwise
+   ///
+   void visibility_set(bool v_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_visibility_set(efl::eolian::to_c(v_)));
+   }
+
+   /// @brief Retrieves the type of the given Evas object.
+   ///
+   /// @return The type of the object.
+   ///
+   /// For Evas' builtin types, the return strings will be one of:
+   /// - <c>"rectangle"</c>,
+   /// - <c>"line"</c>,
+   /// - <c>"polygon"</c>,
+   /// - <c>"text"</c>,
+   /// - <c>"textblock"</c> and
+   /// - <c>"image"</c>.
+   ///
+   /// For Evas smart objects (see @ref Evas_Smart_Group), the name of the
+   /// smart class itself is returned on this call. For the built-in smart
+   /// objects, these names are:
+   /// - <c>"EvasObjectSmartClipped"</c>, for the clipped smart object
+   /// - <c>"Evas_Object_Box"</c>, for the box object and
+   /// - <c>"Evas_Object_Table"</c>, for the table object.
+   ///
+   /// Example:
+   /// @dontinclude evas-object-manipulation.c
+   /// @skip d.img = evas_object_image_filled_add(d.canvas);
+   /// @until border on the
+   ///
+   /// See the full @ref Example_Evas_Object_Manipulation "example".
+   ///
+   /// @param type in
+   ///
+   std::string type_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_type_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets the type of the given Evas object.
+   ///
+   /// @param type in
+   ///
+   void type_set(std::string type_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_type_set(efl::eolian::to_c(type_)));
+   }
+
+   /// @brief Retrieves the hints for an object's minimum size.
+   ///
+   /// These are hints on the minimum sizes @p obj should have. This is
+   /// not a size enforcement in any way, it's just a hint that should be
+   /// used whenever appropriate.
+   ///
+   /// @note Use @c NULL pointers on the hint components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_size_hint_min_set() for an example
+   ///
+   /// @param w Integer to use as the minimum width hint.
+   /// @param h Integer to use as the minimum height hint.
+   ///
+   void size_hint_min_get(Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_min_get(w_, h_));
+   }
+
+   /// @brief Sets the hints for an object's minimum size.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// Values @c 0 will be treated as unset hint components, when queried
+   /// by managers.
+   ///
+   /// Example:
+   /// @dontinclude evas-hints.c
+   /// @skip evas_object_size_hint_min_set
+   /// @until return
+   ///
+   /// In this example the minimum size hints change the behavior of an
+   /// Evas box when layouting its children. See the full @ref
+   /// Example_Evas_Size_Hints "example".
+   ///
+   /// @see evas_object_size_hint_min_get()
+   ///
+   /// @param w Integer to use as the minimum width hint.
+   /// @param h Integer to use as the minimum height hint.
+   ///
+   void size_hint_min_set(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_min_set(w_, h_));
+   }
+
+   /// @brief Determine how pointer will behave.
+   /// @return pointer behavior.
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param pointer_mode desired behavior.
+   ///
+   Evas_Object_Pointer_Mode pointer_mode_get() const
+   {
+      Evas_Object_Pointer_Mode _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_pointer_mode_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set pointer behavior.
+   ///
+   /// This function has direct effect on event callbacks related to
+   /// mouse.
+   ///
+   /// If @p setting is EVAS_OBJECT_POINTER_MODE_AUTOGRAB, then when mouse
+   /// is down at this object, events will be restricted to it as source,
+   /// mouse moves, for example, will be emitted even if outside this
+   /// object area.
+   ///
+   /// If @p setting is EVAS_OBJECT_POINTER_MODE_NOGRAB, then events will
+   /// be emitted just when inside this object area.
+   ///
+   /// The default value is EVAS_OBJECT_POINTER_MODE_AUTOGRAB.
+   ///
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param pointer_mode desired behavior.
+   ///
+   void pointer_mode_set(Evas_Object_Pointer_Mode pointer_mode_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_pointer_mode_set(pointer_mode_));
+   }
+
+   /// @brief Retrieves the current value of the operation used for rendering the Evas object.
+   /// @return  one of the enumerated values in Evas_Render_Op.
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param render_op one of the Evas_Render_Op values.
+   ///
+   Evas_Render_Op render_op_get() const
+   {
+      Evas_Render_Op _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_render_op_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the render_op to be used for rendering the Evas object.
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param render_op one of the Evas_Render_Op values.
+   ///
+   void render_op_set(Evas_Render_Op render_op_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_render_op_set(render_op_));
+   }
+
+   /// @brief Determine whether an object is set to freeze (discard) events.
+   ///
+   /// @return freeze whether @p obj is set to freeze events (@c EINA_TRUE) or
+   /// not (@c EINA_FALSE)
+   ///
+   /// @see evas_object_freeze_events_set()
+   /// @see evas_object_pass_events_get()
+   /// @see evas_object_repeat_events_get()
+   /// @see evas_object_propagate_events_get()
+   /// @since 1.1
+   ///
+   /// @param freeze pass whether @p obj is to freeze events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   bool freeze_events_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_freeze_events_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set whether an Evas object is to freeze (discard) events.
+   ///
+   /// If @p freeze is @c EINA_TRUE, it will make events on @p obj to be @b
+   /// discarded. Unlike evas_object_pass_events_set(), events will not be
+   /// passed to @b next lower object. This API can be used for blocking
+   /// events while @p obj is on transiting.
+   ///
+   /// If @p freeze is @c EINA_FALSE, events will be processed on that
+   /// object as normal.
+   ///
+   /// @warning If you block only key/mouse up events with this API, we won't
+   /// guarantee the state of the object, that only had key/mouse down
+   /// events, will be.
+   ///
+   /// @see evas_object_freeze_events_get()
+   /// @see evas_object_pass_events_set()
+   /// @see evas_object_repeat_events_set()
+   /// @see evas_object_propagate_events_set()
+   /// @since 1.1
+   ///
+   /// @param freeze pass whether @p obj is to freeze events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   void freeze_events_set(bool freeze_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_freeze_events_set(efl::eolian::to_c(freeze_)));
+   }
+
+   /// @brief Get current object transformation map.
+   ///
+   /// This returns the current internal map set on the indicated object. It is
+   /// intended for read-only access and is only valid as long as the object is
+   /// not deleted or the map on the object is not changed. If you wish to modify
+   /// the map and set it back do the following:
+   ///
+   /// @code
+   /// const Evas_Map *m = evas_object_map_get(obj);
+   /// Evas_Map *m2 = evas_map_dup(m);
+   /// evas_map_util_rotate(m2, 30.0, 0, 0);
+   /// evas_object_map_set(obj, m2);
+   /// evas_map_free(m2);
+   /// @endcode
+   ///
+   /// @return map reference to map in use. This is an internal data structure, so
+   /// do not modify it.
+   ///
+   /// @see evas_object_map_set()
+   ///
+   /// @param map new map to use
+   ///
+   const Evas_Map * map_get() const
+   {
+      const Evas_Map * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_map_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set current object transformation map.
+   ///
+   /// This sets the map on a given object. It is copied from the @p map pointer,
+   /// so there is no need to keep the @p map object if you don't need it anymore.
+   ///
+   /// A map is a set of 4 points which have canvas x, y coordinates per point,
+   /// with an optional z point value as a hint for perspective correction, if it
+   /// is available. As well each point has u and v coordinates. These are like
+   /// "texture coordinates" in OpenGL in that they define a point in the source
+   /// image that is mapped to that map vertex/point. The u corresponds to the x
+   /// coordinate of this mapped point and v, the y coordinate. Note that these
+   /// coordinates describe a bounding region to sample. If you have a 200x100
+   /// source image and want to display it at 200x100 with proper pixel
+   /// precision, then do:
+   ///
+   /// @code
+   /// Evas_Map *m = evas_map_new(4);
+   /// evas_map_point_coord_set(m, 0,   0,   0, 0);
+   /// evas_map_point_coord_set(m, 1, 200,   0, 0);
+   /// evas_map_point_coord_set(m, 2, 200, 100, 0);
+   /// evas_map_point_coord_set(m, 3,   0, 100, 0);
+   /// evas_map_point_image_uv_set(m, 0,   0,   0);
+   /// evas_map_point_image_uv_set(m, 1, 200,   0);
+   /// evas_map_point_image_uv_set(m, 2, 200, 100);
+   /// evas_map_point_image_uv_set(m, 3,   0, 100);
+   /// evas_object_map_set(obj, m);
+   /// evas_map_free(m);
+   /// @endcode
+   ///
+   /// Note that the map points a uv coordinates match the image geometry. If
+   /// the @p map parameter is NULL, the stored map will be freed and geometry
+   /// prior to enabling/setting a map will be restored.
+   ///
+   /// @see evas_map_new()
+   ///
+   /// @param map new map to use
+   ///
+   void map_set(const Evas_Map * map_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_map_set(map_));
+   }
+
+   /// @brief Retrieves the hints for an object's aspect ratio.
+   ///
+   /// The different aspect ratio policies are documented in the
+   /// #Evas_Aspect_Control type. A container respecting these size hints
+   /// would @b resize its children accordingly to those policies.
+   ///
+   /// For any policy, if any of the given aspect ratio terms are @c 0,
+   /// the object's container should ignore the aspect and scale @p obj to
+   /// occupy the whole available area. If they are both positive
+   /// integers, that proportion will be respected, under each scaling
+   /// policy.
+   ///
+   /// These images illustrate some of the #Evas_Aspect_Control policies:
+   ///
+   /// @image html any-policy.png
+   /// @image rtf any-policy.png
+   /// @image latex any-policy.eps
+   ///
+   /// @image html aspect-control-none-neither.png
+   /// @image rtf aspect-control-none-neither.png
+   /// @image latex aspect-control-none-neither.eps
+   ///
+   /// @image html aspect-control-both.png
+   /// @image rtf aspect-control-both.png
+   /// @image latex aspect-control-both.eps
+   ///
+   /// @image html aspect-control-horizontal.png
+   /// @image rtf aspect-control-horizontal.png
+   /// @image latex aspect-control-horizontal.eps
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// @note Use @c NULL pointers on the hint components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// Example:
+   /// @dontinclude evas-aspect-hints.c
+   /// @skip if (strcmp(ev->key, "c") == 0)
+   /// @until }
+   ///
+   /// See the full @ref Example_Evas_Aspect_Hints "example".
+   ///
+   /// @see evas_object_size_hint_aspect_set()
+   ///
+   /// @param aspect The policy/type of aspect ratio to apply to @p obj.
+   /// @param w Integer to use as aspect width ratio term.
+   /// @param h Integer to use as aspect height ratio term.
+   ///
+   void size_hint_aspect_get(Evas_Aspect_Control* aspect_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_aspect_get(aspect_, w_, h_));
+   }
+
+   /// @brief Sets the hints for an object's aspect ratio.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that should
+   /// be used whenever appropriate.
+   ///
+   /// If any of the given aspect ratio terms are @c 0,
+   /// the object's container will ignore the aspect and scale @p obj to
+   /// occupy the whole available area, for any given policy.
+   ///
+   /// @see evas_object_size_hint_aspect_get() for more information.
+   ///
+   /// @param aspect The policy/type of aspect ratio to apply to @p obj.
+   /// @param w Integer to use as aspect width ratio term.
+   /// @param h Integer to use as aspect height ratio term.
+   ///
+   void size_hint_aspect_set(Evas_Aspect_Control aspect_, Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_aspect_set(aspect_, w_, h_));
+   }
+
+   /// @brief Retrieves the layer of its canvas that the given object is part of.
+   ///
+   /// @return  Number of its layer
+   ///
+   /// @see evas_object_layer_set()
+   ///
+   /// @param l The number of the layer to place the object on.
+   /// Must be between #EVAS_LAYER_MIN and #EVAS_LAYER_MAX.
+   ///
+   short layer_get() const
+   {
+      short _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_layer_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the layer of its canvas that the given object will be part of.
+   ///
+   /// If you don't use this function, you'll be dealing with an @b unique
+   /// layer of objects, the default one. Additional layers are handy when
+   /// you don't want a set of objects to interfere with another set with
+   /// regard to @b stacking. Two layers are completely disjoint in that
+   /// matter.
+   ///
+   /// This is a low-level function, which you'd be using when something
+   /// should be always on top, for example.
+   ///
+   /// @warning Be careful, it doesn't make sense to change the layer of
+   /// smart objects' children. Smart objects have a layer of their own,
+   /// which should contain all their children objects.
+   ///
+   /// @see evas_object_layer_get()
+   ///
+   /// @param l The number of the layer to place the object on.
+   /// Must be between #EVAS_LAYER_MIN and #EVAS_LAYER_MAX.
+   ///
+   void layer_set(short l_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_layer_set(l_));
+   }
+
+   /// @brief Get the object clipping @p obj (if any).
+   ///
+   /// This function returns the object clipping @p obj. If @p obj is
+   /// not being clipped at all, @c NULL is returned. The object @p obj
+   /// must be a valid .Evas_Object.
+   ///
+   /// See also evas_object_clip_set(), evas_object_clip_unset() and
+   /// evas_object_clipees_get().
+   ///
+   /// Example:
+   /// @dontinclude evas-object-manipulation.c
+   /// @skip if (evas_object_clip_get(d.img) == d.clipper)
+   /// @until return
+   ///
+   /// See the full @ref Example_Evas_Object_Manipulation "example".
+   ///
+   /// @param clip The object to clip @p obj by
+   ///
+   evas::object clip_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_clip_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Clip one object to another.
+   ///
+   /// This function will clip the object @p obj to the area occupied by
+   /// the object @p clip. This means the object @p obj will only be
+   /// visible within the area occupied by the clipping object (@p clip).
+   ///
+   /// The color of the object being clipped will be multiplied by the
+   /// color of the clipping one, so the resulting color for the former
+   /// will be <code>RESULT = (OBJ * CLIP) / (255 * 255)</code>, per color
+   /// element (red, green, blue and alpha).
+   ///
+   /// Clipping is recursive, so clipping objects may be clipped by
+   /// others, and their color will in term be multiplied. You may @b not
+   /// set up circular clipping lists (i.e. object 1 clips object 2, which
+   /// clips object 1): the behavior of Evas is undefined in this case.
+   ///
+   /// Objects which do not clip others are visible in the canvas as
+   /// normal; <b>those that clip one or more objects become invisible
+   /// themselves</b>, only affecting what they clip. If an object ceases
+   /// to have other objects being clipped by it, it will become visible
+   /// again.
+   ///
+   /// The visibility of an object affects the objects that are clipped by
+   /// it, so if the object clipping others is not shown (as in
+   /// evas_object_show()), the objects clipped by it will not be shown
+   /// either.
+   ///
+   /// If @p obj was being clipped by another object when this function is
+   /// called, it gets implicitly removed from the old clipper's domain
+   /// and is made now to be clipped by its new clipper.
+   ///
+   /// The following figure illustrates some clipping in Evas:
+   ///
+   /// @image html clipping.png
+   /// @image rtf clipping.png
+   /// @image latex clipping.eps
+   ///
+   /// @note At the moment the <b>only objects that can validly be used to
+   /// clip other objects are rectangle objects</b>. All other object
+   /// types are invalid and the result of using them is undefined. The
+   /// clip object @p clip must be a valid object, but can also be @c
+   /// NULL, in which case the effect of this function is the same as
+   /// calling evas_object_clip_unset() on the @p obj object.
+   ///
+   /// Example:
+   /// @dontinclude evas-object-manipulation.c
+   /// @skip solid white clipper (note that it's the default color for a
+   /// @until evas_object_show(d.clipper);
+   ///
+   /// See the full @ref Example_Evas_Object_Manipulation "example".
+   ///
+   /// @param clip The object to clip @p obj by
+   ///
+   void clip_set(evas::object clip_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_clip_set(efl::eolian::to_c(clip_)));
+   }
+
+   /// @brief Retrieves the hints for an object's padding space.
+   ///
+   /// Padding is extra space an object takes on each of its delimiting
+   /// rectangle sides, in canvas units. This space will be rendered
+   /// transparent, naturally, as in the following figure:
+   ///
+   /// @image html padding-hints.png
+   /// @image rtf padding-hints.png
+   /// @image latex padding-hints.eps
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// @note Use @c NULL pointers on the hint components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// Example:
+   /// @dontinclude evas-hints.c
+   /// @skip evas_object_size_hint_padding_set
+   /// @until return
+   ///
+   /// In this example the padding hints change the behavior of an Evas box
+   /// when layouting its children. See the full @ref
+   /// Example_Evas_Size_Hints "example".
+   ///
+   /// @see evas_object_size_hint_padding_set()
+   ///
+   /// @param l Integer to specify left padding.
+   /// @param r Integer to specify right padding.
+   /// @param t Integer to specify top padding.
+   /// @param b Integer to specify bottom padding.
+   ///
+   void size_hint_padding_get(Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_padding_get(l_, r_, t_, b_));
+   }
+
+   /// @brief Sets the hints for an object's padding space.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// @see evas_object_size_hint_padding_get() for more information
+   ///
+   /// @param l Integer to specify left padding.
+   /// @param r Integer to specify right padding.
+   /// @param t Integer to specify top padding.
+   /// @param b Integer to specify bottom padding.
+   ///
+   void size_hint_padding_set(Evas_Coord l_, Evas_Coord r_, Evas_Coord t_, Evas_Coord b_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_padding_set(l_, r_, t_, b_));
+   }
+
+   /// @brief Determine whether an object is set to repeat events.
+   ///
+   /// @return whether @p obj is set to repeat events (@c EINA_TRUE)
+   /// or not (@c EINA_FALSE)
+   ///
+   /// @see evas_object_repeat_events_set() for an example
+   /// @see evas_object_pass_events_get()
+   /// @see evas_object_propagate_events_get()
+   /// @see evas_object_freeze_events_get()
+   ///
+   /// @param repeat whether @p obj is to repeat events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   bool repeat_events_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_repeat_events_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set whether an Evas object is to repeat events.
+   ///
+   /// If @p repeat is @c EINA_TRUE, it will make events on @p obj to also
+   /// be repeated for the @b next lower object in the objects' stack (see
+   /// see evas_object_below_get()).
+   ///
+   /// If @p repeat is @c EINA_FALSE, events occurring on @p obj will be
+   /// processed only on it.
+   ///
+   /// Example:
+   /// @dontinclude evas-stacking.c
+   /// @skip if (strcmp(ev->key, "r") == 0)
+   /// @until }
+   ///
+   /// See the full @ref Example_Evas_Stacking "example".
+   ///
+   /// @see evas_object_repeat_events_get()
+   /// @see evas_object_pass_events_set()
+   /// @see evas_object_propagate_events_set()
+   /// @see evas_object_freeze_events_set()
+   ///
+   /// @param repeat whether @p obj is to repeat events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   void repeat_events_set(bool repeat_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_repeat_events_set(efl::eolian::to_c(repeat_)));
+   }
+
+   /// @brief Retrieves the hints for an object's weight.
+   ///
+   /// Accepted values are zero or positive values. Some users might use
+   /// this hint as a boolean, but some might consider it as a @b
+   /// proportion, see documentation of possible users, which in Evas are
+   /// the @ref Evas_Object_Box "box" and @ref Evas_Object_Table "table"
+   /// smart objects.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// @note Use @c NULL pointers on the hint components you're not
+   /// interested in: they'll be ignored by the function.
+   /// @note If @c obj is invalid, then the hint components will be set with 0.0
+   ///
+   /// @see evas_object_size_hint_weight_set() for an example
+   ///
+   /// @param x Nonnegative double value to use as horizontal weight hint.
+   /// @param y Nonnegative double value to use as vertical weight hint.
+   ///
+   void size_hint_weight_get(double* x_, double* y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_weight_get(x_, y_));
+   }
+
+   /// @brief Sets the hints for an object's weight.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// This is a hint on how a container object should @b resize a given
+   /// child within its area. Containers may adhere to the simpler logic
+   /// of just expanding the child object's dimensions to fit its own (see
+   /// the #EVAS_HINT_EXPAND helper weight macro) or the complete one of
+   /// taking each child's weight hint as real @b weights to how much of
+   /// its size to allocate for them in each axis. A container is supposed
+   /// to, after @b normalizing the weights of its children (with weight
+   /// hints), distribute the space it has to layout them by those factors
+   /// -- most weighted children get larger in this process than the least
+   /// ones.
+   ///
+   /// Example:
+   /// @dontinclude evas-hints.c
+   /// @skip evas_object_size_hint_weight_set
+   /// @until return
+   ///
+   /// In this example the weight hints change the behavior of an Evas box
+   /// when layouting its children. See the full @ref
+   /// Example_Evas_Size_Hints "example".
+   ///
+   /// @note Default weight hint values are 0.0, for both axis.
+   ///
+   /// @see evas_object_size_hint_weight_get() for more information
+   ///
+   /// @param x Nonnegative double value to use as horizontal weight hint.
+   /// @param y Nonnegative double value to use as vertical weight hint.
+   ///
+   void size_hint_weight_set(double x_, double y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_weight_set(x_, y_));
+   }
+
+   /// @brief Retrieves the name of the given Evas object.
+   ///
+   /// @return  The name of the object or @c NULL, if no name has been given
+   /// to it.
+   ///
+   /// Example:
+   /// @dontinclude evas-events.c
+   /// @skip fprintf(stdout, "An object got focused: %s\n",
+   /// @until evas_focus_get
+   ///
+   /// See the full @ref Example_Evas_Events "example".
+   ///
+   /// @param name The given name.
+   ///
+   std::string name_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_name_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets the name of the given Evas object to the given name.
+   ///
+   /// There might be occasions where one would like to name his/her
+   /// objects.
+   ///
+   /// Example:
+   /// @dontinclude evas-events.c
+   /// @skip d.bg = evas_object_rectangle_add(d.canvas);
+   /// @until evas_object_name_set(d.bg, "our dear rectangle");
+   ///
+   /// See the full @ref Example_Evas_Events "example".
+   ///
+   /// @param name The given name.
+   ///
+   void name_set(std::string name_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_name_set(efl::eolian::to_c(name_)));
+   }
+
+   /// @brief Retrieves the scaling factor for the given Evas object.
+   ///
+   /// @return  The scaling factor.
+   ///
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @see evas_object_scale_set()
+   ///
+   /// @param scale The scaling factor. <c>1.0</c> means no scaling,
+   /// default size.
+   ///
+   double scale_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_scale_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the scaling factor for an Evas object. Does not affect all
+   /// objects.
+   ///
+   /// This will multiply the object's dimension by the given factor, thus
+   /// altering its geometry (width and height). Useful when you want
+   /// scalable UI elements, possibly at run time.
+   ///
+   /// @note Only text and textblock objects have scaling change
+   /// handlers. Other objects won't change visually on this call.
+   ///
+   /// @see evas_object_scale_get()
+   ///
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param scale The scaling factor. <c>1.0</c> means no scaling,
+   /// default size.
+   ///
+   void scale_set(double scale_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_scale_set(scale_));
+   }
+
+   /// @brief Get the "static clipper" hint flag for a given Evas object.
+   ///
+   /// @return @c EINA_TRUE if it's set as a static clipper,
+   /// @c EINA_FALSE otherwise.
+   ///
+   /// @see evas_object_static_clip_set() for more details
+   ///
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param is_static_clip @c EINA_TRUE if it's to be used as a static
+   /// clipper, @c EINA_FALSE otherwise.
+   ///
+   bool static_clip_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_static_clip_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set a hint flag on the given Evas object that it's used as a "static
+   /// clipper".
+   ///
+   /// This is a hint to Evas that this object is used as a big static
+   /// clipper and shouldn't be moved with children and otherwise
+   /// considered specially. The default value for new objects is
+   /// @c EINA_FALSE.
+   ///
+   /// @see evas_object_static_clip_get()
+   ///
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param is_static_clip @c EINA_TRUE if it's to be used as a static
+   /// clipper, @c EINA_FALSE otherwise.
+   ///
+   void static_clip_set(bool is_static_clip_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_static_clip_set(efl::eolian::to_c(is_static_clip_)));
+   }
+
+   /// @brief Retrieves the (rectangular) size of the given Evas object.
+   ///
+   /// @param w in
+   /// @param h in
+   ///
+   void size_get(Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_get(w_, h_));
+   }
+
+   /// @brief Changes the size of the given Evas object.
+   ///
+   /// @param w in
+   /// @param h in
+   ///
+   void size_set(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_set(w_, h_));
+   }
+
+   /// @brief Retrieve whether an object has the focus.
+   ///
+   /// @return @c EINA_TRUE if the object has the focus, @c EINA_FALSE otherwise.
+   ///
+   /// If the passed object is the currently focused one, @c EINA_TRUE is
+   /// returned. @c EINA_FALSE is returned, otherwise.
+   ///
+   /// Example:
+   /// @dontinclude evas-events.c
+   /// @skip And again
+   /// @until something is bad
+   ///
+   /// See the full example @ref Example_Evas_Events "here".
+   ///
+   /// @see evas_object_focus_set
+   /// @see evas_focus_get
+   /// @see evas_object_key_grab
+   /// @see evas_object_key_ungrab
+   ///
+   /// @param focus @c EINA_TRUE, to set it as focused or @c EINA_FALSE,
+   /// to take away the focus from it.
+   ///
+   bool focus_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_focus_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets or unsets a given object as the currently focused one on its
+   /// canvas.
+   ///
+   /// Changing focus only affects where (key) input events go. There can
+   /// be only one object focused at any time. If @p focus is @c EINA_TRUE,
+   /// @p obj will be set as the currently focused object and it will
+   /// receive all keyboard events that are not exclusive key grabs on
+   /// other objects.
+   ///
+   /// Example:
+   /// @dontinclude evas-events.c
+   /// @skip evas_object_focus_set
+   /// @until evas_object_focus_set
+   ///
+   /// See the full example @ref Example_Evas_Events "here".
+   ///
+   /// @see evas_object_focus_get
+   /// @see evas_focus_get
+   /// @see evas_object_key_grab
+   /// @see evas_object_key_ungrab
+   ///
+   /// @param focus @c EINA_TRUE, to set it as focused or @c EINA_FALSE,
+   /// to take away the focus from it.
+   ///
+   void focus_set(bool focus_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_focus_set(efl::eolian::to_c(focus_)));
+   }
+
+   /// @brief @since 1.2
+   ///
+   /// @param is_frame in
+   ///
+   bool is_frame_object_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_is_frame_object_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @since 1.2
+   ///
+   /// @param is_frame in
+   ///
+   void is_frame_object_set(bool is_frame_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_is_frame_object_set(efl::eolian::to_c(is_frame_)));
+   }
+
+   /// @brief Get the map enabled state
+   ///
+   /// This returns the currently enabled state of the map on the object indicated.
+   /// The default map enable state is off. You can enable and disable it with
+   /// evas_object_map_enable_set().
+   ///
+   /// @return the map enabled state
+   ///
+   /// @param enabled enabled state
+   ///
+   bool map_enable_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_map_enable_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Enable or disable the map that is set.
+   ///
+   /// Enable or disable the use of map for the object @p obj.
+   /// On enable, the object geometry will be saved, and the new geometry will
+   /// change (position and size) to reflect the map geometry set.
+   ///
+   /// If the object doesn't have a map set (with evas_object_map_set()), the
+   /// initial geometry will be undefined. It is advised to always set a map
+   /// to the object first, and then call this function to enable its use.
+   ///
+   /// @param enabled enabled state
+   ///
+   void map_enable_set(bool enabled_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_map_enable_set(efl::eolian::to_c(enabled_)));
+   }
+
+   /// @brief Determine whether an object is set to use precise point collision
+   /// detection.
+   ///
+   /// @return whether @p obj is set to use precise point collision
+   /// detection or not The default value is false.
+   ///
+   /// @see evas_object_precise_is_inside_set() for an example
+   ///
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param precise Whether to use precise point collision detection or
+   /// not. The default value is false.
+   ///
+   bool precise_is_inside_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_precise_is_inside_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set whether to use precise (usually expensive) point collision
+   /// detection for a given Evas object.
+   ///
+   /// Use this function to make Evas treat objects' transparent areas as
+   /// @b not belonging to it with regard to mouse pointer events. By
+   /// default, all of the object's boundary rectangle will be taken in
+   /// account for them.
+   ///
+   /// @warning By using precise point collision detection you'll be
+   /// making Evas more resource intensive.
+   ///
+   /// Example code follows.
+   /// @dontinclude evas-events.c
+   /// @skip if (strcmp(ev->key, "p") == 0)
+   /// @until }
+   ///
+   /// See the full example @ref Example_Evas_Events "here".
+   ///
+   /// @see evas_object_precise_is_inside_get()
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param precise Whether to use precise point collision detection or
+   /// not. The default value is false.
+   ///
+   void precise_is_inside_set(bool precise_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_precise_is_inside_set(efl::eolian::to_c(precise_)));
+   }
+
+   /// @brief Retrieves the hints for on object's alignment.
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// @note Use @c NULL pointers on the hint components you're not
+   /// interested in: they'll be ignored by the function.
+   /// @note If @c obj is invalid, then the hint components will be set with 0.5
+   ///
+   /// @see evas_object_size_hint_align_set() for more information
+   ///
+   /// @param x Double, ranging from @c 0.0 to @c 1.0 or with the
+   /// special value #EVAS_HINT_FILL, to use as horizontal alignment hint.
+   /// @param y Double, ranging from @c 0.0 to @c 1.0 or with the
+   /// special value #EVAS_HINT_FILL, to use as vertical alignment hint.
+   ///
+   void size_hint_align_get(double* x_, double* y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_align_get(x_, y_));
+   }
+
+   /// @brief Sets the hints for an object's alignment.
+   ///
+   /// These are hints on how to align an object <b>inside the boundaries
+   /// of a container/manager</b>. Accepted values are in the @c 0.0 to @c
+   /// 1.0 range, with the special value #EVAS_HINT_FILL used to specify
+   /// "justify" or "fill" by some users. In this case, maximum size hints
+   /// should be enforced with higher priority, if they are set. Also, any
+   /// padding hint set on objects should add up to the alignment space on
+   /// the final scene composition.
+   ///
+   /// See documentation of possible users: in Evas, they are the @ref
+   /// Evas_Object_Box "box" and @ref Evas_Object_Table "table" smart
+   /// objects.
+   ///
+   /// For the horizontal component, @c 0.0 means to the left, @c 1.0
+   /// means to the right. Analogously, for the vertical component, @c 0.0
+   /// to the top, @c 1.0 means to the bottom.
+   ///
+   /// See the following figure:
+   ///
+   /// @image html alignment-hints.png
+   /// @image rtf alignment-hints.png
+   /// @image latex alignment-hints.eps
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// should be used whenever appropriate.
+   ///
+   /// @note Default alignment hint values are 0.5, for both axis.
+   ///
+   /// Example:
+   /// @dontinclude evas-hints.c
+   /// @skip evas_object_size_hint_align_set
+   /// @until return
+   ///
+   /// In this example the alignment hints change the behavior of an Evas
+   /// box when layouting its children. See the full @ref
+   /// Example_Evas_Size_Hints "example".
+   ///
+   /// @see evas_object_size_hint_align_get()
+   /// @see evas_object_size_hint_max_set()
+   /// @see evas_object_size_hint_padding_set()
+   ///
+   /// @param x Double, ranging from @c 0.0 to @c 1.0 or with the
+   /// special value #EVAS_HINT_FILL, to use as horizontal alignment hint.
+   /// @param y Double, ranging from @c 0.0 to @c 1.0 or with the
+   /// special value #EVAS_HINT_FILL, to use as vertical alignment hint.
+   ///
+   void size_hint_align_set(double x_, double y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_align_set(x_, y_));
+   }
+
+   /// @brief Retrieve whether an Evas object is set to propagate events.
+   ///
+   /// @return whether @p obj is set to propagate events (@c EINA_TRUE)
+   /// or not (@c EINA_FALSE)
+   ///
+   /// @see evas_object_propagate_events_set()
+   /// @see evas_object_repeat_events_get()
+   /// @see evas_object_pass_events_get()
+   /// @see evas_object_freeze_events_get()
+   ///
+   /// @param propagate whether to propagate events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   bool propagate_events_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_propagate_events_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set whether events on a smart object's member should get propagated
+   /// up to its parent.
+   ///
+   /// This function has @b no effect if @p obj is not a member of a smart
+   /// object.
+   ///
+   /// If @p prop is @c EINA_TRUE, events occurring on this object will be
+   /// propagated on to the smart object of which @p obj is a member.  If
+   /// @p prop is @c EINA_FALSE, events occurring on this object will @b
+   /// not be propagated on to the smart object of which @p obj is a
+   /// member.  The default value is @c EINA_TRUE.
+   ///
+   /// @see evas_object_propagate_events_get()
+   /// @see evas_object_repeat_events_set()
+   /// @see evas_object_pass_events_set()
+   /// @see evas_object_freeze_events_set()
+   ///
+   /// @param propagate whether to propagate events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   void propagate_events_set(bool propagate_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_propagate_events_set(efl::eolian::to_c(propagate_)));
+   }
+
+   /// @brief Determine whether an object is set to pass (ignore) events.
+   ///
+   /// @return pass whether @p obj is set to pass events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   /// Example:
+   /// @dontinclude evas-stacking.c
+   /// @skip if (strcmp(ev->key, "p") == 0)
+   /// @until }
+   ///
+   /// See the full @ref Example_Evas_Stacking "example".
+   ///
+   /// @see evas_object_pass_events_set()
+   /// @see evas_object_repeat_events_get()
+   /// @see evas_object_propagate_events_get()
+   /// @see evas_object_freeze_events_get()
+   ///
+   /// @param pass whether @p obj is to pass events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   bool pass_events_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_pass_events_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set whether an Evas object is to pass (ignore) events.
+   ///
+   /// If @p pass is @c EINA_TRUE, it will make events on @p obj to be @b
+   /// ignored. They will be triggered on the @b next lower object (that
+   /// is not set to pass events), instead (see evas_object_below_get()).
+   ///
+   /// If @p pass is @c EINA_FALSE, events will be processed on that
+   /// object as normal.
+   ///
+   /// @see evas_object_pass_events_get() for an example
+   /// @see evas_object_repeat_events_set()
+   /// @see evas_object_propagate_events_set()
+   /// @see evas_object_freeze_events_set()
+   ///
+   /// @param pass whether @p obj is to pass events (@c EINA_TRUE) or not
+   /// (@c EINA_FALSE)
+   ///
+   void pass_events_set(bool pass_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_pass_events_set(efl::eolian::to_c(pass_)));
+   }
+
+   /// @brief Retrieves the position of the given Evas object.
+   ///
+   /// @param x in
+   /// @param y in
+   ///
+   void position_get(Evas_Coord* x_, Evas_Coord* y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_position_get(x_, y_));
+   }
+
+   /// @brief Move the given Evas object to the given location inside its canvas' viewport.
+   ///
+   /// @param x in
+   /// @param y in
+   ///
+   void position_set(Evas_Coord x_, Evas_Coord y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_position_set(x_, y_));
+   }
+
+   /// @brief Retrieves whether or not the given Evas object is to be drawn anti_aliased.
+   /// @return  (@c EINA_TRUE) if the object is to be anti_aliased.  (@c EINA_FALSE) otherwise.
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param anti_alias (@c EINA_TRUE) if the object is to be anti_aliased, (@c EINA_FALSE) otherwise.
+   ///
+   bool anti_alias_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_anti_alias_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets whether or not the given Evas object is to be drawn anti-aliased.
+   ///
+   /// @ingroup Evas_Object_Group_Extras
+   ///
+   /// @param anti_alias (@c EINA_TRUE) if the object is to be anti_aliased, (@c EINA_FALSE) otherwise.
+   ///
+   void anti_alias_set(bool anti_alias_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_anti_alias_set(efl::eolian::to_c(anti_alias_)));
+   }
+
+   /// @brief Retrieves the general/main color of the given Evas object.
+   ///
+   /// Retrieves the main color's RGB component (and alpha channel)
+   /// values, <b>which range from 0 to 255</b>. For the alpha channel,
+   /// which defines the object's transparency level, 0 means totally
+   /// transparent, while 255 means opaque. These color values are
+   /// premultiplied by the alpha value.
+   ///
+   /// Usually youll use this attribute for text and rectangle objects,
+   /// where the main color is their unique one. If set for objects
+   /// which themselves have colors, like the images one, those colors get
+   /// modulated by this one.
+   ///
+   /// @note All newly created Evas rectangles get the default color
+   /// values of <code>255 255 255 255</code> (opaque white).
+   ///
+   /// @note Use @c NULL pointers on the components you're not interested
+   /// in: they'll be ignored by the function.
+   ///
+   /// Example:
+   /// @dontinclude evas-object-manipulation.c
+   /// @skip int alpha, r, g, b;
+   /// @until return
+   ///
+   /// See the full @ref Example_Evas_Object_Manipulation "example".
+   ///
+   /// @ingroup Evas_Object_Group_Basic
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void color_get(int* r_, int* g_, int* b_, int* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_color_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Sets the general/main color of the given Evas object to the given
+   /// one.
+   ///
+   /// @see evas_object_color_get() (for an example)
+   /// @note These color values are expected to be premultiplied by @p a.
+   ///
+   /// @ingroup Evas_Object_Group_Basic
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void color_set(int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_color_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Retrieve user data stored on a given smart object.
+   ///
+   /// @return A pointer to data stored using
+   /// evas_object_smart_data_set(), or @c NULL, if none has been
+   /// set.
+   ///
+   /// @see evas_object_smart_data_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void * smart_data_get() const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_data_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the clipper object for the given clipped smart object.
+   ///
+   /// @return the clipper object.
+   ///
+   /// Use this function if you want to change any of this clipper's
+   /// properties, like colors.
+   ///
+   /// @see evas_object_smart_clipped_smart_add()
+   ///
+   evas::object smart_clipped_clipper_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_clipped_clipper_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the Evas object stacked right below @p obj
+   ///
+   /// @return the #Evas_Object directly below @p obj, if any, or @c NULL,
+   /// if none
+   ///
+   /// This function will traverse layers in its search, if there are
+   /// objects on layers below the one @p obj is placed at.
+   ///
+   /// @see evas_object_layer_get()
+   /// @see evas_object_layer_set()
+   /// @see evas_object_below_get()
+   ///
+   evas::object below_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_below_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Return a list of objects currently clipped by @p obj.
+   ///
+   /// @return a list of objects being clipped by @p obj
+   ///
+   /// This returns the internal list handle that contains all objects
+   /// clipped by the object @p obj. If none are clipped by it, the call
+   /// returns @c NULL. This list is only valid until the clip list is
+   /// changed and should be fetched again with another call to
+   /// evas_object_clipees_get() if any objects being clipped by this
+   /// object are unclipped, clipped by a new object, deleted or get the
+   /// clipper deleted. These operations will invalidate the list
+   /// returned, so it should not be used anymore after that point. Any
+   /// use of the list after this may have undefined results, possibly
+   /// leading to crashes. The object @p obj must be a valid
+   /// .Evas_Object.
+   ///
+   /// See also evas_object_clip_set(), evas_object_clip_unset() and
+   /// evas_object_clip_get().
+   ///
+   /// Example:
+   /// @code
+   /// extern Evas_Object *obj;
+   /// Evas_Object *clipper;
+   ///
+   /// clipper = evas_object_clip_get(obj);
+   /// if (clipper)
+   /// {
+   /// Eina_List *clippees, *l;
+   /// Evas_Object *obj_tmp;
+   ///
+   /// clippees = evas_object_clipees_get(clipper);
+   /// printf("Clipper clips %i objects\n", eina_list_count(clippees));
+   /// EINA_LIST_FOREACH(clippees, l, obj_tmp)
+   /// evas_object_show(obj_tmp);
+   /// }
+   /// @endcode
+   ///
+   efl::eina::crange_list< evas::object > clipees_get() const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_clipees_get());
+      return efl::eolian::to_cxx<efl::eina::crange_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief Gets the parent smart object of a given Evas object, if it has one.
+   ///
+   /// @return Returns the parent smart object of @a obj or @c NULL, if @a
+   /// obj is not a smart member of any
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   evas::object smart_parent_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_parent_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get the Evas object stacked right above @p obj
+   ///
+   /// @return the #Evas_Object directly above @p obj, if any, or @c NULL,
+   /// if none
+   ///
+   /// This function will traverse layers in its search, if there are
+   /// objects on layers above the one @p obj is placed at.
+   ///
+   /// @see evas_object_layer_get()
+   /// @see evas_object_layer_set()
+   /// @see evas_object_below_get()
+   ///
+   evas::object above_get() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_above_get());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieves the hints for an object's display mode
+   ///
+   /// These are hints on the display mode @p obj. This is
+   /// not a size enforcement in any way, it's just a hint that can be
+   /// used whenever appropriate.
+   /// This mode can be used object's display mode like commpress or expand
+   ///
+   /// @param dispmode display mode hint
+   ///
+   Evas_Display_Mode size_hint_display_mode_get() const
+   {
+      Evas_Display_Mode _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_size_hint_display_mode_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the hints for an object's disply mode
+   ///
+   /// This is not a size enforcement in any way, it's just a hint that
+   /// can be used whenever appropriate.
+   ///
+   /// @param dispmode display mode hint
+   ///
+   void size_hint_display_mode_set(Evas_Display_Mode dispmode_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_hint_display_mode_set(dispmode_));
+   }
+
+   /// @brief Test if any object is clipped by @p obj.
+   ///
+   /// @return EINA_TRUE if @p obj clip any object.
+   /// @since 1.8
+   ///
+   bool clipees_has() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_clipees_has());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Requests @p keyname key events be directed to @p obj.
+   ///
+   /// @return @c EINA_TRUE, if the call succeeded, @c EINA_FALSE otherwise.
+   ///
+   /// Key grabs allow one or more objects to receive key events for
+   /// specific key strokes even if other objects have focus. Whenever a
+   /// key is grabbed, only the objects grabbing it will get the events
+   /// for the given keys.
+   ///
+   /// @p keyname is a platform dependent symbolic name for the key
+   /// pressed (see @ref Evas_Keys for more information).
+   ///
+   /// @p modifiers and @p not_modifiers are bit masks of all the
+   /// modifiers that must and mustn't, respectively, be pressed along
+   /// with @p keyname key in order to trigger this new key
+   /// grab. Modifiers can be things such as Shift and Ctrl as well as
+   /// user defined types via evas_key_modifier_add(). Retrieve them with
+   /// evas_key_modifier_mask_get() or use @c 0 for empty masks.
+   ///
+   /// @p exclusive will make the given object the only one permitted to
+   /// grab the given key. If given @c EINA_TRUE, subsequent calls on this
+   /// function with different @p obj arguments will fail, unless the key
+   /// is ungrabbed again.
+   ///
+   /// Example code follows.
+   /// @dontinclude evas-events.c
+   /// @skip if (d.focus)
+   /// @until else
+   ///
+   /// See the full example @ref Example_Evas_Events "here".
+   ///
+   /// @warning Providing impossible modifier sets creates undefined behavior
+   ///
+   /// @see evas_object_key_ungrab
+   /// @see evas_object_focus_set
+   /// @see evas_object_focus_get
+   /// @see evas_focus_get
+   /// @see evas_key_modifier_add
+   ///
+   /// @param keyname the key to request events for.
+   /// @param modifiers a mask of modifiers that must be present to
+   /// trigger the event.
+   /// @param not_modifiers a mask of modifiers that must @b not be present
+   /// to trigger the event.
+   /// @param exclusive request that the @p obj is the only object
+   /// receiving the @p keyname events.
+   ///
+   bool key_grab(std::string keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_, bool exclusive_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_key_grab(efl::eolian::to_c(keyname_), modifiers_, not_modifiers_, efl::eolian::to_c(exclusive_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Stack @p obj immediately below @p below
+   ///
+   /// Objects, in a given canvas, are stacked in the order they get added
+   /// to it.  This means that, if they overlap, the highest ones will
+   /// cover the lowest ones, in that order. This function is a way to
+   /// change the stacking order for the objects.
+   ///
+   /// This function is intended to be used with <b>objects belonging to
+   /// the same layer</b> in a given canvas, otherwise it will fail (and
+   /// accomplish nothing).
+   ///
+   /// If you have smart objects on your canvas and @p obj is a member of
+   /// one of them, then @p below must also be a member of the same
+   /// smart object.
+   ///
+   /// Similarly, if @p obj is not a member of a smart object, @p below
+   /// must not be either.
+   ///
+   /// @see evas_object_layer_get()
+   /// @see evas_object_layer_set()
+   /// @see evas_object_stack_below()
+   ///
+   /// @param below the object below which to stack
+   ///
+   void stack_below(evas::object below_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_stack_below(efl::eolian::to_c(below_)));
+   }
+
+   /// @brief Raise @p obj to the top of its layer.
+   ///
+   /// @p obj will, then, be the highest one in the layer it belongs
+   /// to. Object on other layers won't get touched.
+   ///
+   /// @see evas_object_stack_above()
+   /// @see evas_object_stack_below()
+   /// @see evas_object_lower()
+   ///
+   void raise() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_raise());
+   }
+
+   /// @brief Stack @p obj immediately above @p above
+   ///
+   /// Objects, in a given canvas, are stacked in the order they get added
+   /// to it.  This means that, if they overlap, the highest ones will
+   /// cover the lowest ones, in that order. This function is a way to
+   /// change the stacking order for the objects.
+   ///
+   /// This function is intended to be used with <b>objects belonging to
+   /// the same layer</b> in a given canvas, otherwise it will fail (and
+   /// accomplish nothing).
+   ///
+   /// If you have smart objects on your canvas and @p obj is a member of
+   /// one of them, then @p above must also be a member of the same
+   /// smart object.
+   ///
+   /// Similarly, if @p obj is not a member of a smart object, @p above
+   /// must not be either.
+   ///
+   /// @see evas_object_layer_get()
+   /// @see evas_object_layer_set()
+   /// @see evas_object_stack_below()
+   ///
+   /// @param above the object above which to stack
+   ///
+   void stack_above(evas::object above_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_stack_above(efl::eolian::to_c(above_)));
+   }
+
+   /// @brief Checks whether a given smart object or any of its smart object
+   /// parents is of a given smart class.
+   ///
+   /// @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+   /// type, @c EINA_FALSE otherwise
+   ///
+   /// If @p obj is not a smart object, this call will fail
+   /// immediately.
+   ///
+   /// This function supports Eo and legacy inheritance mechanisms. However,
+   /// it is recommended to use eo_isa instead if your object is using Eo from
+   /// top to bottom.
+   ///
+   /// The checks use smart classes names and <b>string
+   /// comparison</b>. There is a version of this same check using
+   /// <b>pointer comparison</b>, since a smart class' name is a single
+   /// string in Evas.
+   ///
+   /// @see evas_object_smart_type_check_ptr()
+   /// @see eo_isa
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param type The @b name (type) of the smart class to check for
+   ///
+   bool smart_type_check(std::string type_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check(efl::eolian::to_c(type_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieves the object from children of the given object with the given name.
+   /// @return  If successful, the Evas object with the given name.  Otherwise,
+   /// @c NULL.
+   ///
+   /// This looks for the evas object given a name by evas_object_name_set(), but
+   /// it ONLY looks at the children of the object *p obj, and will only recurse
+   /// into those children if @p recurse is greater than 0. If the name is not
+   /// unique within immediate children (or the whole child tree) then it is not
+   /// defined which child object will be returned. If @p recurse is set to -1 then
+   /// it will recurse without limit.
+   ///
+   /// @since 1.2
+   ///
+   /// @ingroup Evas_Object_Group_Find
+   ///
+   /// @param name The given name.
+   /// @param recurse Set to the number of child levels to recurse (0 == don't recurse, 1 == only look at the children of @p obj or their immediate children, but no further etc.).
+   ///
+   evas::object name_child_find(std::string name_, int recurse_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_name_child_find(efl::eolian::to_c(name_), recurse_));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Removes the grab on @p keyname key events by @p obj.
+   ///
+   /// Removes a key grab on @p obj if @p keyname, @p modifiers, and @p
+   /// not_modifiers match.
+   ///
+   /// Example code follows.
+   /// @dontinclude evas-events.c
+   /// @skip got here by key grabs
+   /// @until }
+   ///
+   /// See the full example @ref Example_Evas_Events "here".
+   ///
+   /// @see evas_object_key_grab
+   /// @see evas_object_focus_set
+   /// @see evas_object_focus_get
+   /// @see evas_focus_get
+   ///
+   /// @param keyname the key the grab is set for.
+   /// @param modifiers a mask of modifiers that must be present to
+   /// trigger the event.
+   /// @param not_modifiers a mask of modifiers that must not not be
+   /// present to trigger the event.
+   ///
+   void key_ungrab(std::string keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_key_ungrab(efl::eolian::to_c(keyname_), modifiers_, not_modifiers_));
+   }
+
+   /// @brief Lower @p obj to the bottom of its layer.
+   ///
+   /// @p obj will, then, be the lowest one in the layer it belongs
+   /// to. Objects on other layers won't get touched.
+   ///
+   /// @see evas_object_stack_above()
+   /// @see evas_object_stack_below()
+   /// @see evas_object_raise()
+   ///
+   void lower() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_lower());
+   }
+
+   /// @brief Disable/cease clipping on a clipped @p obj object.
+   ///
+   /// This function disables clipping for the object @p obj, if it was
+   /// already clipped, i.e., its visibility and color get detached from
+   /// the previous clipper. If it wasn't, this has no effect. The object
+   /// @p obj must be a valid .Evas_Object.
+   ///
+   /// See also evas_object_clip_set() (for an example),
+   /// evas_object_clipees_get() and evas_object_clip_get().
+   ///
+   void clip_unset() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_clip_unset());
+   }
+
+   /// @brief Moves all children objects of a given smart object relative to a
+   /// given offset.
+   ///
+   /// This will make each of @p obj object's children to move, from where
+   /// they before, with those delta values (offsets) on both directions.
+   ///
+   /// @note This is most useful on custom smart @c move() functions.
+   ///
+   /// @note Clipped smart objects already make use of this function on
+   /// their @c move() smart function definition.
+   ///
+   /// @param dx horizontal offset (delta).
+   /// @param dy vertical offset (delta).
+   ///
+   void smart_move_children_relative(Evas_Coord dx_, Evas_Coord dy_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_move_children_relative(dx_, dy_));
+   }
+
+   /// @brief Checks whether a given smart object or any of its smart object
+   /// parents is of a given smart class, <b>using pointer comparison</b>.
+   ///
+   /// @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+   /// type, @c EINA_FALSE otherwise
+   ///
+   /// @see evas_object_smart_type_check() for more details
+   /// @see eo_isa
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param type The type (name string) to check for. Must be the name
+   ///
+   bool smart_type_check_ptr(std::string type_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check_ptr(efl::eolian::to_c(type_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_in_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_IN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_IN );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_in_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_IN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_out_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_OUT, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_OUT );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_out_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_OUT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_down_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_UP );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_up_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_move_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_MOVE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_MOVE );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_move_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_MOVE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_wheel_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_WHEEL, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_WHEEL );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_wheel_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_WHEEL, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_multi_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MULTI_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MULTI_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_multi_down_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MULTI_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_multi_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MULTI_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MULTI_UP );
+   }
+
+   template <typename T>
+   void
+   callback_multi_up_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MULTI_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_multi_move_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MULTI_MOVE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MULTI_MOVE );
+   }
+
+   template <typename T>
+   void
+   callback_multi_move_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MULTI_MOVE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_free_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_FREE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_FREE );
+   }
+
+   template <typename T>
+   void
+   callback_free_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_FREE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_key_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_KEY_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_KEY_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_key_down_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_KEY_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_key_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_KEY_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_KEY_UP );
+   }
+
+   template <typename T>
+   void
+   callback_key_up_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_KEY_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_focus_in_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_FOCUS_IN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_FOCUS_IN );
+   }
+
+   template <typename T>
+   void
+   callback_focus_in_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_FOCUS_IN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_focus_out_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_FOCUS_OUT, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_FOCUS_OUT );
+   }
+
+   template <typename T>
+   void
+   callback_focus_out_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_FOCUS_OUT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_show_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_SHOW, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_SHOW );
+   }
+
+   template <typename T>
+   void
+   callback_show_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_SHOW, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_hide_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_HIDE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_HIDE );
+   }
+
+   template <typename T>
+   void
+   callback_hide_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_HIDE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_move_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOVE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOVE );
+   }
+
+   template <typename T>
+   void
+   callback_move_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOVE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_resize_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_RESIZE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_RESIZE );
+   }
+
+   template <typename T>
+   void
+   callback_resize_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_RESIZE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_restack_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_RESTACK, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_RESTACK );
+   }
+
+   template <typename T>
+   void
+   callback_restack_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_RESTACK, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_del_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_DEL, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_DEL );
+   }
+
+   template <typename T>
+   void
+   callback_del_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_DEL, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_hold_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_HOLD, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_HOLD );
+   }
+
+   template <typename T>
+   void
+   callback_hold_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_HOLD, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_changed_size_hints_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS );
+   }
+
+   template <typename T>
+   void
+   callback_changed_size_hints_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_image_preloaded_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_IMAGE_PRELOADED, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_IMAGE_PRELOADED );
+   }
+
+   template <typename T>
+   void
+   callback_image_preloaded_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_IMAGE_PRELOADED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_image_resize_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_IMAGE_RESIZE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_IMAGE_RESIZE );
+   }
+
+   template <typename T>
+   void
+   callback_image_resize_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_IMAGE_RESIZE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_image_unloaded_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_IMAGE_UNLOADED, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_IMAGE_UNLOADED );
+   }
+
+   template <typename T>
+   void
+   callback_image_unloaded_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_IMAGE_UNLOADED, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_OBJECT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_OBJECT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_object_dbg_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo_Dbg_Info * root_node_)
+{
+   static_cast<T*>(self->this_)->dbg_info_get(root_node_);
+}
+
+template <typename T>
+Evas * evas_object_evas_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->evas_get();
+}
+
+template <typename T>
+void evas_object_size_hint_max_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->size_hint_max_get(w_, h_);
+}
+
+template <typename T>
+void evas_object_size_hint_max_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->size_hint_max_set(w_, h_);
+}
+
+template <typename T>
+void evas_object_size_hint_request_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->size_hint_request_get(w_, h_);
+}
+
+template <typename T>
+void evas_object_size_hint_request_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->size_hint_request_set(w_, h_);
+}
+
+template <typename T>
+bool evas_object_visibility_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->visibility_get();
+}
+
+template <typename T>
+void evas_object_visibility_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool v_)
+{
+   static_cast<T*>(self->this_)->visibility_set(efl::eolian::to_cxx<bool>(v_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string evas_object_type_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->type_get();
+}
+
+template <typename T>
+void evas_object_type_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * type_)
+{
+   static_cast<T*>(self->this_)->type_set(efl::eolian::to_cxx<std::string>(type_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_size_hint_min_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->size_hint_min_get(w_, h_);
+}
+
+template <typename T>
+void evas_object_size_hint_min_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->size_hint_min_set(w_, h_);
+}
+
+template <typename T>
+Evas_Object_Pointer_Mode evas_object_pointer_mode_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->pointer_mode_get();
+}
+
+template <typename T>
+void evas_object_pointer_mode_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Pointer_Mode pointer_mode_)
+{
+   static_cast<T*>(self->this_)->pointer_mode_set(pointer_mode_);
+}
+
+template <typename T>
+Evas_Render_Op evas_object_render_op_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->render_op_get();
+}
+
+template <typename T>
+void evas_object_render_op_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Render_Op render_op_)
+{
+   static_cast<T*>(self->this_)->render_op_set(render_op_);
+}
+
+template <typename T>
+bool evas_object_freeze_events_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->freeze_events_get();
+}
+
+template <typename T>
+void evas_object_freeze_events_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool freeze_)
+{
+   static_cast<T*>(self->this_)->freeze_events_set(efl::eolian::to_cxx<bool>(freeze_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+const Evas_Map * evas_object_map_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->map_get();
+}
+
+template <typename T>
+void evas_object_map_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Evas_Map * map_)
+{
+   static_cast<T*>(self->this_)->map_set(map_);
+}
+
+template <typename T>
+void evas_object_size_hint_aspect_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Aspect_Control* aspect_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->size_hint_aspect_get(aspect_, w_, h_);
+}
+
+template <typename T>
+void evas_object_size_hint_aspect_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Aspect_Control aspect_, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->size_hint_aspect_set(aspect_, w_, h_);
+}
+
+template <typename T>
+short evas_object_layer_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->layer_get();
+}
+
+template <typename T>
+void evas_object_layer_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, short l_)
+{
+   static_cast<T*>(self->this_)->layer_set(l_);
+}
+
+template <typename T>
+evas::object evas_object_clip_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->clip_get();
+}
+
+template <typename T>
+void evas_object_clip_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * clip_)
+{
+   static_cast<T*>(self->this_)->clip_set(efl::eolian::to_cxx<evas::object>(clip_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_size_hint_padding_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_)
+{
+   static_cast<T*>(self->this_)->size_hint_padding_get(l_, r_, t_, b_);
+}
+
+template <typename T>
+void evas_object_size_hint_padding_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord l_, Evas_Coord r_, Evas_Coord t_, Evas_Coord b_)
+{
+   static_cast<T*>(self->this_)->size_hint_padding_set(l_, r_, t_, b_);
+}
+
+template <typename T>
+bool evas_object_repeat_events_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->repeat_events_get();
+}
+
+template <typename T>
+void evas_object_repeat_events_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool repeat_)
+{
+   static_cast<T*>(self->this_)->repeat_events_set(efl::eolian::to_cxx<bool>(repeat_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_size_hint_weight_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double* x_, double* y_)
+{
+   static_cast<T*>(self->this_)->size_hint_weight_get(x_, y_);
+}
+
+template <typename T>
+void evas_object_size_hint_weight_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double x_, double y_)
+{
+   static_cast<T*>(self->this_)->size_hint_weight_set(x_, y_);
+}
+
+template <typename T>
+std::string evas_object_name_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->name_get();
+}
+
+template <typename T>
+void evas_object_name_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_)
+{
+   static_cast<T*>(self->this_)->name_set(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+double evas_object_scale_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->scale_get();
+}
+
+template <typename T>
+void evas_object_scale_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double scale_)
+{
+   static_cast<T*>(self->this_)->scale_set(scale_);
+}
+
+template <typename T>
+bool evas_object_static_clip_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->static_clip_get();
+}
+
+template <typename T>
+void evas_object_static_clip_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool is_static_clip_)
+{
+   static_cast<T*>(self->this_)->static_clip_set(efl::eolian::to_cxx<bool>(is_static_clip_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->size_get(w_, h_);
+}
+
+template <typename T>
+void evas_object_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->size_set(w_, h_);
+}
+
+template <typename T>
+bool evas_object_focus_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->focus_get();
+}
+
+template <typename T>
+void evas_object_focus_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool focus_)
+{
+   static_cast<T*>(self->this_)->focus_set(efl::eolian::to_cxx<bool>(focus_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_object_is_frame_object_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->is_frame_object_get();
+}
+
+template <typename T>
+void evas_object_is_frame_object_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool is_frame_)
+{
+   static_cast<T*>(self->this_)->is_frame_object_set(efl::eolian::to_cxx<bool>(is_frame_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_object_map_enable_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->map_enable_get();
+}
+
+template <typename T>
+void evas_object_map_enable_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool enabled_)
+{
+   static_cast<T*>(self->this_)->map_enable_set(efl::eolian::to_cxx<bool>(enabled_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_object_precise_is_inside_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->precise_is_inside_get();
+}
+
+template <typename T>
+void evas_object_precise_is_inside_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool precise_)
+{
+   static_cast<T*>(self->this_)->precise_is_inside_set(efl::eolian::to_cxx<bool>(precise_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_size_hint_align_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double* x_, double* y_)
+{
+   static_cast<T*>(self->this_)->size_hint_align_get(x_, y_);
+}
+
+template <typename T>
+void evas_object_size_hint_align_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double x_, double y_)
+{
+   static_cast<T*>(self->this_)->size_hint_align_set(x_, y_);
+}
+
+template <typename T>
+bool evas_object_propagate_events_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->propagate_events_get();
+}
+
+template <typename T>
+void evas_object_propagate_events_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool propagate_)
+{
+   static_cast<T*>(self->this_)->propagate_events_set(efl::eolian::to_cxx<bool>(propagate_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_object_pass_events_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->pass_events_get();
+}
+
+template <typename T>
+void evas_object_pass_events_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool pass_)
+{
+   static_cast<T*>(self->this_)->pass_events_set(efl::eolian::to_cxx<bool>(pass_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_position_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x_, Evas_Coord* y_)
+{
+   static_cast<T*>(self->this_)->position_get(x_, y_);
+}
+
+template <typename T>
+void evas_object_position_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_)
+{
+   static_cast<T*>(self->this_)->position_set(x_, y_);
+}
+
+template <typename T>
+bool evas_object_anti_alias_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->anti_alias_get();
+}
+
+template <typename T>
+void evas_object_anti_alias_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool anti_alias_)
+{
+   static_cast<T*>(self->this_)->anti_alias_set(efl::eolian::to_cxx<bool>(anti_alias_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* r_, int* g_, int* b_, int* a_)
+{
+   static_cast<T*>(self->this_)->color_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_object_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void * evas_object_smart_data_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smart_data_get();
+}
+
+template <typename T>
+evas::object evas_object_smart_clipped_clipper_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smart_clipped_clipper_get();
+}
+
+template <typename T>
+evas::object evas_object_below_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->below_get();
+}
+
+template <typename T>
+efl::eina::crange_list< evas::object > evas_object_clipees_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->clipees_get();
+}
+
+template <typename T>
+evas::object evas_object_smart_parent_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smart_parent_get();
+}
+
+template <typename T>
+evas::object evas_object_above_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->above_get();
+}
+
+template <typename T>
+Evas_Display_Mode evas_object_size_hint_display_mode_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->size_hint_display_mode_get();
+}
+
+template <typename T>
+void evas_object_size_hint_display_mode_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Display_Mode dispmode_)
+{
+   static_cast<T*>(self->this_)->size_hint_display_mode_set(dispmode_);
+}
+
+template <typename T>
+bool evas_object_clipees_has_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->clipees_has();
+}
+
+template <typename T>
+bool evas_object_key_grab_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_, Eina_Bool exclusive_)
+{
+   return static_cast<T*>(self->this_)->key_grab(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()), modifiers_, not_modifiers_, efl::eolian::to_cxx<bool>(exclusive_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_stack_below_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * below_)
+{
+   static_cast<T*>(self->this_)->stack_below(efl::eolian::to_cxx<evas::object>(below_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_raise_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->raise();
+}
+
+template <typename T>
+void evas_object_stack_above_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * above_)
+{
+   static_cast<T*>(self->this_)->stack_above(efl::eolian::to_cxx<evas::object>(above_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_object_smart_type_check_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * type_)
+{
+   return static_cast<T*>(self->this_)->smart_type_check(efl::eolian::to_cxx<std::string>(type_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+evas::object evas_object_name_child_find_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_, int recurse_)
+{
+   return static_cast<T*>(self->this_)->name_child_find(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()), recurse_);
+}
+
+template <typename T>
+void evas_object_key_ungrab_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_)
+{
+   static_cast<T*>(self->this_)->key_ungrab(efl::eolian::to_cxx<std::string>(keyname_, std::tuple<std::false_type>()), modifiers_, not_modifiers_);
+}
+
+template <typename T>
+void evas_object_lower_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->lower();
+}
+
+template <typename T>
+void evas_object_clip_unset_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->clip_unset();
+}
+
+template <typename T>
+void evas_object_smart_move_children_relative_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord dx_, Evas_Coord dy_)
+{
+   static_cast<T*>(self->this_)->smart_move_children_relative(dx_, dy_);
+}
+
+template <typename T>
+bool evas_object_smart_type_check_ptr_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * type_)
+{
+   return static_cast<T*>(self->this_)->smart_type_check_ptr(efl::eolian::to_cxx<std::string>(type_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::object >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_dbg_info_get(root_node_));
+      }
+
+      virtual Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+      virtual void size_hint_max_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_max_get(w_, h_));
+      }
+
+      virtual void size_hint_max_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_max_set(w_, h_));
+      }
+
+      virtual void size_hint_request_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_request_get(w_, h_));
+      }
+
+      virtual void size_hint_request_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_request_set(w_, h_));
+      }
+
+      virtual bool visibility_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_visibility_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void visibility_set(bool v_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_visibility_set(efl::eolian::to_c(v_)));
+      }
+
+      virtual std::string type_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_type_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void type_set(std::string type_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_type_set(efl::eolian::to_c(type_)));
+      }
+
+      virtual void size_hint_min_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_min_get(w_, h_));
+      }
+
+      virtual void size_hint_min_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_min_set(w_, h_));
+      }
+
+      virtual Evas_Object_Pointer_Mode pointer_mode_get()
+      {
+         Evas_Object_Pointer_Mode _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_pointer_mode_get());
+            return _tmp_ret;
+      }
+
+      virtual void pointer_mode_set(Evas_Object_Pointer_Mode pointer_mode_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_pointer_mode_set(pointer_mode_));
+      }
+
+      virtual Evas_Render_Op render_op_get()
+      {
+         Evas_Render_Op _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_render_op_get());
+            return _tmp_ret;
+      }
+
+      virtual void render_op_set(Evas_Render_Op render_op_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_render_op_set(render_op_));
+      }
+
+      virtual bool freeze_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_freeze_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void freeze_events_set(bool freeze_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_freeze_events_set(efl::eolian::to_c(freeze_)));
+      }
+
+      virtual const Evas_Map * map_get()
+      {
+         const Evas_Map * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_map_get());
+            return _tmp_ret;
+      }
+
+      virtual void map_set(const Evas_Map * map_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_map_set(map_));
+      }
+
+      virtual void size_hint_aspect_get(Evas_Aspect_Control* aspect_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_aspect_get(aspect_, w_, h_));
+      }
+
+      virtual void size_hint_aspect_set(Evas_Aspect_Control aspect_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_aspect_set(aspect_, w_, h_));
+      }
+
+      virtual short layer_get()
+      {
+         short _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_layer_get());
+            return _tmp_ret;
+      }
+
+      virtual void layer_set(short l_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_layer_set(l_));
+      }
+
+      virtual evas::object clip_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_clip_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void clip_set(evas::object clip_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_clip_set(efl::eolian::to_c(clip_)));
+      }
+
+      virtual void size_hint_padding_get(Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_padding_get(l_, r_, t_, b_));
+      }
+
+      virtual void size_hint_padding_set(Evas_Coord l_, Evas_Coord r_, Evas_Coord t_, Evas_Coord b_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_padding_set(l_, r_, t_, b_));
+      }
+
+      virtual bool repeat_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_repeat_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void repeat_events_set(bool repeat_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_repeat_events_set(efl::eolian::to_c(repeat_)));
+      }
+
+      virtual void size_hint_weight_get(double* x_, double* y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_weight_get(x_, y_));
+      }
+
+      virtual void size_hint_weight_set(double x_, double y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_weight_set(x_, y_));
+      }
+
+      virtual std::string name_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_name_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void name_set(std::string name_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_name_set(efl::eolian::to_c(name_)));
+      }
+
+      virtual double scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_scale_get());
+            return _tmp_ret;
+      }
+
+      virtual void scale_set(double scale_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_scale_set(scale_));
+      }
+
+      virtual bool static_clip_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_static_clip_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void static_clip_set(bool is_static_clip_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_static_clip_set(efl::eolian::to_c(is_static_clip_)));
+      }
+
+      virtual void size_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_get(w_, h_));
+      }
+
+      virtual void size_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_set(w_, h_));
+      }
+
+      virtual bool focus_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_focus_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void focus_set(bool focus_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_focus_set(efl::eolian::to_c(focus_)));
+      }
+
+      virtual bool is_frame_object_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_is_frame_object_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void is_frame_object_set(bool is_frame_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_is_frame_object_set(efl::eolian::to_c(is_frame_)));
+      }
+
+      virtual bool map_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_map_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void map_enable_set(bool enabled_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_map_enable_set(efl::eolian::to_c(enabled_)));
+      }
+
+      virtual bool precise_is_inside_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_precise_is_inside_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void precise_is_inside_set(bool precise_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_precise_is_inside_set(efl::eolian::to_c(precise_)));
+      }
+
+      virtual void size_hint_align_get(double* x_, double* y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_align_get(x_, y_));
+      }
+
+      virtual void size_hint_align_set(double x_, double y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_align_set(x_, y_));
+      }
+
+      virtual bool propagate_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_propagate_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void propagate_events_set(bool propagate_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_propagate_events_set(efl::eolian::to_c(propagate_)));
+      }
+
+      virtual bool pass_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_pass_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void pass_events_set(bool pass_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_pass_events_set(efl::eolian::to_c(pass_)));
+      }
+
+      virtual void position_get(Evas_Coord* x_, Evas_Coord* y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_position_get(x_, y_));
+      }
+
+      virtual void position_set(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_position_set(x_, y_));
+      }
+
+      virtual bool anti_alias_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_anti_alias_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void anti_alias_set(bool anti_alias_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_anti_alias_set(efl::eolian::to_c(anti_alias_)));
+      }
+
+      virtual void color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_color_get(r_, g_, b_, a_));
+      }
+
+      virtual void color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_color_set(r_, g_, b_, a_));
+      }
+
+      virtual void * smart_data_get()
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_data_get());
+            return _tmp_ret;
+      }
+
+      virtual evas::object smart_clipped_clipper_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_clipped_clipper_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object below_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_below_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual efl::eina::crange_list< evas::object > clipees_get()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_clipees_get());
+            return efl::eolian::to_cxx<efl::eina::crange_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual evas::object smart_parent_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_parent_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object above_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_above_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual Evas_Display_Mode size_hint_display_mode_get()
+      {
+         Evas_Display_Mode _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_size_hint_display_mode_get());
+            return _tmp_ret;
+      }
+
+      virtual void size_hint_display_mode_set(Evas_Display_Mode dispmode_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_hint_display_mode_set(dispmode_));
+      }
+
+      virtual bool clipees_has()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_clipees_has());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool key_grab(std::string keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_, bool exclusive_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_key_grab(efl::eolian::to_c(keyname_), modifiers_, not_modifiers_, efl::eolian::to_c(exclusive_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void stack_below(evas::object below_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_stack_below(efl::eolian::to_c(below_)));
+      }
+
+      virtual void raise()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_raise());
+      }
+
+      virtual void stack_above(evas::object above_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_stack_above(efl::eolian::to_c(above_)));
+      }
+
+      virtual bool smart_type_check(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_type_check(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual evas::object name_child_find(std::string name_, int recurse_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_name_child_find(efl::eolian::to_c(name_), recurse_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void key_ungrab(std::string keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_key_ungrab(efl::eolian::to_c(keyname_), modifiers_, not_modifiers_));
+      }
+
+      virtual void lower()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_lower());
+      }
+
+      virtual void clip_unset()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_clip_unset());
+      }
+
+      virtual void smart_move_children_relative(Evas_Coord dx_, Evas_Coord dy_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_move_children_relative(dx_, dy_));
+      }
+
+      virtual bool smart_type_check_ptr(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_type_check_ptr(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::object >
+{
+   static const int value = 80;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::object>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_object_dbg_info_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_dbg_info_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_object_evas_get_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_common_evas_get);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_object_size_hint_max_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_max_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_object_size_hint_max_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_max_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_object_size_hint_request_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_request_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_object_size_hint_request_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_request_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_object_visibility_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_visibility_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_object_visibility_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_visibility_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_object_type_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_type_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_object_type_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_type_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_object_size_hint_min_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_min_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_object_size_hint_min_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_min_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_object_pointer_mode_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_pointer_mode_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_object_pointer_mode_set_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_pointer_mode_set);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_object_render_op_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_render_op_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_object_render_op_set_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_obj_render_op_set);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_object_freeze_events_get_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_obj_freeze_events_get);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_object_freeze_events_set_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_obj_freeze_events_set);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_object_map_get_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_obj_map_get);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_object_map_set_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_obj_map_set);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_object_size_hint_aspect_get_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_aspect_get);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_object_size_hint_aspect_set_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_aspect_set);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::evas_object_layer_get_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_obj_layer_get);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::evas_object_layer_set_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_obj_layer_set);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::evas_object_clip_get_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_obj_clip_get);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::evas_object_clip_set_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_obj_clip_set);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::evas_object_size_hint_padding_get_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_padding_get);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::evas_object_size_hint_padding_set_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_padding_set);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::evas_object_repeat_events_get_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::evas_obj_repeat_events_get);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   ops[29].func = reinterpret_cast<void*>(& ::evas_object_repeat_events_set_wrapper<T>);
+   ops[29].api_func = reinterpret_cast<void*>(& ::evas_obj_repeat_events_set);
+   ops[29].op = EO_OP_OVERRIDE;
+   ops[29].op_type = EO_OP_TYPE_REGULAR;
+   ops[29].doc = NULL;
+
+   ops[30].func = reinterpret_cast<void*>(& ::evas_object_size_hint_weight_get_wrapper<T>);
+   ops[30].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_weight_get);
+   ops[30].op = EO_OP_OVERRIDE;
+   ops[30].op_type = EO_OP_TYPE_REGULAR;
+   ops[30].doc = NULL;
+
+   ops[31].func = reinterpret_cast<void*>(& ::evas_object_size_hint_weight_set_wrapper<T>);
+   ops[31].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_weight_set);
+   ops[31].op = EO_OP_OVERRIDE;
+   ops[31].op_type = EO_OP_TYPE_REGULAR;
+   ops[31].doc = NULL;
+
+   ops[32].func = reinterpret_cast<void*>(& ::evas_object_name_get_wrapper<T>);
+   ops[32].api_func = reinterpret_cast<void*>(& ::evas_obj_name_get);
+   ops[32].op = EO_OP_OVERRIDE;
+   ops[32].op_type = EO_OP_TYPE_REGULAR;
+   ops[32].doc = NULL;
+
+   ops[33].func = reinterpret_cast<void*>(& ::evas_object_name_set_wrapper<T>);
+   ops[33].api_func = reinterpret_cast<void*>(& ::evas_obj_name_set);
+   ops[33].op = EO_OP_OVERRIDE;
+   ops[33].op_type = EO_OP_TYPE_REGULAR;
+   ops[33].doc = NULL;
+
+   ops[34].func = reinterpret_cast<void*>(& ::evas_object_scale_get_wrapper<T>);
+   ops[34].api_func = reinterpret_cast<void*>(& ::evas_obj_scale_get);
+   ops[34].op = EO_OP_OVERRIDE;
+   ops[34].op_type = EO_OP_TYPE_REGULAR;
+   ops[34].doc = NULL;
+
+   ops[35].func = reinterpret_cast<void*>(& ::evas_object_scale_set_wrapper<T>);
+   ops[35].api_func = reinterpret_cast<void*>(& ::evas_obj_scale_set);
+   ops[35].op = EO_OP_OVERRIDE;
+   ops[35].op_type = EO_OP_TYPE_REGULAR;
+   ops[35].doc = NULL;
+
+   ops[36].func = reinterpret_cast<void*>(& ::evas_object_static_clip_get_wrapper<T>);
+   ops[36].api_func = reinterpret_cast<void*>(& ::evas_obj_static_clip_get);
+   ops[36].op = EO_OP_OVERRIDE;
+   ops[36].op_type = EO_OP_TYPE_REGULAR;
+   ops[36].doc = NULL;
+
+   ops[37].func = reinterpret_cast<void*>(& ::evas_object_static_clip_set_wrapper<T>);
+   ops[37].api_func = reinterpret_cast<void*>(& ::evas_obj_static_clip_set);
+   ops[37].op = EO_OP_OVERRIDE;
+   ops[37].op_type = EO_OP_TYPE_REGULAR;
+   ops[37].doc = NULL;
+
+   ops[38].func = reinterpret_cast<void*>(& ::evas_object_size_get_wrapper<T>);
+   ops[38].api_func = reinterpret_cast<void*>(& ::evas_obj_size_get);
+   ops[38].op = EO_OP_OVERRIDE;
+   ops[38].op_type = EO_OP_TYPE_REGULAR;
+   ops[38].doc = NULL;
+
+   ops[39].func = reinterpret_cast<void*>(& ::evas_object_size_set_wrapper<T>);
+   ops[39].api_func = reinterpret_cast<void*>(& ::evas_obj_size_set);
+   ops[39].op = EO_OP_OVERRIDE;
+   ops[39].op_type = EO_OP_TYPE_REGULAR;
+   ops[39].doc = NULL;
+
+   ops[40].func = reinterpret_cast<void*>(& ::evas_object_focus_get_wrapper<T>);
+   ops[40].api_func = reinterpret_cast<void*>(& ::evas_obj_focus_get);
+   ops[40].op = EO_OP_OVERRIDE;
+   ops[40].op_type = EO_OP_TYPE_REGULAR;
+   ops[40].doc = NULL;
+
+   ops[41].func = reinterpret_cast<void*>(& ::evas_object_focus_set_wrapper<T>);
+   ops[41].api_func = reinterpret_cast<void*>(& ::evas_obj_focus_set);
+   ops[41].op = EO_OP_OVERRIDE;
+   ops[41].op_type = EO_OP_TYPE_REGULAR;
+   ops[41].doc = NULL;
+
+   ops[42].func = reinterpret_cast<void*>(& ::evas_object_is_frame_object_get_wrapper<T>);
+   ops[42].api_func = reinterpret_cast<void*>(& ::evas_obj_is_frame_object_get);
+   ops[42].op = EO_OP_OVERRIDE;
+   ops[42].op_type = EO_OP_TYPE_REGULAR;
+   ops[42].doc = NULL;
+
+   ops[43].func = reinterpret_cast<void*>(& ::evas_object_is_frame_object_set_wrapper<T>);
+   ops[43].api_func = reinterpret_cast<void*>(& ::evas_obj_is_frame_object_set);
+   ops[43].op = EO_OP_OVERRIDE;
+   ops[43].op_type = EO_OP_TYPE_REGULAR;
+   ops[43].doc = NULL;
+
+   ops[44].func = reinterpret_cast<void*>(& ::evas_object_map_enable_get_wrapper<T>);
+   ops[44].api_func = reinterpret_cast<void*>(& ::evas_obj_map_enable_get);
+   ops[44].op = EO_OP_OVERRIDE;
+   ops[44].op_type = EO_OP_TYPE_REGULAR;
+   ops[44].doc = NULL;
+
+   ops[45].func = reinterpret_cast<void*>(& ::evas_object_map_enable_set_wrapper<T>);
+   ops[45].api_func = reinterpret_cast<void*>(& ::evas_obj_map_enable_set);
+   ops[45].op = EO_OP_OVERRIDE;
+   ops[45].op_type = EO_OP_TYPE_REGULAR;
+   ops[45].doc = NULL;
+
+   ops[46].func = reinterpret_cast<void*>(& ::evas_object_precise_is_inside_get_wrapper<T>);
+   ops[46].api_func = reinterpret_cast<void*>(& ::evas_obj_precise_is_inside_get);
+   ops[46].op = EO_OP_OVERRIDE;
+   ops[46].op_type = EO_OP_TYPE_REGULAR;
+   ops[46].doc = NULL;
+
+   ops[47].func = reinterpret_cast<void*>(& ::evas_object_precise_is_inside_set_wrapper<T>);
+   ops[47].api_func = reinterpret_cast<void*>(& ::evas_obj_precise_is_inside_set);
+   ops[47].op = EO_OP_OVERRIDE;
+   ops[47].op_type = EO_OP_TYPE_REGULAR;
+   ops[47].doc = NULL;
+
+   ops[48].func = reinterpret_cast<void*>(& ::evas_object_size_hint_align_get_wrapper<T>);
+   ops[48].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_align_get);
+   ops[48].op = EO_OP_OVERRIDE;
+   ops[48].op_type = EO_OP_TYPE_REGULAR;
+   ops[48].doc = NULL;
+
+   ops[49].func = reinterpret_cast<void*>(& ::evas_object_size_hint_align_set_wrapper<T>);
+   ops[49].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_align_set);
+   ops[49].op = EO_OP_OVERRIDE;
+   ops[49].op_type = EO_OP_TYPE_REGULAR;
+   ops[49].doc = NULL;
+
+   ops[50].func = reinterpret_cast<void*>(& ::evas_object_propagate_events_get_wrapper<T>);
+   ops[50].api_func = reinterpret_cast<void*>(& ::evas_obj_propagate_events_get);
+   ops[50].op = EO_OP_OVERRIDE;
+   ops[50].op_type = EO_OP_TYPE_REGULAR;
+   ops[50].doc = NULL;
+
+   ops[51].func = reinterpret_cast<void*>(& ::evas_object_propagate_events_set_wrapper<T>);
+   ops[51].api_func = reinterpret_cast<void*>(& ::evas_obj_propagate_events_set);
+   ops[51].op = EO_OP_OVERRIDE;
+   ops[51].op_type = EO_OP_TYPE_REGULAR;
+   ops[51].doc = NULL;
+
+   ops[52].func = reinterpret_cast<void*>(& ::evas_object_pass_events_get_wrapper<T>);
+   ops[52].api_func = reinterpret_cast<void*>(& ::evas_obj_pass_events_get);
+   ops[52].op = EO_OP_OVERRIDE;
+   ops[52].op_type = EO_OP_TYPE_REGULAR;
+   ops[52].doc = NULL;
+
+   ops[53].func = reinterpret_cast<void*>(& ::evas_object_pass_events_set_wrapper<T>);
+   ops[53].api_func = reinterpret_cast<void*>(& ::evas_obj_pass_events_set);
+   ops[53].op = EO_OP_OVERRIDE;
+   ops[53].op_type = EO_OP_TYPE_REGULAR;
+   ops[53].doc = NULL;
+
+   ops[54].func = reinterpret_cast<void*>(& ::evas_object_position_get_wrapper<T>);
+   ops[54].api_func = reinterpret_cast<void*>(& ::evas_obj_position_get);
+   ops[54].op = EO_OP_OVERRIDE;
+   ops[54].op_type = EO_OP_TYPE_REGULAR;
+   ops[54].doc = NULL;
+
+   ops[55].func = reinterpret_cast<void*>(& ::evas_object_position_set_wrapper<T>);
+   ops[55].api_func = reinterpret_cast<void*>(& ::evas_obj_position_set);
+   ops[55].op = EO_OP_OVERRIDE;
+   ops[55].op_type = EO_OP_TYPE_REGULAR;
+   ops[55].doc = NULL;
+
+   ops[56].func = reinterpret_cast<void*>(& ::evas_object_anti_alias_get_wrapper<T>);
+   ops[56].api_func = reinterpret_cast<void*>(& ::evas_obj_anti_alias_get);
+   ops[56].op = EO_OP_OVERRIDE;
+   ops[56].op_type = EO_OP_TYPE_REGULAR;
+   ops[56].doc = NULL;
+
+   ops[57].func = reinterpret_cast<void*>(& ::evas_object_anti_alias_set_wrapper<T>);
+   ops[57].api_func = reinterpret_cast<void*>(& ::evas_obj_anti_alias_set);
+   ops[57].op = EO_OP_OVERRIDE;
+   ops[57].op_type = EO_OP_TYPE_REGULAR;
+   ops[57].doc = NULL;
+
+   ops[58].func = reinterpret_cast<void*>(& ::evas_object_color_get_wrapper<T>);
+   ops[58].api_func = reinterpret_cast<void*>(& ::evas_obj_color_get);
+   ops[58].op = EO_OP_OVERRIDE;
+   ops[58].op_type = EO_OP_TYPE_REGULAR;
+   ops[58].doc = NULL;
+
+   ops[59].func = reinterpret_cast<void*>(& ::evas_object_color_set_wrapper<T>);
+   ops[59].api_func = reinterpret_cast<void*>(& ::evas_obj_color_set);
+   ops[59].op = EO_OP_OVERRIDE;
+   ops[59].op_type = EO_OP_TYPE_REGULAR;
+   ops[59].doc = NULL;
+
+   ops[60].func = reinterpret_cast<void*>(& ::evas_object_smart_data_get_wrapper<T>);
+   ops[60].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_data_get);
+   ops[60].op = EO_OP_OVERRIDE;
+   ops[60].op_type = EO_OP_TYPE_REGULAR;
+   ops[60].doc = NULL;
+
+   ops[61].func = reinterpret_cast<void*>(& ::evas_object_smart_clipped_clipper_get_wrapper<T>);
+   ops[61].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_clipped_clipper_get);
+   ops[61].op = EO_OP_OVERRIDE;
+   ops[61].op_type = EO_OP_TYPE_REGULAR;
+   ops[61].doc = NULL;
+
+   ops[62].func = reinterpret_cast<void*>(& ::evas_object_below_get_wrapper<T>);
+   ops[62].api_func = reinterpret_cast<void*>(& ::evas_obj_below_get);
+   ops[62].op = EO_OP_OVERRIDE;
+   ops[62].op_type = EO_OP_TYPE_REGULAR;
+   ops[62].doc = NULL;
+
+   ops[63].func = reinterpret_cast<void*>(& ::evas_object_clipees_get_wrapper<T>);
+   ops[63].api_func = reinterpret_cast<void*>(& ::evas_obj_clipees_get);
+   ops[63].op = EO_OP_OVERRIDE;
+   ops[63].op_type = EO_OP_TYPE_REGULAR;
+   ops[63].doc = NULL;
+
+   ops[64].func = reinterpret_cast<void*>(& ::evas_object_smart_parent_get_wrapper<T>);
+   ops[64].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_parent_get);
+   ops[64].op = EO_OP_OVERRIDE;
+   ops[64].op_type = EO_OP_TYPE_REGULAR;
+   ops[64].doc = NULL;
+
+   ops[65].func = reinterpret_cast<void*>(& ::evas_object_above_get_wrapper<T>);
+   ops[65].api_func = reinterpret_cast<void*>(& ::evas_obj_above_get);
+   ops[65].op = EO_OP_OVERRIDE;
+   ops[65].op_type = EO_OP_TYPE_REGULAR;
+   ops[65].doc = NULL;
+
+   ops[66].func = reinterpret_cast<void*>(& ::evas_object_size_hint_display_mode_get_wrapper<T>);
+   ops[66].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_display_mode_get);
+   ops[66].op = EO_OP_OVERRIDE;
+   ops[66].op_type = EO_OP_TYPE_REGULAR;
+   ops[66].doc = NULL;
+
+   ops[67].func = reinterpret_cast<void*>(& ::evas_object_size_hint_display_mode_set_wrapper<T>);
+   ops[67].api_func = reinterpret_cast<void*>(& ::evas_obj_size_hint_display_mode_set);
+   ops[67].op = EO_OP_OVERRIDE;
+   ops[67].op_type = EO_OP_TYPE_REGULAR;
+   ops[67].doc = NULL;
+
+   ops[68].func = reinterpret_cast<void*>(& ::evas_object_clipees_has_wrapper<T>);
+   ops[68].api_func = reinterpret_cast<void*>(& ::evas_obj_clipees_has);
+   ops[68].op = EO_OP_OVERRIDE;
+   ops[68].op_type = EO_OP_TYPE_REGULAR;
+   ops[68].doc = NULL;
+
+   ops[69].func = reinterpret_cast<void*>(& ::evas_object_key_grab_wrapper<T>);
+   ops[69].api_func = reinterpret_cast<void*>(& ::evas_obj_key_grab);
+   ops[69].op = EO_OP_OVERRIDE;
+   ops[69].op_type = EO_OP_TYPE_REGULAR;
+   ops[69].doc = NULL;
+
+   ops[70].func = reinterpret_cast<void*>(& ::evas_object_stack_below_wrapper<T>);
+   ops[70].api_func = reinterpret_cast<void*>(& ::evas_obj_stack_below);
+   ops[70].op = EO_OP_OVERRIDE;
+   ops[70].op_type = EO_OP_TYPE_REGULAR;
+   ops[70].doc = NULL;
+
+   ops[71].func = reinterpret_cast<void*>(& ::evas_object_raise_wrapper<T>);
+   ops[71].api_func = reinterpret_cast<void*>(& ::evas_obj_raise);
+   ops[71].op = EO_OP_OVERRIDE;
+   ops[71].op_type = EO_OP_TYPE_REGULAR;
+   ops[71].doc = NULL;
+
+   ops[72].func = reinterpret_cast<void*>(& ::evas_object_stack_above_wrapper<T>);
+   ops[72].api_func = reinterpret_cast<void*>(& ::evas_obj_stack_above);
+   ops[72].op = EO_OP_OVERRIDE;
+   ops[72].op_type = EO_OP_TYPE_REGULAR;
+   ops[72].doc = NULL;
+
+   ops[73].func = reinterpret_cast<void*>(& ::evas_object_smart_type_check_wrapper<T>);
+   ops[73].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_type_check);
+   ops[73].op = EO_OP_OVERRIDE;
+   ops[73].op_type = EO_OP_TYPE_REGULAR;
+   ops[73].doc = NULL;
+
+   ops[74].func = reinterpret_cast<void*>(& ::evas_object_name_child_find_wrapper<T>);
+   ops[74].api_func = reinterpret_cast<void*>(& ::evas_obj_name_child_find);
+   ops[74].op = EO_OP_OVERRIDE;
+   ops[74].op_type = EO_OP_TYPE_REGULAR;
+   ops[74].doc = NULL;
+
+   ops[75].func = reinterpret_cast<void*>(& ::evas_object_key_ungrab_wrapper<T>);
+   ops[75].api_func = reinterpret_cast<void*>(& ::evas_obj_key_ungrab);
+   ops[75].op = EO_OP_OVERRIDE;
+   ops[75].op_type = EO_OP_TYPE_REGULAR;
+   ops[75].doc = NULL;
+
+   ops[76].func = reinterpret_cast<void*>(& ::evas_object_lower_wrapper<T>);
+   ops[76].api_func = reinterpret_cast<void*>(& ::evas_obj_lower);
+   ops[76].op = EO_OP_OVERRIDE;
+   ops[76].op_type = EO_OP_TYPE_REGULAR;
+   ops[76].doc = NULL;
+
+   ops[77].func = reinterpret_cast<void*>(& ::evas_object_clip_unset_wrapper<T>);
+   ops[77].api_func = reinterpret_cast<void*>(& ::evas_obj_clip_unset);
+   ops[77].op = EO_OP_OVERRIDE;
+   ops[77].op_type = EO_OP_TYPE_REGULAR;
+   ops[77].doc = NULL;
+
+   ops[78].func = reinterpret_cast<void*>(& ::evas_object_smart_move_children_relative_wrapper<T>);
+   ops[78].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_move_children_relative);
+   ops[78].op = EO_OP_OVERRIDE;
+   ops[78].op_type = EO_OP_TYPE_REGULAR;
+   ops[78].doc = NULL;
+
+   ops[79].func = reinterpret_cast<void*>(& ::evas_object_smart_type_check_ptr_wrapper<T>);
+   ops[79].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_type_check_ptr);
+   ops[79].op = EO_OP_OVERRIDE;
+   ops[79].op_type = EO_OP_TYPE_REGULAR;
+   ops[79].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::object >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::object, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::object >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::object, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::object>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::object() const
+      {
+         return evas::object(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_dbg_info_get(root_node_));
+      }
+
+      Evas * evas_get()
+      {
+         Evas * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_common_evas_get());
+            return _tmp_ret;
+      }
+
+      void size_hint_max_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_max_get(w_, h_));
+      }
+
+      void size_hint_max_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_max_set(w_, h_));
+      }
+
+      void size_hint_request_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_request_get(w_, h_));
+      }
+
+      void size_hint_request_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_request_set(w_, h_));
+      }
+
+      bool visibility_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_visibility_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void visibility_set(bool v_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_visibility_set(efl::eolian::to_c(v_)));
+      }
+
+      std::string type_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_type_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void type_set(std::string type_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_type_set(efl::eolian::to_c(type_)));
+      }
+
+      void size_hint_min_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_min_get(w_, h_));
+      }
+
+      void size_hint_min_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_min_set(w_, h_));
+      }
+
+      Evas_Object_Pointer_Mode pointer_mode_get()
+      {
+         Evas_Object_Pointer_Mode _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_pointer_mode_get());
+            return _tmp_ret;
+      }
+
+      void pointer_mode_set(Evas_Object_Pointer_Mode pointer_mode_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_pointer_mode_set(pointer_mode_));
+      }
+
+      Evas_Render_Op render_op_get()
+      {
+         Evas_Render_Op _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_render_op_get());
+            return _tmp_ret;
+      }
+
+      void render_op_set(Evas_Render_Op render_op_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_render_op_set(render_op_));
+      }
+
+      bool freeze_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_freeze_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void freeze_events_set(bool freeze_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_freeze_events_set(efl::eolian::to_c(freeze_)));
+      }
+
+      const Evas_Map * map_get()
+      {
+         const Evas_Map * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_map_get());
+            return _tmp_ret;
+      }
+
+      void map_set(const Evas_Map * map_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_map_set(map_));
+      }
+
+      void size_hint_aspect_get(Evas_Aspect_Control* aspect_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_aspect_get(aspect_, w_, h_));
+      }
+
+      void size_hint_aspect_set(Evas_Aspect_Control aspect_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_aspect_set(aspect_, w_, h_));
+      }
+
+      short layer_get()
+      {
+         short _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_layer_get());
+            return _tmp_ret;
+      }
+
+      void layer_set(short l_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_layer_set(l_));
+      }
+
+      evas::object clip_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_clip_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void clip_set(evas::object clip_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_clip_set(efl::eolian::to_c(clip_)));
+      }
+
+      void size_hint_padding_get(Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_padding_get(l_, r_, t_, b_));
+      }
+
+      void size_hint_padding_set(Evas_Coord l_, Evas_Coord r_, Evas_Coord t_, Evas_Coord b_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_padding_set(l_, r_, t_, b_));
+      }
+
+      bool repeat_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_repeat_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void repeat_events_set(bool repeat_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_repeat_events_set(efl::eolian::to_c(repeat_)));
+      }
+
+      void size_hint_weight_get(double* x_, double* y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_weight_get(x_, y_));
+      }
+
+      void size_hint_weight_set(double x_, double y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_weight_set(x_, y_));
+      }
+
+      std::string name_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_name_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void name_set(std::string name_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_name_set(efl::eolian::to_c(name_)));
+      }
+
+      double scale_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_scale_get());
+            return _tmp_ret;
+      }
+
+      void scale_set(double scale_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_scale_set(scale_));
+      }
+
+      bool static_clip_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_static_clip_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void static_clip_set(bool is_static_clip_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_static_clip_set(efl::eolian::to_c(is_static_clip_)));
+      }
+
+      void size_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_get(w_, h_));
+      }
+
+      void size_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_set(w_, h_));
+      }
+
+      bool focus_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_focus_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void focus_set(bool focus_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_focus_set(efl::eolian::to_c(focus_)));
+      }
+
+      bool is_frame_object_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_is_frame_object_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void is_frame_object_set(bool is_frame_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_is_frame_object_set(efl::eolian::to_c(is_frame_)));
+      }
+
+      bool map_enable_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_map_enable_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void map_enable_set(bool enabled_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_map_enable_set(efl::eolian::to_c(enabled_)));
+      }
+
+      bool precise_is_inside_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_precise_is_inside_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void precise_is_inside_set(bool precise_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_precise_is_inside_set(efl::eolian::to_c(precise_)));
+      }
+
+      void size_hint_align_get(double* x_, double* y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_align_get(x_, y_));
+      }
+
+      void size_hint_align_set(double x_, double y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_align_set(x_, y_));
+      }
+
+      bool propagate_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_propagate_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void propagate_events_set(bool propagate_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_propagate_events_set(efl::eolian::to_c(propagate_)));
+      }
+
+      bool pass_events_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_pass_events_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void pass_events_set(bool pass_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_pass_events_set(efl::eolian::to_c(pass_)));
+      }
+
+      void position_get(Evas_Coord* x_, Evas_Coord* y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_position_get(x_, y_));
+      }
+
+      void position_set(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_position_set(x_, y_));
+      }
+
+      bool anti_alias_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_anti_alias_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void anti_alias_set(bool anti_alias_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_anti_alias_set(efl::eolian::to_c(anti_alias_)));
+      }
+
+      void color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_color_get(r_, g_, b_, a_));
+      }
+
+      void color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_color_set(r_, g_, b_, a_));
+      }
+
+      void * smart_data_get()
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_data_get());
+            return _tmp_ret;
+      }
+
+      evas::object smart_clipped_clipper_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_clipped_clipper_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object below_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_below_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      efl::eina::crange_list< evas::object > clipees_get()
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_clipees_get());
+            return efl::eolian::to_cxx<efl::eina::crange_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      evas::object smart_parent_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_parent_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object above_get()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_above_get());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      Evas_Display_Mode size_hint_display_mode_get()
+      {
+         Evas_Display_Mode _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_size_hint_display_mode_get());
+            return _tmp_ret;
+      }
+
+      void size_hint_display_mode_set(Evas_Display_Mode dispmode_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_hint_display_mode_set(dispmode_));
+      }
+
+      bool clipees_has()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_clipees_has());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool key_grab(std::string keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_, bool exclusive_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_key_grab(efl::eolian::to_c(keyname_), modifiers_, not_modifiers_, efl::eolian::to_c(exclusive_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void stack_below(evas::object below_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_stack_below(efl::eolian::to_c(below_)));
+      }
+
+      void raise()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_raise());
+      }
+
+      void stack_above(evas::object above_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_stack_above(efl::eolian::to_c(above_)));
+      }
+
+      bool smart_type_check(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      evas::object name_child_find(std::string name_, int recurse_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_name_child_find(efl::eolian::to_c(name_), recurse_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void key_ungrab(std::string keyname_, Evas_Modifier_Mask modifiers_, Evas_Modifier_Mask not_modifiers_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_key_ungrab(efl::eolian::to_c(keyname_), modifiers_, not_modifiers_));
+      }
+
+      void lower()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_lower());
+      }
+
+      void clip_unset()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_clip_unset());
+      }
+
+      void smart_move_children_relative(Evas_Coord dx_, Evas_Coord dy_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_move_children_relative(dx_, dy_));
+      }
+
+      bool smart_type_check_ptr(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check_ptr(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_in_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_IN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_IN );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_in_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_IN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_out_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_OUT, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_OUT );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_out_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_OUT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_down_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_UP );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_up_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_move_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_MOVE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_MOVE );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_move_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_MOVE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_mouse_wheel_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOUSE_WHEEL, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOUSE_WHEEL );
+   }
+
+   template <typename T>
+   void
+   callback_mouse_wheel_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOUSE_WHEEL, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_multi_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MULTI_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MULTI_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_multi_down_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MULTI_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_multi_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MULTI_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MULTI_UP );
+   }
+
+   template <typename T>
+   void
+   callback_multi_up_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MULTI_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_multi_move_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MULTI_MOVE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MULTI_MOVE );
+   }
+
+   template <typename T>
+   void
+   callback_multi_move_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MULTI_MOVE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_free_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_FREE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_FREE );
+   }
+
+   template <typename T>
+   void
+   callback_free_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_FREE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_key_down_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_KEY_DOWN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_KEY_DOWN );
+   }
+
+   template <typename T>
+   void
+   callback_key_down_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_KEY_DOWN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_key_up_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_KEY_UP, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_KEY_UP );
+   }
+
+   template <typename T>
+   void
+   callback_key_up_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_KEY_UP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_focus_in_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_FOCUS_IN, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_FOCUS_IN );
+   }
+
+   template <typename T>
+   void
+   callback_focus_in_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_FOCUS_IN, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_focus_out_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_FOCUS_OUT, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_FOCUS_OUT );
+   }
+
+   template <typename T>
+   void
+   callback_focus_out_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_FOCUS_OUT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_show_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_SHOW, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_SHOW );
+   }
+
+   template <typename T>
+   void
+   callback_show_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_SHOW, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_hide_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_HIDE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_HIDE );
+   }
+
+   template <typename T>
+   void
+   callback_hide_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_HIDE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_move_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_MOVE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_MOVE );
+   }
+
+   template <typename T>
+   void
+   callback_move_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_MOVE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_resize_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_RESIZE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_RESIZE );
+   }
+
+   template <typename T>
+   void
+   callback_resize_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_RESIZE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_restack_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_RESTACK, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_RESTACK );
+   }
+
+   template <typename T>
+   void
+   callback_restack_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_RESTACK, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_del_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_DEL, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_DEL );
+   }
+
+   template <typename T>
+   void
+   callback_del_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_DEL, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_hold_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_HOLD, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_HOLD );
+   }
+
+   template <typename T>
+   void
+   callback_hold_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_HOLD, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_changed_size_hints_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS );
+   }
+
+   template <typename T>
+   void
+   callback_changed_size_hints_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_image_preloaded_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_IMAGE_PRELOADED, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_IMAGE_PRELOADED );
+   }
+
+   template <typename T>
+   void
+   callback_image_preloaded_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_IMAGE_PRELOADED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_image_resize_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_IMAGE_RESIZE, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_IMAGE_RESIZE );
+   }
+
+   template <typename T>
+   void
+   callback_image_resize_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_IMAGE_RESIZE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_image_unloaded_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_OBJECT_EVENT_IMAGE_UNLOADED, priority_,
+            &efl::eo::_detail::event_callback<evas::object, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::object, function_type>,
+         EVAS_OBJECT_EVENT_IMAGE_UNLOADED );
+   }
+
+   template <typename T>
+   void
+   callback_image_unloaded_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_OBJECT_EVENT_IMAGE_UNLOADED, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::object>)
+{
+   return (EVAS_OBJECT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_OBJECT_HH
+
diff -Naur a/src/lib/evas/canvas/evas_object.eo.legacy.h b/src/lib/evas/canvas/evas_object.eo.legacy.h
--- a/src/lib/evas/canvas/evas_object.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object.eo.legacy.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,1587 @@
+#ifndef _EVAS_OBJECT_EO_LEGACY_H_
+#define _EVAS_OBJECT_EO_LEGACY_H_
+
+#ifndef _EVAS_OBJECT_EO_CLASS_TYPE
+#define _EVAS_OBJECT_EO_CLASS_TYPE
+
+typedef Eo Evas_Object;
+
+#endif
+
+#ifndef _EVAS_OBJECT_EO_TYPES
+#define _EVAS_OBJECT_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Sets the hints for an object's maximum size.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * Values @c -1 will be treated as unset hint components, when queried
+ * by managers.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_max_set
+ * @until return
+ *
+ * In this example the maximum size hints change the behavior of an
+ * Evas box when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_max_get()
+ *
+ * @param[in] w Integer to use as the maximum width hint.
+ * @param[in] h Integer to use as the maximum height hint.
+ */
+EAPI void evas_object_size_hint_max_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's maximum size.
+ *
+ * These are hints on the maximum sizes @p obj should have. This is
+ * not a size enforcement in any way, it's just a hint that should be
+ * used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_size_hint_max_set()
+ *
+ * @param[out] w Integer to use as the maximum width hint.
+ * @param[out] h Integer to use as the maximum height hint.
+ */
+EAPI void evas_object_size_hint_max_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the hints for an object's optimum size.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * Values @c 0 will be treated as unset hint components, when queried
+ * by managers.
+ *
+ * @see evas_object_size_hint_request_get()
+ *
+ * @param[in] w Integer to use as the preferred width hint.
+ * @param[in] h Integer to use as the preferred height hint.
+ */
+EAPI void evas_object_size_hint_request_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's optimum size.
+ *
+ * These are hints on the optimum sizes @p obj should have. This is
+ * not a size enforcement in any way, it's just a hint that should be
+ * used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_size_hint_request_set()
+ *
+ * @param[out] w Integer to use as the preferred width hint.
+ * @param[out] h Integer to use as the preferred height hint.
+ */
+EAPI void evas_object_size_hint_request_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Retrieves whether or not the given Evas object is visible.
+ *
+ */
+EAPI Eina_Bool evas_object_visible_get(const Evas_Object *obj);
+
+/**
+ *
+ * Retrieves the type of the given Evas object.
+ *
+ * @return The type of the object.
+ *
+ * For Evas' builtin types, the return strings will be one of:
+ * - <c>"rectangle"</c>,
+ * - <c>"line"</c>,
+ * - <c>"polygon"</c>,
+ * - <c>"text"</c>,
+ * - <c>"textblock"</c> and
+ * - <c>"image"</c>.
+ *
+ * For Evas smart objects (see @ref Evas_Smart_Group), the name of the
+ * smart class itself is returned on this call. For the built-in smart
+ * objects, these names are:
+ * - <c>"EvasObjectSmartClipped"</c>, for the clipped smart object
+ * - <c>"Evas_Object_Box"</c>, for the box object and
+ * - <c>"Evas_Object_Table"</c>, for the table object.
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip d.img = evas_object_image_filled_add(d.canvas);
+ * @until border on the
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ */
+EAPI const char *evas_object_type_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the hints for an object's minimum size.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * Values @c 0 will be treated as unset hint components, when queried
+ * by managers.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_min_set
+ * @until return
+ *
+ * In this example the minimum size hints change the behavior of an
+ * Evas box when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_min_get()
+ *
+ * @param[in] w Integer to use as the minimum width hint.
+ * @param[in] h Integer to use as the minimum height hint.
+ */
+EAPI void evas_object_size_hint_min_set(Evas_Object *obj, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's minimum size.
+ *
+ * These are hints on the minimum sizes @p obj should have. This is
+ * not a size enforcement in any way, it's just a hint that should be
+ * used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_size_hint_min_set() for an example
+ *
+ * @param[out] w Integer to use as the minimum width hint.
+ * @param[out] h Integer to use as the minimum height hint.
+ */
+EAPI void evas_object_size_hint_min_get(const Evas_Object *obj, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Set pointer behavior.
+ *
+ * This function has direct effect on event callbacks related to
+ * mouse.
+ *
+ * If @p setting is EVAS_OBJECT_POINTER_MODE_AUTOGRAB, then when mouse
+ * is down at this object, events will be restricted to it as source,
+ * mouse moves, for example, will be emitted even if outside this
+ * object area.
+ *
+ * If @p setting is EVAS_OBJECT_POINTER_MODE_NOGRAB, then events will
+ * be emitted just when inside this object area.
+ *
+ * The default value is EVAS_OBJECT_POINTER_MODE_AUTOGRAB.
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] pointer_mode desired behavior.
+ */
+EAPI void evas_object_pointer_mode_set(Evas_Object *obj, Evas_Object_Pointer_Mode pointer_mode);
+
+/**
+ *
+ * Determine how pointer will behave.
+ * @return pointer behavior.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ */
+EAPI Evas_Object_Pointer_Mode evas_object_pointer_mode_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the render_op to be used for rendering the Evas object.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] render_op one of the Evas_Render_Op values.
+ */
+EAPI void evas_object_render_op_set(Evas_Object *obj, Evas_Render_Op render_op);
+
+/**
+ *
+ * Retrieves the current value of the operation used for rendering the Evas object.
+ * @return  one of the enumerated values in Evas_Render_Op.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ */
+EAPI Evas_Render_Op evas_object_render_op_get(const Evas_Object *obj);
+
+/**
+ *
+ * Set whether an Evas object is to freeze (discard) events.
+ *
+ * If @p freeze is @c EINA_TRUE, it will make events on @p obj to be @b
+ * discarded. Unlike evas_object_pass_events_set(), events will not be
+ * passed to @b next lower object. This API can be used for blocking
+ * events while @p obj is on transiting.
+ *
+ * If @p freeze is @c EINA_FALSE, events will be processed on that
+ * object as normal.
+ *
+ * @warning If you block only key/mouse up events with this API, we won't
+ * guarantee the state of the object, that only had key/mouse down
+ * events, will be.
+ *
+ * @see evas_object_freeze_events_get()
+ * @see evas_object_pass_events_set()
+ * @see evas_object_repeat_events_set()
+ * @see evas_object_propagate_events_set()
+ * @since 1.1
+ *
+ * @param[in] freeze pass whether @p obj is to freeze events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ */
+EAPI void evas_object_freeze_events_set(Evas_Object *obj, Eina_Bool freeze);
+
+/**
+ *
+ * Determine whether an object is set to freeze (discard) events.
+ *
+ * @return freeze whether @p obj is set to freeze events (@c EINA_TRUE) or
+ * not (@c EINA_FALSE)
+ *
+ * @see evas_object_freeze_events_set()
+ * @see evas_object_pass_events_get()
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_propagate_events_get()
+ * @since 1.1
+ *
+ */
+EAPI Eina_Bool evas_object_freeze_events_get(const Evas_Object *obj);
+
+/**
+ *
+ * Set current object transformation map.
+ *
+ * This sets the map on a given object. It is copied from the @p map pointer,
+ * so there is no need to keep the @p map object if you don't need it anymore.
+ *
+ * A map is a set of 4 points which have canvas x, y coordinates per point,
+ * with an optional z point value as a hint for perspective correction, if it
+ * is available. As well each point has u and v coordinates. These are like
+ * "texture coordinates" in OpenGL in that they define a point in the source
+ * image that is mapped to that map vertex/point. The u corresponds to the x
+ * coordinate of this mapped point and v, the y coordinate. Note that these
+ * coordinates describe a bounding region to sample. If you have a 200x100
+ * source image and want to display it at 200x100 with proper pixel
+ * precision, then do:
+ *
+ * @code
+ * Evas_Map *m = evas_map_new(4);
+ * evas_map_point_coord_set(m, 0,   0,   0, 0);
+ * evas_map_point_coord_set(m, 1, 200,   0, 0);
+ * evas_map_point_coord_set(m, 2, 200, 100, 0);
+ * evas_map_point_coord_set(m, 3,   0, 100, 0);
+ * evas_map_point_image_uv_set(m, 0,   0,   0);
+ * evas_map_point_image_uv_set(m, 1, 200,   0);
+ * evas_map_point_image_uv_set(m, 2, 200, 100);
+ * evas_map_point_image_uv_set(m, 3,   0, 100);
+ * evas_object_map_set(obj, m);
+ * evas_map_free(m);
+ * @endcode
+ *
+ * Note that the map points a uv coordinates match the image geometry. If
+ * the @p map parameter is NULL, the stored map will be freed and geometry
+ * prior to enabling/setting a map will be restored.
+ *
+ * @see evas_map_new()
+ *
+ * @param[in] map new map to use
+ */
+EAPI void evas_object_map_set(Evas_Object *obj, const Evas_Map *map);
+
+/**
+ *
+ * Get current object transformation map.
+ *
+ * This returns the current internal map set on the indicated object. It is
+ * intended for read-only access and is only valid as long as the object is
+ * not deleted or the map on the object is not changed. If you wish to modify
+ * the map and set it back do the following:
+ *
+ * @code
+ * const Evas_Map *m = evas_object_map_get(obj);
+ * Evas_Map *m2 = evas_map_dup(m);
+ * evas_map_util_rotate(m2, 30.0, 0, 0);
+ * evas_object_map_set(obj, m2);
+ * evas_map_free(m2);
+ * @endcode
+ *
+ * @return map reference to map in use. This is an internal data structure, so
+ * do not modify it.
+ *
+ * @see evas_object_map_set()
+ *
+ */
+EAPI const Evas_Map *evas_object_map_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the hints for an object's aspect ratio.
+ *
+ * This is not a size enforcement in any way, it's just a hint that should
+ * be used whenever appropriate.
+ *
+ * If any of the given aspect ratio terms are @c 0,
+ * the object's container will ignore the aspect and scale @p obj to
+ * occupy the whole available area, for any given policy.
+ *
+ * @see evas_object_size_hint_aspect_get() for more information.
+ *
+ * @param[in] aspect The policy/type of aspect ratio to apply to @p obj.
+ * @param[in] w Integer to use as aspect width ratio term.
+ * @param[in] h Integer to use as aspect height ratio term.
+ */
+EAPI void evas_object_size_hint_aspect_set(Evas_Object *obj, Evas_Aspect_Control aspect, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Retrieves the hints for an object's aspect ratio.
+ *
+ * The different aspect ratio policies are documented in the
+ * #Evas_Aspect_Control type. A container respecting these size hints
+ * would @b resize its children accordingly to those policies.
+ *
+ * For any policy, if any of the given aspect ratio terms are @c 0,
+ * the object's container should ignore the aspect and scale @p obj to
+ * occupy the whole available area. If they are both positive
+ * integers, that proportion will be respected, under each scaling
+ * policy.
+ *
+ * These images illustrate some of the #Evas_Aspect_Control policies:
+ *
+ * @image html any-policy.png
+ * @image rtf any-policy.png
+ * @image latex any-policy.eps
+ *
+ * @image html aspect-control-none-neither.png
+ * @image rtf aspect-control-none-neither.png
+ * @image latex aspect-control-none-neither.eps
+ *
+ * @image html aspect-control-both.png
+ * @image rtf aspect-control-both.png
+ * @image latex aspect-control-both.eps
+ *
+ * @image html aspect-control-horizontal.png
+ * @image rtf aspect-control-horizontal.png
+ * @image latex aspect-control-horizontal.eps
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * Example:
+ * @dontinclude evas-aspect-hints.c
+ * @skip if (strcmp(ev->key, "c") == 0)
+ * @until }
+ *
+ * See the full @ref Example_Evas_Aspect_Hints "example".
+ *
+ * @see evas_object_size_hint_aspect_set()
+ *
+ * @param[out] aspect The policy/type of aspect ratio to apply to @p obj.
+ * @param[out] w Integer to use as aspect width ratio term.
+ * @param[out] h Integer to use as aspect height ratio term.
+ */
+EAPI void evas_object_size_hint_aspect_get(const Evas_Object *obj, Evas_Aspect_Control *aspect, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the layer of its canvas that the given object will be part of.
+ *
+ * If you don't use this function, you'll be dealing with an @b unique
+ * layer of objects, the default one. Additional layers are handy when
+ * you don't want a set of objects to interfere with another set with
+ * regard to @b stacking. Two layers are completely disjoint in that
+ * matter.
+ *
+ * This is a low-level function, which you'd be using when something
+ * should be always on top, for example.
+ *
+ * @warning Be careful, it doesn't make sense to change the layer of
+ * smart objects' children. Smart objects have a layer of their own,
+ * which should contain all their children objects.
+ *
+ * @see evas_object_layer_get()
+ *
+ * @param[in] l The number of the layer to place the object on.
+Must be between #EVAS_LAYER_MIN and #EVAS_LAYER_MAX.
+ */
+EAPI void evas_object_layer_set(Evas_Object *obj, short l);
+
+/**
+ *
+ * Retrieves the layer of its canvas that the given object is part of.
+ *
+ * @return  Number of its layer
+ *
+ * @see evas_object_layer_set()
+ *
+ */
+EAPI short evas_object_layer_get(const Evas_Object *obj);
+
+/**
+ *
+ * Clip one object to another.
+ *
+ * This function will clip the object @p obj to the area occupied by
+ * the object @p clip. This means the object @p obj will only be
+ * visible within the area occupied by the clipping object (@p clip).
+ *
+ * The color of the object being clipped will be multiplied by the
+ * color of the clipping one, so the resulting color for the former
+ * will be <code>RESULT = (OBJ * CLIP) / (255 * 255)</code>, per color
+ * element (red, green, blue and alpha).
+ *
+ * Clipping is recursive, so clipping objects may be clipped by
+ * others, and their color will in term be multiplied. You may @b not
+ * set up circular clipping lists (i.e. object 1 clips object 2, which
+ * clips object 1): the behavior of Evas is undefined in this case.
+ *
+ * Objects which do not clip others are visible in the canvas as
+ * normal; <b>those that clip one or more objects become invisible
+ * themselves</b>, only affecting what they clip. If an object ceases
+ * to have other objects being clipped by it, it will become visible
+ * again.
+ *
+ * The visibility of an object affects the objects that are clipped by
+ * it, so if the object clipping others is not shown (as in
+ * evas_object_show()), the objects clipped by it will not be shown
+ * either.
+ *
+ * If @p obj was being clipped by another object when this function is
+ * called, it gets implicitly removed from the old clipper's domain
+ * and is made now to be clipped by its new clipper.
+ *
+ * The following figure illustrates some clipping in Evas:
+ *
+ * @image html clipping.png
+ * @image rtf clipping.png
+ * @image latex clipping.eps
+ *
+ * @note At the moment the <b>only objects that can validly be used to
+ * clip other objects are rectangle objects</b>. All other object
+ * types are invalid and the result of using them is undefined. The
+ * clip object @p clip must be a valid object, but can also be @c
+ * NULL, in which case the effect of this function is the same as
+ * calling evas_object_clip_unset() on the @p obj object.
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip solid white clipper (note that it's the default color for a
+ * @until evas_object_show(d.clipper);
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ * @param[in] clip The object to clip @p obj by
+ */
+EAPI void evas_object_clip_set(Evas_Object *obj, Evas_Object *clip) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Get the object clipping @p obj (if any).
+ *
+ * This function returns the object clipping @p obj. If @p obj is
+ * not being clipped at all, @c NULL is returned. The object @p obj
+ * must be a valid .Evas_Object.
+ *
+ * See also evas_object_clip_set(), evas_object_clip_unset() and
+ * evas_object_clipees_get().
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip if (evas_object_clip_get(d.img) == d.clipper)
+ * @until return
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ */
+EAPI Evas_Object *evas_object_clip_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the hints for an object's padding space.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @see evas_object_size_hint_padding_get() for more information
+ *
+ * @param[in] l Integer to specify left padding.
+ * @param[in] r Integer to specify right padding.
+ * @param[in] t Integer to specify top padding.
+ * @param[in] b Integer to specify bottom padding.
+ */
+EAPI void evas_object_size_hint_padding_set(Evas_Object *obj, Evas_Coord l, Evas_Coord r, Evas_Coord t, Evas_Coord b);
+
+/**
+ *
+ * Retrieves the hints for an object's padding space.
+ *
+ * Padding is extra space an object takes on each of its delimiting
+ * rectangle sides, in canvas units. This space will be rendered
+ * transparent, naturally, as in the following figure:
+ *
+ * @image html padding-hints.png
+ * @image rtf padding-hints.png
+ * @image latex padding-hints.eps
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_padding_set
+ * @until return
+ *
+ * In this example the padding hints change the behavior of an Evas box
+ * when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_padding_set()
+ *
+ * @param[out] l Integer to specify left padding.
+ * @param[out] r Integer to specify right padding.
+ * @param[out] t Integer to specify top padding.
+ * @param[out] b Integer to specify bottom padding.
+ */
+EAPI void evas_object_size_hint_padding_get(const Evas_Object *obj, Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+/**
+ *
+ * Set whether an Evas object is to repeat events.
+ *
+ * If @p repeat is @c EINA_TRUE, it will make events on @p obj to also
+ * be repeated for the @b next lower object in the objects' stack (see
+ * see evas_object_below_get()).
+ *
+ * If @p repeat is @c EINA_FALSE, events occurring on @p obj will be
+ * processed only on it.
+ *
+ * Example:
+ * @dontinclude evas-stacking.c
+ * @skip if (strcmp(ev->key, "r") == 0)
+ * @until }
+ *
+ * See the full @ref Example_Evas_Stacking "example".
+ *
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_pass_events_set()
+ * @see evas_object_propagate_events_set()
+ * @see evas_object_freeze_events_set()
+ *
+ * @param[in] repeat whether @p obj is to repeat events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ */
+EAPI void evas_object_repeat_events_set(Evas_Object *obj, Eina_Bool repeat);
+
+/**
+ *
+ * Determine whether an object is set to repeat events.
+ *
+ * @return whether @p obj is set to repeat events (@c EINA_TRUE)
+ * or not (@c EINA_FALSE)
+ *
+ * @see evas_object_repeat_events_set() for an example
+ * @see evas_object_pass_events_get()
+ * @see evas_object_propagate_events_get()
+ * @see evas_object_freeze_events_get()
+ *
+ */
+EAPI Eina_Bool evas_object_repeat_events_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the hints for an object's weight.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * This is a hint on how a container object should @b resize a given
+ * child within its area. Containers may adhere to the simpler logic
+ * of just expanding the child object's dimensions to fit its own (see
+ * the #EVAS_HINT_EXPAND helper weight macro) or the complete one of
+ * taking each child's weight hint as real @b weights to how much of
+ * its size to allocate for them in each axis. A container is supposed
+ * to, after @b normalizing the weights of its children (with weight
+ * hints), distribute the space it has to layout them by those factors
+ * -- most weighted children get larger in this process than the least
+ * ones.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_weight_set
+ * @until return
+ *
+ * In this example the weight hints change the behavior of an Evas box
+ * when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @note Default weight hint values are 0.0, for both axis.
+ *
+ * @see evas_object_size_hint_weight_get() for more information
+ *
+ * @param[in] x Nonnegative double value to use as horizontal weight hint.
+ * @param[in] y Nonnegative double value to use as vertical weight hint.
+ */
+EAPI void evas_object_size_hint_weight_set(Evas_Object *obj, double x, double y);
+
+/**
+ *
+ * Retrieves the hints for an object's weight.
+ *
+ * Accepted values are zero or positive values. Some users might use
+ * this hint as a boolean, but some might consider it as a @b
+ * proportion, see documentation of possible users, which in Evas are
+ * the @ref Evas_Object_Box "box" and @ref Evas_Object_Table "table"
+ * smart objects.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ * @note If @c obj is invalid, then the hint components will be set with 0.0
+ *
+ * @see evas_object_size_hint_weight_set() for an example
+ *
+ * @param[out] x Nonnegative double value to use as horizontal weight hint.
+ * @param[out] y Nonnegative double value to use as vertical weight hint.
+ */
+EAPI void evas_object_size_hint_weight_get(const Evas_Object *obj, double *x, double *y);
+
+/**
+ *
+ * Sets the name of the given Evas object to the given name.
+ *
+ * There might be occasions where one would like to name his/her
+ * objects.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip d.bg = evas_object_rectangle_add(d.canvas);
+ * @until evas_object_name_set(d.bg, "our dear rectangle");
+ *
+ * See the full @ref Example_Evas_Events "example".
+ *
+ * @param[in] name The given name.
+ */
+EAPI void evas_object_name_set(Evas_Object *obj, const char *name);
+
+/**
+ *
+ * Retrieves the name of the given Evas object.
+ *
+ * @return  The name of the object or @c NULL, if no name has been given
+ * to it.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip fprintf(stdout, "An object got focused: %s\n",
+ * @until evas_focus_get
+ *
+ * See the full @ref Example_Evas_Events "example".
+ *
+ */
+EAPI const char *evas_object_name_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the scaling factor for an Evas object. Does not affect all
+ * objects.
+ *
+ * This will multiply the object's dimension by the given factor, thus
+ * altering its geometry (width and height). Useful when you want
+ * scalable UI elements, possibly at run time.
+ *
+ * @note Only text and textblock objects have scaling change
+ * handlers. Other objects won't change visually on this call.
+ *
+ * @see evas_object_scale_get()
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] scale The scaling factor. <c>1.0</c> means no scaling,
+default size.
+ */
+EAPI void evas_object_scale_set(Evas_Object *obj, double scale);
+
+/**
+ *
+ * Retrieves the scaling factor for the given Evas object.
+ *
+ * @return  The scaling factor.
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @see evas_object_scale_set()
+ *
+ */
+EAPI double evas_object_scale_get(const Evas_Object *obj);
+
+/**
+ *
+ * Set a hint flag on the given Evas object that it's used as a "static
+ * clipper".
+ *
+ * This is a hint to Evas that this object is used as a big static
+ * clipper and shouldn't be moved with children and otherwise
+ * considered specially. The default value for new objects is
+ * @c EINA_FALSE.
+ *
+ * @see evas_object_static_clip_get()
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] is_static_clip @c EINA_TRUE if it's to be used as a static
+clipper, @c EINA_FALSE otherwise.
+ */
+EAPI void evas_object_static_clip_set(Evas_Object *obj, Eina_Bool is_static_clip);
+
+/**
+ *
+ * Get the "static clipper" hint flag for a given Evas object.
+ *
+ * @return @c EINA_TRUE if it's set as a static clipper,
+ * @c EINA_FALSE otherwise.
+ *
+ * @see evas_object_static_clip_set() for more details
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ */
+EAPI Eina_Bool evas_object_static_clip_get(const Evas_Object *obj);
+
+/**
+ *
+ * Changes the size of the given Evas object.
+ *
+ * @param[in] w in
+ * @param[in] h in
+ */
+EAPI void evas_object_resize(Evas_Object *obj, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Sets or unsets a given object as the currently focused one on its
+ * canvas.
+ *
+ * Changing focus only affects where (key) input events go. There can
+ * be only one object focused at any time. If @p focus is @c EINA_TRUE,
+ * @p obj will be set as the currently focused object and it will
+ * receive all keyboard events that are not exclusive key grabs on
+ * other objects.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip evas_object_focus_set
+ * @until evas_object_focus_set
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_focus_get
+ * @see evas_focus_get
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ *
+ * @param[in] focus @c EINA_TRUE, to set it as focused or @c EINA_FALSE,
+to take away the focus from it.
+ */
+EAPI void evas_object_focus_set(Evas_Object *obj, Eina_Bool focus);
+
+/**
+ *
+ * Retrieve whether an object has the focus.
+ *
+ * @return @c EINA_TRUE if the object has the focus, @c EINA_FALSE otherwise.
+ *
+ * If the passed object is the currently focused one, @c EINA_TRUE is
+ * returned. @c EINA_FALSE is returned, otherwise.
+ *
+ * Example:
+ * @dontinclude evas-events.c
+ * @skip And again
+ * @until something is bad
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_focus_set
+ * @see evas_focus_get
+ * @see evas_object_key_grab
+ * @see evas_object_key_ungrab
+ *
+ */
+EAPI Eina_Bool evas_object_focus_get(const Evas_Object *obj);
+
+/**
+ *
+ * @since 1.2
+ *
+ * @param[in] is_frame in
+ */
+EAPI void evas_object_is_frame_object_set(Evas_Object *obj, Eina_Bool is_frame);
+
+/**
+ *
+ * @since 1.2
+ *
+ */
+EAPI Eina_Bool evas_object_is_frame_object_get(const Evas_Object *obj);
+
+/**
+ *
+ * Enable or disable the map that is set.
+ *
+ * Enable or disable the use of map for the object @p obj.
+ * On enable, the object geometry will be saved, and the new geometry will
+ * change (position and size) to reflect the map geometry set.
+ *
+ * If the object doesn't have a map set (with evas_object_map_set()), the
+ * initial geometry will be undefined. It is advised to always set a map
+ * to the object first, and then call this function to enable its use.
+ *
+ * @param[in] enabled enabled state
+ */
+EAPI void evas_object_map_enable_set(Evas_Object *obj, Eina_Bool enabled);
+
+/**
+ *
+ * Get the map enabled state
+ *
+ * This returns the currently enabled state of the map on the object indicated.
+ * The default map enable state is off. You can enable and disable it with
+ * evas_object_map_enable_set().
+ *
+ * @return the map enabled state
+ *
+ */
+EAPI Eina_Bool evas_object_map_enable_get(const Evas_Object *obj);
+
+/**
+ *
+ * Set whether to use precise (usually expensive) point collision
+ * detection for a given Evas object.
+ *
+ * Use this function to make Evas treat objects' transparent areas as
+ * @b not belonging to it with regard to mouse pointer events. By
+ * default, all of the object's boundary rectangle will be taken in
+ * account for them.
+ *
+ * @warning By using precise point collision detection you'll be
+ * making Evas more resource intensive.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip if (strcmp(ev->key, "p") == 0)
+ * @until }
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_precise_is_inside_get()
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] precise Whether to use precise point collision detection or
+not. The default value is false.
+ */
+EAPI void evas_object_precise_is_inside_set(Evas_Object *obj, Eina_Bool precise);
+
+/**
+ *
+ * Determine whether an object is set to use precise point collision
+ * detection.
+ *
+ * @return whether @p obj is set to use precise point collision
+ * detection or not The default value is false.
+ *
+ * @see evas_object_precise_is_inside_set() for an example
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ */
+EAPI Eina_Bool evas_object_precise_is_inside_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the hints for an object's alignment.
+ *
+ * These are hints on how to align an object <b>inside the boundaries
+ * of a container/manager</b>. Accepted values are in the @c 0.0 to @c
+ * 1.0 range, with the special value #EVAS_HINT_FILL used to specify
+ * "justify" or "fill" by some users. In this case, maximum size hints
+ * should be enforced with higher priority, if they are set. Also, any
+ * padding hint set on objects should add up to the alignment space on
+ * the final scene composition.
+ *
+ * See documentation of possible users: in Evas, they are the @ref
+ * Evas_Object_Box "box" and @ref Evas_Object_Table "table" smart
+ * objects.
+ *
+ * For the horizontal component, @c 0.0 means to the left, @c 1.0
+ * means to the right. Analogously, for the vertical component, @c 0.0
+ * to the top, @c 1.0 means to the bottom.
+ *
+ * See the following figure:
+ *
+ * @image html alignment-hints.png
+ * @image rtf alignment-hints.png
+ * @image latex alignment-hints.eps
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Default alignment hint values are 0.5, for both axis.
+ *
+ * Example:
+ * @dontinclude evas-hints.c
+ * @skip evas_object_size_hint_align_set
+ * @until return
+ *
+ * In this example the alignment hints change the behavior of an Evas
+ * box when layouting its children. See the full @ref
+ * Example_Evas_Size_Hints "example".
+ *
+ * @see evas_object_size_hint_align_get()
+ * @see evas_object_size_hint_max_set()
+ * @see evas_object_size_hint_padding_set()
+ *
+ * @param[in] x Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as horizontal alignment hint.
+ * @param[in] y Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as vertical alignment hint.
+ */
+EAPI void evas_object_size_hint_align_set(Evas_Object *obj, double x, double y);
+
+/**
+ *
+ * Retrieves the hints for on object's alignment.
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * should be used whenever appropriate.
+ *
+ * @note Use @c NULL pointers on the hint components you're not
+ * interested in: they'll be ignored by the function.
+ * @note If @c obj is invalid, then the hint components will be set with 0.5
+ *
+ * @see evas_object_size_hint_align_set() for more information
+ *
+ * @param[out] x Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as horizontal alignment hint.
+ * @param[out] y Double, ranging from @c 0.0 to @c 1.0 or with the
+special value #EVAS_HINT_FILL, to use as vertical alignment hint.
+ */
+EAPI void evas_object_size_hint_align_get(const Evas_Object *obj, double *x, double *y);
+
+/**
+ *
+ * Set whether events on a smart object's member should get propagated
+ * up to its parent.
+ *
+ * This function has @b no effect if @p obj is not a member of a smart
+ * object.
+ *
+ * If @p prop is @c EINA_TRUE, events occurring on this object will be
+ * propagated on to the smart object of which @p obj is a member.  If
+ * @p prop is @c EINA_FALSE, events occurring on this object will @b
+ * not be propagated on to the smart object of which @p obj is a
+ * member.  The default value is @c EINA_TRUE.
+ *
+ * @see evas_object_propagate_events_get()
+ * @see evas_object_repeat_events_set()
+ * @see evas_object_pass_events_set()
+ * @see evas_object_freeze_events_set()
+ *
+ * @param[in] propagate whether to propagate events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ */
+EAPI void evas_object_propagate_events_set(Evas_Object *obj, Eina_Bool propagate);
+
+/**
+ *
+ * Retrieve whether an Evas object is set to propagate events.
+ *
+ * @return whether @p obj is set to propagate events (@c EINA_TRUE)
+ * or not (@c EINA_FALSE)
+ *
+ * @see evas_object_propagate_events_set()
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_pass_events_get()
+ * @see evas_object_freeze_events_get()
+ *
+ */
+EAPI Eina_Bool evas_object_propagate_events_get(const Evas_Object *obj);
+
+/**
+ *
+ * Set whether an Evas object is to pass (ignore) events.
+ *
+ * If @p pass is @c EINA_TRUE, it will make events on @p obj to be @b
+ * ignored. They will be triggered on the @b next lower object (that
+ * is not set to pass events), instead (see evas_object_below_get()).
+ *
+ * If @p pass is @c EINA_FALSE, events will be processed on that
+ * object as normal.
+ *
+ * @see evas_object_pass_events_get() for an example
+ * @see evas_object_repeat_events_set()
+ * @see evas_object_propagate_events_set()
+ * @see evas_object_freeze_events_set()
+ *
+ * @param[in] pass whether @p obj is to pass events (@c EINA_TRUE) or not
+(@c EINA_FALSE)
+ */
+EAPI void evas_object_pass_events_set(Evas_Object *obj, Eina_Bool pass);
+
+/**
+ *
+ * Determine whether an object is set to pass (ignore) events.
+ *
+ * @return pass whether @p obj is set to pass events (@c EINA_TRUE) or not
+ * (@c EINA_FALSE)
+ *
+ * Example:
+ * @dontinclude evas-stacking.c
+ * @skip if (strcmp(ev->key, "p") == 0)
+ * @until }
+ *
+ * See the full @ref Example_Evas_Stacking "example".
+ *
+ * @see evas_object_pass_events_set()
+ * @see evas_object_repeat_events_get()
+ * @see evas_object_propagate_events_get()
+ * @see evas_object_freeze_events_get()
+ *
+ */
+EAPI Eina_Bool evas_object_pass_events_get(const Evas_Object *obj);
+
+/**
+ *
+ * Move the given Evas object to the given location inside its canvas' viewport.
+ *
+ * @param[in] x in
+ * @param[in] y in
+ */
+EAPI void evas_object_move(Evas_Object *obj, Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * Sets whether or not the given Evas object is to be drawn anti-aliased.
+ *
+ * @ingroup Evas_Object_Group_Extras
+ *
+ * @param[in] anti_alias (@c EINA_TRUE) if the object is to be anti_aliased, (@c EINA_FALSE) otherwise.
+ */
+EAPI void evas_object_anti_alias_set(Evas_Object *obj, Eina_Bool anti_alias);
+
+/**
+ *
+ * Retrieves whether or not the given Evas object is to be drawn anti_aliased.
+ * @return  (@c EINA_TRUE) if the object is to be anti_aliased.  (@c EINA_FALSE) otherwise.
+ * @ingroup Evas_Object_Group_Extras
+ *
+ */
+EAPI Eina_Bool evas_object_anti_alias_get(const Evas_Object *obj);
+
+/**
+ *
+ * Sets the general/main color of the given Evas object to the given
+ * one.
+ *
+ * @see evas_object_color_get() (for an example)
+ * @note These color values are expected to be premultiplied by @p a.
+ *
+ * @ingroup Evas_Object_Group_Basic
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ */
+EAPI void evas_object_color_set(Evas_Object *obj, int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the general/main color of the given Evas object.
+ *
+ * Retrieves the main color's RGB component (and alpha channel)
+ * values, <b>which range from 0 to 255</b>. For the alpha channel,
+ * which defines the object's transparency level, 0 means totally
+ * transparent, while 255 means opaque. These color values are
+ * premultiplied by the alpha value.
+ *
+ * Usually youll use this attribute for text and rectangle objects,
+ * where the main color is their unique one. If set for objects
+ * which themselves have colors, like the images one, those colors get
+ * modulated by this one.
+ *
+ * @note All newly created Evas rectangles get the default color
+ * values of <code>255 255 255 255</code> (opaque white).
+ *
+ * @note Use @c NULL pointers on the components you're not interested
+ * in: they'll be ignored by the function.
+ *
+ * Example:
+ * @dontinclude evas-object-manipulation.c
+ * @skip int alpha, r, g, b;
+ * @until return
+ *
+ * See the full @ref Example_Evas_Object_Manipulation "example".
+ *
+ * @ingroup Evas_Object_Group_Basic
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ */
+EAPI void evas_object_color_get(const Evas_Object *obj, int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * Retrieve user data stored on a given smart object.
+ *
+ * @return A pointer to data stored using
+ * evas_object_smart_data_set(), or @c NULL, if none has been
+ * set.
+ *
+ * @see evas_object_smart_data_set()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ */
+EAPI void *evas_object_smart_data_get(const Evas_Object *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the clipper object for the given clipped smart object.
+ *
+ * @return the clipper object.
+ *
+ * Use this function if you want to change any of this clipper's
+ * properties, like colors.
+ *
+ * @see evas_object_smart_clipped_smart_add()
+ *
+ */
+EAPI Evas_Object *evas_object_smart_clipped_clipper_get(const Evas_Object *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the Evas object stacked right below @p obj
+ *
+ * @return the #Evas_Object directly below @p obj, if any, or @c NULL,
+ * if none
+ *
+ * This function will traverse layers in its search, if there are
+ * objects on layers below the one @p obj is placed at.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ *
+ */
+EAPI Evas_Object *evas_object_below_get(const Evas_Object *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Return a list of objects currently clipped by @p obj.
+ *
+ * @return a list of objects being clipped by @p obj
+ *
+ * This returns the internal list handle that contains all objects
+ * clipped by the object @p obj. If none are clipped by it, the call
+ * returns @c NULL. This list is only valid until the clip list is
+ * changed and should be fetched again with another call to
+ * evas_object_clipees_get() if any objects being clipped by this
+ * object are unclipped, clipped by a new object, deleted or get the
+ * clipper deleted. These operations will invalidate the list
+ * returned, so it should not be used anymore after that point. Any
+ * use of the list after this may have undefined results, possibly
+ * leading to crashes. The object @p obj must be a valid
+ * .Evas_Object.
+ *
+ * See also evas_object_clip_set(), evas_object_clip_unset() and
+ * evas_object_clip_get().
+ *
+ * Example:
+ * @code
+ * extern Evas_Object *obj;
+ * Evas_Object *clipper;
+ *
+ * clipper = evas_object_clip_get(obj);
+ * if (clipper)
+ * {
+ * Eina_List *clippees, *l;
+ * Evas_Object *obj_tmp;
+ *
+ * clippees = evas_object_clipees_get(clipper);
+ * printf("Clipper clips %i objects\n", eina_list_count(clippees));
+ * EINA_LIST_FOREACH(clippees, l, obj_tmp)
+ * evas_object_show(obj_tmp);
+ * }
+ * @endcode
+ *
+ */
+EAPI const Eina_List *evas_object_clipees_get(const Evas_Object *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Gets the parent smart object of a given Evas object, if it has one.
+ *
+ * @return Returns the parent smart object of @a obj or @c NULL, if @a
+ * obj is not a smart member of any
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ */
+EAPI Evas_Object *evas_object_smart_parent_get(const Evas_Object *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the Evas object stacked right above @p obj
+ *
+ * @return the #Evas_Object directly above @p obj, if any, or @c NULL,
+ * if none
+ *
+ * This function will traverse layers in its search, if there are
+ * objects on layers above the one @p obj is placed at.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_below_get()
+ *
+ */
+EAPI Evas_Object *evas_object_above_get(const Evas_Object *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Sets the hints for an object's disply mode
+ *
+ * This is not a size enforcement in any way, it's just a hint that
+ * can be used whenever appropriate.
+ *
+ * @param[in] dispmode display mode hint
+ */
+EAPI void evas_object_size_hint_display_mode_set(Evas_Object *obj, Evas_Display_Mode dispmode);
+
+/**
+ *
+ * Retrieves the hints for an object's display mode
+ *
+ * These are hints on the display mode @p obj. This is
+ * not a size enforcement in any way, it's just a hint that can be
+ * used whenever appropriate.
+ * This mode can be used object's display mode like commpress or expand
+ *
+ */
+EAPI Evas_Display_Mode evas_object_size_hint_display_mode_get(const Evas_Object *obj);
+
+/**
+ *
+ * Test if any object is clipped by @p obj.
+ *
+ * @return EINA_TRUE if @p obj clip any object.
+ * @since 1.8
+ * 
+ *
+ */
+EAPI Eina_Bool evas_object_clipees_has(const Evas_Object *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Requests @p keyname key events be directed to @p obj.
+ *
+ * @return @c EINA_TRUE, if the call succeeded, @c EINA_FALSE otherwise.
+ *
+ * Key grabs allow one or more objects to receive key events for
+ * specific key strokes even if other objects have focus. Whenever a
+ * key is grabbed, only the objects grabbing it will get the events
+ * for the given keys.
+ *
+ * @p keyname is a platform dependent symbolic name for the key
+ * pressed (see @ref Evas_Keys for more information).
+ *
+ * @p modifiers and @p not_modifiers are bit masks of all the
+ * modifiers that must and mustn't, respectively, be pressed along
+ * with @p keyname key in order to trigger this new key
+ * grab. Modifiers can be things such as Shift and Ctrl as well as
+ * user defined types via evas_key_modifier_add(). Retrieve them with
+ * evas_key_modifier_mask_get() or use @c 0 for empty masks.
+ *
+ * @p exclusive will make the given object the only one permitted to
+ * grab the given key. If given @c EINA_TRUE, subsequent calls on this
+ * function with different @p obj arguments will fail, unless the key
+ * is ungrabbed again.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip if (d.focus)
+ * @until else
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @warning Providing impossible modifier sets creates undefined behavior
+ *
+ * @see evas_object_key_ungrab
+ * @see evas_object_focus_set
+ * @see evas_object_focus_get
+ * @see evas_focus_get
+ * @see evas_key_modifier_add
+ * 
+ *
+ * @param[in] keyname the key to request events for.
+ * @param[in] modifiers a mask of modifiers that must be present to
+trigger the event.
+ * @param[in] not_modifiers a mask of modifiers that must @b not be present
+to trigger the event.
+ * @param[in] exclusive request that the @p obj is the only object
+receiving the @p keyname events.
+ */
+EAPI Eina_Bool evas_object_key_grab(Evas_Object *obj, const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers, Eina_Bool exclusive) EINA_WARN_UNUSED_RESULT EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Stack @p obj immediately below @p below
+ *
+ * Objects, in a given canvas, are stacked in the order they get added
+ * to it.  This means that, if they overlap, the highest ones will
+ * cover the lowest ones, in that order. This function is a way to
+ * change the stacking order for the objects.
+ *
+ * This function is intended to be used with <b>objects belonging to
+ * the same layer</b> in a given canvas, otherwise it will fail (and
+ * accomplish nothing).
+ *
+ * If you have smart objects on your canvas and @p obj is a member of
+ * one of them, then @p below must also be a member of the same
+ * smart object.
+ *
+ * Similarly, if @p obj is not a member of a smart object, @p below
+ * must not be either.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_stack_below()
+ * 
+ *
+ * @param[in] below the object below which to stack
+ */
+EAPI void evas_object_stack_below(Evas_Object *obj, Evas_Object *below) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Raise @p obj to the top of its layer.
+ *
+ * @p obj will, then, be the highest one in the layer it belongs
+ * to. Object on other layers won't get touched.
+ *
+ * @see evas_object_stack_above()
+ * @see evas_object_stack_below()
+ * @see evas_object_lower()
+ * 
+ *
+ */
+EAPI void evas_object_raise(Evas_Object *obj);
+
+/**
+ *
+ * Stack @p obj immediately above @p above
+ *
+ * Objects, in a given canvas, are stacked in the order they get added
+ * to it.  This means that, if they overlap, the highest ones will
+ * cover the lowest ones, in that order. This function is a way to
+ * change the stacking order for the objects.
+ *
+ * This function is intended to be used with <b>objects belonging to
+ * the same layer</b> in a given canvas, otherwise it will fail (and
+ * accomplish nothing).
+ *
+ * If you have smart objects on your canvas and @p obj is a member of
+ * one of them, then @p above must also be a member of the same
+ * smart object.
+ *
+ * Similarly, if @p obj is not a member of a smart object, @p above
+ * must not be either.
+ *
+ * @see evas_object_layer_get()
+ * @see evas_object_layer_set()
+ * @see evas_object_stack_below()
+ * 
+ *
+ * @param[in] above the object above which to stack
+ */
+EAPI void evas_object_stack_above(Evas_Object *obj, Evas_Object *above) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Checks whether a given smart object or any of its smart object
+ * parents is of a given smart class.
+ *
+ * @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+ * type, @c EINA_FALSE otherwise
+ *
+ * If @p obj is not a smart object, this call will fail
+ * immediately.
+ *
+ * This function supports Eo and legacy inheritance mechanisms. However,
+ * it is recommended to use eo_isa instead if your object is using Eo from
+ * top to bottom.
+ *
+ * The checks use smart classes names and <b>string
+ * comparison</b>. There is a version of this same check using
+ * <b>pointer comparison</b>, since a smart class' name is a single
+ * string in Evas.
+ *
+ * @see evas_object_smart_type_check_ptr()
+ * @see eo_isa
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[in] type The @b name (type) of the smart class to check for
+ */
+EAPI Eina_Bool evas_object_smart_type_check(const Evas_Object *obj, const char *type) EINA_WARN_UNUSED_RESULT EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Retrieves the object from children of the given object with the given name.
+ * @return  If successful, the Evas object with the given name.  Otherwise,
+ * @c NULL.
+ *
+ * This looks for the evas object given a name by evas_object_name_set(), but
+ * it ONLY looks at the children of the object *p obj, and will only recurse
+ * into those children if @p recurse is greater than 0. If the name is not
+ * unique within immediate children (or the whole child tree) then it is not
+ * defined which child object will be returned. If @p recurse is set to -1 then
+ * it will recurse without limit.
+ *
+ * @since 1.2
+ *
+ * @ingroup Evas_Object_Group_Find
+ * 
+ *
+ * @param[in] name The given name.
+ * @param[in] recurse Set to the number of child levels to recurse (0 == don't recurse, 1 == only look at the children of @p obj or their immediate children, but no further etc.).
+ */
+EAPI Evas_Object *evas_object_name_child_find(const Evas_Object *obj, const char *name, int recurse) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Removes the grab on @p keyname key events by @p obj.
+ *
+ * Removes a key grab on @p obj if @p keyname, @p modifiers, and @p
+ * not_modifiers match.
+ *
+ * Example code follows.
+ * @dontinclude evas-events.c
+ * @skip got here by key grabs
+ * @until }
+ *
+ * See the full example @ref Example_Evas_Events "here".
+ *
+ * @see evas_object_key_grab
+ * @see evas_object_focus_set
+ * @see evas_object_focus_get
+ * @see evas_focus_get
+ * 
+ *
+ * @param[in] keyname the key the grab is set for.
+ * @param[in] modifiers a mask of modifiers that must be present to
+trigger the event.
+ * @param[in] not_modifiers a mask of modifiers that must not not be
+present to trigger the event.
+ */
+EAPI void evas_object_key_ungrab(Evas_Object *obj, const char *keyname, Evas_Modifier_Mask modifiers, Evas_Modifier_Mask not_modifiers) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Lower @p obj to the bottom of its layer.
+ *
+ * @p obj will, then, be the lowest one in the layer it belongs
+ * to. Objects on other layers won't get touched.
+ *
+ * @see evas_object_stack_above()
+ * @see evas_object_stack_below()
+ * @see evas_object_raise()
+ * 
+ *
+ */
+EAPI void evas_object_lower(Evas_Object *obj);
+
+/**
+ *
+ * Disable/cease clipping on a clipped @p obj object.
+ *
+ * This function disables clipping for the object @p obj, if it was
+ * already clipped, i.e., its visibility and color get detached from
+ * the previous clipper. If it wasn't, this has no effect. The object
+ * @p obj must be a valid .Evas_Object.
+ *
+ * See also evas_object_clip_set() (for an example),
+ * evas_object_clipees_get() and evas_object_clip_get().
+ * 
+ *
+ */
+EAPI void evas_object_clip_unset(Evas_Object *obj);
+
+/**
+ *
+ * Moves all children objects of a given smart object relative to a
+ * given offset.
+ *
+ * This will make each of @p obj object's children to move, from where
+ * they before, with those delta values (offsets) on both directions.
+ *
+ * @note This is most useful on custom smart @c move() functions.
+ *
+ * @note Clipped smart objects already make use of this function on
+ * their @c move() smart function definition.
+ * 
+ *
+ * @param[in] dx horizontal offset (delta).
+ * @param[in] dy vertical offset (delta).
+ */
+EAPI void evas_object_smart_move_children_relative(Evas_Object *obj, Evas_Coord dx, Evas_Coord dy);
+
+/**
+ *
+ * Checks whether a given smart object or any of its smart object
+ * parents is of a given smart class, <b>using pointer comparison</b>.
+ *
+ * @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+ * type, @c EINA_FALSE otherwise
+ *
+ * @see evas_object_smart_type_check() for more details
+ * @see eo_isa
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[in] type The type (name string) to check for. Must be the name
+ */
+EAPI Eina_Bool evas_object_smart_type_check_ptr(const Evas_Object *obj, const char *type) EINA_WARN_UNUSED_RESULT EINA_ARG_NONNULL(2);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_object_smart.eo.c b/src/lib/evas/canvas/evas_object_smart.eo.c
--- a/src/lib/evas/canvas/evas_object_smart.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object_smart.eo.c	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,213 @@
+
+void _evas_object_smart_need_recalculate_set(Eo *obj, Evas_Smart_Data *pd, Eina_Bool value);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_need_recalculate_set, EO_FUNC_CALL(value), Eina_Bool value);
+
+Eina_Bool _evas_object_smart_need_recalculate_get(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_smart_need_recalculate_get, Eina_Bool, 0);
+
+void _evas_object_smart_clip_set(Eo *obj, Evas_Smart_Data *pd, Evas_Object *clip);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_clip_set, EO_FUNC_CALL(clip), Evas_Object *clip);
+
+void _evas_object_smart_color_set(Eo *obj, Evas_Smart_Data *pd, int r, int g, int b, int a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_color_set, EO_FUNC_CALL(r, g, b, a), int r, int g, int b, int a);
+
+void _evas_object_smart_data_set(Eo *obj, Evas_Smart_Data *pd, void *data);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_data_set, EO_FUNC_CALL(data), void *data);
+
+Eina_List * _evas_object_smart_members_get(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_smart_members_get, Eina_List *, 0);
+
+Evas_Smart * _evas_object_smart_smart_get(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_smart_get, Evas_Smart *, 0);
+
+void _evas_object_smart_show(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_smart_show);
+
+void _evas_object_smart_move(Eo *obj, Evas_Smart_Data *pd, Evas_Coord x, Evas_Coord y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_move, EO_FUNC_CALL(x, y), Evas_Coord x, Evas_Coord y);
+
+Eina_Bool _evas_object_smart_callbacks_descriptions_set(Eo *obj, Evas_Smart_Data *pd, const Evas_Smart_Cb_Description *descriptions);
+
+EOAPI EO_FUNC_BODYV(evas_obj_smart_callbacks_descriptions_set, Eina_Bool, 0, EO_FUNC_CALL(descriptions), const Evas_Smart_Cb_Description *descriptions);
+
+void _evas_object_smart_callbacks_descriptions_get(Eo *obj, Evas_Smart_Data *pd, const Evas_Smart_Cb_Description ***class_descriptions, unsigned int *class_count, const Evas_Smart_Cb_Description ***instance_descriptions, unsigned int *instance_count);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_callbacks_descriptions_get, EO_FUNC_CALL(class_descriptions, class_count, instance_descriptions, instance_count), const Evas_Smart_Cb_Description ***class_descriptions, unsigned int *class_count, const Evas_Smart_Cb_Description ***instance_descriptions, unsigned int *instance_count);
+
+Eina_Iterator * _evas_object_smart_iterator_new(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_smart_iterator_new, Eina_Iterator *, 0);
+
+void _evas_object_smart_callback_description_find(Eo *obj, Evas_Smart_Data *pd, const char *name, const Evas_Smart_Cb_Description **class_description, const Evas_Smart_Cb_Description **instance_description);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_callback_description_find, EO_FUNC_CALL(name, class_description, instance_description), const char *name, const Evas_Smart_Cb_Description **class_description, const Evas_Smart_Cb_Description **instance_description);
+
+void _evas_object_smart_hide(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_smart_hide);
+
+void _evas_object_smart_calculate(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_smart_calculate);
+
+void _evas_object_smart_add(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_smart_add);
+
+void _evas_object_smart_member_add(Eo *obj, Evas_Smart_Data *pd, Evas_Object *sub_obj);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_member_add, EO_FUNC_CALL(sub_obj), Evas_Object *sub_obj);
+
+void _evas_object_smart_resize(Eo *obj, Evas_Smart_Data *pd, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_resize, EO_FUNC_CALL(w, h), Evas_Coord w, Evas_Coord h);
+
+void _evas_object_smart_clip_unset(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_smart_clip_unset);
+
+void _evas_object_smart_changed(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_smart_changed);
+
+void _evas_object_smart_member_del(Eo *obj, Evas_Smart_Data *pd, Evas_Object *sub_obj);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_member_del, EO_FUNC_CALL(sub_obj), Evas_Object *sub_obj);
+
+void _evas_object_smart_del(Eo *obj, Evas_Smart_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_smart_del);
+
+void _evas_object_smart_attach(Eo *obj, Evas_Smart_Data *pd, Evas_Smart *s);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_smart_attach, EO_FUNC_CALL(s), Evas_Smart *s);
+
+void _evas_object_smart_eo_base_constructor(Eo *obj, Evas_Smart_Data *pd);
+
+
+Eina_Bool _evas_object_smart_evas_object_smart_type_check_ptr(Eo *obj, Evas_Smart_Data *pd, const char *type);
+
+
+Eina_Bool _evas_object_smart_evas_object_smart_type_check(Eo *obj, Evas_Smart_Data *pd, const char *type);
+
+
+void * _evas_object_smart_evas_object_smart_data_get(Eo *obj, Evas_Smart_Data *pd);
+
+
+static Eo_Op_Description _evas_object_smart_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_object_smart_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_type_check_ptr, _evas_object_smart_evas_object_smart_type_check_ptr),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_type_check, _evas_object_smart_evas_object_smart_type_check),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_data_get, _evas_object_smart_evas_object_smart_data_get),
+     EO_OP_FUNC(evas_obj_smart_need_recalculate_set, _evas_object_smart_need_recalculate_set, "Set or unset the flag signalling that a given smart object needs to"),
+     EO_OP_FUNC(evas_obj_smart_need_recalculate_get, _evas_object_smart_need_recalculate_get, "Get the value of the flag signalling that a given smart object needs to"),
+     EO_OP_FUNC(evas_obj_smart_clip_set, _evas_object_smart_clip_set, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_smart_color_set, _evas_object_smart_color_set, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_smart_data_set, _evas_object_smart_data_set, "Store a pointer to user data for a given smart object."),
+     EO_OP_FUNC(evas_obj_smart_members_get, _evas_object_smart_members_get, "Retrieves the list of the member objects of a given Evas smart"),
+     EO_OP_FUNC(evas_obj_smart_get, _evas_object_smart_smart_get, "Get the #Evas_Smart from which @p obj smart object was created."),
+     EO_OP_FUNC(evas_obj_smart_show, _evas_object_smart_show, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_smart_move, _evas_object_smart_move, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_smart_callbacks_descriptions_set, _evas_object_smart_callbacks_descriptions_set, "Set an smart object @b instance's smart callbacks descriptions."),
+     EO_OP_FUNC(evas_obj_smart_callbacks_descriptions_get, _evas_object_smart_callbacks_descriptions_get, "Retrieve an smart object's know smart callback descriptions (both"),
+     EO_OP_FUNC(evas_obj_smart_iterator_new, _evas_object_smart_iterator_new, "Retrieves an iterator of the member objects of a given Evas smart"),
+     EO_OP_FUNC(evas_obj_smart_callback_description_find, _evas_object_smart_callback_description_find, "Find callback description for callback called @a name."),
+     EO_OP_FUNC(evas_obj_smart_hide, _evas_object_smart_hide, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_smart_calculate, _evas_object_smart_calculate, "Call the @b calculate() smart function immediately on a given smart"),
+     EO_OP_FUNC(evas_obj_smart_add, _evas_object_smart_add, "Instantiates a new smart object described by @p s."),
+     EO_OP_FUNC(evas_obj_smart_member_add, _evas_object_smart_member_add, "Set an Evas object as a member of a given smart object."),
+     EO_OP_FUNC(evas_obj_smart_resize, _evas_object_smart_resize, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_smart_clip_unset, _evas_object_smart_clip_unset, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_smart_changed, _evas_object_smart_changed, "Mark smart object as changed, dirty."),
+     EO_OP_FUNC(evas_obj_smart_member_del, _evas_object_smart_member_del, "Removes a member object from a given smart object."),
+     EO_OP_FUNC(evas_obj_smart_del, _evas_object_smart_del, "Deletes a smart object."),
+     EO_OP_FUNC(evas_obj_smart_attach, _evas_object_smart_attach, "Attach a given smart data to a given smart object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_object_smart_class_desc = {
+     EO_VERSION,
+     "Evas_Object_Smart",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_object_smart_op_desc),
+     NULL,
+     sizeof(Evas_Smart_Data),
+     _evas_object_smart_class_constructor,
+     _evas_object_smart_class_destructor
+};
+
+EO_DEFINE_CLASS(evas_object_smart_class_get, &_evas_object_smart_class_desc, EVAS_OBJECT_CLASS, EVAS_SIGNAL_INTERFACE_INTERFACE, NULL);
+EAPI void
+evas_object_smart_need_recalculate_set(Evas_Object_Smart *obj, Eina_Bool value)
+{
+   eo_do((Evas_Object_Smart *)obj, evas_obj_smart_need_recalculate_set(value));
+}
+
+EAPI Eina_Bool
+evas_object_smart_need_recalculate_get(const Evas_Object_Smart *obj)
+{
+   return eo_do((Evas_Object_Smart *)obj, evas_obj_smart_need_recalculate_get());
+}
+
+EAPI void
+evas_object_smart_data_set(Evas_Object_Smart *obj, void *data)
+{
+   eo_do((Evas_Object_Smart *)obj, evas_obj_smart_data_set(data));
+}
+
+EAPI Eina_List *
+evas_object_smart_members_get(const Evas_Object_Smart *obj)
+{
+   return eo_do((Evas_Object_Smart *)obj, evas_obj_smart_members_get());
+}
+
+EAPI Evas_Smart *
+evas_object_smart_smart_get(const Evas_Object_Smart *obj)
+{
+   return eo_do((Evas_Object_Smart *)obj, evas_obj_smart_get());
+}
+
+EAPI Eina_Bool
+evas_object_smart_callbacks_descriptions_set(Evas_Object_Smart *obj, const Evas_Smart_Cb_Description *descriptions)
+{
+   return eo_do((Evas_Object_Smart *)obj, evas_obj_smart_callbacks_descriptions_set(descriptions));
+}
+
+EAPI void
+evas_object_smart_callbacks_descriptions_get(const Evas_Object_Smart *obj, const Evas_Smart_Cb_Description ***class_descriptions, unsigned int *class_count, const Evas_Smart_Cb_Description ***instance_descriptions, unsigned int *instance_count)
+{
+   eo_do((Evas_Object_Smart *)obj, evas_obj_smart_callbacks_descriptions_get(class_descriptions, class_count, instance_descriptions, instance_count));
+}
+
+EAPI Eina_Iterator *
+evas_object_smart_iterator_new(const Evas_Object_Smart *obj)
+{
+   return eo_do((Evas_Object_Smart *)obj, evas_obj_smart_iterator_new());
+}
+
+EAPI void
+evas_object_smart_callback_description_find(const Evas_Object_Smart *obj, const char *name, const Evas_Smart_Cb_Description **class_description, const Evas_Smart_Cb_Description **instance_description)
+{
+   eo_do((Evas_Object_Smart *)obj, evas_obj_smart_callback_description_find(name, class_description, instance_description));
+}
+
+EAPI void
+evas_object_smart_calculate(Evas_Object_Smart *obj)
+{
+   eo_do((Evas_Object_Smart *)obj, evas_obj_smart_calculate());
+}
+
+EAPI void
+evas_object_smart_changed(Evas_Object_Smart *obj)
+{
+   eo_do((Evas_Object_Smart *)obj, evas_obj_smart_changed());
+}
diff -Naur a/src/lib/evas/canvas/evas_object_smart.eo.h b/src/lib/evas/canvas/evas_object_smart.eo.h
--- a/src/lib/evas/canvas/evas_object_smart.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object_smart.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,419 @@
+#ifndef _EVAS_OBJECT_SMART_EO_H_
+#define _EVAS_OBJECT_SMART_EO_H_
+
+#ifndef _EVAS_OBJECT_SMART_EO_CLASS_TYPE
+#define _EVAS_OBJECT_SMART_EO_CLASS_TYPE
+
+typedef Eo Evas_Object_Smart;
+
+#endif
+
+#ifndef _EVAS_OBJECT_SMART_EO_TYPES
+#define _EVAS_OBJECT_SMART_EO_TYPES
+
+
+#endif
+#define EVAS_OBJECT_SMART_CLASS evas_object_smart_class_get()
+
+const Eo_Class *evas_object_smart_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Set or unset the flag signalling that a given smart object needs to
+ * get recalculated.
+ *
+ * If this flag is set, then the @c calculate() smart function of @p
+ * obj will be called, if one is provided, during rendering phase of
+ * Evas (see evas_render()), after which this flag will be
+ * automatically unset.
+ *
+ * If that smart function is not provided for the given object, this
+ * flag will be left unchanged.
+ *
+ * @note just setting this flag will not make the canvas' whole scene
+ * dirty, by itself, and evas_render() will have no effect. To
+ * force that, use evas_object_smart_changed(), that will also
+ * call this function automatically, with @c EINA_TRUE as parameter.
+ *
+ * @see evas_object_smart_need_recalculate_get()
+ * @see evas_object_smart_calculate()
+ * @see evas_smart_objects_calculate()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ * @param[in] value whether one wants to set (@c EINA_TRUE) or to unset
+(@c EINA_FALSE) the flag.
+ *
+ */
+EOAPI void  evas_obj_smart_need_recalculate_set(Eina_Bool value);
+
+/**
+ *
+ * Get the value of the flag signalling that a given smart object needs to
+ * get recalculated.
+ *
+ * @return if flag is set or not.
+ *
+ * @note this flag will be unset during the rendering phase, when the
+ * @c calculate() smart function is called, if one is provided.
+ * If it's not provided, then the flag will be left unchanged
+ * after the rendering phase.
+ *
+ * @see evas_object_smart_need_recalculate_set(), for more details
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_smart_need_recalculate_get(void);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ * @param[in] clip No description supplied.
+ *
+ */
+EOAPI void  evas_obj_smart_clip_set(Evas_Object *clip);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ * @param[in] r No description supplied.
+ * @param[in] g No description supplied.
+ * @param[in] b No description supplied.
+ * @param[in] a No description supplied.
+ *
+ */
+EOAPI void  evas_obj_smart_color_set(int r, int g, int b, int a);
+
+/**
+ *
+ * Store a pointer to user data for a given smart object.
+ *
+ * This data is stored @b independently of the one set by
+ * evas_object_data_set(), naturally.
+ *
+ * @see evas_object_smart_data_get()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ * @param[in] data A pointer to user data
+ *
+ */
+EOAPI void  evas_obj_smart_data_set(void *data);
+
+/**
+ *
+ * Retrieves the list of the member objects of a given Evas smart
+ * object
+ *
+ * @return Returns the list of the member objects of @p obj.
+ *
+ * The returned list should be freed with @c eina_list_free() when you
+ * no longer need it.
+ *
+ * @since 1.7 This function will return @c NULL when a non-smart object is passed.
+ *
+ * @see evas_object_smart_member_add()
+ * @see evas_object_smart_member_del()
+ * @see evas_object_smart_iterator_new()
+ *
+ *
+ */
+EOAPI Eina_List * evas_obj_smart_members_get(void);
+
+/**
+ *
+ * Get the #Evas_Smart from which @p obj smart object was created.
+ *
+ * @return the #Evas_Smart handle or @c NULL, on errors
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ *
+ */
+EOAPI Evas_Smart * evas_obj_smart_get(void);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_smart_show(void);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ *
+ */
+EOAPI void  evas_obj_smart_move(Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * Set an smart object @b instance's smart callbacks descriptions.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE on failure.
+ *
+ * These descriptions are hints to be used by introspection and are
+ * not enforced in any way.
+ *
+ * It will not be checked if instance callbacks descriptions have the
+ * same name as respective possibly registered in the smart object
+ * @b class. Both are kept in different arrays and users of
+ * evas_object_smart_callbacks_descriptions_get() should handle this
+ * case as they wish.
+ *
+ * @note Becase @p descriptions must be @c NULL terminated, and
+ * because a @c NULL name makes little sense, too,
+ * Evas_Smart_Cb_Description.name must @b not be @c NULL.
+ *
+ * @note While instance callbacks descriptions are possible, they are
+ * @b not recommended. Use @b class callbacks descriptions
+ * instead as they make you smart object user's life simpler and
+ * will use less memory, as descriptions and arrays will be
+ * shared among all instances.
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[in] descriptions @c NULL terminated array with
+#Evas_Smart_Cb_Description descriptions. Array elements won't be
+modified at run time, but references to them and their contents
+will be made, so this array should be kept alive during the whole
+object's lifetime.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_smart_callbacks_descriptions_set(const Evas_Smart_Cb_Description *descriptions);
+
+/**
+ *
+ * Retrieve an smart object's know smart callback descriptions (both
+ * instance and class ones).
+ *
+ * This call searches for registered callback descriptions for both
+ * instance and class of the given smart object. These arrays will be
+ * sorted by Evas_Smart_Cb_Description.name and also @c NULL
+ * terminated, so both @a class_count and @a instance_count can be
+ * ignored, if the caller wishes so. The terminator @c NULL is not
+ * counted in these values.
+ *
+ * @note If just class descriptions are of interest, try
+ * evas_smart_callbacks_descriptions_get() instead.
+ *
+ * @note Use @c NULL pointers on the descriptions/counters you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_smart_callbacks_descriptions_get()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[out] class_descriptions Where to store class callbacks
+descriptions array, if any is known. If no descriptions are
+known, @c NULL is returned
+ * @param[out] class_count Returns how many class callbacks descriptions
+are known.
+ * @param[out] instance_descriptions Where to store instance callbacks
+descriptions array, if any is known. If no descriptions are
+known, @c NULL is returned.
+ * @param[out] instance_count Returns how many instance callbacks
+descriptions are known.
+ *
+ */
+EOAPI void  evas_obj_smart_callbacks_descriptions_get(const Evas_Smart_Cb_Description ***class_descriptions, unsigned int *class_count, const Evas_Smart_Cb_Description ***instance_descriptions, unsigned int *instance_count);
+
+/**
+ *
+ * Retrieves an iterator of the member objects of a given Evas smart
+ * object
+ *
+ * @return Returns the iterator of the member objects of @p obj.
+ *
+ * @since 1.8
+ *
+ * @see evas_object_smart_member_add()
+ * @see evas_object_smart_member_del()
+ * @see evas_object_smart_members_get()
+ * 
+ *
+ *
+ */
+EOAPI Eina_Iterator * evas_obj_smart_iterator_new(void);
+
+/**
+ *
+ * Find callback description for callback called @a name.
+ *
+ * or @c NULL if not found. If parameter is @c NULL, no search
+ * will be done on instance descriptions.
+ * @return reference to description if found, @c NULL if not found.
+ * 
+ *
+ * @param[in] name name of desired callback, must @b not be @c NULL.  The
+search have a special case for @a name being the same
+pointer as registered with Evas_Smart_Cb_Description, one
+can use it to avoid excessive use of strcmp().
+ * @param[out] class_description pointer to return class description or
+@c NULL if not found. If parameter is @c NULL, no search will
+be done on class descriptions.
+ * @param[out] instance_description pointer to return instance description
+ *
+ */
+EOAPI void  evas_obj_smart_callback_description_find(const char *name, const Evas_Smart_Cb_Description **class_description, const Evas_Smart_Cb_Description **instance_description);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_smart_hide(void);
+
+/**
+ *
+ * Call the @b calculate() smart function immediately on a given smart
+ * object.
+ *
+ * This will force immediate calculations (see #Evas_Smart_Class)
+ * needed for renderization of this object and, besides, unset the
+ * flag on it telling it needs recalculation for the next rendering
+ * phase.
+ *
+ * @see evas_object_smart_need_recalculate_set()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_smart_calculate(void);
+
+/**
+ *
+ * Instantiates a new smart object described by @p s.
+ *
+ * @return a new #Evas_Object handle
+ *
+ * This is the function one should use when defining the public
+ * function @b adding an instance of the new smart object to a given
+ * canvas. It will take care of setting all of its internals to work
+ * as they should, if the user set things properly, as seem on the
+ * #EVAS_SMART_SUBCLASS_NEW, for example.
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_smart_add(void);
+
+/**
+ *
+ * Set an Evas object as a member of a given smart object.
+ *
+ * Members will automatically be stacked and layered together with the
+ * smart object. The various stacking functions will operate on
+ * members relative to the other members instead of the entire canvas,
+ * since they now live on an exclusive layer (see
+ * evas_object_stack_above(), for more details).
+ *
+ * Any @p smart_obj object's specific implementation of the @c
+ * member_add() smart function will take place too, naturally.
+ *
+ * @see evas_object_smart_member_del()
+ * @see evas_object_smart_members_get()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[in] sub_obj The member object
+ *
+ */
+EOAPI void  evas_obj_smart_member_add(Evas_Object *sub_obj);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] w No description supplied.
+ * @param[in] h No description supplied.
+ *
+ */
+EOAPI void  evas_obj_smart_resize(Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_smart_clip_unset(void);
+
+/**
+ *
+ * Mark smart object as changed, dirty.
+ *
+ * This will flag the given object as needing recalculation,
+ * forcefully. As an effect, on the next rendering cycle its @b
+ * calculate() (see #Evas_Smart_Class) smart function will be called.
+ *
+ * @see evas_object_smart_need_recalculate_set().
+ * @see evas_object_smart_calculate().
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_smart_changed(void);
+
+/**
+ *
+ * Removes a member object from a given smart object.
+ *
+ * This removes a member object from a smart object, if it was added
+ * to any. The object will still be on the canvas, but no longer
+ * associated with whichever smart object it was associated with.
+ *
+ * @see evas_object_smart_member_add() for more details
+ * @see evas_object_smart_members_get()
+ * 
+ *
+ * @param[in] sub_obj the member object
+@ingroup Evas_Smart_Object_Group
+ *
+ */
+EOAPI void  evas_obj_smart_member_del(Evas_Object *sub_obj);
+
+/**
+ *
+ * Deletes a smart object.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_smart_del(void);
+
+/**
+ *
+ * Attach a given smart data to a given smart object.
+ * 
+ *
+ * @param[in] s No description supplied.
+ *
+ */
+EOAPI void  evas_obj_smart_attach(Evas_Smart *s);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_object_smart.eo.hh b/src/lib/evas/canvas/evas_object_smart.eo.hh
--- a/src/lib/evas/canvas/evas_object_smart.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object_smart.eo.hh	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,1249 @@
+#ifndef EFL_GENERATED_EVAS_OBJECT_SMART_HH
+#define EFL_GENERATED_EVAS_OBJECT_SMART_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_object_smart.eo.h"
+}
+
+#include "evas_object.eo.hh"
+#include "evas_signal_interface.eo.hh"
+#include <canvas/evas_object.eo.hh>
+#include <string>
+
+namespace evas {
+
+struct object_smart
+      : evas::object,
+      efl::eo::detail::extension_inheritance<evas::signal_interface>::template type< ::evas::object_smart>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit object_smart(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit object_smart(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   object_smart(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : object_smart(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   object_smart(object_smart const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~object_smart() {}
+
+   /// @brief Checks whether a given smart object or any of its smart object
+   /// parents is of a given smart class, <b>using pointer comparison</b>.
+   ///
+   /// @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+   /// type, @c EINA_FALSE otherwise
+   ///
+   /// @see evas_object_smart_type_check() for more details
+   /// @see eo_isa
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param type The type (name string) to check for. Must be the name
+   ///
+   bool smart_type_check_ptr(std::string type_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check_ptr(efl::eolian::to_c(type_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Checks whether a given smart object or any of its smart object
+   /// parents is of a given smart class.
+   ///
+   /// @return @c EINA_TRUE, if @a obj or any of its parents is of type @a
+   /// type, @c EINA_FALSE otherwise
+   ///
+   /// If @p obj is not a smart object, this call will fail
+   /// immediately.
+   ///
+   /// This function supports Eo and legacy inheritance mechanisms. However,
+   /// it is recommended to use eo_isa instead if your object is using Eo from
+   /// top to bottom.
+   ///
+   /// The checks use smart classes names and <b>string
+   /// comparison</b>. There is a version of this same check using
+   /// <b>pointer comparison</b>, since a smart class' name is a single
+   /// string in Evas.
+   ///
+   /// @see evas_object_smart_type_check_ptr()
+   /// @see eo_isa
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param type The @b name (type) of the smart class to check for
+   ///
+   bool smart_type_check(std::string type_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check(efl::eolian::to_c(type_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve user data stored on a given smart object.
+   ///
+   /// @return A pointer to data stored using
+   /// evas_object_smart_data_set(), or @c NULL, if none has been
+   /// set.
+   ///
+   /// @see evas_object_smart_data_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void * smart_data_get() const
+   {
+      void * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_data_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the value of the flag signalling that a given smart object needs to
+   /// get recalculated.
+   ///
+   /// @return if flag is set or not.
+   ///
+   /// @note this flag will be unset during the rendering phase, when the
+   /// @c calculate() smart function is called, if one is provided.
+   /// If it's not provided, then the flag will be left unchanged
+   /// after the rendering phase.
+   ///
+   /// @see evas_object_smart_need_recalculate_set(), for more details
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param value whether one wants to set (@c EINA_TRUE) or to unset
+   /// (@c EINA_FALSE) the flag.
+   ///
+   bool need_recalculate_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_need_recalculate_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set or unset the flag signalling that a given smart object needs to
+   /// get recalculated.
+   ///
+   /// If this flag is set, then the @c calculate() smart function of @p
+   /// obj will be called, if one is provided, during rendering phase of
+   /// Evas (see evas_render()), after which this flag will be
+   /// automatically unset.
+   ///
+   /// If that smart function is not provided for the given object, this
+   /// flag will be left unchanged.
+   ///
+   /// @note just setting this flag will not make the canvas' whole scene
+   /// dirty, by itself, and evas_render() will have no effect. To
+   /// force that, use evas_object_smart_changed(), that will also
+   /// call this function automatically, with @c EINA_TRUE as parameter.
+   ///
+   /// @see evas_object_smart_need_recalculate_get()
+   /// @see evas_object_smart_calculate()
+   /// @see evas_smart_objects_calculate()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param value whether one wants to set (@c EINA_TRUE) or to unset
+   /// (@c EINA_FALSE) the flag.
+   ///
+   void need_recalculate_set(bool value_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_need_recalculate_set(efl::eolian::to_c(value_)));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param clip 
+   ///
+   void clip_set(evas::object clip_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_clip_set(efl::eolian::to_c(clip_)));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param r 
+   /// @param g 
+   /// @param b 
+   /// @param a 
+   ///
+   void color_set(int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_color_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Store a pointer to user data for a given smart object.
+   ///
+   /// This data is stored @b independently of the one set by
+   /// evas_object_data_set(), naturally.
+   ///
+   /// @see evas_object_smart_data_get()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param data A pointer to user data
+   ///
+   void data_set(void * data_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_data_set(data_));
+   }
+
+   /// @brief Retrieves the list of the member objects of a given Evas smart
+   /// object
+   ///
+   /// @return Returns the list of the member objects of @p obj.
+   ///
+   /// The returned list should be freed with @c eina_list_free() when you
+   /// no longer need it.
+   ///
+   /// @since 1.7 This function will return @c NULL when a non-smart object is passed.
+   ///
+   /// @see evas_object_smart_member_add()
+   /// @see evas_object_smart_member_del()
+   /// @see evas_object_smart_iterator_new()
+   ///
+   efl::eina::range_list< evas::object > members_get() const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_members_get());
+      return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief Get the #Evas_Smart from which @p obj smart object was created.
+   ///
+   /// @return the #Evas_Smart handle or @c NULL, on errors
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   Evas_Smart * smart_get() const
+   {
+      Evas_Smart * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_get());
+      return _tmp_ret;
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void show() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_show());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param x 
+   /// @param y 
+   ///
+   void move(Evas_Coord x_, Evas_Coord y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_move(x_, y_));
+   }
+
+   /// @brief Set an smart object @b instance's smart callbacks descriptions.
+   ///
+   /// @return @c EINA_TRUE on success, @c EINA_FALSE on failure.
+   ///
+   /// These descriptions are hints to be used by introspection and are
+   /// not enforced in any way.
+   ///
+   /// It will not be checked if instance callbacks descriptions have the
+   /// same name as respective possibly registered in the smart object
+   /// @b class. Both are kept in different arrays and users of
+   /// evas_object_smart_callbacks_descriptions_get() should handle this
+   /// case as they wish.
+   ///
+   /// @note Becase @p descriptions must be @c NULL terminated, and
+   /// because a @c NULL name makes little sense, too,
+   /// Evas_Smart_Cb_Description.name must @b not be @c NULL.
+   ///
+   /// @note While instance callbacks descriptions are possible, they are
+   /// @b not recommended. Use @b class callbacks descriptions
+   /// instead as they make you smart object user's life simpler and
+   /// will use less memory, as descriptions and arrays will be
+   /// shared among all instances.
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param descriptions @c NULL terminated array with
+   /// #Evas_Smart_Cb_Description descriptions. Array elements won't be
+   /// modified at run time, but references to them and their contents
+   /// will be made, so this array should be kept alive during the whole
+   /// object's lifetime.
+   ///
+   bool callbacks_descriptions_set(const Evas_Smart_Cb_Description * descriptions_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_callbacks_descriptions_set(descriptions_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve an smart object's know smart callback descriptions (both
+   /// instance and class ones).
+   ///
+   /// This call searches for registered callback descriptions for both
+   /// instance and class of the given smart object. These arrays will be
+   /// sorted by Evas_Smart_Cb_Description.name and also @c NULL
+   /// terminated, so both @a class_count and @a instance_count can be
+   /// ignored, if the caller wishes so. The terminator @c NULL is not
+   /// counted in these values.
+   ///
+   /// @note If just class descriptions are of interest, try
+   /// evas_smart_callbacks_descriptions_get() instead.
+   ///
+   /// @note Use @c NULL pointers on the descriptions/counters you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_smart_callbacks_descriptions_get()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param[out] class_descriptions Where to store class callbacks
+   /// descriptions array, if any is known. If no descriptions are
+   /// known, @c NULL is returned
+   /// @param[out] class_count Returns how many class callbacks descriptions
+   /// are known.
+   /// @param[out] instance_descriptions Where to store instance callbacks
+   /// descriptions array, if any is known. If no descriptions are
+   /// known, @c NULL is returned.
+   /// @param[out] instance_count Returns how many instance callbacks
+   /// descriptions are known.
+   ///
+   void callbacks_descriptions_get(const Evas_Smart_Cb_Description *** class_descriptions_, unsigned int* class_count_, const Evas_Smart_Cb_Description *** instance_descriptions_, unsigned int* instance_count_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_callbacks_descriptions_get(class_descriptions_, class_count_, instance_descriptions_, instance_count_));
+   }
+
+   /// @brief Retrieves an iterator of the member objects of a given Evas smart
+   /// object
+   ///
+   /// @return Returns the iterator of the member objects of @p obj.
+   ///
+   /// @since 1.8
+   ///
+   /// @see evas_object_smart_member_add()
+   /// @see evas_object_smart_member_del()
+   /// @see evas_object_smart_members_get()
+   ///
+   Eina_Iterator * iterator_new() const
+   {
+      Eina_Iterator * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_smart_iterator_new());
+      return _tmp_ret;
+   }
+
+   /// @brief Find callback description for callback called @a name.
+   ///
+   /// or @c NULL if not found. If parameter is @c NULL, no search
+   /// will be done on instance descriptions.
+   /// @return reference to description if found, @c NULL if not found.
+   ///
+   /// @param name name of desired callback, must @b not be @c NULL.  The
+   /// search have a special case for @a name being the same
+   /// pointer as registered with Evas_Smart_Cb_Description, one
+   /// can use it to avoid excessive use of strcmp().
+   /// @param[out] class_description pointer to return class description or
+   /// @c NULL if not found. If parameter is @c NULL, no search will
+   /// be done on class descriptions.
+   /// @param[out] instance_description pointer to return instance description
+   ///
+   void callback_description_find(std::string name_, const Evas_Smart_Cb_Description ** class_description_, const Evas_Smart_Cb_Description ** instance_description_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_callback_description_find(efl::eolian::to_c(name_), class_description_, instance_description_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void hide() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_hide());
+   }
+
+   /// @brief Call the @b calculate() smart function immediately on a given smart
+   /// object.
+   ///
+   /// This will force immediate calculations (see #Evas_Smart_Class)
+   /// needed for renderization of this object and, besides, unset the
+   /// flag on it telling it needs recalculation for the next rendering
+   /// phase.
+   ///
+   /// @see evas_object_smart_need_recalculate_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void calculate() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_calculate());
+   }
+
+   /// @brief Instantiates a new smart object described by @p s.
+   ///
+   /// @return a new #Evas_Object handle
+   ///
+   /// This is the function one should use when defining the public
+   /// function @b adding an instance of the new smart object to a given
+   /// canvas. It will take care of setting all of its internals to work
+   /// as they should, if the user set things properly, as seem on the
+   /// #EVAS_SMART_SUBCLASS_NEW, for example.
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void add() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_add());
+   }
+
+   /// @brief Set an Evas object as a member of a given smart object.
+   ///
+   /// Members will automatically be stacked and layered together with the
+   /// smart object. The various stacking functions will operate on
+   /// members relative to the other members instead of the entire canvas,
+   /// since they now live on an exclusive layer (see
+   /// evas_object_stack_above(), for more details).
+   ///
+   /// Any @p smart_obj object's specific implementation of the @c
+   /// member_add() smart function will take place too, naturally.
+   ///
+   /// @see evas_object_smart_member_del()
+   /// @see evas_object_smart_members_get()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param sub_obj The member object
+   ///
+   void member_add(evas::object sub_obj_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_member_add(efl::eolian::to_c(sub_obj_)));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param w 
+   /// @param h 
+   ///
+   void resize(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void clip_unset() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_clip_unset());
+   }
+
+   /// @brief Mark smart object as changed, dirty.
+   ///
+   /// This will flag the given object as needing recalculation,
+   /// forcefully. As an effect, on the next rendering cycle its @b
+   /// calculate() (see #Evas_Smart_Class) smart function will be called.
+   ///
+   /// @see evas_object_smart_need_recalculate_set().
+   /// @see evas_object_smart_calculate().
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void changed() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_changed());
+   }
+
+   /// @brief Removes a member object from a given smart object.
+   ///
+   /// This removes a member object from a smart object, if it was added
+   /// to any. The object will still be on the canvas, but no longer
+   /// associated with whichever smart object it was associated with.
+   ///
+   /// @see evas_object_smart_member_add() for more details
+   /// @see evas_object_smart_members_get()
+   ///
+   /// @param sub_obj the member object
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void member_del(evas::object sub_obj_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_member_del(efl::eolian::to_c(sub_obj_)));
+   }
+
+   /// @brief Deletes a smart object.
+   ///
+   void del() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_del());
+   }
+
+   /// @brief Attach a given smart data to a given smart object.
+   ///
+   /// @param s 
+   ///
+   void attach(Evas_Smart * s_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_attach(s_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_OBJECT_SMART_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_OBJECT_SMART_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+bool evas_object_smart_smart_type_check_ptr_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * type_)
+{
+   return static_cast<T*>(self->this_)->smart_type_check_ptr(efl::eolian::to_cxx<std::string>(type_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_object_smart_smart_type_check_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * type_)
+{
+   return static_cast<T*>(self->this_)->smart_type_check(efl::eolian::to_cxx<std::string>(type_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void * evas_object_smart_smart_data_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smart_data_get();
+}
+
+template <typename T>
+bool evas_object_smart_need_recalculate_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->need_recalculate_get();
+}
+
+template <typename T>
+void evas_object_smart_need_recalculate_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool value_)
+{
+   static_cast<T*>(self->this_)->need_recalculate_set(efl::eolian::to_cxx<bool>(value_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_smart_clip_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * clip_)
+{
+   static_cast<T*>(self->this_)->clip_set(efl::eolian::to_cxx<evas::object>(clip_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_smart_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_object_smart_data_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, void * data_)
+{
+   static_cast<T*>(self->this_)->data_set(data_);
+}
+
+template <typename T>
+efl::eina::range_list< evas::object > evas_object_smart_members_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->members_get();
+}
+
+template <typename T>
+Evas_Smart * evas_object_smart_smart_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->smart_get();
+}
+
+template <typename T>
+void evas_object_smart_show_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->show();
+}
+
+template <typename T>
+void evas_object_smart_move_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_)
+{
+   static_cast<T*>(self->this_)->move(x_, y_);
+}
+
+template <typename T>
+bool evas_object_smart_callbacks_descriptions_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Evas_Smart_Cb_Description * descriptions_)
+{
+   return static_cast<T*>(self->this_)->callbacks_descriptions_set(descriptions_);
+}
+
+template <typename T>
+void evas_object_smart_callbacks_descriptions_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Evas_Smart_Cb_Description *** class_descriptions_, unsigned int* class_count_, const Evas_Smart_Cb_Description *** instance_descriptions_, unsigned int* instance_count_)
+{
+   static_cast<T*>(self->this_)->callbacks_descriptions_get(class_descriptions_, class_count_, instance_descriptions_, instance_count_);
+}
+
+template <typename T>
+Eina_Iterator * evas_object_smart_iterator_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->iterator_new();
+}
+
+template <typename T>
+void evas_object_smart_callback_description_find_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_, const Evas_Smart_Cb_Description ** class_description_, const Evas_Smart_Cb_Description ** instance_description_)
+{
+   static_cast<T*>(self->this_)->callback_description_find(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()), class_description_, instance_description_);
+}
+
+template <typename T>
+void evas_object_smart_hide_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->hide();
+}
+
+template <typename T>
+void evas_object_smart_calculate_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->calculate();
+}
+
+template <typename T>
+void evas_object_smart_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->add();
+}
+
+template <typename T>
+void evas_object_smart_member_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * sub_obj_)
+{
+   static_cast<T*>(self->this_)->member_add(efl::eolian::to_cxx<evas::object>(sub_obj_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_smart_resize_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->resize(w_, h_);
+}
+
+template <typename T>
+void evas_object_smart_clip_unset_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->clip_unset();
+}
+
+template <typename T>
+void evas_object_smart_changed_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->changed();
+}
+
+template <typename T>
+void evas_object_smart_member_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * sub_obj_)
+{
+   static_cast<T*>(self->this_)->member_del(efl::eolian::to_cxx<evas::object>(sub_obj_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_object_smart_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->del();
+}
+
+template <typename T>
+void evas_object_smart_attach_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Smart * s_)
+{
+   static_cast<T*>(self->this_)->attach(s_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::object_smart >
+{
+   template <typename T>
+   struct type
+   {
+      virtual bool smart_type_check_ptr(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_type_check_ptr(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool smart_type_check(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_type_check(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void * smart_data_get()
+      {
+         void * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_data_get());
+            return _tmp_ret;
+      }
+
+      virtual bool need_recalculate_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_need_recalculate_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void need_recalculate_set(bool value_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_need_recalculate_set(efl::eolian::to_c(value_)));
+      }
+
+      virtual void clip_set(evas::object clip_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_clip_set(efl::eolian::to_c(clip_)));
+      }
+
+      virtual void color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_color_set(r_, g_, b_, a_));
+      }
+
+      virtual void data_set(void * data_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_data_set(data_));
+      }
+
+      virtual efl::eina::range_list< evas::object > members_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_members_get());
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual Evas_Smart * smart_get()
+      {
+         Evas_Smart * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_get());
+            return _tmp_ret;
+      }
+
+      virtual void show()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_show());
+      }
+
+      virtual void move(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_move(x_, y_));
+      }
+
+      virtual bool callbacks_descriptions_set(const Evas_Smart_Cb_Description * descriptions_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_callbacks_descriptions_set(descriptions_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void callbacks_descriptions_get(const Evas_Smart_Cb_Description *** class_descriptions_, unsigned int* class_count_, const Evas_Smart_Cb_Description *** instance_descriptions_, unsigned int* instance_count_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_callbacks_descriptions_get(class_descriptions_, class_count_, instance_descriptions_, instance_count_));
+      }
+
+      virtual Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_smart_iterator_new());
+            return _tmp_ret;
+      }
+
+      virtual void callback_description_find(std::string name_, const Evas_Smart_Cb_Description ** class_description_, const Evas_Smart_Cb_Description ** instance_description_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_callback_description_find(efl::eolian::to_c(name_), class_description_, instance_description_));
+      }
+
+      virtual void hide()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_hide());
+      }
+
+      virtual void calculate()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_calculate());
+      }
+
+      virtual void add()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_add());
+      }
+
+      virtual void member_add(evas::object sub_obj_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_member_add(efl::eolian::to_c(sub_obj_)));
+      }
+
+      virtual void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_resize(w_, h_));
+      }
+
+      virtual void clip_unset()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_clip_unset());
+      }
+
+      virtual void changed()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_changed());
+      }
+
+      virtual void member_del(evas::object sub_obj_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_member_del(efl::eolian::to_c(sub_obj_)));
+      }
+
+      virtual void del()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_del());
+      }
+
+      virtual void attach(Evas_Smart * s_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_attach(s_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::object_smart >
+{
+   static const int value = 26;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::object_smart>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_object_smart_smart_type_check_ptr_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_type_check_ptr);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_object_smart_smart_type_check_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_type_check);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_object_smart_smart_data_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_data_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_object_smart_need_recalculate_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_need_recalculate_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_object_smart_need_recalculate_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_need_recalculate_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_object_smart_clip_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_clip_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_object_smart_color_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_color_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_object_smart_data_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_data_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_object_smart_members_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_members_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_object_smart_smart_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_object_smart_show_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_show);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_object_smart_move_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_move);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_object_smart_callbacks_descriptions_set_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_callbacks_descriptions_set);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_object_smart_callbacks_descriptions_get_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_callbacks_descriptions_get);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_object_smart_iterator_new_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_iterator_new);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_object_smart_callback_description_find_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_callback_description_find);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_object_smart_hide_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_hide);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_object_smart_calculate_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_calculate);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_object_smart_add_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_add);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_object_smart_member_add_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_member_add);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_object_smart_resize_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_resize);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_object_smart_clip_unset_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_clip_unset);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::evas_object_smart_changed_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_changed);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::evas_object_smart_member_del_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_member_del);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::evas_object_smart_del_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_del);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::evas_object_smart_attach_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_attach);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::object_smart >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::object_smart, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::object_smart >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::object_smart, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::object_smart>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::object_smart() const
+      {
+         return evas::object_smart(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      bool smart_type_check_ptr(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check_ptr(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool smart_type_check(std::string type_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_type_check(efl::eolian::to_c(type_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void * smart_data_get()
+      {
+         void * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_data_get());
+            return _tmp_ret;
+      }
+
+      bool need_recalculate_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_need_recalculate_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void need_recalculate_set(bool value_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_need_recalculate_set(efl::eolian::to_c(value_)));
+      }
+
+      void clip_set(evas::object clip_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_clip_set(efl::eolian::to_c(clip_)));
+      }
+
+      void color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_color_set(r_, g_, b_, a_));
+      }
+
+      void data_set(void * data_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_data_set(data_));
+      }
+
+      efl::eina::range_list< evas::object > members_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_members_get());
+            return efl::eolian::to_cxx<efl::eina::range_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      Evas_Smart * smart_get()
+      {
+         Evas_Smart * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_get());
+            return _tmp_ret;
+      }
+
+      void show()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_show());
+      }
+
+      void move(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_move(x_, y_));
+      }
+
+      bool callbacks_descriptions_set(const Evas_Smart_Cb_Description * descriptions_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_callbacks_descriptions_set(descriptions_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void callbacks_descriptions_get(const Evas_Smart_Cb_Description *** class_descriptions_, unsigned int* class_count_, const Evas_Smart_Cb_Description *** instance_descriptions_, unsigned int* instance_count_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_callbacks_descriptions_get(class_descriptions_, class_count_, instance_descriptions_, instance_count_));
+      }
+
+      Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_smart_iterator_new());
+            return _tmp_ret;
+      }
+
+      void callback_description_find(std::string name_, const Evas_Smart_Cb_Description ** class_description_, const Evas_Smart_Cb_Description ** instance_description_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_callback_description_find(efl::eolian::to_c(name_), class_description_, instance_description_));
+      }
+
+      void hide()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_hide());
+      }
+
+      void calculate()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_calculate());
+      }
+
+      void add()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_add());
+      }
+
+      void member_add(evas::object sub_obj_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_member_add(efl::eolian::to_c(sub_obj_)));
+      }
+
+      void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+      }
+
+      void clip_unset()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_clip_unset());
+      }
+
+      void changed()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_changed());
+      }
+
+      void member_del(evas::object sub_obj_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_member_del(efl::eolian::to_c(sub_obj_)));
+      }
+
+      void del()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_del());
+      }
+
+      void attach(Evas_Smart * s_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_attach(s_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::object_smart>)
+{
+   return (EVAS_OBJECT_SMART_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_OBJECT_SMART_HH
+
diff -Naur a/src/lib/evas/canvas/evas_object_smart.eo.legacy.h b/src/lib/evas/canvas/evas_object_smart.eo.legacy.h
--- a/src/lib/evas/canvas/evas_object_smart.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_object_smart.eo.legacy.h	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,254 @@
+#ifndef _EVAS_OBJECT_SMART_EO_LEGACY_H_
+#define _EVAS_OBJECT_SMART_EO_LEGACY_H_
+
+#ifndef _EVAS_OBJECT_SMART_EO_CLASS_TYPE
+#define _EVAS_OBJECT_SMART_EO_CLASS_TYPE
+
+typedef Eo Evas_Object_Smart;
+
+#endif
+
+#ifndef _EVAS_OBJECT_SMART_EO_TYPES
+#define _EVAS_OBJECT_SMART_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Set or unset the flag signalling that a given smart object needs to
+ * get recalculated.
+ *
+ * If this flag is set, then the @c calculate() smart function of @p
+ * obj will be called, if one is provided, during rendering phase of
+ * Evas (see evas_render()), after which this flag will be
+ * automatically unset.
+ *
+ * If that smart function is not provided for the given object, this
+ * flag will be left unchanged.
+ *
+ * @note just setting this flag will not make the canvas' whole scene
+ * dirty, by itself, and evas_render() will have no effect. To
+ * force that, use evas_object_smart_changed(), that will also
+ * call this function automatically, with @c EINA_TRUE as parameter.
+ *
+ * @see evas_object_smart_need_recalculate_get()
+ * @see evas_object_smart_calculate()
+ * @see evas_smart_objects_calculate()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ * @param[in] value whether one wants to set (@c EINA_TRUE) or to unset
+(@c EINA_FALSE) the flag.
+ */
+EAPI void evas_object_smart_need_recalculate_set(Evas_Object_Smart *obj, Eina_Bool value);
+
+/**
+ *
+ * Get the value of the flag signalling that a given smart object needs to
+ * get recalculated.
+ *
+ * @return if flag is set or not.
+ *
+ * @note this flag will be unset during the rendering phase, when the
+ * @c calculate() smart function is called, if one is provided.
+ * If it's not provided, then the flag will be left unchanged
+ * after the rendering phase.
+ *
+ * @see evas_object_smart_need_recalculate_set(), for more details
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ */
+EAPI Eina_Bool evas_object_smart_need_recalculate_get(const Evas_Object_Smart *obj);
+
+/**
+ *
+ * Store a pointer to user data for a given smart object.
+ *
+ * This data is stored @b independently of the one set by
+ * evas_object_data_set(), naturally.
+ *
+ * @see evas_object_smart_data_get()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ * @param[in] data A pointer to user data
+ */
+EAPI void evas_object_smart_data_set(Evas_Object_Smart *obj, void *data);
+
+/**
+ *
+ * Retrieves the list of the member objects of a given Evas smart
+ * object
+ *
+ * @return Returns the list of the member objects of @p obj.
+ *
+ * The returned list should be freed with @c eina_list_free() when you
+ * no longer need it.
+ *
+ * @since 1.7 This function will return @c NULL when a non-smart object is passed.
+ *
+ * @see evas_object_smart_member_add()
+ * @see evas_object_smart_member_del()
+ * @see evas_object_smart_iterator_new()
+ *
+ */
+EAPI Eina_List *evas_object_smart_members_get(const Evas_Object_Smart *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the #Evas_Smart from which @p obj smart object was created.
+ *
+ * @return the #Evas_Smart handle or @c NULL, on errors
+ *
+ * @ingroup Evas_Smart_Object_Group
+ *
+ */
+EAPI Evas_Smart *evas_object_smart_smart_get(const Evas_Object_Smart *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Set an smart object @b instance's smart callbacks descriptions.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE on failure.
+ *
+ * These descriptions are hints to be used by introspection and are
+ * not enforced in any way.
+ *
+ * It will not be checked if instance callbacks descriptions have the
+ * same name as respective possibly registered in the smart object
+ * @b class. Both are kept in different arrays and users of
+ * evas_object_smart_callbacks_descriptions_get() should handle this
+ * case as they wish.
+ *
+ * @note Becase @p descriptions must be @c NULL terminated, and
+ * because a @c NULL name makes little sense, too,
+ * Evas_Smart_Cb_Description.name must @b not be @c NULL.
+ *
+ * @note While instance callbacks descriptions are possible, they are
+ * @b not recommended. Use @b class callbacks descriptions
+ * instead as they make you smart object user's life simpler and
+ * will use less memory, as descriptions and arrays will be
+ * shared among all instances.
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[in] descriptions @c NULL terminated array with
+#Evas_Smart_Cb_Description descriptions. Array elements won't be
+modified at run time, but references to them and their contents
+will be made, so this array should be kept alive during the whole
+object's lifetime.
+ */
+EAPI Eina_Bool evas_object_smart_callbacks_descriptions_set(Evas_Object_Smart *obj, const Evas_Smart_Cb_Description *descriptions);
+
+/**
+ *
+ * Retrieve an smart object's know smart callback descriptions (both
+ * instance and class ones).
+ *
+ * This call searches for registered callback descriptions for both
+ * instance and class of the given smart object. These arrays will be
+ * sorted by Evas_Smart_Cb_Description.name and also @c NULL
+ * terminated, so both @a class_count and @a instance_count can be
+ * ignored, if the caller wishes so. The terminator @c NULL is not
+ * counted in these values.
+ *
+ * @note If just class descriptions are of interest, try
+ * evas_smart_callbacks_descriptions_get() instead.
+ *
+ * @note Use @c NULL pointers on the descriptions/counters you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_smart_callbacks_descriptions_get()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ * @param[out] class_descriptions Where to store class callbacks
+descriptions array, if any is known. If no descriptions are
+known, @c NULL is returned
+ * @param[out] class_count Returns how many class callbacks descriptions
+are known.
+ * @param[out] instance_descriptions Where to store instance callbacks
+descriptions array, if any is known. If no descriptions are
+known, @c NULL is returned.
+ * @param[out] instance_count Returns how many instance callbacks
+descriptions are known.
+ */
+EAPI void evas_object_smart_callbacks_descriptions_get(const Evas_Object_Smart *obj, const Evas_Smart_Cb_Description ***class_descriptions, unsigned int *class_count, const Evas_Smart_Cb_Description ***instance_descriptions, unsigned int *instance_count);
+
+/**
+ *
+ * Retrieves an iterator of the member objects of a given Evas smart
+ * object
+ *
+ * @return Returns the iterator of the member objects of @p obj.
+ *
+ * @since 1.8
+ *
+ * @see evas_object_smart_member_add()
+ * @see evas_object_smart_member_del()
+ * @see evas_object_smart_members_get()
+ * 
+ *
+ */
+EAPI Eina_Iterator *evas_object_smart_iterator_new(const Evas_Object_Smart *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Find callback description for callback called @a name.
+ *
+ * or @c NULL if not found. If parameter is @c NULL, no search
+ * will be done on instance descriptions.
+ * @return reference to description if found, @c NULL if not found.
+ * 
+ *
+ * @param[in] name name of desired callback, must @b not be @c NULL.  The
+search have a special case for @a name being the same
+pointer as registered with Evas_Smart_Cb_Description, one
+can use it to avoid excessive use of strcmp().
+ * @param[out] class_description pointer to return class description or
+@c NULL if not found. If parameter is @c NULL, no search will
+be done on class descriptions.
+ * @param[out] instance_description pointer to return instance description
+ */
+EAPI void evas_object_smart_callback_description_find(const Evas_Object_Smart *obj, const char *name, const Evas_Smart_Cb_Description **class_description, const Evas_Smart_Cb_Description **instance_description) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Call the @b calculate() smart function immediately on a given smart
+ * object.
+ *
+ * This will force immediate calculations (see #Evas_Smart_Class)
+ * needed for renderization of this object and, besides, unset the
+ * flag on it telling it needs recalculation for the next rendering
+ * phase.
+ *
+ * @see evas_object_smart_need_recalculate_set()
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ */
+EAPI void evas_object_smart_calculate(Evas_Object_Smart *obj);
+
+/**
+ *
+ * Mark smart object as changed, dirty.
+ *
+ * This will flag the given object as needing recalculation,
+ * forcefully. As an effect, on the next rendering cycle its @b
+ * calculate() (see #Evas_Smart_Class) smart function will be called.
+ *
+ * @see evas_object_smart_need_recalculate_set().
+ * @see evas_object_smart_calculate().
+ *
+ * @ingroup Evas_Smart_Object_Group
+ * 
+ *
+ */
+EAPI void evas_object_smart_changed(Evas_Object_Smart *obj);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_out.eo.c b/src/lib/evas/canvas/evas_out.eo.c
--- a/src/lib/evas/canvas/evas_out.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_out.eo.c	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,68 @@
+
+void _evas_out_view_set(Eo *obj, Evas_Out_Data *pd, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_out_view_set, EO_FUNC_CALL(x, y, w, h), Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+void _evas_out_view_get(Eo *obj, Evas_Out_Data *pd, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_out_view_get, EO_FUNC_CALL(x, y, w, h), Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+Eina_Bool _evas_out_engine_info_set(Eo *obj, Evas_Out_Data *pd, Evas_Engine_Info *info);
+
+EOAPI EO_FUNC_BODYV(evas_out_engine_info_set, Eina_Bool, 0, EO_FUNC_CALL(info), Evas_Engine_Info *info);
+
+Evas_Engine_Info * _evas_out_engine_info_get(Eo *obj, Evas_Out_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_out_engine_info_get, Evas_Engine_Info *, 0);
+
+void _evas_out_eo_base_constructor(Eo *obj, Evas_Out_Data *pd);
+
+
+void _evas_out_eo_base_destructor(Eo *obj, Evas_Out_Data *pd);
+
+
+static Eo_Op_Description _evas_out_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_out_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_out_eo_base_destructor),
+     EO_OP_FUNC(evas_out_view_set, _evas_out_view_set, "Sets the viewport region of the canvas that the output displays This sets both the viewport region in the canvas that displays on the given output, but also the viewport size will match the output resolution 1:1."),
+     EO_OP_FUNC(evas_out_view_get, _evas_out_view_get, "Gets the viewport region of the canvas that the output displays"),
+     EO_OP_FUNC(evas_out_engine_info_set, _evas_out_engine_info_set, "Sets the engine specific output parameters for a given output."),
+     EO_OP_FUNC(evas_out_engine_info_get, _evas_out_engine_info_get, "Gets the engine specific output parameters for a given output."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_out_class_desc = {
+     EO_VERSION,
+     "Evas_Out",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_out_op_desc),
+     NULL,
+     sizeof(Evas_Out_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_out_class_get, &_evas_out_class_desc, EO_BASE_CLASS, NULL);
+EAPI void
+evas_output_view_set(Evas_Out *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)
+{
+   eo_do((Evas_Out *)obj, evas_out_view_set(x, y, w, h));
+}
+
+EAPI void
+evas_output_view_get(const Evas_Out *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Out *)obj, evas_out_view_get(x, y, w, h));
+}
+
+EAPI Eina_Bool
+evas_output_engine_info_set(Evas_Out *obj, Evas_Engine_Info *info)
+{
+   return eo_do((Evas_Out *)obj, evas_out_engine_info_set(info));
+}
+
+EAPI Evas_Engine_Info *
+evas_output_engine_info_get(const Evas_Out *obj)
+{
+   return eo_do((Evas_Out *)obj, evas_out_engine_info_get());
+}
diff -Naur a/src/lib/evas/canvas/evas_out.eo.h b/src/lib/evas/canvas/evas_out.eo.h
--- a/src/lib/evas/canvas/evas_out.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_out.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,62 @@
+#ifndef _EVAS_OUT_EO_H_
+#define _EVAS_OUT_EO_H_
+
+#ifndef _EVAS_OUT_EO_CLASS_TYPE
+#define _EVAS_OUT_EO_CLASS_TYPE
+
+typedef Eo Evas_Out;
+
+#endif
+
+#ifndef _EVAS_OUT_EO_TYPES
+#define _EVAS_OUT_EO_TYPES
+
+
+#endif
+#define EVAS_OUT_CLASS evas_out_class_get()
+
+const Eo_Class *evas_out_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Sets the viewport region of the canvas that the output displays This sets both the viewport region in the canvas that displays on the given output, but also the viewport size will match the output resolution 1:1.
+ *
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] w No description supplied.
+ * @param[in] h No description supplied.
+ *
+ */
+EOAPI void  evas_out_view_set(Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Gets the viewport region of the canvas that the output displays
+ *
+ * @param[out] x No description supplied.
+ * @param[out] y No description supplied.
+ * @param[out] w No description supplied.
+ * @param[out] h No description supplied.
+ *
+ */
+EOAPI void  evas_out_view_get(Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the engine specific output parameters for a given output.
+ *
+ * @param[in] info The engine parameters
+ *
+ */
+EOAPI Eina_Bool  evas_out_engine_info_set(Evas_Engine_Info *info);
+
+/**
+ *
+ * Gets the engine specific output parameters for a given output.
+ *
+ *
+ */
+EOAPI Evas_Engine_Info * evas_out_engine_info_get(void);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_out.eo.hh b/src/lib/evas/canvas/evas_out.eo.hh
--- a/src/lib/evas/canvas/evas_out.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_out.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,284 @@
+#ifndef EFL_GENERATED_EVAS_OUT_HH
+#define EFL_GENERATED_EVAS_OUT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_out.eo.h"
+}
+
+
+namespace evas {
+
+struct out
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit out(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit out(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   out(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : out(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   out(out const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~out() {}
+
+   /// @brief Gets the viewport region of the canvas that the output displays
+   ///
+   /// @param x 
+   /// @param y 
+   /// @param w 
+   /// @param h 
+   ///
+   void view_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_out_view_get(x_, y_, w_, h_));
+   }
+
+   /// @brief Sets the viewport region of the canvas that the output displays This sets both the viewport region in the canvas that displays on the given output, but also the viewport size will match the output resolution 1:1.
+   ///
+   /// @param x 
+   /// @param y 
+   /// @param w 
+   /// @param h 
+   ///
+   void view_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_out_view_set(x_, y_, w_, h_));
+   }
+
+   /// @brief Gets the engine specific output parameters for a given output.
+   ///
+   /// @param info The engine parameters
+   ///
+   Evas_Engine_Info * engine_info_get() const
+   {
+      Evas_Engine_Info * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_out_engine_info_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the engine specific output parameters for a given output.
+   ///
+   /// @param info The engine parameters
+   ///
+   bool engine_info_set(Evas_Engine_Info * info_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_out_engine_info_set(info_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_OUT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_OUT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_out_view_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->view_get(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_out_view_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->view_set(x_, y_, w_, h_);
+}
+
+template <typename T>
+Evas_Engine_Info * evas_out_engine_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->engine_info_get();
+}
+
+template <typename T>
+bool evas_out_engine_info_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Engine_Info * info_)
+{
+   return static_cast<T*>(self->this_)->engine_info_set(info_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::out >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void view_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_out_view_get(x_, y_, w_, h_));
+      }
+
+      virtual void view_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_out_view_set(x_, y_, w_, h_));
+      }
+
+      virtual Evas_Engine_Info * engine_info_get()
+      {
+         Evas_Engine_Info * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_out_engine_info_get());
+            return _tmp_ret;
+      }
+
+      virtual bool engine_info_set(Evas_Engine_Info * info_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_out_engine_info_set(info_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::out >
+{
+   static const int value = 4;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::out>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_out_view_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_out_view_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_out_view_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_out_view_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_out_engine_info_get_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_out_engine_info_get);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_out_engine_info_set_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_out_engine_info_set);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::out >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::out, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::out >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::out, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::out>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::out() const
+      {
+         return evas::out(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void view_get(Evas_Coord* x_, Evas_Coord* y_, Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_out_view_get(x_, y_, w_, h_));
+      }
+
+      void view_set(Evas_Coord x_, Evas_Coord y_, Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_out_view_set(x_, y_, w_, h_));
+      }
+
+      Evas_Engine_Info * engine_info_get()
+      {
+         Evas_Engine_Info * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_out_engine_info_get());
+            return _tmp_ret;
+      }
+
+      bool engine_info_set(Evas_Engine_Info * info_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_out_engine_info_set(info_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::out>)
+{
+   return (EVAS_OUT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_OUT_HH
+
diff -Naur a/src/lib/evas/canvas/evas_out.eo.legacy.h b/src/lib/evas/canvas/evas_out.eo.legacy.h
--- a/src/lib/evas/canvas/evas_out.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_out.eo.legacy.h	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,54 @@
+#ifndef _EVAS_OUT_EO_LEGACY_H_
+#define _EVAS_OUT_EO_LEGACY_H_
+
+#ifndef _EVAS_OUT_EO_CLASS_TYPE
+#define _EVAS_OUT_EO_CLASS_TYPE
+
+typedef Eo Evas_Out;
+
+#endif
+
+#ifndef _EVAS_OUT_EO_TYPES
+#define _EVAS_OUT_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Sets the viewport region of the canvas that the output displays This sets both the viewport region in the canvas that displays on the given output, but also the viewport size will match the output resolution 1:1.
+ *
+ * @param[in] x No description supplied.
+ * @param[in] y No description supplied.
+ * @param[in] w No description supplied.
+ * @param[in] h No description supplied.
+ */
+EAPI void evas_output_view_set(Evas_Out *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h);
+
+/**
+ *
+ * Gets the viewport region of the canvas that the output displays
+ *
+ * @param[out] x No description supplied.
+ * @param[out] y No description supplied.
+ * @param[out] w No description supplied.
+ * @param[out] h No description supplied.
+ */
+EAPI void evas_output_view_get(const Evas_Out *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Sets the engine specific output parameters for a given output.
+ *
+ * @param[in] info The engine parameters
+ */
+EAPI Eina_Bool evas_output_engine_info_set(Evas_Out *obj, Evas_Engine_Info *info);
+
+/**
+ *
+ * Gets the engine specific output parameters for a given output.
+ *
+ */
+EAPI Evas_Engine_Info *evas_output_engine_info_get(const Evas_Out *obj);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_polygon.eo.c b/src/lib/evas/canvas/evas_polygon.eo.c
--- a/src/lib/evas/canvas/evas_polygon.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_polygon.eo.c	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,46 @@
+
+void _evas_polygon_point_add(Eo *obj, Evas_Polygon_Data *pd, Evas_Coord x, Evas_Coord y);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_polygon_point_add, EO_FUNC_CALL(x, y), Evas_Coord x, Evas_Coord y);
+
+void _evas_polygon_points_clear(Eo *obj, Evas_Polygon_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_polygon_points_clear);
+
+void _evas_polygon_eo_base_constructor(Eo *obj, Evas_Polygon_Data *pd);
+
+
+void _evas_polygon_eo_base_destructor(Eo *obj, Evas_Polygon_Data *pd);
+
+
+static Eo_Op_Description _evas_polygon_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_polygon_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_polygon_eo_base_destructor),
+     EO_OP_FUNC(evas_obj_polygon_point_add, _evas_polygon_point_add, "Adds the given point to the given evas polygon object."),
+     EO_OP_FUNC(evas_obj_polygon_points_clear, _evas_polygon_points_clear, "Removes all of the points from the given evas polygon object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_polygon_class_desc = {
+     EO_VERSION,
+     "Evas_Polygon",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_polygon_op_desc),
+     NULL,
+     sizeof(Evas_Polygon_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_polygon_class_get, &_evas_polygon_class_desc, EVAS_OBJECT_CLASS, NULL);
+EAPI void
+evas_object_polygon_point_add(Evas_Polygon *obj, Evas_Coord x, Evas_Coord y)
+{
+   eo_do((Evas_Polygon *)obj, evas_obj_polygon_point_add(x, y));
+}
+
+EAPI void
+evas_object_polygon_points_clear(Evas_Polygon *obj)
+{
+   eo_do((Evas_Polygon *)obj, evas_obj_polygon_points_clear());
+}
diff -Naur a/src/lib/evas/canvas/evas_polygon.eo.h b/src/lib/evas/canvas/evas_polygon.eo.h
--- a/src/lib/evas/canvas/evas_polygon.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_polygon.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,42 @@
+#ifndef _EVAS_POLYGON_EO_H_
+#define _EVAS_POLYGON_EO_H_
+
+#ifndef _EVAS_POLYGON_EO_CLASS_TYPE
+#define _EVAS_POLYGON_EO_CLASS_TYPE
+
+typedef Eo Evas_Polygon;
+
+#endif
+
+#ifndef _EVAS_POLYGON_EO_TYPES
+#define _EVAS_POLYGON_EO_TYPES
+
+
+#endif
+#define EVAS_POLYGON_CLASS evas_polygon_class_get()
+
+const Eo_Class *evas_polygon_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Adds the given point to the given evas polygon object.
+ * @ingroup Evas_Polygon_Group
+ * 
+ *
+ * @param[in] x The X coordinate of the given point.
+ * @param[in] y The Y coordinate of the given point.
+ *
+ */
+EOAPI void  evas_obj_polygon_point_add(Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * Removes all of the points from the given evas polygon object.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_polygon_points_clear(void);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_polygon.eo.hh b/src/lib/evas/canvas/evas_polygon.eo.hh
--- a/src/lib/evas/canvas/evas_polygon.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_polygon.eo.hh	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,201 @@
+#ifndef EFL_GENERATED_EVAS_POLYGON_HH
+#define EFL_GENERATED_EVAS_POLYGON_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_polygon.eo.h"
+}
+
+#include "evas_object.eo.hh"
+
+namespace evas {
+
+struct polygon
+      : evas::object
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit polygon(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit polygon(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   polygon(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : polygon(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   polygon(polygon const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~polygon() {}
+
+   /// @brief Adds the given point to the given evas polygon object.
+   /// @ingroup Evas_Polygon_Group
+   ///
+   /// @param x The X coordinate of the given point.
+   /// @param y The Y coordinate of the given point.
+   ///
+   void point_add(Evas_Coord x_, Evas_Coord y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_polygon_point_add(x_, y_));
+   }
+
+   /// @brief Removes all of the points from the given evas polygon object.
+   ///
+   void points_clear() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_polygon_points_clear());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_POLYGON_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_POLYGON_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_polygon_point_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_)
+{
+   static_cast<T*>(self->this_)->point_add(x_, y_);
+}
+
+template <typename T>
+void evas_polygon_points_clear_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->points_clear();
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::polygon >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void point_add(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_polygon_point_add(x_, y_));
+      }
+
+      virtual void points_clear()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_polygon_points_clear());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::polygon >
+{
+   static const int value = 2;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::polygon>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_polygon_point_add_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_polygon_point_add);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_polygon_points_clear_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_polygon_points_clear);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::polygon >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::polygon, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::polygon >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::polygon, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::polygon>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::polygon() const
+      {
+         return evas::polygon(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void point_add(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_polygon_point_add(x_, y_));
+      }
+
+      void points_clear()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_polygon_points_clear());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::polygon>)
+{
+   return (EVAS_POLYGON_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_POLYGON_HH
+
diff -Naur a/src/lib/evas/canvas/evas_polygon.eo.legacy.h b/src/lib/evas/canvas/evas_polygon.eo.legacy.h
--- a/src/lib/evas/canvas/evas_polygon.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_polygon.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,36 @@
+#ifndef _EVAS_POLYGON_EO_LEGACY_H_
+#define _EVAS_POLYGON_EO_LEGACY_H_
+
+#ifndef _EVAS_POLYGON_EO_CLASS_TYPE
+#define _EVAS_POLYGON_EO_CLASS_TYPE
+
+typedef Eo Evas_Polygon;
+
+#endif
+
+#ifndef _EVAS_POLYGON_EO_TYPES
+#define _EVAS_POLYGON_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Adds the given point to the given evas polygon object.
+ * @ingroup Evas_Polygon_Group
+ * 
+ *
+ * @param[in] x The X coordinate of the given point.
+ * @param[in] y The Y coordinate of the given point.
+ */
+EAPI void evas_object_polygon_point_add(Evas_Polygon *obj, Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * Removes all of the points from the given evas polygon object.
+ * 
+ *
+ */
+EAPI void evas_object_polygon_points_clear(Evas_Polygon *obj);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_rectangle.eo.c b/src/lib/evas/canvas/evas_rectangle.eo.c
--- a/src/lib/evas/canvas/evas_rectangle.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_rectangle.eo.c	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,21 @@
+
+void _evas_rectangle_eo_base_constructor(Eo *obj, Evas_Rectangle_Data *pd);
+
+
+static Eo_Op_Description _evas_rectangle_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_rectangle_eo_base_constructor),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_rectangle_class_desc = {
+     EO_VERSION,
+     "Evas_Rectangle",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_rectangle_op_desc),
+     NULL,
+     sizeof(Evas_Rectangle_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_rectangle_class_get, &_evas_rectangle_class_desc, EVAS_OBJECT_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_rectangle.eo.h b/src/lib/evas/canvas/evas_rectangle.eo.h
--- a/src/lib/evas/canvas/evas_rectangle.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_rectangle.eo.h	2014-11-27 00:57:33.490380314 +0200
@@ -0,0 +1,21 @@
+#ifndef _EVAS_RECTANGLE_EO_H_
+#define _EVAS_RECTANGLE_EO_H_
+
+#ifndef _EVAS_RECTANGLE_EO_CLASS_TYPE
+#define _EVAS_RECTANGLE_EO_CLASS_TYPE
+
+typedef Eo Evas_Rectangle;
+
+#endif
+
+#ifndef _EVAS_RECTANGLE_EO_TYPES
+#define _EVAS_RECTANGLE_EO_TYPES
+
+
+#endif
+#define EVAS_RECTANGLE_CLASS evas_rectangle_class_get()
+
+const Eo_Class *evas_rectangle_class_get(void) EINA_CONST;
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_rectangle.eo.hh b/src/lib/evas/canvas/evas_rectangle.eo.hh
--- a/src/lib/evas/canvas/evas_rectangle.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_rectangle.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,135 @@
+#ifndef EFL_GENERATED_EVAS_RECTANGLE_HH
+#define EFL_GENERATED_EVAS_RECTANGLE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_rectangle.eo.h"
+}
+
+#include "evas_object.eo.hh"
+
+namespace evas {
+
+struct rectangle
+      : evas::object
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit rectangle(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit rectangle(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   rectangle(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : rectangle(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   rectangle(rectangle const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~rectangle() {}
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_RECTANGLE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_RECTANGLE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::rectangle >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::rectangle >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::rectangle>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< evas::rectangle >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::rectangle, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::rectangle >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::rectangle, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::rectangle>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::rectangle() const
+      {
+         return evas::rectangle(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::rectangle>)
+{
+   return (EVAS_RECTANGLE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_RECTANGLE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_rectangle.eo.legacy.h b/src/lib/evas/canvas/evas_rectangle.eo.legacy.h
--- a/src/lib/evas/canvas/evas_rectangle.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_rectangle.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_RECTANGLE_EO_LEGACY_H_
+#define _EVAS_RECTANGLE_EO_LEGACY_H_
+
+#ifndef _EVAS_RECTANGLE_EO_CLASS_TYPE
+#define _EVAS_RECTANGLE_EO_CLASS_TYPE
+
+typedef Eo Evas_Rectangle;
+
+#endif
+
+#ifndef _EVAS_RECTANGLE_EO_TYPES
+#define _EVAS_RECTANGLE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_scrollable_interface.eo.c b/src/lib/evas/canvas/evas_scrollable_interface.eo.c
--- a/src/lib/evas/canvas/evas_scrollable_interface.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_scrollable_interface.eo.c	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,32 @@
+EOAPI const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL =
+   EO_EVENT_DESCRIPTION("scroll", "");
+EOAPI const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START =
+   EO_EVENT_DESCRIPTION("scroll,anim,start", "");
+EOAPI const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP =
+   EO_EVENT_DESCRIPTION("scroll,anim,stop", "");
+EOAPI const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START =
+   EO_EVENT_DESCRIPTION("scroll,drag,start", "");
+EOAPI const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP =
+   EO_EVENT_DESCRIPTION("scroll,drag,stop", "");
+
+static const Eo_Event_Description *_evas_scrollable_interface_event_desc[] = {
+     EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL,
+     EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START,
+     EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP,
+     EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START,
+     EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP,
+     NULL
+};
+
+static const Eo_Class_Description _evas_scrollable_interface_class_desc = {
+     EO_VERSION,
+     "Evas_Scrollable_Interface",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     _evas_scrollable_interface_event_desc,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_scrollable_interface_interface_get, &_evas_scrollable_interface_class_desc, EVAS_SIGNAL_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_scrollable_interface.eo.h b/src/lib/evas/canvas/evas_scrollable_interface.eo.h
--- a/src/lib/evas/canvas/evas_scrollable_interface.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_scrollable_interface.eo.h	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,51 @@
+#ifndef _EVAS_SCROLLABLE_INTERFACE_EO_H_
+#define _EVAS_SCROLLABLE_INTERFACE_EO_H_
+
+#ifndef _EVAS_SCROLLABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_SCROLLABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Scrollable_Interface;
+
+#endif
+
+#ifndef _EVAS_SCROLLABLE_INTERFACE_EO_TYPES
+#define _EVAS_SCROLLABLE_INTERFACE_EO_TYPES
+
+
+#endif
+#define EVAS_SCROLLABLE_INTERFACE_INTERFACE evas_scrollable_interface_interface_get()
+
+const Eo_Class *evas_scrollable_interface_interface_get(void) EINA_CONST;
+
+EOAPI extern const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL;
+EOAPI extern const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START;
+EOAPI extern const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP;
+EOAPI extern const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START;
+EOAPI extern const Eo_Event_Description _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP;
+
+/**
+ * No description
+ */
+#define EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL (&(_EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL))
+
+/**
+ * No description
+ */
+#define EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START (&(_EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START))
+
+/**
+ * No description
+ */
+#define EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP (&(_EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP))
+
+/**
+ * No description
+ */
+#define EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START (&(_EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START))
+
+/**
+ * No description
+ */
+#define EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP (&(_EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP))
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_scrollable_interface.eo.hh b/src/lib/evas/canvas/evas_scrollable_interface.eo.hh
--- a/src/lib/evas/canvas/evas_scrollable_interface.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_scrollable_interface.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,354 @@
+#ifndef EFL_GENERATED_EVAS_SCROLLABLE_INTERFACE_HH
+#define EFL_GENERATED_EVAS_SCROLLABLE_INTERFACE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_scrollable_interface.eo.h"
+}
+
+#include "evas_signal_interface.eo.hh"
+
+namespace evas {
+
+struct scrollable_interface
+      : evas::signal_interface
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit scrollable_interface(Eo* eo)
+      : evas::signal_interface(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit scrollable_interface(std::nullptr_t)
+      : evas::signal_interface(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   scrollable_interface(scrollable_interface const& other)
+      : evas::signal_interface(eo_ref(other._eo_ptr()))
+   {}
+
+   ~scrollable_interface() {}
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_anim_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_anim_start_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_anim_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_anim_stop_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_drag_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_drag_start_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_drag_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_drag_stop_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_SCROLLABLE_INTERFACE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::scrollable_interface >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::scrollable_interface >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::scrollable_interface>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< evas::scrollable_interface >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::scrollable_interface, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::scrollable_interface>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::scrollable_interface() const
+      {
+         return evas::scrollable_interface(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_anim_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_anim_start_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_anim_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_anim_stop_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_drag_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_drag_start_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_scroll_drag_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::scrollable_interface, function_type>,
+         EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_scroll_drag_stop_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::scrollable_interface>)
+{
+   return (EVAS_SCROLLABLE_INTERFACE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_SCROLLABLE_INTERFACE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_scrollable_interface.eo.legacy.h b/src/lib/evas/canvas/evas_scrollable_interface.eo.legacy.h
--- a/src/lib/evas/canvas/evas_scrollable_interface.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_scrollable_interface.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_SCROLLABLE_INTERFACE_EO_LEGACY_H_
+#define _EVAS_SCROLLABLE_INTERFACE_EO_LEGACY_H_
+
+#ifndef _EVAS_SCROLLABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_SCROLLABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Scrollable_Interface;
+
+#endif
+
+#ifndef _EVAS_SCROLLABLE_INTERFACE_EO_TYPES
+#define _EVAS_SCROLLABLE_INTERFACE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_selectable_interface.eo.c b/src/lib/evas/canvas/evas_selectable_interface.eo.c
--- a/src/lib/evas/canvas/evas_selectable_interface.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_selectable_interface.eo.c	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,41 @@
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED =
+   EO_EVENT_DESCRIPTION("selected", "");
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED =
+   EO_EVENT_DESCRIPTION("unselected", "");
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE =
+   EO_EVENT_DESCRIPTION("selection,paste", "");
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY =
+   EO_EVENT_DESCRIPTION("selection,copy", "");
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT =
+   EO_EVENT_DESCRIPTION("selection,cut", "");
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START =
+   EO_EVENT_DESCRIPTION("selection,start", "");
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED =
+   EO_EVENT_DESCRIPTION("selection,changed", "");
+EOAPI const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED =
+   EO_EVENT_DESCRIPTION("selection,cleared", "");
+
+static const Eo_Event_Description *_evas_selectable_interface_event_desc[] = {
+     EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED,
+     EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED,
+     EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE,
+     EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY,
+     EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT,
+     EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START,
+     EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED,
+     EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED,
+     NULL
+};
+
+static const Eo_Class_Description _evas_selectable_interface_class_desc = {
+     EO_VERSION,
+     "Evas_Selectable_Interface",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     _evas_selectable_interface_event_desc,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_selectable_interface_interface_get, &_evas_selectable_interface_class_desc, EVAS_SIGNAL_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_selectable_interface.eo.h b/src/lib/evas/canvas/evas_selectable_interface.eo.h
--- a/src/lib/evas/canvas/evas_selectable_interface.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_selectable_interface.eo.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,69 @@
+#ifndef _EVAS_SELECTABLE_INTERFACE_EO_H_
+#define _EVAS_SELECTABLE_INTERFACE_EO_H_
+
+#ifndef _EVAS_SELECTABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_SELECTABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Selectable_Interface;
+
+#endif
+
+#ifndef _EVAS_SELECTABLE_INTERFACE_EO_TYPES
+#define _EVAS_SELECTABLE_INTERFACE_EO_TYPES
+
+
+#endif
+#define EVAS_SELECTABLE_INTERFACE_INTERFACE evas_selectable_interface_interface_get()
+
+const Eo_Class *evas_selectable_interface_interface_get(void) EINA_CONST;
+
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED;
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED;
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE;
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY;
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT;
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START;
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED;
+EOAPI extern const Eo_Event_Description _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED;
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED (&(_EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED))
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED (&(_EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED))
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE (&(_EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE))
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY (&(_EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY))
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT (&(_EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT))
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START (&(_EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START))
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED (&(_EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED))
+
+/**
+ * No description
+ */
+#define EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED (&(_EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED))
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_selectable_interface.eo.hh b/src/lib/evas/canvas/evas_selectable_interface.eo.hh
--- a/src/lib/evas/canvas/evas_selectable_interface.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_selectable_interface.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,498 @@
+#ifndef EFL_GENERATED_EVAS_SELECTABLE_INTERFACE_HH
+#define EFL_GENERATED_EVAS_SELECTABLE_INTERFACE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_selectable_interface.eo.h"
+}
+
+#include "evas_signal_interface.eo.hh"
+
+namespace evas {
+
+struct selectable_interface
+      : evas::signal_interface
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit selectable_interface(Eo* eo)
+      : evas::signal_interface(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit selectable_interface(std::nullptr_t)
+      : evas::signal_interface(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   selectable_interface(selectable_interface const& other)
+      : evas::signal_interface(eo_ref(other._eo_ptr()))
+   {}
+
+   ~selectable_interface() {}
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selected_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED );
+   }
+
+   template <typename T>
+   void
+   callback_selected_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_unselected_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED );
+   }
+
+   template <typename T>
+   void
+   callback_unselected_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_paste_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE );
+   }
+
+   template <typename T>
+   void
+   callback_selection_paste_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_copy_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY );
+   }
+
+   template <typename T>
+   void
+   callback_selection_copy_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_cut_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT );
+   }
+
+   template <typename T>
+   void
+   callback_selection_cut_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START );
+   }
+
+   template <typename T>
+   void
+   callback_selection_start_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_changed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED );
+   }
+
+   template <typename T>
+   void
+   callback_selection_changed_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_cleared_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED );
+   }
+
+   template <typename T>
+   void
+   callback_selection_cleared_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_SELECTABLE_INTERFACE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::selectable_interface >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::selectable_interface >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::selectable_interface>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< evas::selectable_interface >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::selectable_interface, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::selectable_interface>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::selectable_interface() const
+      {
+         return evas::selectable_interface(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selected_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED );
+   }
+
+   template <typename T>
+   void
+   callback_selected_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_unselected_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED );
+   }
+
+   template <typename T>
+   void
+   callback_unselected_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_paste_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE );
+   }
+
+   template <typename T>
+   void
+   callback_selection_paste_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_copy_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY );
+   }
+
+   template <typename T>
+   void
+   callback_selection_copy_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_cut_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT );
+   }
+
+   template <typename T>
+   void
+   callback_selection_cut_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START );
+   }
+
+   template <typename T>
+   void
+   callback_selection_start_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_changed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED );
+   }
+
+   template <typename T>
+   void
+   callback_selection_changed_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_selection_cleared_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED, priority_,
+            &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::selectable_interface, function_type>,
+         EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED );
+   }
+
+   template <typename T>
+   void
+   callback_selection_cleared_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::selectable_interface>)
+{
+   return (EVAS_SELECTABLE_INTERFACE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_SELECTABLE_INTERFACE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_selectable_interface.eo.legacy.h b/src/lib/evas/canvas/evas_selectable_interface.eo.legacy.h
--- a/src/lib/evas/canvas/evas_selectable_interface.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_selectable_interface.eo.legacy.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_SELECTABLE_INTERFACE_EO_LEGACY_H_
+#define _EVAS_SELECTABLE_INTERFACE_EO_LEGACY_H_
+
+#ifndef _EVAS_SELECTABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_SELECTABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Selectable_Interface;
+
+#endif
+
+#ifndef _EVAS_SELECTABLE_INTERFACE_EO_TYPES
+#define _EVAS_SELECTABLE_INTERFACE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_signal_interface.eo.c b/src/lib/evas/canvas/evas_signal_interface.eo.c
--- a/src/lib/evas/canvas/evas_signal_interface.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_signal_interface.eo.c	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,13 @@
+
+static const Eo_Class_Description _evas_signal_interface_class_desc = {
+     EO_VERSION,
+     "Evas_Signal_Interface",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     NULL,
+     0,
+     _evas_signal_interface_class_constructor,
+     _evas_signal_interface_class_destructor
+};
+
+EO_DEFINE_CLASS(evas_signal_interface_interface_get, &_evas_signal_interface_class_desc, NULL, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_signal_interface.eo.h b/src/lib/evas/canvas/evas_signal_interface.eo.h
--- a/src/lib/evas/canvas/evas_signal_interface.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_signal_interface.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,21 @@
+#ifndef _EVAS_SIGNAL_INTERFACE_EO_H_
+#define _EVAS_SIGNAL_INTERFACE_EO_H_
+
+#ifndef _EVAS_SIGNAL_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_SIGNAL_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Signal_Interface;
+
+#endif
+
+#ifndef _EVAS_SIGNAL_INTERFACE_EO_TYPES
+#define _EVAS_SIGNAL_INTERFACE_EO_TYPES
+
+
+#endif
+#define EVAS_SIGNAL_INTERFACE_INTERFACE evas_signal_interface_interface_get()
+
+const Eo_Class *evas_signal_interface_interface_get(void) EINA_CONST;
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_signal_interface.eo.hh b/src/lib/evas/canvas/evas_signal_interface.eo.hh
--- a/src/lib/evas/canvas/evas_signal_interface.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_signal_interface.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,113 @@
+#ifndef EFL_GENERATED_EVAS_SIGNAL_INTERFACE_HH
+#define EFL_GENERATED_EVAS_SIGNAL_INTERFACE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_signal_interface.eo.h"
+}
+
+
+namespace evas {
+
+struct signal_interface
+      : efl::eo::base
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit signal_interface(Eo* eo)
+      : efl::eo::base(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit signal_interface(std::nullptr_t)
+      : efl::eo::base(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   signal_interface(signal_interface const& other)
+      : efl::eo::base(eo_ref(other._eo_ptr()))
+   {}
+
+   ~signal_interface() {}
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_SIGNAL_INTERFACE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::signal_interface >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::signal_interface >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::signal_interface>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< evas::signal_interface >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::signal_interface, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::signal_interface>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::signal_interface() const
+      {
+         return evas::signal_interface(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::signal_interface>)
+{
+   return (EVAS_SIGNAL_INTERFACE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_SIGNAL_INTERFACE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_signal_interface.eo.legacy.h b/src/lib/evas/canvas/evas_signal_interface.eo.legacy.h
--- a/src/lib/evas/canvas/evas_signal_interface.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_signal_interface.eo.legacy.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_SIGNAL_INTERFACE_EO_LEGACY_H_
+#define _EVAS_SIGNAL_INTERFACE_EO_LEGACY_H_
+
+#ifndef _EVAS_SIGNAL_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_SIGNAL_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Signal_Interface;
+
+#endif
+
+#ifndef _EVAS_SIGNAL_INTERFACE_EO_TYPES
+#define _EVAS_SIGNAL_INTERFACE_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_smart_clipped.eo.c b/src/lib/evas/canvas/evas_smart_clipped.eo.c
--- a/src/lib/evas/canvas/evas_smart_clipped.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_smart_clipped.eo.c	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,61 @@
+
+void _evas_smart_clipped_eo_base_constructor(Eo *obj, Evas_Object_Smart_Clipped_Data *pd);
+
+
+void _evas_smart_clipped_evas_object_smart_hide(Eo *obj, Evas_Object_Smart_Clipped_Data *pd);
+
+
+void _evas_smart_clipped_evas_object_smart_clip_set(Eo *obj, Evas_Object_Smart_Clipped_Data *pd, Evas_Object *clip);
+
+
+void _evas_smart_clipped_evas_object_smart_clip_unset(Eo *obj, Evas_Object_Smart_Clipped_Data *pd);
+
+
+void _evas_smart_clipped_evas_object_smart_show(Eo *obj, Evas_Object_Smart_Clipped_Data *pd);
+
+
+void _evas_smart_clipped_evas_object_smart_color_set(Eo *obj, Evas_Object_Smart_Clipped_Data *pd, int r, int g, int b, int a);
+
+
+void _evas_smart_clipped_evas_object_smart_move(Eo *obj, Evas_Object_Smart_Clipped_Data *pd, Evas_Coord x, Evas_Coord y);
+
+
+void _evas_smart_clipped_evas_object_smart_member_del(Eo *obj, Evas_Object_Smart_Clipped_Data *pd, Evas_Object *sub_obj);
+
+
+void _evas_smart_clipped_evas_object_smart_add(Eo *obj, Evas_Object_Smart_Clipped_Data *pd);
+
+
+void _evas_smart_clipped_evas_object_smart_del(Eo *obj, Evas_Object_Smart_Clipped_Data *pd);
+
+
+void _evas_smart_clipped_evas_object_smart_member_add(Eo *obj, Evas_Object_Smart_Clipped_Data *pd, Evas_Object *sub_obj);
+
+
+static Eo_Op_Description _evas_smart_clipped_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_smart_clipped_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_hide, _evas_smart_clipped_evas_object_smart_hide),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_clip_set, _evas_smart_clipped_evas_object_smart_clip_set),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_clip_unset, _evas_smart_clipped_evas_object_smart_clip_unset),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_show, _evas_smart_clipped_evas_object_smart_show),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_color_set, _evas_smart_clipped_evas_object_smart_color_set),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_move, _evas_smart_clipped_evas_object_smart_move),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_member_del, _evas_smart_clipped_evas_object_smart_member_del),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_add, _evas_smart_clipped_evas_object_smart_add),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_del, _evas_smart_clipped_evas_object_smart_del),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_member_add, _evas_smart_clipped_evas_object_smart_member_add),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_smart_clipped_class_desc = {
+     EO_VERSION,
+     "Evas_Smart_Clipped",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_smart_clipped_op_desc),
+     NULL,
+     sizeof(Evas_Object_Smart_Clipped_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_smart_clipped_class_get, &_evas_smart_clipped_class_desc, EVAS_OBJECT_SMART_CLASS, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_smart_clipped.eo.h b/src/lib/evas/canvas/evas_smart_clipped.eo.h
--- a/src/lib/evas/canvas/evas_smart_clipped.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_smart_clipped.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,21 @@
+#ifndef _EVAS_SMART_CLIPPED_EO_H_
+#define _EVAS_SMART_CLIPPED_EO_H_
+
+#ifndef _EVAS_SMART_CLIPPED_EO_CLASS_TYPE
+#define _EVAS_SMART_CLIPPED_EO_CLASS_TYPE
+
+typedef Eo Evas_Smart_Clipped;
+
+#endif
+
+#ifndef _EVAS_SMART_CLIPPED_EO_TYPES
+#define _EVAS_SMART_CLIPPED_EO_TYPES
+
+
+#endif
+#define EVAS_SMART_CLIPPED_CLASS evas_smart_clipped_class_get()
+
+const Eo_Class *evas_smart_clipped_class_get(void) EINA_CONST;
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_smart_clipped.eo.hh b/src/lib/evas/canvas/evas_smart_clipped.eo.hh
--- a/src/lib/evas/canvas/evas_smart_clipped.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_smart_clipped.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,492 @@
+#ifndef EFL_GENERATED_EVAS_SMART_CLIPPED_HH
+#define EFL_GENERATED_EVAS_SMART_CLIPPED_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_smart_clipped.eo.h"
+}
+
+#include "evas_object_smart.eo.hh"
+#include <canvas/evas_object.eo.hh>
+
+namespace evas {
+
+struct smart_clipped
+      : evas::object_smart
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit smart_clipped(Eo* eo)
+      : evas::object_smart(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit smart_clipped(std::nullptr_t)
+      : evas::object_smart(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   smart_clipped(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : smart_clipped(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   smart_clipped(smart_clipped const& other)
+      : evas::object_smart(eo_ref(other._eo_ptr()))
+   {}
+
+   ~smart_clipped() {}
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void hide() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_hide());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param clip 
+   ///
+   void clip_set(evas::object clip_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_clip_set(efl::eolian::to_c(clip_)));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void clip_unset() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_clip_unset());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   void show() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_show());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param r 
+   /// @param g 
+   /// @param b 
+   /// @param a 
+   ///
+   void color_set(int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_color_set(r_, g_, b_, a_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param x 
+   /// @param y 
+   ///
+   void move(Evas_Coord x_, Evas_Coord y_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_move(x_, y_));
+   }
+
+   /// @brief Removes a member object from a given smart object.
+   ///
+   /// This removes a member object from a smart object, if it was added
+   /// to any. The object will still be on the canvas, but no longer
+   /// associated with whichever smart object it was associated with.
+   ///
+   /// @see evas_object_smart_member_add() for more details
+   /// @see evas_object_smart_members_get()
+   ///
+   /// @param sub_obj the member object
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void member_del(evas::object sub_obj_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_member_del(efl::eolian::to_c(sub_obj_)));
+   }
+
+   /// @brief Instantiates a new smart object described by @p s.
+   ///
+   /// @return a new #Evas_Object handle
+   ///
+   /// This is the function one should use when defining the public
+   /// function @b adding an instance of the new smart object to a given
+   /// canvas. It will take care of setting all of its internals to work
+   /// as they should, if the user set things properly, as seem on the
+   /// #EVAS_SMART_SUBCLASS_NEW, for example.
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void add() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_add());
+   }
+
+   /// @brief Deletes a smart object.
+   ///
+   void del() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_del());
+   }
+
+   /// @brief Set an Evas object as a member of a given smart object.
+   ///
+   /// Members will automatically be stacked and layered together with the
+   /// smart object. The various stacking functions will operate on
+   /// members relative to the other members instead of the entire canvas,
+   /// since they now live on an exclusive layer (see
+   /// evas_object_stack_above(), for more details).
+   ///
+   /// Any @p smart_obj object's specific implementation of the @c
+   /// member_add() smart function will take place too, naturally.
+   ///
+   /// @see evas_object_smart_member_del()
+   /// @see evas_object_smart_members_get()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   /// @param sub_obj The member object
+   ///
+   void member_add(evas::object sub_obj_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_member_add(efl::eolian::to_c(sub_obj_)));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_SMART_CLIPPED_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_SMART_CLIPPED_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_smart_clipped_hide_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->hide();
+}
+
+template <typename T>
+void evas_smart_clipped_clip_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * clip_)
+{
+   static_cast<T*>(self->this_)->clip_set(efl::eolian::to_cxx<evas::object>(clip_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_smart_clipped_clip_unset_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->clip_unset();
+}
+
+template <typename T>
+void evas_smart_clipped_show_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->show();
+}
+
+template <typename T>
+void evas_smart_clipped_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_smart_clipped_move_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_)
+{
+   static_cast<T*>(self->this_)->move(x_, y_);
+}
+
+template <typename T>
+void evas_smart_clipped_member_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * sub_obj_)
+{
+   static_cast<T*>(self->this_)->member_del(efl::eolian::to_cxx<evas::object>(sub_obj_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_smart_clipped_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->add();
+}
+
+template <typename T>
+void evas_smart_clipped_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->del();
+}
+
+template <typename T>
+void evas_smart_clipped_member_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * sub_obj_)
+{
+   static_cast<T*>(self->this_)->member_add(efl::eolian::to_cxx<evas::object>(sub_obj_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::smart_clipped >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void hide()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_hide());
+      }
+
+      virtual void clip_set(evas::object clip_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_clip_set(efl::eolian::to_c(clip_)));
+      }
+
+      virtual void clip_unset()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_clip_unset());
+      }
+
+      virtual void show()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_show());
+      }
+
+      virtual void color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_color_set(r_, g_, b_, a_));
+      }
+
+      virtual void move(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_move(x_, y_));
+      }
+
+      virtual void member_del(evas::object sub_obj_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_member_del(efl::eolian::to_c(sub_obj_)));
+      }
+
+      virtual void add()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_add());
+      }
+
+      virtual void del()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_del());
+      }
+
+      virtual void member_add(evas::object sub_obj_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_member_add(efl::eolian::to_c(sub_obj_)));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::smart_clipped >
+{
+   static const int value = 10;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::smart_clipped>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_smart_clipped_hide_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_hide);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_smart_clipped_clip_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_clip_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_smart_clipped_clip_unset_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_clip_unset);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_smart_clipped_show_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_show);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_smart_clipped_color_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_color_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_smart_clipped_move_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_move);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_smart_clipped_member_del_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_member_del);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_smart_clipped_add_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_add);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_smart_clipped_del_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_del);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_smart_clipped_member_add_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_member_add);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::smart_clipped >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::smart_clipped, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::smart_clipped >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::smart_clipped, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::smart_clipped>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::smart_clipped() const
+      {
+         return evas::smart_clipped(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void hide()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_hide());
+      }
+
+      void clip_set(evas::object clip_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_clip_set(efl::eolian::to_c(clip_)));
+      }
+
+      void clip_unset()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_clip_unset());
+      }
+
+      void show()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_show());
+      }
+
+      void color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_color_set(r_, g_, b_, a_));
+      }
+
+      void move(Evas_Coord x_, Evas_Coord y_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_move(x_, y_));
+      }
+
+      void member_del(evas::object sub_obj_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_member_del(efl::eolian::to_c(sub_obj_)));
+      }
+
+      void add()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_add());
+      }
+
+      void del()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_del());
+      }
+
+      void member_add(evas::object sub_obj_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_member_add(efl::eolian::to_c(sub_obj_)));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::smart_clipped>)
+{
+   return (EVAS_SMART_CLIPPED_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_SMART_CLIPPED_HH
+
diff -Naur a/src/lib/evas/canvas/evas_smart_clipped.eo.legacy.h b/src/lib/evas/canvas/evas_smart_clipped.eo.legacy.h
--- a/src/lib/evas/canvas/evas_smart_clipped.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_smart_clipped.eo.legacy.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_SMART_CLIPPED_EO_LEGACY_H_
+#define _EVAS_SMART_CLIPPED_EO_LEGACY_H_
+
+#ifndef _EVAS_SMART_CLIPPED_EO_CLASS_TYPE
+#define _EVAS_SMART_CLIPPED_EO_CLASS_TYPE
+
+typedef Eo Evas_Smart_Clipped;
+
+#endif
+
+#ifndef _EVAS_SMART_CLIPPED_EO_TYPES
+#define _EVAS_SMART_CLIPPED_EO_TYPES
+
+
+#endif
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_table.eo.c b/src/lib/evas/canvas/evas_table.eo.c
--- a/src/lib/evas/canvas/evas_table.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_table.eo.c	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,234 @@
+
+void _evas_table_homogeneous_set(Eo *obj, Evas_Table_Data *pd, Evas_Object_Table_Homogeneous_Mode homogeneous);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_homogeneous_set, EO_FUNC_CALL(homogeneous), Evas_Object_Table_Homogeneous_Mode homogeneous);
+
+Evas_Object_Table_Homogeneous_Mode _evas_table_homogeneous_get(Eo *obj, Evas_Table_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_table_homogeneous_get, Evas_Object_Table_Homogeneous_Mode, 0);
+
+void _evas_table_align_set(Eo *obj, Evas_Table_Data *pd, double horizontal, double vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_align_set, EO_FUNC_CALL(horizontal, vertical), double horizontal, double vertical);
+
+void _evas_table_align_get(Eo *obj, Evas_Table_Data *pd, double *horizontal, double *vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_align_get, EO_FUNC_CALL(horizontal, vertical), double *horizontal, double *vertical);
+
+void _evas_table_padding_set(Eo *obj, Evas_Table_Data *pd, Evas_Coord horizontal, Evas_Coord vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_padding_set, EO_FUNC_CALL(horizontal, vertical), Evas_Coord horizontal, Evas_Coord vertical);
+
+void _evas_table_padding_get(Eo *obj, Evas_Table_Data *pd, Evas_Coord *horizontal, Evas_Coord *vertical);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_padding_get, EO_FUNC_CALL(horizontal, vertical), Evas_Coord *horizontal, Evas_Coord *vertical);
+
+void _evas_table_mirrored_set(Eo *obj, Evas_Table_Data *pd, Eina_Bool mirrored);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_mirrored_set, EO_FUNC_CALL(mirrored), Eina_Bool mirrored);
+
+Eina_Bool _evas_table_mirrored_get(Eo *obj, Evas_Table_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_table_mirrored_get, Eina_Bool, 0);
+
+void _evas_table_col_row_size_get(Eo *obj, Evas_Table_Data *pd, int *cols, int *rows);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_col_row_size_get, EO_FUNC_CALL(cols, rows), int *cols, int *rows);
+
+Eina_List * _evas_table_children_get(Eo *obj, Evas_Table_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_table_children_get, Eina_List *, 0);
+
+Evas_Object * _evas_table_child_get(Eo *obj, Evas_Table_Data *pd, unsigned short col, unsigned short row);
+
+EOAPI EO_FUNC_BODYV(evas_obj_table_child_get, Evas_Object *, 0, EO_FUNC_CALL(col, row), unsigned short col, unsigned short row);
+
+void _evas_table_clear(Eo *obj, Evas_Table_Data *pd, Eina_Bool clear);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_table_clear, EO_FUNC_CALL(clear), Eina_Bool clear);
+
+Eina_Accessor * _evas_table_accessor_new(Eo *obj, Evas_Table_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_table_accessor_new, Eina_Accessor *, 0);
+
+Eina_Iterator * _evas_table_iterator_new(Eo *obj, Evas_Table_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_table_iterator_new, Eina_Iterator *, 0);
+
+Evas_Object * _evas_table_add_to(Eo *obj, Evas_Table_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_table_add_to, Evas_Object *, 0);
+
+Eina_Bool _evas_table_pack_get(Eo *obj, Evas_Table_Data *pd, Evas_Object *child, unsigned short *col, unsigned short *row, unsigned short *colspan, unsigned short *rowspan);
+
+EOAPI EO_FUNC_BODYV(evas_obj_table_pack_get, Eina_Bool, 0, EO_FUNC_CALL(child, col, row, colspan, rowspan), Evas_Object *child, unsigned short *col, unsigned short *row, unsigned short *colspan, unsigned short *rowspan);
+
+Eina_Bool _evas_table_pack(Eo *obj, Evas_Table_Data *pd, Evas_Object *child, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan);
+
+EOAPI EO_FUNC_BODYV(evas_obj_table_pack, Eina_Bool, 0, EO_FUNC_CALL(child, col, row, colspan, rowspan), Evas_Object *child, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan);
+
+Eina_Bool _evas_table_unpack(Eo *obj, Evas_Table_Data *pd, Evas_Object *child);
+
+EOAPI EO_FUNC_BODYV(evas_obj_table_unpack, Eina_Bool, 0, EO_FUNC_CALL(child), Evas_Object *child);
+
+void _evas_table_eo_base_constructor(Eo *obj, Evas_Table_Data *pd);
+
+
+void _evas_table_evas_object_smart_add(Eo *obj, Evas_Table_Data *pd);
+
+
+void _evas_table_evas_object_smart_del(Eo *obj, Evas_Table_Data *pd);
+
+
+void _evas_table_evas_object_smart_calculate(Eo *obj, Evas_Table_Data *pd);
+
+
+void _evas_table_evas_object_smart_resize(Eo *obj, Evas_Table_Data *pd, Evas_Coord w, Evas_Coord h);
+
+
+static Eo_Op_Description _evas_table_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_table_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_add, _evas_table_evas_object_smart_add),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_del, _evas_table_evas_object_smart_del),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_calculate, _evas_table_evas_object_smart_calculate),
+     EO_OP_FUNC_OVERRIDE(evas_obj_smart_resize, _evas_table_evas_object_smart_resize),
+     EO_OP_FUNC(evas_obj_table_homogeneous_set, _evas_table_homogeneous_set, "@brief Set how this table should layout children."),
+     EO_OP_FUNC(evas_obj_table_homogeneous_get, _evas_table_homogeneous_get, "Get the current layout homogeneous mode."),
+     EO_OP_FUNC(evas_obj_table_align_set, _evas_table_align_set, "Set the alignment of the whole bounding box of contents."),
+     EO_OP_FUNC(evas_obj_table_align_get, _evas_table_align_get, "Get alignment of the whole bounding box of contents."),
+     EO_OP_FUNC(evas_obj_table_padding_set, _evas_table_padding_set, "Set padding between cells."),
+     EO_OP_FUNC(evas_obj_table_padding_get, _evas_table_padding_get, "Get padding between cells."),
+     EO_OP_FUNC(evas_obj_table_mirrored_set, _evas_table_mirrored_set, "Sets the mirrored mode of the table. In mirrored mode the table items go"),
+     EO_OP_FUNC(evas_obj_table_mirrored_get, _evas_table_mirrored_get, "Gets the mirrored mode of the table."),
+     EO_OP_FUNC(evas_obj_table_col_row_size_get, _evas_table_col_row_size_get, "Get the number of columns and rows this table takes."),
+     EO_OP_FUNC(evas_obj_table_children_get, _evas_table_children_get, "Get the list of children for the table."),
+     EO_OP_FUNC(evas_obj_table_child_get, _evas_table_child_get, "Get the child of the table at the given coordinates"),
+     EO_OP_FUNC(evas_obj_table_clear, _evas_table_clear, "Faster way to remove all child objects from a table object."),
+     EO_OP_FUNC(evas_obj_table_accessor_new, _evas_table_accessor_new, "Get an accessor to get random access to the list of children for the table."),
+     EO_OP_FUNC(evas_obj_table_iterator_new, _evas_table_iterator_new, "Get an iterator to walk the list of children for the table."),
+     EO_OP_FUNC(evas_obj_table_add_to, _evas_table_add_to, "@brief Create a table that is child of a given element @a parent."),
+     EO_OP_FUNC(evas_obj_table_pack_get, _evas_table_pack_get, "Get packing location of a child of table"),
+     EO_OP_FUNC(evas_obj_table_pack, _evas_table_pack, "Add a new child to a table object or set its current packing."),
+     EO_OP_FUNC(evas_obj_table_unpack, _evas_table_unpack, "Remove child from table."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_table_class_desc = {
+     EO_VERSION,
+     "Evas_Table",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_table_op_desc),
+     NULL,
+     sizeof(Evas_Table_Data),
+     _evas_table_class_constructor,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_table_class_get, &_evas_table_class_desc, EVAS_SMART_CLIPPED_CLASS, NULL);
+EAPI void
+evas_object_table_homogeneous_set(Evas_Table *obj, Evas_Object_Table_Homogeneous_Mode homogeneous)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_homogeneous_set(homogeneous));
+}
+
+EAPI Evas_Object_Table_Homogeneous_Mode
+evas_object_table_homogeneous_get(const Evas_Table *obj)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_homogeneous_get());
+}
+
+EAPI void
+evas_object_table_align_set(Evas_Table *obj, double horizontal, double vertical)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_align_set(horizontal, vertical));
+}
+
+EAPI void
+evas_object_table_align_get(const Evas_Table *obj, double *horizontal, double *vertical)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_align_get(horizontal, vertical));
+}
+
+EAPI void
+evas_object_table_padding_set(Evas_Table *obj, Evas_Coord horizontal, Evas_Coord vertical)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_padding_set(horizontal, vertical));
+}
+
+EAPI void
+evas_object_table_padding_get(const Evas_Table *obj, Evas_Coord *horizontal, Evas_Coord *vertical)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_padding_get(horizontal, vertical));
+}
+
+EAPI void
+evas_object_table_mirrored_set(Evas_Table *obj, Eina_Bool mirrored)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_mirrored_set(mirrored));
+}
+
+EAPI Eina_Bool
+evas_object_table_mirrored_get(const Evas_Table *obj)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_mirrored_get());
+}
+
+EAPI void
+evas_object_table_col_row_size_get(const Evas_Table *obj, int *cols, int *rows)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_col_row_size_get(cols, rows));
+}
+
+EAPI Eina_List *
+evas_object_table_children_get(const Evas_Table *obj)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_children_get());
+}
+
+EAPI Evas_Object *
+evas_object_table_child_get(const Evas_Table *obj, unsigned short col, unsigned short row)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_child_get(col, row));
+}
+
+EAPI void
+evas_object_table_clear(Evas_Table *obj, Eina_Bool clear)
+{
+   eo_do((Evas_Table *)obj, evas_obj_table_clear(clear));
+}
+
+EAPI Eina_Accessor *
+evas_object_table_accessor_new(const Evas_Table *obj)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_accessor_new());
+}
+
+EAPI Eina_Iterator *
+evas_object_table_iterator_new(const Evas_Table *obj)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_iterator_new());
+}
+
+EAPI Evas_Object *
+evas_object_table_add_to(Evas_Table *obj)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_add_to());
+}
+
+EAPI Eina_Bool
+evas_object_table_pack_get(const Evas_Table *obj, Evas_Object *child, unsigned short *col, unsigned short *row, unsigned short *colspan, unsigned short *rowspan)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_pack_get(child, col, row, colspan, rowspan));
+}
+
+EAPI Eina_Bool
+evas_object_table_pack(Evas_Table *obj, Evas_Object *child, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_pack(child, col, row, colspan, rowspan));
+}
+
+EAPI Eina_Bool
+evas_object_table_unpack(Evas_Table *obj, Evas_Object *child)
+{
+   return eo_do((Evas_Table *)obj, evas_obj_table_unpack(child));
+}
diff -Naur a/src/lib/evas/canvas/evas_table.eo.h b/src/lib/evas/canvas/evas_table.eo.h
--- a/src/lib/evas/canvas/evas_table.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_table.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,282 @@
+#ifndef _EVAS_TABLE_EO_H_
+#define _EVAS_TABLE_EO_H_
+
+#ifndef _EVAS_TABLE_EO_CLASS_TYPE
+#define _EVAS_TABLE_EO_CLASS_TYPE
+
+typedef Eo Evas_Table;
+
+#endif
+
+#ifndef _EVAS_TABLE_EO_TYPES
+#define _EVAS_TABLE_EO_TYPES
+
+
+#endif
+#define EVAS_TABLE_CLASS evas_table_class_get()
+
+const Eo_Class *evas_table_class_get(void) EINA_CONST;
+
+/**
+ *
+ * @brief Set how this table should layout children.
+ *
+ * @todo consider aspect hint and respect it.
+ *
+ * @par EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE
+ * If table does not use homogeneous mode then columns and rows will
+ * be calculated based on hints of individual cells. This operation
+ * mode is more flexible, but more complex and heavy to calculate as
+ * well. @b Weight properties are handled as a boolean expand. Negative
+ * alignment will be considered as 0.5. This is the default.
+ *
+ * @todo @c EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE should balance weight.
+ *
+ * @par EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE
+ * When homogeneous is relative to table the own table size is divided
+ * equally among children, filling the whole table area. That is, if
+ * table has @c WIDTH and @c COLUMNS, each cell will get <tt>WIDTH /
+ * COLUMNS</tt> pixels. If children have minimum size that is larger
+ * than this amount (including padding), then it will overflow and be
+ * aligned respecting the alignment hint, possible overlapping sibling
+ * cells. @b Weight hint is used as a boolean, if greater than zero it
+ * will make the child expand in that axis, taking as much space as
+ * possible (bounded to maximum size hint). Negative alignment will be
+ * considered as 0.5.
+ *
+ * @par EVAS_OBJECT_TABLE_HOMOGENEOUS_ITEM
+ * When homogeneous is relative to item it means the greatest minimum
+ * cell size will be used. That is, if no element is set to expand,
+ * the table will have its contents to a minimum size, the bounding
+ * box of all these children will be aligned relatively to the table
+ * object using evas_object_table_align_get(). If the table area is
+ * too small to hold this minimum bounding box, then the objects will
+ * keep their size and the bounding box will overflow the box area,
+ * still respecting the alignment. @b Weight hint is used as a
+ * boolean, if greater than zero it will make that cell expand in that
+ * axis, toggling the <b>expand mode</b>, which makes the table behave
+ * much like @b EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE, except that the
+ * bounding box will overflow and items will not overlap siblings. If
+ * no minimum size is provided at all then the table will fallback to
+ * expand mode as well.
+ *
+ * @param[in] homogeneous No description supplied.
+ *
+ */
+EOAPI void  evas_obj_table_homogeneous_set(Evas_Object_Table_Homogeneous_Mode homogeneous);
+
+/**
+ *
+ * Get the current layout homogeneous mode.
+ *
+ * @see evas_object_table_homogeneous_set()
+ *
+ *
+ */
+EOAPI Evas_Object_Table_Homogeneous_Mode  evas_obj_table_homogeneous_get(void);
+
+/**
+ *
+ * Set the alignment of the whole bounding box of contents.
+ *
+ * @param[in] horizontal No description supplied.
+ * @param[in] vertical No description supplied.
+ *
+ */
+EOAPI void  evas_obj_table_align_set(double horizontal, double vertical);
+
+/**
+ *
+ * Get alignment of the whole bounding box of contents.
+ *
+ * @param[out] horizontal No description supplied.
+ * @param[out] vertical No description supplied.
+ *
+ */
+EOAPI void  evas_obj_table_align_get(double *horizontal, double *vertical);
+
+/**
+ *
+ * Set padding between cells.
+ *
+ * @param[in] horizontal No description supplied.
+ * @param[in] vertical No description supplied.
+ *
+ */
+EOAPI void  evas_obj_table_padding_set(Evas_Coord horizontal, Evas_Coord vertical);
+
+/**
+ *
+ * Get padding between cells.
+ *
+ * @param[out] horizontal No description supplied.
+ * @param[out] vertical No description supplied.
+ *
+ */
+EOAPI void  evas_obj_table_padding_get(Evas_Coord *horizontal, Evas_Coord *vertical);
+
+/**
+ *
+ * Sets the mirrored mode of the table. In mirrored mode the table items go
+ * from right to left instead of left to right. That is, 1,1 is top right, not
+ * top left.
+ *
+ * @since 1.1
+ *
+ * @param[in] mirrored the mirrored mode to set
+ *
+ */
+EOAPI void  evas_obj_table_mirrored_set(Eina_Bool mirrored);
+
+/**
+ *
+ * Gets the mirrored mode of the table.
+ *
+ * @return @c EINA_TRUE if it's a mirrored table, @c EINA_FALSE otherwise.
+ * @since 1.1
+ * @see evas_object_table_mirrored_set()
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_table_mirrored_get(void);
+
+/**
+ *
+ * Get the number of columns and rows this table takes.
+ *
+ * @note columns and rows are virtual entities, one can specify a table
+ * with a single object that takes 4 columns and 5 rows. The only
+ * difference for a single cell table is that paddings will be
+ * accounted proportionally.
+ *
+ * @param[out] cols No description supplied.
+ * @param[out] rows No description supplied.
+ *
+ */
+EOAPI void  evas_obj_table_col_row_size_get(int *cols, int *rows);
+
+/**
+ *
+ * Get the list of children for the table.
+ *
+ * @note This is a duplicate of the list kept by the table internally.
+ * It's up to the user to destroy it when it no longer needs it.
+ * It's possible to remove objects from the table when walking this
+ * list, but these removals won't be reflected on it.
+ *
+ *
+ */
+EOAPI Eina_List * evas_obj_table_children_get(void);
+
+/**
+ *
+ * Get the child of the table at the given coordinates
+ *
+ * @note This does not take into account col/row spanning
+ *
+ * @param[in] col No description supplied.
+ * @param[in] row No description supplied.
+ *
+ */
+EOAPI Evas_Object * evas_obj_table_child_get(unsigned short col, unsigned short row);
+
+/**
+ *
+ * Faster way to remove all child objects from a table object.
+ * 
+ *
+ * @param[in] clear if true, it will delete just removed children.
+ *
+ */
+EOAPI void  evas_obj_table_clear(Eina_Bool clear);
+
+/**
+ *
+ * Get an accessor to get random access to the list of children for the table.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * 
+ *
+ *
+ */
+EOAPI Eina_Accessor * evas_obj_table_accessor_new(void);
+
+/**
+ *
+ * Get an iterator to walk the list of children for the table.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * 
+ *
+ *
+ */
+EOAPI Eina_Iterator * evas_obj_table_iterator_new(void);
+
+/**
+ *
+ * @brief Create a table that is child of a given element @a parent.
+ *
+ * @see evas_object_table_add()
+ * 
+ *
+ *
+ */
+EOAPI Evas_Object * evas_obj_table_add_to(void);
+
+/**
+ *
+ * Get packing location of a child of table
+ *
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child The child object to add.
+ * @param[out] col pointer to store relative-horizontal position to place child.
+ * @param[out] row pointer to store relative-vertical position to place child.
+ * @param[out] colspan pointer to store how many relative-horizontal position to use for this child.
+ * @param[out] rowspan pointer to store how many relative-vertical position to use for this child.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_table_pack_get(Evas_Object *child, unsigned short *col, unsigned short *row, unsigned short *colspan, unsigned short *rowspan);
+
+/**
+ *
+ * Add a new child to a table object or set its current packing.
+ *
+ * Note that columns and rows only guarantee 16bit unsigned values at best.
+ * That means that col + colspan AND row + rowspan must fit inside 16bit
+ * unsigned values cleanly. You will be warned once values exceed 15bit
+ * storage, and attempting to use values not able to fit in 16bits will
+ * result in failure.
+ *
+ * @return 1 on success, 0 on failure.
+ * 
+ *
+ * @param[in] child The child object to add.
+ * @param[in] col relative-horizontal position to place child.
+ * @param[in] row relative-vertical position to place child.
+ * @param[in] colspan how many relative-horizontal position to use for this child.
+ * @param[in] rowspan how many relative-vertical position to use for this child.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_table_pack(Evas_Object *child, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan);
+
+/**
+ *
+ * Remove child from table.
+ *
+ * @note removing a child will immediately call a walk over children in order
+ * to recalculate numbers of columns and rows. If you plan to remove
+ * all children, use evas_object_table_clear() instead.
+ *
+ * @return 1 on success, 0 on failure.
+ * 
+ *
+ * @param[in] child No description supplied.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_table_unpack(Evas_Object *child);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_table.eo.hh b/src/lib/evas/canvas/evas_table.eo.hh
--- a/src/lib/evas/canvas/evas_table.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_table.eo.hh	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,1026 @@
+#ifndef EFL_GENERATED_EVAS_TABLE_HH
+#define EFL_GENERATED_EVAS_TABLE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_table.eo.h"
+}
+
+#include "evas_smart_clipped.eo.hh"
+#include <canvas/evas_object.eo.hh>
+
+namespace evas {
+
+struct table
+      : evas::smart_clipped
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit table(Eo* eo)
+      : evas::smart_clipped(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit table(std::nullptr_t)
+      : evas::smart_clipped(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   table(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : table(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   table(table const& other)
+      : evas::smart_clipped(eo_ref(other._eo_ptr()))
+   {}
+
+   ~table() {}
+
+   /// @brief Instantiates a new smart object described by @p s.
+   ///
+   /// @return a new #Evas_Object handle
+   ///
+   /// This is the function one should use when defining the public
+   /// function @b adding an instance of the new smart object to a given
+   /// canvas. It will take care of setting all of its internals to work
+   /// as they should, if the user set things properly, as seem on the
+   /// #EVAS_SMART_SUBCLASS_NEW, for example.
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void add() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_add());
+   }
+
+   /// @brief Deletes a smart object.
+   ///
+   void del() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_del());
+   }
+
+   /// @brief Call the @b calculate() smart function immediately on a given smart
+   /// object.
+   ///
+   /// This will force immediate calculations (see #Evas_Smart_Class)
+   /// needed for renderization of this object and, besides, unset the
+   /// flag on it telling it needs recalculation for the next rendering
+   /// phase.
+   ///
+   /// @see evas_object_smart_need_recalculate_set()
+   ///
+   /// @ingroup Evas_Smart_Object_Group
+   ///
+   void calculate() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_calculate());
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param w 
+   /// @param h 
+   ///
+   void resize(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+   }
+
+   /// @brief Get the current layout homogeneous mode.
+   ///
+   /// @see evas_object_table_homogeneous_set()
+   ///
+   /// @param homogeneous 
+   ///
+   Evas_Object_Table_Homogeneous_Mode homogeneous_get() const
+   {
+      Evas_Object_Table_Homogeneous_Mode _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_homogeneous_get());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Set how this table should layout children.
+   ///
+   /// @todo consider aspect hint and respect it.
+   ///
+   /// @par EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE
+   /// If table does not use homogeneous mode then columns and rows will
+   /// be calculated based on hints of individual cells. This operation
+   /// mode is more flexible, but more complex and heavy to calculate as
+   /// well. @b Weight properties are handled as a boolean expand. Negative
+   /// alignment will be considered as 0.5. This is the default.
+   ///
+   /// @todo @c EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE should balance weight.
+   ///
+   /// @par EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE
+   /// When homogeneous is relative to table the own table size is divided
+   /// equally among children, filling the whole table area. That is, if
+   /// table has @c WIDTH and @c COLUMNS, each cell will get <tt>WIDTH /
+   /// COLUMNS</tt> pixels. If children have minimum size that is larger
+   /// than this amount (including padding), then it will overflow and be
+   /// aligned respecting the alignment hint, possible overlapping sibling
+   /// cells. @b Weight hint is used as a boolean, if greater than zero it
+   /// will make the child expand in that axis, taking as much space as
+   /// possible (bounded to maximum size hint). Negative alignment will be
+   /// considered as 0.5.
+   ///
+   /// @par EVAS_OBJECT_TABLE_HOMOGENEOUS_ITEM
+   /// When homogeneous is relative to item it means the greatest minimum
+   /// cell size will be used. That is, if no element is set to expand,
+   /// the table will have its contents to a minimum size, the bounding
+   /// box of all these children will be aligned relatively to the table
+   /// object using evas_object_table_align_get(). If the table area is
+   /// too small to hold this minimum bounding box, then the objects will
+   /// keep their size and the bounding box will overflow the box area,
+   /// still respecting the alignment. @b Weight hint is used as a
+   /// boolean, if greater than zero it will make that cell expand in that
+   /// axis, toggling the <b>expand mode</b>, which makes the table behave
+   /// much like @b EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE, except that the
+   /// bounding box will overflow and items will not overlap siblings. If
+   /// no minimum size is provided at all then the table will fallback to
+   /// expand mode as well.
+   ///
+   /// @param homogeneous 
+   ///
+   void homogeneous_set(Evas_Object_Table_Homogeneous_Mode homogeneous_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_homogeneous_set(homogeneous_));
+   }
+
+   /// @brief Get alignment of the whole bounding box of contents.
+   ///
+   /// @param horizontal 
+   /// @param vertical 
+   ///
+   void align_get(double* horizontal_, double* vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_align_get(horizontal_, vertical_));
+   }
+
+   /// @brief Set the alignment of the whole bounding box of contents.
+   ///
+   /// @param horizontal 
+   /// @param vertical 
+   ///
+   void align_set(double horizontal_, double vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_align_set(horizontal_, vertical_));
+   }
+
+   /// @brief Get padding between cells.
+   ///
+   /// @param horizontal 
+   /// @param vertical 
+   ///
+   void padding_get(Evas_Coord* horizontal_, Evas_Coord* vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_padding_get(horizontal_, vertical_));
+   }
+
+   /// @brief Set padding between cells.
+   ///
+   /// @param horizontal 
+   /// @param vertical 
+   ///
+   void padding_set(Evas_Coord horizontal_, Evas_Coord vertical_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_padding_set(horizontal_, vertical_));
+   }
+
+   /// @brief Gets the mirrored mode of the table.
+   ///
+   /// @return @c EINA_TRUE if it's a mirrored table, @c EINA_FALSE otherwise.
+   /// @since 1.1
+   /// @see evas_object_table_mirrored_set()
+   ///
+   /// @param mirrored the mirrored mode to set
+   ///
+   bool mirrored_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_mirrored_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets the mirrored mode of the table. In mirrored mode the table items go
+   /// from right to left instead of left to right. That is, 1,1 is top right, not
+   /// top left.
+   ///
+   /// @since 1.1
+   ///
+   /// @param mirrored the mirrored mode to set
+   ///
+   void mirrored_set(bool mirrored_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_mirrored_set(efl::eolian::to_c(mirrored_)));
+   }
+
+   /// @brief Get the number of columns and rows this table takes.
+   ///
+   /// @note columns and rows are virtual entities, one can specify a table
+   /// with a single object that takes 4 columns and 5 rows. The only
+   /// difference for a single cell table is that paddings will be
+   /// accounted proportionally.
+   ///
+   /// @param cols 
+   /// @param rows 
+   ///
+   void col_row_size_get(int* cols_, int* rows_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_col_row_size_get(cols_, rows_));
+   }
+
+   /// @brief Get the list of children for the table.
+   ///
+   /// @note This is a duplicate of the list kept by the table internally.
+   /// It's up to the user to destroy it when it no longer needs it.
+   /// It's possible to remove objects from the table when walking this
+   /// list, but these removals won't be reflected on it.
+   ///
+   efl::eina::list< evas::object > children_get() const
+   {
+      Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_children_get());
+      return efl::eolian::to_cxx<efl::eina::list< evas::object >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+   }
+
+   /// @brief Get the child of the table at the given coordinates
+   ///
+   /// @note This does not take into account col/row spanning
+   ///
+   /// @param child 
+   ///
+   evas::object child_get(unsigned short col_, unsigned short row_) const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_child_get(col_, row_));
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Faster way to remove all child objects from a table object.
+   ///
+   /// @param clear if true, it will delete just removed children.
+   ///
+   void clear(bool clear_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_table_clear(efl::eolian::to_c(clear_)));
+   }
+
+   /// @brief Get an accessor to get random access to the list of children for the table.
+   ///
+   /// @note Do not remove or delete objects while walking the list.
+   ///
+   Eina_Accessor * accessor_new() const
+   {
+      Eina_Accessor * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_accessor_new());
+      return _tmp_ret;
+   }
+
+   /// @brief Get an iterator to walk the list of children for the table.
+   ///
+   /// @note Do not remove or delete objects while walking the list.
+   ///
+   Eina_Iterator * iterator_new() const
+   {
+      Eina_Iterator * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_iterator_new());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Create a table that is child of a given element @a parent.
+   ///
+   /// @see evas_object_table_add()
+   ///
+   evas::object add_to() const
+   {
+      Evas_Object * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_add_to());
+      return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Get packing location of a child of table
+   ///
+   /// @return 1 on success, 0 on failure.
+   /// @since 1.1
+   ///
+   /// @param child The child object to add.
+   /// @param[out] col pointer to store relative-horizontal position to place child.
+   /// @param[out] row pointer to store relative-vertical position to place child.
+   /// @param[out] colspan pointer to store how many relative-horizontal position to use for this child.
+   /// @param[out] rowspan pointer to store how many relative-vertical position to use for this child.
+   ///
+   bool pack_get(evas::object child_, unsigned short* col_, unsigned short* row_, unsigned short* colspan_, unsigned short* rowspan_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_pack_get(efl::eolian::to_c(child_), col_, row_, colspan_, rowspan_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Add a new child to a table object or set its current packing.
+   ///
+   /// Note that columns and rows only guarantee 16bit unsigned values at best.
+   /// That means that col + colspan AND row + rowspan must fit inside 16bit
+   /// unsigned values cleanly. You will be warned once values exceed 15bit
+   /// storage, and attempting to use values not able to fit in 16bits will
+   /// result in failure.
+   ///
+   /// @return 1 on success, 0 on failure.
+   ///
+   /// @param child The child object to add.
+   /// @param col relative-horizontal position to place child.
+   /// @param row relative-vertical position to place child.
+   /// @param colspan how many relative-horizontal position to use for this child.
+   /// @param rowspan how many relative-vertical position to use for this child.
+   ///
+   bool pack(evas::object child_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_pack(efl::eolian::to_c(child_), col_, row_, colspan_, rowspan_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Remove child from table.
+   ///
+   /// @note removing a child will immediately call a walk over children in order
+   /// to recalculate numbers of columns and rows. If you plan to remove
+   /// all children, use evas_object_table_clear() instead.
+   ///
+   /// @return 1 on success, 0 on failure.
+   ///
+   /// @param child 
+   ///
+   bool unpack(evas::object child_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_table_unpack(efl::eolian::to_c(child_)));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_TABLE_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_TABLE_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_table_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->add();
+}
+
+template <typename T>
+void evas_table_del_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->del();
+}
+
+template <typename T>
+void evas_table_calculate_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->calculate();
+}
+
+template <typename T>
+void evas_table_resize_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->resize(w_, h_);
+}
+
+template <typename T>
+Evas_Object_Table_Homogeneous_Mode evas_table_homogeneous_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->homogeneous_get();
+}
+
+template <typename T>
+void evas_table_homogeneous_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Table_Homogeneous_Mode homogeneous_)
+{
+   static_cast<T*>(self->this_)->homogeneous_set(homogeneous_);
+}
+
+template <typename T>
+void evas_table_align_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double* horizontal_, double* vertical_)
+{
+   static_cast<T*>(self->this_)->align_get(horizontal_, vertical_);
+}
+
+template <typename T>
+void evas_table_align_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double horizontal_, double vertical_)
+{
+   static_cast<T*>(self->this_)->align_set(horizontal_, vertical_);
+}
+
+template <typename T>
+void evas_table_padding_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* horizontal_, Evas_Coord* vertical_)
+{
+   static_cast<T*>(self->this_)->padding_get(horizontal_, vertical_);
+}
+
+template <typename T>
+void evas_table_padding_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord horizontal_, Evas_Coord vertical_)
+{
+   static_cast<T*>(self->this_)->padding_set(horizontal_, vertical_);
+}
+
+template <typename T>
+bool evas_table_mirrored_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->mirrored_get();
+}
+
+template <typename T>
+void evas_table_mirrored_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool mirrored_)
+{
+   static_cast<T*>(self->this_)->mirrored_set(efl::eolian::to_cxx<bool>(mirrored_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_table_col_row_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* cols_, int* rows_)
+{
+   static_cast<T*>(self->this_)->col_row_size_get(cols_, rows_);
+}
+
+template <typename T>
+efl::eina::list< evas::object > evas_table_children_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->children_get();
+}
+
+template <typename T>
+evas::object evas_table_child_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, unsigned short col_, unsigned short row_)
+{
+   return static_cast<T*>(self->this_)->child_get(col_, row_);
+}
+
+template <typename T>
+void evas_table_clear_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool clear_)
+{
+   static_cast<T*>(self->this_)->clear(efl::eolian::to_cxx<bool>(clear_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Eina_Accessor * evas_table_accessor_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->accessor_new();
+}
+
+template <typename T>
+Eina_Iterator * evas_table_iterator_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->iterator_new();
+}
+
+template <typename T>
+evas::object evas_table_add_to_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->add_to();
+}
+
+template <typename T>
+bool evas_table_pack_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, unsigned short* col_, unsigned short* row_, unsigned short* colspan_, unsigned short* rowspan_)
+{
+   return static_cast<T*>(self->this_)->pack_get(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), col_, row_, colspan_, rowspan_);
+}
+
+template <typename T>
+bool evas_table_pack_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_)
+{
+   return static_cast<T*>(self->this_)->pack(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()), col_, row_, colspan_, rowspan_);
+}
+
+template <typename T>
+bool evas_table_unpack_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object * child_)
+{
+   return static_cast<T*>(self->this_)->unpack(efl::eolian::to_cxx<evas::object>(child_, std::tuple<std::false_type>()));
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::table >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void add()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_add());
+      }
+
+      virtual void del()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_del());
+      }
+
+      virtual void calculate()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_calculate());
+      }
+
+      virtual void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_smart_resize(w_, h_));
+      }
+
+      virtual Evas_Object_Table_Homogeneous_Mode homogeneous_get()
+      {
+         Evas_Object_Table_Homogeneous_Mode _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_homogeneous_get());
+            return _tmp_ret;
+      }
+
+      virtual void homogeneous_set(Evas_Object_Table_Homogeneous_Mode homogeneous_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_homogeneous_set(homogeneous_));
+      }
+
+      virtual void align_get(double* horizontal_, double* vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_align_get(horizontal_, vertical_));
+      }
+
+      virtual void align_set(double horizontal_, double vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_align_set(horizontal_, vertical_));
+      }
+
+      virtual void padding_get(Evas_Coord* horizontal_, Evas_Coord* vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_padding_get(horizontal_, vertical_));
+      }
+
+      virtual void padding_set(Evas_Coord horizontal_, Evas_Coord vertical_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_padding_set(horizontal_, vertical_));
+      }
+
+      virtual bool mirrored_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_mirrored_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void mirrored_set(bool mirrored_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_mirrored_set(efl::eolian::to_c(mirrored_)));
+      }
+
+      virtual void col_row_size_get(int* cols_, int* rows_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_col_row_size_get(cols_, rows_));
+      }
+
+      virtual efl::eina::list< evas::object > children_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_children_get());
+            return efl::eolian::to_cxx<efl::eina::list< evas::object >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+      }
+
+      virtual evas::object child_get(unsigned short col_, unsigned short row_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_child_get(col_, row_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void clear(bool clear_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_table_clear(efl::eolian::to_c(clear_)));
+      }
+
+      virtual Eina_Accessor * accessor_new()
+      {
+         Eina_Accessor * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_accessor_new());
+            return _tmp_ret;
+      }
+
+      virtual Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_iterator_new());
+            return _tmp_ret;
+      }
+
+      virtual evas::object add_to()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_add_to());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool pack_get(evas::object child_, unsigned short* col_, unsigned short* row_, unsigned short* colspan_, unsigned short* rowspan_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_pack_get(efl::eolian::to_c(child_), col_, row_, colspan_, rowspan_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool pack(evas::object child_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_pack(efl::eolian::to_c(child_), col_, row_, colspan_, rowspan_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual bool unpack(evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_table_unpack(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::table >
+{
+   static const int value = 22;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::table>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_table_add_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_add);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_table_del_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_del);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_table_calculate_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_calculate);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_table_resize_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_smart_resize);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_table_homogeneous_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_table_homogeneous_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_table_homogeneous_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_table_homogeneous_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_table_align_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_table_align_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_table_align_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_table_align_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_table_padding_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_table_padding_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_table_padding_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_table_padding_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_table_mirrored_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_table_mirrored_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_table_mirrored_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_table_mirrored_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_table_col_row_size_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_table_col_row_size_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_table_children_get_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_table_children_get);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_table_child_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_table_child_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_table_clear_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_obj_table_clear);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_table_accessor_new_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_obj_table_accessor_new);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_table_iterator_new_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_obj_table_iterator_new);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_table_add_to_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_obj_table_add_to);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_table_pack_get_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_obj_table_pack_get);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_table_pack_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_obj_table_pack);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_table_unpack_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_obj_table_unpack);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::table >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::table, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::table >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::table, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::table>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::table() const
+      {
+         return evas::table(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void add()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_add());
+      }
+
+      void del()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_del());
+      }
+
+      void calculate()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_calculate());
+      }
+
+      void resize(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_smart_resize(w_, h_));
+      }
+
+      Evas_Object_Table_Homogeneous_Mode homogeneous_get()
+      {
+         Evas_Object_Table_Homogeneous_Mode _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_homogeneous_get());
+            return _tmp_ret;
+      }
+
+      void homogeneous_set(Evas_Object_Table_Homogeneous_Mode homogeneous_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_homogeneous_set(homogeneous_));
+      }
+
+      void align_get(double* horizontal_, double* vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_align_get(horizontal_, vertical_));
+      }
+
+      void align_set(double horizontal_, double vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_align_set(horizontal_, vertical_));
+      }
+
+      void padding_get(Evas_Coord* horizontal_, Evas_Coord* vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_padding_get(horizontal_, vertical_));
+      }
+
+      void padding_set(Evas_Coord horizontal_, Evas_Coord vertical_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_padding_set(horizontal_, vertical_));
+      }
+
+      bool mirrored_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_mirrored_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void mirrored_set(bool mirrored_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_mirrored_set(efl::eolian::to_c(mirrored_)));
+      }
+
+      void col_row_size_get(int* cols_, int* rows_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_col_row_size_get(cols_, rows_));
+      }
+
+      efl::eina::list< evas::object > children_get()
+      {
+         Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_children_get());
+            return efl::eolian::to_cxx<efl::eina::list< evas::object >>(_tmp_ret, std::tuple<std::true_type, std::false_type>());
+      }
+
+      evas::object child_get(unsigned short col_, unsigned short row_)
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_child_get(col_, row_));
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void clear(bool clear_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_table_clear(efl::eolian::to_c(clear_)));
+      }
+
+      Eina_Accessor * accessor_new()
+      {
+         Eina_Accessor * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_accessor_new());
+            return _tmp_ret;
+      }
+
+      Eina_Iterator * iterator_new()
+      {
+         Eina_Iterator * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_iterator_new());
+            return _tmp_ret;
+      }
+
+      evas::object add_to()
+      {
+         Evas_Object * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_add_to());
+            return efl::eolian::to_cxx<evas::object>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool pack_get(evas::object child_, unsigned short* col_, unsigned short* row_, unsigned short* colspan_, unsigned short* rowspan_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_pack_get(efl::eolian::to_c(child_), col_, row_, colspan_, rowspan_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool pack(evas::object child_, unsigned short col_, unsigned short row_, unsigned short colspan_, unsigned short rowspan_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_pack(efl::eolian::to_c(child_), col_, row_, colspan_, rowspan_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      bool unpack(evas::object child_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_table_unpack(efl::eolian::to_c(child_)));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::table>)
+{
+   return (EVAS_TABLE_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_TABLE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_table.eo.legacy.h b/src/lib/evas/canvas/evas_table.eo.legacy.h
--- a/src/lib/evas/canvas/evas_table.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_table.eo.legacy.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,260 @@
+#ifndef _EVAS_TABLE_EO_LEGACY_H_
+#define _EVAS_TABLE_EO_LEGACY_H_
+
+#ifndef _EVAS_TABLE_EO_CLASS_TYPE
+#define _EVAS_TABLE_EO_CLASS_TYPE
+
+typedef Eo Evas_Table;
+
+#endif
+
+#ifndef _EVAS_TABLE_EO_TYPES
+#define _EVAS_TABLE_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * @brief Set how this table should layout children.
+ *
+ * @todo consider aspect hint and respect it.
+ *
+ * @par EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE
+ * If table does not use homogeneous mode then columns and rows will
+ * be calculated based on hints of individual cells. This operation
+ * mode is more flexible, but more complex and heavy to calculate as
+ * well. @b Weight properties are handled as a boolean expand. Negative
+ * alignment will be considered as 0.5. This is the default.
+ *
+ * @todo @c EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE should balance weight.
+ *
+ * @par EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE
+ * When homogeneous is relative to table the own table size is divided
+ * equally among children, filling the whole table area. That is, if
+ * table has @c WIDTH and @c COLUMNS, each cell will get <tt>WIDTH /
+ * COLUMNS</tt> pixels. If children have minimum size that is larger
+ * than this amount (including padding), then it will overflow and be
+ * aligned respecting the alignment hint, possible overlapping sibling
+ * cells. @b Weight hint is used as a boolean, if greater than zero it
+ * will make the child expand in that axis, taking as much space as
+ * possible (bounded to maximum size hint). Negative alignment will be
+ * considered as 0.5.
+ *
+ * @par EVAS_OBJECT_TABLE_HOMOGENEOUS_ITEM
+ * When homogeneous is relative to item it means the greatest minimum
+ * cell size will be used. That is, if no element is set to expand,
+ * the table will have its contents to a minimum size, the bounding
+ * box of all these children will be aligned relatively to the table
+ * object using evas_object_table_align_get(). If the table area is
+ * too small to hold this minimum bounding box, then the objects will
+ * keep their size and the bounding box will overflow the box area,
+ * still respecting the alignment. @b Weight hint is used as a
+ * boolean, if greater than zero it will make that cell expand in that
+ * axis, toggling the <b>expand mode</b>, which makes the table behave
+ * much like @b EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE, except that the
+ * bounding box will overflow and items will not overlap siblings. If
+ * no minimum size is provided at all then the table will fallback to
+ * expand mode as well.
+ *
+ * @param[in] homogeneous No description supplied.
+ */
+EAPI void evas_object_table_homogeneous_set(Evas_Table *obj, Evas_Object_Table_Homogeneous_Mode homogeneous);
+
+/**
+ *
+ * Get the current layout homogeneous mode.
+ *
+ * @see evas_object_table_homogeneous_set()
+ *
+ */
+EAPI Evas_Object_Table_Homogeneous_Mode evas_object_table_homogeneous_get(const Evas_Table *obj);
+
+/**
+ *
+ * Set the alignment of the whole bounding box of contents.
+ *
+ * @param[in] horizontal No description supplied.
+ * @param[in] vertical No description supplied.
+ */
+EAPI void evas_object_table_align_set(Evas_Table *obj, double horizontal, double vertical);
+
+/**
+ *
+ * Get alignment of the whole bounding box of contents.
+ *
+ * @param[out] horizontal No description supplied.
+ * @param[out] vertical No description supplied.
+ */
+EAPI void evas_object_table_align_get(const Evas_Table *obj, double *horizontal, double *vertical);
+
+/**
+ *
+ * Set padding between cells.
+ *
+ * @param[in] horizontal No description supplied.
+ * @param[in] vertical No description supplied.
+ */
+EAPI void evas_object_table_padding_set(Evas_Table *obj, Evas_Coord horizontal, Evas_Coord vertical);
+
+/**
+ *
+ * Get padding between cells.
+ *
+ * @param[out] horizontal No description supplied.
+ * @param[out] vertical No description supplied.
+ */
+EAPI void evas_object_table_padding_get(const Evas_Table *obj, Evas_Coord *horizontal, Evas_Coord *vertical);
+
+/**
+ *
+ * Sets the mirrored mode of the table. In mirrored mode the table items go
+ * from right to left instead of left to right. That is, 1,1 is top right, not
+ * top left.
+ *
+ * @since 1.1
+ *
+ * @param[in] mirrored the mirrored mode to set
+ */
+EAPI void evas_object_table_mirrored_set(Evas_Table *obj, Eina_Bool mirrored);
+
+/**
+ *
+ * Gets the mirrored mode of the table.
+ *
+ * @return @c EINA_TRUE if it's a mirrored table, @c EINA_FALSE otherwise.
+ * @since 1.1
+ * @see evas_object_table_mirrored_set()
+ *
+ */
+EAPI Eina_Bool evas_object_table_mirrored_get(const Evas_Table *obj);
+
+/**
+ *
+ * Get the number of columns and rows this table takes.
+ *
+ * @note columns and rows are virtual entities, one can specify a table
+ * with a single object that takes 4 columns and 5 rows. The only
+ * difference for a single cell table is that paddings will be
+ * accounted proportionally.
+ *
+ * @param[out] cols No description supplied.
+ * @param[out] rows No description supplied.
+ */
+EAPI void evas_object_table_col_row_size_get(const Evas_Table *obj, int *cols, int *rows);
+
+/**
+ *
+ * Get the list of children for the table.
+ *
+ * @note This is a duplicate of the list kept by the table internally.
+ * It's up to the user to destroy it when it no longer needs it.
+ * It's possible to remove objects from the table when walking this
+ * list, but these removals won't be reflected on it.
+ *
+ */
+EAPI Eina_List *evas_object_table_children_get(const Evas_Table *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get the child of the table at the given coordinates
+ *
+ * @note This does not take into account col/row spanning
+ *
+ * @param[in] col No description supplied.
+ * @param[in] row No description supplied.
+ */
+EAPI Evas_Object *evas_object_table_child_get(const Evas_Table *obj, unsigned short col, unsigned short row);
+
+/**
+ *
+ * Faster way to remove all child objects from a table object.
+ * 
+ *
+ * @param[in] clear if true, it will delete just removed children.
+ */
+EAPI void evas_object_table_clear(Evas_Table *obj, Eina_Bool clear);
+
+/**
+ *
+ * Get an accessor to get random access to the list of children for the table.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * 
+ *
+ */
+EAPI Eina_Accessor *evas_object_table_accessor_new(const Evas_Table *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get an iterator to walk the list of children for the table.
+ *
+ * @note Do not remove or delete objects while walking the list.
+ * 
+ *
+ */
+EAPI Eina_Iterator *evas_object_table_iterator_new(const Evas_Table *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * @brief Create a table that is child of a given element @a parent.
+ *
+ * @see evas_object_table_add()
+ * 
+ *
+ */
+EAPI Evas_Object *evas_object_table_add_to(Evas_Table *obj) EINA_WARN_UNUSED_RESULT;
+
+/**
+ *
+ * Get packing location of a child of table
+ *
+ * @return 1 on success, 0 on failure.
+ * @since 1.1
+ * 
+ *
+ * @param[in] child The child object to add.
+ * @param[out] col pointer to store relative-horizontal position to place child.
+ * @param[out] row pointer to store relative-vertical position to place child.
+ * @param[out] colspan pointer to store how many relative-horizontal position to use for this child.
+ * @param[out] rowspan pointer to store how many relative-vertical position to use for this child.
+ */
+EAPI Eina_Bool evas_object_table_pack_get(const Evas_Table *obj, Evas_Object *child, unsigned short *col, unsigned short *row, unsigned short *colspan, unsigned short *rowspan);
+
+/**
+ *
+ * Add a new child to a table object or set its current packing.
+ *
+ * Note that columns and rows only guarantee 16bit unsigned values at best.
+ * That means that col + colspan AND row + rowspan must fit inside 16bit
+ * unsigned values cleanly. You will be warned once values exceed 15bit
+ * storage, and attempting to use values not able to fit in 16bits will
+ * result in failure.
+ *
+ * @return 1 on success, 0 on failure.
+ * 
+ *
+ * @param[in] child The child object to add.
+ * @param[in] col relative-horizontal position to place child.
+ * @param[in] row relative-vertical position to place child.
+ * @param[in] colspan how many relative-horizontal position to use for this child.
+ * @param[in] rowspan how many relative-vertical position to use for this child.
+ */
+EAPI Eina_Bool evas_object_table_pack(Evas_Table *obj, Evas_Object *child, unsigned short col, unsigned short row, unsigned short colspan, unsigned short rowspan) EINA_ARG_NONNULL(2);
+
+/**
+ *
+ * Remove child from table.
+ *
+ * @note removing a child will immediately call a walk over children in order
+ * to recalculate numbers of columns and rows. If you plan to remove
+ * all children, use evas_object_table_clear() instead.
+ *
+ * @return 1 on success, 0 on failure.
+ * 
+ *
+ * @param[in] child No description supplied.
+ */
+EAPI Eina_Bool evas_object_table_unpack(Evas_Table *obj, Evas_Object *child) EINA_ARG_NONNULL(2);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_text.eo.c b/src/lib/evas/canvas/evas_text.eo.c
--- a/src/lib/evas/canvas/evas_text.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_text.eo.c	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,352 @@
+
+void _evas_text_shadow_color_set(Eo *obj, Evas_Text_Data *pd, int r, int g, int b, int a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_shadow_color_set, EO_FUNC_CALL(r, g, b, a), int r, int g, int b, int a);
+
+void _evas_text_shadow_color_get(Eo *obj, Evas_Text_Data *pd, int *r, int *g, int *b, int *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_shadow_color_get, EO_FUNC_CALL(r, g, b, a), int *r, int *g, int *b, int *a);
+
+void _evas_text_ellipsis_set(Eo *obj, Evas_Text_Data *pd, double ellipsis);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_ellipsis_set, EO_FUNC_CALL(ellipsis), double ellipsis);
+
+double _evas_text_ellipsis_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_ellipsis_get, double, 0);
+
+void _evas_text_bidi_delimiters_set(Eo *obj, Evas_Text_Data *pd, const char *delim);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_bidi_delimiters_set, EO_FUNC_CALL(delim), const char *delim);
+
+const char * _evas_text_bidi_delimiters_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_bidi_delimiters_get, const char *, 0);
+
+void _evas_text_outline_color_set(Eo *obj, Evas_Text_Data *pd, int r, int g, int b, int a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_outline_color_set, EO_FUNC_CALL(r, g, b, a), int r, int g, int b, int a);
+
+void _evas_text_outline_color_get(Eo *obj, Evas_Text_Data *pd, int *r, int *g, int *b, int *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_outline_color_get, EO_FUNC_CALL(r, g, b, a), int *r, int *g, int *b, int *a);
+
+void _evas_text_glow2_color_set(Eo *obj, Evas_Text_Data *pd, int r, int g, int b, int a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_glow2_color_set, EO_FUNC_CALL(r, g, b, a), int r, int g, int b, int a);
+
+void _evas_text_glow2_color_get(Eo *obj, Evas_Text_Data *pd, int *r, int *g, int *b, int *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_glow2_color_get, EO_FUNC_CALL(r, g, b, a), int *r, int *g, int *b, int *a);
+
+void _evas_text_style_set(Eo *obj, Evas_Text_Data *pd, Evas_Text_Style_Type style);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_style_set, EO_FUNC_CALL(style), Evas_Text_Style_Type style);
+
+Evas_Text_Style_Type _evas_text_style_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_style_get, Evas_Text_Style_Type, 0);
+
+void _evas_text_glow_color_set(Eo *obj, Evas_Text_Data *pd, int r, int g, int b, int a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_glow_color_set, EO_FUNC_CALL(r, g, b, a), int r, int g, int b, int a);
+
+void _evas_text_glow_color_get(Eo *obj, Evas_Text_Data *pd, int *r, int *g, int *b, int *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_glow_color_get, EO_FUNC_CALL(r, g, b, a), int *r, int *g, int *b, int *a);
+
+void _evas_text_filter_program_set(Eo *obj, Evas_Text_Data *pd, const char *program);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_filter_program_set, EO_FUNC_CALL(program), const char *program);
+
+void _evas_text_filter_source_set(Eo *obj, Evas_Text_Data *pd, const char *name, Eo *eobj);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_filter_source_set, EO_FUNC_CALL(name, eobj), const char *name, Eo *eobj);
+
+Evas_Coord _evas_text_max_descent_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_max_descent_get, Evas_Coord, 0);
+
+void _evas_text_style_pad_get(Eo *obj, Evas_Text_Data *pd, int *l, int *r, int *t, int *b);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_text_style_pad_get, EO_FUNC_CALL(l, r, t, b), int *l, int *r, int *t, int *b);
+
+Evas_BiDi_Direction _evas_text_direction_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_direction_get, Evas_BiDi_Direction, 0);
+
+Evas_Coord _evas_text_ascent_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_ascent_get, Evas_Coord, 0);
+
+Evas_Coord _evas_text_horiz_advance_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_horiz_advance_get, Evas_Coord, 0);
+
+Evas_Coord _evas_text_inset_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_inset_get, Evas_Coord, 0);
+
+Evas_Coord _evas_text_max_ascent_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_max_ascent_get, Evas_Coord, 0);
+
+Evas_Coord _evas_text_vert_advance_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_vert_advance_get, Evas_Coord, 0);
+
+Evas_Coord _evas_text_descent_get(Eo *obj, Evas_Text_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_text_descent_get, Evas_Coord, 0);
+
+int _evas_text_last_up_to_pos(Eo *obj, Evas_Text_Data *pd, Evas_Coord x, Evas_Coord y);
+
+EOAPI EO_FUNC_BODYV(evas_obj_text_last_up_to_pos, int, 0, EO_FUNC_CALL(x, y), Evas_Coord x, Evas_Coord y);
+
+int _evas_text_char_coords_get(Eo *obj, Evas_Text_Data *pd, Evas_Coord x, Evas_Coord y, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+EOAPI EO_FUNC_BODYV(evas_obj_text_char_coords_get, int, 0, EO_FUNC_CALL(x, y, cx, cy, cw, ch), Evas_Coord x, Evas_Coord y, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+Eina_Bool _evas_text_char_pos_get(Eo *obj, Evas_Text_Data *pd, int pos, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+EOAPI EO_FUNC_BODYV(evas_obj_text_char_pos_get, Eina_Bool, 0, EO_FUNC_CALL(pos, cx, cy, cw, ch), int pos, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+void _evas_text_eo_base_constructor(Eo *obj, Evas_Text_Data *pd);
+
+
+void _evas_text_eo_base_destructor(Eo *obj, Evas_Text_Data *pd);
+
+
+void _evas_text_eo_base_dbg_info_get(Eo *obj, Evas_Text_Data *pd, Eo_Dbg_Info *root_node);
+
+
+void _evas_text_evas_object_size_set(Eo *obj, Evas_Text_Data *pd, Evas_Coord w, Evas_Coord h);
+
+
+void _evas_text_efl_text_text_set(Eo *obj, Evas_Text_Data *pd, const char *text);
+
+
+const char * _evas_text_efl_text_text_get(Eo *obj, Evas_Text_Data *pd);
+
+
+void _evas_text_efl_text_properties_font_get(Eo *obj, Evas_Text_Data *pd, const char **font, Efl_Font_Size *size);
+
+
+void _evas_text_efl_text_properties_font_set(Eo *obj, Evas_Text_Data *pd, const char *font, Efl_Font_Size size);
+
+
+const char * _evas_text_efl_text_properties_font_source_get(Eo *obj, Evas_Text_Data *pd);
+
+
+void _evas_text_efl_text_properties_font_source_set(Eo *obj, Evas_Text_Data *pd, const char *font_source);
+
+
+static Eo_Op_Description _evas_text_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_text_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_text_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_dbg_info_get, _evas_text_eo_base_dbg_info_get),
+     EO_OP_FUNC_OVERRIDE(evas_obj_size_set, _evas_text_evas_object_size_set),
+     EO_OP_FUNC_OVERRIDE(efl_text_set, _evas_text_efl_text_text_set),
+     EO_OP_FUNC_OVERRIDE(efl_text_get, _evas_text_efl_text_text_get),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_get, _evas_text_efl_text_properties_font_get),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_set, _evas_text_efl_text_properties_font_set),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_source_get, _evas_text_efl_text_properties_font_source_get),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_source_set, _evas_text_efl_text_properties_font_source_set),
+     EO_OP_FUNC(evas_obj_text_shadow_color_set, _evas_text_shadow_color_set, "Sets the shadow color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_shadow_color_get, _evas_text_shadow_color_get, "Retrieves the shadow color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_ellipsis_set, _evas_text_ellipsis_set, "@brief Sets the ellipsis that should be used for the text object."),
+     EO_OP_FUNC(evas_obj_text_ellipsis_get, _evas_text_ellipsis_get, "@brief Gets the ellipsis currently set on the text object."),
+     EO_OP_FUNC(evas_obj_text_bidi_delimiters_set, _evas_text_bidi_delimiters_set, "@brief Sets the BiDi delimiters used in the textblock."),
+     EO_OP_FUNC(evas_obj_text_bidi_delimiters_get, _evas_text_bidi_delimiters_get, "@brief Gets the BiDi delimiters used in the textblock."),
+     EO_OP_FUNC(evas_obj_text_outline_color_set, _evas_text_outline_color_set, "Sets the outline color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_outline_color_get, _evas_text_outline_color_get, "Retrieves the outline color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_glow2_color_set, _evas_text_glow2_color_set, "Sets the 'glow 2' color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_glow2_color_get, _evas_text_glow2_color_get, "Retrieves the 'glow 2' color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_style_set, _evas_text_style_set, "Sets the style to apply on the given text object."),
+     EO_OP_FUNC(evas_obj_text_style_get, _evas_text_style_get, "Retrieves the style on use on the given text object."),
+     EO_OP_FUNC(evas_obj_text_glow_color_set, _evas_text_glow_color_set, "Sets the glow color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_glow_color_get, _evas_text_glow_color_get, "Retrieves the glow color for the given text object."),
+     EO_OP_FUNC(evas_obj_text_filter_program_set, _evas_text_filter_program_set, "Set an Evas filter program on this Text Object."),
+     EO_OP_FUNC(evas_obj_text_filter_source_set, _evas_text_filter_source_set, "Bind an object to use as a mask or texture with Evas Filters."),
+     EO_OP_FUNC(evas_obj_text_max_descent_get, _evas_text_max_descent_get, ""),
+     EO_OP_FUNC(evas_obj_text_style_pad_get, _evas_text_style_pad_get, "Gets the text style pad of a text object."),
+     EO_OP_FUNC(evas_obj_text_direction_get, _evas_text_direction_get, "Retrieves the direction of the text currently being displayed in the"),
+     EO_OP_FUNC(evas_obj_text_ascent_get, _evas_text_ascent_get, ""),
+     EO_OP_FUNC(evas_obj_text_horiz_advance_get, _evas_text_horiz_advance_get, ""),
+     EO_OP_FUNC(evas_obj_text_inset_get, _evas_text_inset_get, ""),
+     EO_OP_FUNC(evas_obj_text_max_ascent_get, _evas_text_max_ascent_get, ""),
+     EO_OP_FUNC(evas_obj_text_vert_advance_get, _evas_text_vert_advance_get, ""),
+     EO_OP_FUNC(evas_obj_text_descent_get, _evas_text_descent_get, ""),
+     EO_OP_FUNC(evas_obj_text_last_up_to_pos, _evas_text_last_up_to_pos, "Returns the logical position of the last char in the text up to the pos given. this is NOT the position of the last char because of the possibility of RTL in the text."),
+     EO_OP_FUNC(evas_obj_text_char_coords_get, _evas_text_char_coords_get, ""),
+     EO_OP_FUNC(evas_obj_text_char_pos_get, _evas_text_char_pos_get, "Retrieve position and dimension information of a character within a text @c Evas_Object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_text_class_desc = {
+     EO_VERSION,
+     "Evas_Text",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_text_op_desc),
+     NULL,
+     sizeof(Evas_Text_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_text_class_get, &_evas_text_class_desc, EVAS_OBJECT_CLASS, EFL_TEXT_INTERFACE, EFL_TEXT_PROPERTIES_INTERFACE, NULL);
+EAPI void
+evas_object_text_shadow_color_set(Evas_Text *obj, int r, int g, int b, int a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_shadow_color_set(r, g, b, a));
+}
+
+EAPI void
+evas_object_text_shadow_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_shadow_color_get(r, g, b, a));
+}
+
+EAPI void
+evas_object_text_ellipsis_set(Evas_Text *obj, double ellipsis)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_ellipsis_set(ellipsis));
+}
+
+EAPI double
+evas_object_text_ellipsis_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_ellipsis_get());
+}
+
+EAPI void
+evas_object_text_bidi_delimiters_set(Evas_Text *obj, const char *delim)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_bidi_delimiters_set(delim));
+}
+
+EAPI const char *
+evas_object_text_bidi_delimiters_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_bidi_delimiters_get());
+}
+
+EAPI void
+evas_object_text_outline_color_set(Evas_Text *obj, int r, int g, int b, int a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_outline_color_set(r, g, b, a));
+}
+
+EAPI void
+evas_object_text_outline_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_outline_color_get(r, g, b, a));
+}
+
+EAPI void
+evas_object_text_glow2_color_set(Evas_Text *obj, int r, int g, int b, int a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_glow2_color_set(r, g, b, a));
+}
+
+EAPI void
+evas_object_text_glow2_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_glow2_color_get(r, g, b, a));
+}
+
+EAPI void
+evas_object_text_style_set(Evas_Text *obj, Evas_Text_Style_Type style)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_style_set(style));
+}
+
+EAPI Evas_Text_Style_Type
+evas_object_text_style_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_style_get());
+}
+
+EAPI void
+evas_object_text_glow_color_set(Evas_Text *obj, int r, int g, int b, int a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_glow_color_set(r, g, b, a));
+}
+
+EAPI void
+evas_object_text_glow_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_glow_color_get(r, g, b, a));
+}
+
+EAPI Evas_Coord
+evas_object_text_max_descent_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_max_descent_get());
+}
+
+EAPI void
+evas_object_text_style_pad_get(const Evas_Text *obj, int *l, int *r, int *t, int *b)
+{
+   eo_do((Evas_Text *)obj, evas_obj_text_style_pad_get(l, r, t, b));
+}
+
+EAPI Evas_BiDi_Direction
+evas_object_text_direction_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_direction_get());
+}
+
+EAPI Evas_Coord
+evas_object_text_ascent_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_ascent_get());
+}
+
+EAPI Evas_Coord
+evas_object_text_horiz_advance_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_horiz_advance_get());
+}
+
+EAPI Evas_Coord
+evas_object_text_inset_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_inset_get());
+}
+
+EAPI Evas_Coord
+evas_object_text_max_ascent_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_max_ascent_get());
+}
+
+EAPI Evas_Coord
+evas_object_text_vert_advance_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_vert_advance_get());
+}
+
+EAPI Evas_Coord
+evas_object_text_descent_get(const Evas_Text *obj)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_descent_get());
+}
+
+EAPI int
+evas_object_text_last_up_to_pos(const Evas_Text *obj, Evas_Coord x, Evas_Coord y)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_last_up_to_pos(x, y));
+}
+
+EAPI int
+evas_object_text_char_coords_get(const Evas_Text *obj, Evas_Coord x, Evas_Coord y, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_char_coords_get(x, y, cx, cy, cw, ch));
+}
+
+EAPI Eina_Bool
+evas_object_text_char_pos_get(const Evas_Text *obj, int pos, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch)
+{
+   return eo_do((Evas_Text *)obj, evas_obj_text_char_pos_get(pos, cx, cy, cw, ch));
+}
diff -Naur a/src/lib/evas/canvas/evas_text.eo.h b/src/lib/evas/canvas/evas_text.eo.h
--- a/src/lib/evas/canvas/evas_text.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_text.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,446 @@
+#ifndef _EVAS_TEXT_EO_H_
+#define _EVAS_TEXT_EO_H_
+
+#ifndef _EVAS_TEXT_EO_CLASS_TYPE
+#define _EVAS_TEXT_EO_CLASS_TYPE
+
+typedef Eo Evas_Text;
+
+#endif
+
+#ifndef _EVAS_TEXT_EO_TYPES
+#define _EVAS_TEXT_EO_TYPES
+
+
+#endif
+#define EVAS_TEXT_CLASS evas_text_class_get()
+
+const Eo_Class *evas_text_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Sets the shadow color for the given text object.
+ *
+ * Shadow effects, which are fading colors decorating the text
+ * underneath it, will just be shown if the object is set to one of
+ * the following styles:
+ *
+ * - #EVAS_TEXT_STYLE_SHADOW
+ * - #EVAS_TEXT_STYLE_OUTLINE_SHADOW
+ * - #EVAS_TEXT_STYLE_FAR_SHADOW
+ * - #EVAS_TEXT_STYLE_OUTLINE_SOFT_SHADOW
+ * - #EVAS_TEXT_STYLE_SOFT_SHADOW
+ * - #EVAS_TEXT_STYLE_FAR_SOFT_SHADOW
+ *
+ * One can also change the direction where the shadow grows to, with
+ * evas_object_text_style_set().
+ *
+ * @see evas_object_text_shadow_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_shadow_color_set(int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the shadow color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_shadow_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_shadow_color_get(int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * @brief Sets the ellipsis that should be used for the text object.
+ *
+ * This is a value between 0.0 and 1.0 indicating the position of the text
+ * to be shown. 0.0 means the start will be shown and the end trimmed, 1.0
+ * means the beginning will be trimmed and the end will be shown, and any value
+ * in between will cause ellipsis to be added in both end of the text and the
+ * requested part to be shown.
+ * -1.0 means ellipsis is turned off.
+ *
+ * @since 1.8
+ *
+ * @param[in] ellipsis the ellipsis.
+ *
+ */
+EOAPI void  evas_obj_text_ellipsis_set(double ellipsis);
+
+/**
+ *
+ * @brief Gets the ellipsis currently set on the text object.
+ *
+ * @return The ellipsis set on the text object.
+ * @see evas_object_text_ellipsis_set.
+ * @since 1.8
+ *
+ *
+ */
+EOAPI double  evas_obj_text_ellipsis_get(void);
+
+/**
+ *
+ * @brief Sets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @since 1.1
+ *
+ * @param[in] delim A null terminated string of delimiters, e.g ",|".
+ *
+ */
+EOAPI void  evas_obj_text_bidi_delimiters_set(const char *delim);
+
+/**
+ *
+ * @brief Gets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @return A null terminated string of delimiters, e.g ",|". If empty, returns NULL.
+ * @since 1.1
+ *
+ *
+ */
+EOAPI const char * evas_obj_text_bidi_delimiters_get(void);
+
+/**
+ *
+ * Sets the outline color for the given text object.
+ *
+ * Outline effects (colored lines around text glyphs) will just be
+ * shown if the object is set to one of the following styles:
+ * - #EVAS_TEXT_STYLE_OUTLINE
+ * - #EVAS_TEXT_STYLE_SOFT_OUTLINE
+ * - #EVAS_TEXT_STYLE_OUTLINE_SHADOW
+ * - #EVAS_TEXT_STYLE_OUTLINE_SOFT_SHADOW
+ *
+ * @see evas_object_text_outline_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_outline_color_set(int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the outline color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_outline_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_outline_color_get(int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * Sets the 'glow 2' color for the given text object.
+ *
+ * 'Glow 2' effects, which are glowing colors decorating the text's
+ * (immediate) surroundings, will just be shown if the object is set
+ * to the #EVAS_TEXT_STYLE_GLOW style. See also
+ * evas_object_text_glow_color_set().
+ *
+ * @see evas_object_text_glow2_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_glow2_color_set(int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the 'glow 2' color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_glow2_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_glow2_color_get(int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * Sets the style to apply on the given text object.
+ *
+ * Text object styles are one of the values in
+ * #Evas_Text_Style_Type. Some of those values are combinations of
+ * more than one style, and some account for the direction of the
+ * rendering of shadow effects.
+ *
+ * @note One may use the helper macros #EVAS_TEXT_STYLE_BASIC_SET and
+ * #EVAS_TEXT_STYLE_SHADOW_DIRECTION_SET to assemble a style value.
+ *
+ * The following figure illustrates the text styles:
+ *
+ * @image html text-styles.png
+ * @image rtf text-styles.png
+ * @image latex text-styles.eps
+ *
+ * @see evas_object_text_style_get()
+ * @see evas_object_text_shadow_color_set()
+ * @see evas_object_text_outline_color_set()
+ * @see evas_object_text_glow_color_set()
+ * @see evas_object_text_glow2_color_set()
+ *
+ * @param[in] style a style type.
+ *
+ */
+EOAPI void  evas_obj_text_style_set(Evas_Text_Style_Type style);
+
+/**
+ *
+ * Retrieves the style on use on the given text object.
+ *
+ * @return the style type in use.
+ *
+ * @see evas_object_text_style_set() for more details.
+ *
+ *
+ */
+EOAPI Evas_Text_Style_Type  evas_obj_text_style_get(void);
+
+/**
+ *
+ * Sets the glow color for the given text object.
+ *
+ * Glow effects, which are glowing colors decorating the text's
+ * surroundings, will just be shown if the object is set to the
+ * #EVAS_TEXT_STYLE_GLOW style.
+ *
+ * @note Glow effects are placed from a short distance of the text
+ * itself, but no touching it. For glowing effects right on the
+ * borders of the glyphs, see 'glow 2' effects
+ * (evas_object_text_glow2_color_set()).
+ *
+ * @see evas_object_text_glow_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_glow_color_set(int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the glow color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_glow_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ *
+ */
+EOAPI void  evas_obj_text_glow_color_get(int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * Set an Evas filter program on this Text Object.
+ *
+ * If the program fails to compile (syntax error, invalid
+ * buffer name, etc...), the standard text effects will be
+ * applied instead (SHADOW, etc...). switch back to the
+ * standard text effects.
+ *
+ * @since 1.9
+ * @note EXPERIMENTAL FEATURE. This is an unstable API,
+ * please use only for testing purposes.
+ * @see @ref evasfiltersref "Evas filters reference"
+ *
+ * @param[in] program The program code, as defined
+by the @ref evasfiltersref "Evas filters script language".
+Pass NULL to remove the former program and switch back
+to the standard text effect
+ *
+ */
+EOAPI void  evas_obj_text_filter_program_set(const char *program);
+
+/**
+ *
+ * Bind an object to use as a mask or texture with Evas Filters.
+ *
+ * This will create automatically a new RGBA buffer containing
+ * the source object's pixels (as it is rendered).
+ *
+ * @since 1.9
+ * @note EXPERIMENTAL FEATURE. This is an unstable API,
+ * please use only for testing purposes.
+ * @see @ref evasfiltersref "Evas filters reference"
+ *
+ * @param[in] name Object name as used in the program code
+ * @param[in] eobj Eo object to use through proxy rendering
+ *
+ */
+EOAPI void  evas_obj_text_filter_source_set(const char *name, Eo *eobj);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Coord  evas_obj_text_max_descent_get(void);
+
+/**
+ *
+ * Gets the text style pad of a text object.
+ *
+ * @param[out] l The left pad (or @c NULL).
+ * @param[out] r The right pad (or @c NULL).
+ * @param[out] t The top pad (or @c NULL).
+ * @param[out] b The bottom pad (or @c NULL).
+ *
+ */
+EOAPI void  evas_obj_text_style_pad_get(int *l, int *r, int *t, int *b);
+
+/**
+ *
+ * Retrieves the direction of the text currently being displayed in the
+ * text object.
+ * @return the direction of the text
+ *
+ *
+ */
+EOAPI Evas_BiDi_Direction  evas_obj_text_direction_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Coord  evas_obj_text_ascent_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Coord  evas_obj_text_horiz_advance_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Coord  evas_obj_text_inset_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Coord  evas_obj_text_max_ascent_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Coord  evas_obj_text_vert_advance_get(void);
+
+/**
+ *
+ * No description supplied.
+ *
+ *
+ */
+EOAPI Evas_Coord  evas_obj_text_descent_get(void);
+
+/**
+ *
+ * Returns the logical position of the last char in the text up to the pos given. this is NOT the position of the last char because of the possibility of RTL in the text.
+ * 
+ *
+ * @param[in] x in
+ * @param[in] y in
+ *
+ */
+EOAPI int  evas_obj_text_last_up_to_pos(Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x in
+ * @param[in] y in
+ * @param[out] cx out
+ * @param[out] cy out
+ * @param[out] cw out
+ * @param[out] ch out
+ *
+ */
+EOAPI int  evas_obj_text_char_coords_get(Evas_Coord x, Evas_Coord y, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+/**
+ *
+ * Retrieve position and dimension information of a character within a text @c Evas_Object.
+ *
+ * This function is used to obtain the X, Y, width and height of the character
+ * located at @p pos within the @c Evas_Object @p obj. @p obj must be a text object
+ * as created with evas_object_text_add(). Any of the @c Evas_Coord parameters (@p cx,
+ * @p cy, @p cw, @p ch) may be @c NULL in which case no value will be assigned to that
+ * parameter.
+ *
+ * @return @c EINA_FALSE on success, @c EINA_TRUE on error.
+ * 
+ *
+ * @param[in] pos The character position to request co-ordinates for.
+ * @param[out] cx A pointer to an @c Evas_Coord to store the X value in (can be NULL).
+ * @param[out] cy A pointer to an @c Evas_Coord to store the Y value in (can be NULL).
+ * @param[out] cw A pointer to an @c Evas_Coord to store the Width value in (can be NULL).
+ * @param[out] ch A pointer to an @c Evas_Coord to store the Height value in (can be NULL).
+ *
+ */
+EOAPI Eina_Bool  evas_obj_text_char_pos_get(int pos, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_text.eo.hh b/src/lib/evas/canvas/evas_text.eo.hh
--- a/src/lib/evas/canvas/evas_text.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_text.eo.hh	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,1615 @@
+#ifndef EFL_GENERATED_EVAS_TEXT_HH
+#define EFL_GENERATED_EVAS_TEXT_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_text.eo.h"
+}
+
+#include "evas_object.eo.hh"
+#include "efl_text.eo.hh"
+#include "efl_text_properties.eo.hh"
+#include <eo_base.hh>
+#include <string>
+
+namespace evas {
+
+struct text
+      : evas::object,
+      efl::eo::detail::extension_inheritance<efl::text>::template type< ::evas::text>,
+      efl::eo::detail::extension_inheritance<efl::text_properties>::template type< ::evas::text>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit text(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit text(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   text(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : text(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   text(text const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~text() {}
+
+   /// @brief Get dbg information from the object.
+   ///
+   /// @param root_node node of the tree
+   ///
+   void dbg_info_get(Eo_Dbg_Info * root_node_) const
+   {
+      eo_do(_eo_ptr(), ::eo_dbg_info_get(root_node_));
+   }
+
+   /// @brief Changes the size of the given Evas object.
+   ///
+   /// @param w in
+   /// @param h in
+   ///
+   void size_set(Evas_Coord w_, Evas_Coord h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_size_set(w_, h_));
+   }
+
+   /// @brief Sets the text string to be displayed by the given text object.
+   ///
+   /// @see evas_object_text_text_get()
+   ///
+   /// @param text Text string to display on it.
+   ///
+   void text_set(std::string text_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_set(efl::eolian::to_c(text_)));
+   }
+
+   /// @brief Retrieves the text string currently being displayed by the given
+   /// text object.
+   ///
+   /// @return The text string currently being displayed on it.
+   ///
+   /// @note Do not free() the return value.
+   ///
+   /// @see evas_object_text_text_set()
+   ///
+   /// @param text Text string to display on it.
+   ///
+   std::string text_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_text_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Retrieve the font family and size in use on a given text object.
+   ///
+   /// This function allows the font name and size of a text object to be
+   /// queried. Be aware that the font name string is still owned by Evas
+   /// and should @b not have free() called on it by the caller of the
+   /// function.
+   ///
+   /// @see evas_object_text_font_set()
+   ///
+   /// @param font The font family name or filename.
+   /// @param size The font size, in points.
+   ///
+   void font_get(const char ** font_, Efl_Font_Size* size_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_get(font_, size_));
+   }
+
+   /// @brief Set the font family or filename, and size on a given text object.
+   ///
+   /// This function allows the font name and size of a text object to be
+   /// set. The @p font string has to follow fontconfig's convention on
+   /// naming fonts, as it's the underlying library used to query system
+   /// fonts by Evas (see the @c fc-list command's output, on your system,
+   /// to get an idea). Alternatively, one can use a full path to a font file.
+   ///
+   /// @see evas_object_text_font_get()
+   /// @see evas_object_text_font_source_set()
+   ///
+   /// @param font The font family name or filename.
+   /// @param size The font size, in points.
+   ///
+   void font_set(std::string font_, Efl_Font_Size size_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+   }
+
+   /// @brief Get the font file's path which is being used on a given text
+   /// object.
+   ///
+   /// @return The font file's path.
+   ///
+   /// @see evas_object_text_font_get() for more details
+   ///
+   /// @param font_source The font file's path.
+   ///
+   std::string font_source_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_text_properties_font_source_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the font (source) file to be used on a given text object.
+   ///
+   /// This function allows the font file to be explicitly set for a given
+   /// text object, overriding system lookup, which will first occur in
+   /// the given file's contents.
+   ///
+   /// @see evas_object_text_font_get()
+   ///
+   /// @param font_source The font file's path.
+   ///
+   void font_source_set(std::string font_source_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+   }
+
+   /// @brief Retrieves the shadow color for the given text object.
+   ///
+   /// @note Use @c NULL pointers on the color components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_text_shadow_color_set() for more details.
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void shadow_color_get(int* r_, int* g_, int* b_, int* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_shadow_color_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Sets the shadow color for the given text object.
+   ///
+   /// Shadow effects, which are fading colors decorating the text
+   /// underneath it, will just be shown if the object is set to one of
+   /// the following styles:
+   ///
+   /// - #EVAS_TEXT_STYLE_SHADOW
+   /// - #EVAS_TEXT_STYLE_OUTLINE_SHADOW
+   /// - #EVAS_TEXT_STYLE_FAR_SHADOW
+   /// - #EVAS_TEXT_STYLE_OUTLINE_SOFT_SHADOW
+   /// - #EVAS_TEXT_STYLE_SOFT_SHADOW
+   /// - #EVAS_TEXT_STYLE_FAR_SOFT_SHADOW
+   ///
+   /// One can also change the direction where the shadow grows to, with
+   /// evas_object_text_style_set().
+   ///
+   /// @see evas_object_text_shadow_color_get()
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void shadow_color_set(int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_shadow_color_set(r_, g_, b_, a_));
+   }
+
+   /// @brief @brief Gets the ellipsis currently set on the text object.
+   ///
+   /// @return The ellipsis set on the text object.
+   /// @see evas_object_text_ellipsis_set.
+   /// @since 1.8
+   ///
+   /// @param ellipsis the ellipsis.
+   ///
+   double ellipsis_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_ellipsis_get());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Sets the ellipsis that should be used for the text object.
+   ///
+   /// This is a value between 0.0 and 1.0 indicating the position of the text
+   /// to be shown. 0.0 means the start will be shown and the end trimmed, 1.0
+   /// means the beginning will be trimmed and the end will be shown, and any value
+   /// in between will cause ellipsis to be added in both end of the text and the
+   /// requested part to be shown.
+   /// -1.0 means ellipsis is turned off.
+   ///
+   /// @since 1.8
+   ///
+   /// @param ellipsis the ellipsis.
+   ///
+   void ellipsis_set(double ellipsis_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_ellipsis_set(ellipsis_));
+   }
+
+   /// @brief @brief Gets the BiDi delimiters used in the textblock.
+   ///
+   /// BiDi delimiters are use for in-paragraph separation of bidi segments. This
+   /// is useful for example in recipients fields of e-mail clients where bidi
+   /// oddities can occur when mixing RTL and LTR.
+   ///
+   /// @return A null terminated string of delimiters, e.g ",|". If empty, returns NULL.
+   /// @since 1.1
+   ///
+   /// @param delim A null terminated string of delimiters, e.g ",|".
+   ///
+   std::string bidi_delimiters_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_bidi_delimiters_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Sets the BiDi delimiters used in the textblock.
+   ///
+   /// BiDi delimiters are use for in-paragraph separation of bidi segments. This
+   /// is useful for example in recipients fields of e-mail clients where bidi
+   /// oddities can occur when mixing RTL and LTR.
+   ///
+   /// @since 1.1
+   ///
+   /// @param delim A null terminated string of delimiters, e.g ",|".
+   ///
+   void bidi_delimiters_set(std::string delim_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_bidi_delimiters_set(efl::eolian::to_c(delim_)));
+   }
+
+   /// @brief Retrieves the outline color for the given text object.
+   ///
+   /// @note Use @c NULL pointers on the color components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_text_outline_color_set() for more details.
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void outline_color_get(int* r_, int* g_, int* b_, int* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_outline_color_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Sets the outline color for the given text object.
+   ///
+   /// Outline effects (colored lines around text glyphs) will just be
+   /// shown if the object is set to one of the following styles:
+   /// - #EVAS_TEXT_STYLE_OUTLINE
+   /// - #EVAS_TEXT_STYLE_SOFT_OUTLINE
+   /// - #EVAS_TEXT_STYLE_OUTLINE_SHADOW
+   /// - #EVAS_TEXT_STYLE_OUTLINE_SOFT_SHADOW
+   ///
+   /// @see evas_object_text_outline_color_get()
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void outline_color_set(int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_outline_color_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Retrieves the 'glow 2' color for the given text object.
+   ///
+   /// @note Use @c NULL pointers on the color components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_text_glow2_color_set() for more details.
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void glow2_color_get(int* r_, int* g_, int* b_, int* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_glow2_color_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Sets the 'glow 2' color for the given text object.
+   ///
+   /// 'Glow 2' effects, which are glowing colors decorating the text's
+   /// (immediate) surroundings, will just be shown if the object is set
+   /// to the #EVAS_TEXT_STYLE_GLOW style. See also
+   /// evas_object_text_glow_color_set().
+   ///
+   /// @see evas_object_text_glow2_color_get()
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void glow2_color_set(int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_glow2_color_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Retrieves the style on use on the given text object.
+   ///
+   /// @return the style type in use.
+   ///
+   /// @see evas_object_text_style_set() for more details.
+   ///
+   /// @param style a style type.
+   ///
+   Evas_Text_Style_Type style_get() const
+   {
+      Evas_Text_Style_Type _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_style_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Sets the style to apply on the given text object.
+   ///
+   /// Text object styles are one of the values in
+   /// #Evas_Text_Style_Type. Some of those values are combinations of
+   /// more than one style, and some account for the direction of the
+   /// rendering of shadow effects.
+   ///
+   /// @note One may use the helper macros #EVAS_TEXT_STYLE_BASIC_SET and
+   /// #EVAS_TEXT_STYLE_SHADOW_DIRECTION_SET to assemble a style value.
+   ///
+   /// The following figure illustrates the text styles:
+   ///
+   /// @image html text-styles.png
+   /// @image rtf text-styles.png
+   /// @image latex text-styles.eps
+   ///
+   /// @see evas_object_text_style_get()
+   /// @see evas_object_text_shadow_color_set()
+   /// @see evas_object_text_outline_color_set()
+   /// @see evas_object_text_glow_color_set()
+   /// @see evas_object_text_glow2_color_set()
+   ///
+   /// @param style a style type.
+   ///
+   void style_set(Evas_Text_Style_Type style_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_style_set(style_));
+   }
+
+   /// @brief Retrieves the glow color for the given text object.
+   ///
+   /// @note Use @c NULL pointers on the color components you're not
+   /// interested in: they'll be ignored by the function.
+   ///
+   /// @see evas_object_text_glow_color_set() for more details.
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void glow_color_get(int* r_, int* g_, int* b_, int* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_glow_color_get(r_, g_, b_, a_));
+   }
+
+   /// @brief Sets the glow color for the given text object.
+   ///
+   /// Glow effects, which are glowing colors decorating the text's
+   /// surroundings, will just be shown if the object is set to the
+   /// #EVAS_TEXT_STYLE_GLOW style.
+   ///
+   /// @note Glow effects are placed from a short distance of the text
+   /// itself, but no touching it. For glowing effects right on the
+   /// borders of the glyphs, see 'glow 2' effects
+   /// (evas_object_text_glow2_color_set()).
+   ///
+   /// @see evas_object_text_glow_color_get()
+   ///
+   /// @param r The red component of the given color.
+   /// @param g The green component of the given color.
+   /// @param b The blue component of the given color.
+   /// @param a The alpha component of the given color.
+   ///
+   void glow_color_set(int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_glow_color_set(r_, g_, b_, a_));
+   }
+
+   /// @brief Set an Evas filter program on this Text Object.
+   ///
+   /// If the program fails to compile (syntax error, invalid
+   /// buffer name, etc...), the standard text effects will be
+   /// applied instead (SHADOW, etc...). switch back to the
+   /// standard text effects.
+   ///
+   /// @since 1.9
+   /// @note EXPERIMENTAL FEATURE. This is an unstable API,
+   /// please use only for testing purposes.
+   /// @see @ref evasfiltersref "Evas filters reference"
+   ///
+   /// @param program The program code, as defined
+   /// by the @ref evasfiltersref "Evas filters script language".
+   /// Pass NULL to remove the former program and switch back
+   /// to the standard text effect
+   ///
+   void filter_program_set(std::string program_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_filter_program_set(efl::eolian::to_c(program_)));
+   }
+
+   /// @brief Bind an object to use as a mask or texture with Evas Filters.
+   ///
+   /// This will create automatically a new RGBA buffer containing
+   /// the source object's pixels (as it is rendered).
+   ///
+   /// @since 1.9
+   /// @note EXPERIMENTAL FEATURE. This is an unstable API,
+   /// please use only for testing purposes.
+   /// @see @ref evasfiltersref "Evas filters reference"
+   ///
+   /// @param name Object name as used in the program code
+   /// @param eobj Eo object to use through proxy rendering
+   ///
+   void filter_source_set(std::string name_, efl::eo::base eobj_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_filter_source_set(efl::eolian::to_c(name_), efl::eolian::to_c(eobj_)));
+   }
+
+   Evas_Coord max_descent_get() const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_max_descent_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Gets the text style pad of a text object.
+   ///
+   /// @param l The left pad (or @c NULL).
+   /// @param r The right pad (or @c NULL).
+   /// @param t The top pad (or @c NULL).
+   /// @param b The bottom pad (or @c NULL).
+   ///
+   void style_pad_get(int* l_, int* r_, int* t_, int* b_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_text_style_pad_get(l_, r_, t_, b_));
+   }
+
+   /// @brief Retrieves the direction of the text currently being displayed in the
+   /// text object.
+   /// @return the direction of the text
+   ///
+   Evas_BiDi_Direction direction_get() const
+   {
+      Evas_BiDi_Direction _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_direction_get());
+      return _tmp_ret;
+   }
+
+   Evas_Coord ascent_get() const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_ascent_get());
+      return _tmp_ret;
+   }
+
+   Evas_Coord horiz_advance_get() const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_horiz_advance_get());
+      return _tmp_ret;
+   }
+
+   Evas_Coord inset_get() const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_inset_get());
+      return _tmp_ret;
+   }
+
+   Evas_Coord max_ascent_get() const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_max_ascent_get());
+      return _tmp_ret;
+   }
+
+   Evas_Coord vert_advance_get() const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_vert_advance_get());
+      return _tmp_ret;
+   }
+
+   Evas_Coord descent_get() const
+   {
+      Evas_Coord _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_descent_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Returns the logical position of the last char in the text up to the pos given. this is NOT the position of the last char because of the possibility of RTL in the text.
+   ///
+   /// @param x in
+   /// @param y in
+   ///
+   int last_up_to_pos(Evas_Coord x_, Evas_Coord y_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_last_up_to_pos(x_, y_));
+      return _tmp_ret;
+   }
+
+   /// @param x in
+   /// @param y in
+   /// @param[out] cx out
+   /// @param[out] cy out
+   /// @param[out] cw out
+   /// @param[out] ch out
+   ///
+   int char_coords_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_) const
+   {
+      int _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_char_coords_get(x_, y_, cx_, cy_, cw_, ch_));
+      return _tmp_ret;
+   }
+
+   /// @brief Retrieve position and dimension information of a character within a text @c Evas_Object.
+   ///
+   /// This function is used to obtain the X, Y, width and height of the character
+   /// located at @p pos within the @c Evas_Object @p obj. @p obj must be a text object
+   /// as created with evas_object_text_add(). Any of the @c Evas_Coord parameters (@p cx,
+   /// @p cy, @p cw, @p ch) may be @c NULL in which case no value will be assigned to that
+   /// parameter.
+   ///
+   /// @return @c EINA_FALSE on success, @c EINA_TRUE on error.
+   ///
+   /// @param pos The character position to request co-ordinates for.
+   /// @param[out] cx A pointer to an @c Evas_Coord to store the X value in (can be NULL).
+   /// @param[out] cy A pointer to an @c Evas_Coord to store the Y value in (can be NULL).
+   /// @param[out] cw A pointer to an @c Evas_Coord to store the Width value in (can be NULL).
+   /// @param[out] ch A pointer to an @c Evas_Coord to store the Height value in (can be NULL).
+   ///
+   bool char_pos_get(int pos_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_text_char_pos_get(pos_, cx_, cy_, cw_, ch_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_TEXT_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_TEXT_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_text_dbg_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo_Dbg_Info * root_node_)
+{
+   static_cast<T*>(self->this_)->dbg_info_get(root_node_);
+}
+
+template <typename T>
+void evas_text_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord w_, Evas_Coord h_)
+{
+   static_cast<T*>(self->this_)->size_set(w_, h_);
+}
+
+template <typename T>
+void evas_text_text_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * text_)
+{
+   static_cast<T*>(self->this_)->text_set(efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+std::string evas_text_text_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->text_get();
+}
+
+template <typename T>
+void evas_text_font_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char ** font_, Efl_Font_Size* size_)
+{
+   static_cast<T*>(self->this_)->font_get(font_, size_);
+}
+
+template <typename T>
+void evas_text_font_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * font_, Efl_Font_Size size_)
+{
+   static_cast<T*>(self->this_)->font_set(efl::eolian::to_cxx<std::string>(font_, std::tuple<std::false_type>()), size_);
+}
+
+template <typename T>
+std::string evas_text_font_source_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->font_source_get();
+}
+
+template <typename T>
+void evas_text_font_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * font_source_)
+{
+   static_cast<T*>(self->this_)->font_source_set(efl::eolian::to_cxx<std::string>(font_source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_text_shadow_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* r_, int* g_, int* b_, int* a_)
+{
+   static_cast<T*>(self->this_)->shadow_color_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_text_shadow_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->shadow_color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+double evas_text_ellipsis_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->ellipsis_get();
+}
+
+template <typename T>
+void evas_text_ellipsis_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double ellipsis_)
+{
+   static_cast<T*>(self->this_)->ellipsis_set(ellipsis_);
+}
+
+template <typename T>
+std::string evas_text_bidi_delimiters_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->bidi_delimiters_get();
+}
+
+template <typename T>
+void evas_text_bidi_delimiters_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * delim_)
+{
+   static_cast<T*>(self->this_)->bidi_delimiters_set(efl::eolian::to_cxx<std::string>(delim_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_text_outline_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* r_, int* g_, int* b_, int* a_)
+{
+   static_cast<T*>(self->this_)->outline_color_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_text_outline_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->outline_color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_text_glow2_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* r_, int* g_, int* b_, int* a_)
+{
+   static_cast<T*>(self->this_)->glow2_color_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_text_glow2_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->glow2_color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+Evas_Text_Style_Type evas_text_style_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->style_get();
+}
+
+template <typename T>
+void evas_text_style_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Text_Style_Type style_)
+{
+   static_cast<T*>(self->this_)->style_set(style_);
+}
+
+template <typename T>
+void evas_text_glow_color_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* r_, int* g_, int* b_, int* a_)
+{
+   static_cast<T*>(self->this_)->glow_color_get(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_text_glow_color_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->glow_color_set(r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_text_filter_program_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * program_)
+{
+   static_cast<T*>(self->this_)->filter_program_set(efl::eolian::to_cxx<std::string>(program_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_text_filter_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * name_, Eo * eobj_)
+{
+   static_cast<T*>(self->this_)->filter_source_set(efl::eolian::to_cxx<std::string>(name_, std::tuple<std::false_type>()), efl::eolian::to_cxx<efl::eo::base>(eobj_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Coord evas_text_max_descent_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->max_descent_get();
+}
+
+template <typename T>
+void evas_text_style_pad_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* l_, int* r_, int* t_, int* b_)
+{
+   static_cast<T*>(self->this_)->style_pad_get(l_, r_, t_, b_);
+}
+
+template <typename T>
+Evas_BiDi_Direction evas_text_direction_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->direction_get();
+}
+
+template <typename T>
+Evas_Coord evas_text_ascent_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->ascent_get();
+}
+
+template <typename T>
+Evas_Coord evas_text_horiz_advance_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->horiz_advance_get();
+}
+
+template <typename T>
+Evas_Coord evas_text_inset_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->inset_get();
+}
+
+template <typename T>
+Evas_Coord evas_text_max_ascent_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->max_ascent_get();
+}
+
+template <typename T>
+Evas_Coord evas_text_vert_advance_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->vert_advance_get();
+}
+
+template <typename T>
+Evas_Coord evas_text_descent_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->descent_get();
+}
+
+template <typename T>
+int evas_text_last_up_to_pos_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_)
+{
+   return static_cast<T*>(self->this_)->last_up_to_pos(x_, y_);
+}
+
+template <typename T>
+int evas_text_char_coords_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord x_, Evas_Coord y_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+{
+   return static_cast<T*>(self->this_)->char_coords_get(x_, y_, cx_, cy_, cw_, ch_);
+}
+
+template <typename T>
+bool evas_text_char_pos_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int pos_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+{
+   return static_cast<T*>(self->this_)->char_pos_get(pos_, cx_, cy_, cw_, ch_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::text >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_dbg_info_get(root_node_));
+      }
+
+      virtual void size_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_size_set(w_, h_));
+      }
+
+      virtual void text_set(std::string text_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_set(efl::eolian::to_c(text_)));
+      }
+
+      virtual std::string text_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_text_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void font_get(const char ** font_, Efl_Font_Size* size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_get(font_, size_));
+      }
+
+      virtual void font_set(std::string font_, Efl_Font_Size size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+      }
+
+      virtual std::string font_source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_text_properties_font_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void font_source_set(std::string font_source_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+      }
+
+      virtual void shadow_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_shadow_color_get(r_, g_, b_, a_));
+      }
+
+      virtual void shadow_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_shadow_color_set(r_, g_, b_, a_));
+      }
+
+      virtual double ellipsis_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_ellipsis_get());
+            return _tmp_ret;
+      }
+
+      virtual void ellipsis_set(double ellipsis_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_ellipsis_set(ellipsis_));
+      }
+
+      virtual std::string bidi_delimiters_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_bidi_delimiters_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void bidi_delimiters_set(std::string delim_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_bidi_delimiters_set(efl::eolian::to_c(delim_)));
+      }
+
+      virtual void outline_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_outline_color_get(r_, g_, b_, a_));
+      }
+
+      virtual void outline_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_outline_color_set(r_, g_, b_, a_));
+      }
+
+      virtual void glow2_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_glow2_color_get(r_, g_, b_, a_));
+      }
+
+      virtual void glow2_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_glow2_color_set(r_, g_, b_, a_));
+      }
+
+      virtual Evas_Text_Style_Type style_get()
+      {
+         Evas_Text_Style_Type _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_style_get());
+            return _tmp_ret;
+      }
+
+      virtual void style_set(Evas_Text_Style_Type style_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_style_set(style_));
+      }
+
+      virtual void glow_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_glow_color_get(r_, g_, b_, a_));
+      }
+
+      virtual void glow_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_glow_color_set(r_, g_, b_, a_));
+      }
+
+      virtual void filter_program_set(std::string program_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_filter_program_set(efl::eolian::to_c(program_)));
+      }
+
+      virtual void filter_source_set(std::string name_, efl::eo::base eobj_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_filter_source_set(efl::eolian::to_c(name_), efl::eolian::to_c(eobj_)));
+      }
+
+      virtual Evas_Coord max_descent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_max_descent_get());
+            return _tmp_ret;
+      }
+
+      virtual void style_pad_get(int* l_, int* r_, int* t_, int* b_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_text_style_pad_get(l_, r_, t_, b_));
+      }
+
+      virtual Evas_BiDi_Direction direction_get()
+      {
+         Evas_BiDi_Direction _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_direction_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Coord ascent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_ascent_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Coord horiz_advance_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_horiz_advance_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Coord inset_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_inset_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Coord max_ascent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_max_ascent_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Coord vert_advance_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_vert_advance_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Coord descent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_descent_get());
+            return _tmp_ret;
+      }
+
+      virtual int last_up_to_pos(Evas_Coord x_, Evas_Coord y_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_last_up_to_pos(x_, y_));
+            return _tmp_ret;
+      }
+
+      virtual int char_coords_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         int _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_char_coords_get(x_, y_, cx_, cy_, cw_, ch_));
+            return _tmp_ret;
+      }
+
+      virtual bool char_pos_get(int pos_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_text_char_pos_get(pos_, cx_, cy_, cw_, ch_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::text >
+{
+   static const int value = 36;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::text>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_text_dbg_info_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_dbg_info_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_text_size_set_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_size_set);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_text_text_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_text_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_text_text_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_text_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_text_font_get_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_get);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_text_font_set_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_set);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_text_font_source_get_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_get);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_text_font_source_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_text_shadow_color_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_text_shadow_color_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_text_shadow_color_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_text_shadow_color_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_text_ellipsis_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_text_ellipsis_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_text_ellipsis_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_text_ellipsis_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_text_bidi_delimiters_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_text_bidi_delimiters_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_text_bidi_delimiters_set_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_text_bidi_delimiters_set);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_text_outline_color_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_text_outline_color_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_text_outline_color_set_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_obj_text_outline_color_set);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_text_glow2_color_get_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_obj_text_glow2_color_get);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_text_glow2_color_set_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_obj_text_glow2_color_set);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_text_style_get_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_obj_text_style_get);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_text_style_set_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_obj_text_style_set);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_text_glow_color_get_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_obj_text_glow_color_get);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_text_glow_color_set_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_obj_text_glow_color_set);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::evas_text_filter_program_set_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_obj_text_filter_program_set);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::evas_text_filter_source_set_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_obj_text_filter_source_set);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::evas_text_max_descent_get_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_obj_text_max_descent_get);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::evas_text_style_pad_get_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_obj_text_style_pad_get);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::evas_text_direction_get_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_obj_text_direction_get);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   ops[27].func = reinterpret_cast<void*>(& ::evas_text_ascent_get_wrapper<T>);
+   ops[27].api_func = reinterpret_cast<void*>(& ::evas_obj_text_ascent_get);
+   ops[27].op = EO_OP_OVERRIDE;
+   ops[27].op_type = EO_OP_TYPE_REGULAR;
+   ops[27].doc = NULL;
+
+   ops[28].func = reinterpret_cast<void*>(& ::evas_text_horiz_advance_get_wrapper<T>);
+   ops[28].api_func = reinterpret_cast<void*>(& ::evas_obj_text_horiz_advance_get);
+   ops[28].op = EO_OP_OVERRIDE;
+   ops[28].op_type = EO_OP_TYPE_REGULAR;
+   ops[28].doc = NULL;
+
+   ops[29].func = reinterpret_cast<void*>(& ::evas_text_inset_get_wrapper<T>);
+   ops[29].api_func = reinterpret_cast<void*>(& ::evas_obj_text_inset_get);
+   ops[29].op = EO_OP_OVERRIDE;
+   ops[29].op_type = EO_OP_TYPE_REGULAR;
+   ops[29].doc = NULL;
+
+   ops[30].func = reinterpret_cast<void*>(& ::evas_text_max_ascent_get_wrapper<T>);
+   ops[30].api_func = reinterpret_cast<void*>(& ::evas_obj_text_max_ascent_get);
+   ops[30].op = EO_OP_OVERRIDE;
+   ops[30].op_type = EO_OP_TYPE_REGULAR;
+   ops[30].doc = NULL;
+
+   ops[31].func = reinterpret_cast<void*>(& ::evas_text_vert_advance_get_wrapper<T>);
+   ops[31].api_func = reinterpret_cast<void*>(& ::evas_obj_text_vert_advance_get);
+   ops[31].op = EO_OP_OVERRIDE;
+   ops[31].op_type = EO_OP_TYPE_REGULAR;
+   ops[31].doc = NULL;
+
+   ops[32].func = reinterpret_cast<void*>(& ::evas_text_descent_get_wrapper<T>);
+   ops[32].api_func = reinterpret_cast<void*>(& ::evas_obj_text_descent_get);
+   ops[32].op = EO_OP_OVERRIDE;
+   ops[32].op_type = EO_OP_TYPE_REGULAR;
+   ops[32].doc = NULL;
+
+   ops[33].func = reinterpret_cast<void*>(& ::evas_text_last_up_to_pos_wrapper<T>);
+   ops[33].api_func = reinterpret_cast<void*>(& ::evas_obj_text_last_up_to_pos);
+   ops[33].op = EO_OP_OVERRIDE;
+   ops[33].op_type = EO_OP_TYPE_REGULAR;
+   ops[33].doc = NULL;
+
+   ops[34].func = reinterpret_cast<void*>(& ::evas_text_char_coords_get_wrapper<T>);
+   ops[34].api_func = reinterpret_cast<void*>(& ::evas_obj_text_char_coords_get);
+   ops[34].op = EO_OP_OVERRIDE;
+   ops[34].op_type = EO_OP_TYPE_REGULAR;
+   ops[34].doc = NULL;
+
+   ops[35].func = reinterpret_cast<void*>(& ::evas_text_char_pos_get_wrapper<T>);
+   ops[35].api_func = reinterpret_cast<void*>(& ::evas_obj_text_char_pos_get);
+   ops[35].op = EO_OP_OVERRIDE;
+   ops[35].op_type = EO_OP_TYPE_REGULAR;
+   ops[35].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::text >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::text, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::text >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::text, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::text>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::text() const
+      {
+         return evas::text(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_dbg_info_get(root_node_));
+      }
+
+      void size_set(Evas_Coord w_, Evas_Coord h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_size_set(w_, h_));
+      }
+
+      void text_set(std::string text_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_set(efl::eolian::to_c(text_)));
+      }
+
+      std::string text_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_text_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void font_get(const char ** font_, Efl_Font_Size* size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_get(font_, size_));
+      }
+
+      void font_set(std::string font_, Efl_Font_Size size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+      }
+
+      std::string font_source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_text_properties_font_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void font_source_set(std::string font_source_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+      }
+
+      void shadow_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_shadow_color_get(r_, g_, b_, a_));
+      }
+
+      void shadow_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_shadow_color_set(r_, g_, b_, a_));
+      }
+
+      double ellipsis_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_ellipsis_get());
+            return _tmp_ret;
+      }
+
+      void ellipsis_set(double ellipsis_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_ellipsis_set(ellipsis_));
+      }
+
+      std::string bidi_delimiters_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_bidi_delimiters_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void bidi_delimiters_set(std::string delim_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_bidi_delimiters_set(efl::eolian::to_c(delim_)));
+      }
+
+      void outline_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_outline_color_get(r_, g_, b_, a_));
+      }
+
+      void outline_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_outline_color_set(r_, g_, b_, a_));
+      }
+
+      void glow2_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_glow2_color_get(r_, g_, b_, a_));
+      }
+
+      void glow2_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_glow2_color_set(r_, g_, b_, a_));
+      }
+
+      Evas_Text_Style_Type style_get()
+      {
+         Evas_Text_Style_Type _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_style_get());
+            return _tmp_ret;
+      }
+
+      void style_set(Evas_Text_Style_Type style_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_style_set(style_));
+      }
+
+      void glow_color_get(int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_glow_color_get(r_, g_, b_, a_));
+      }
+
+      void glow_color_set(int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_glow_color_set(r_, g_, b_, a_));
+      }
+
+      void filter_program_set(std::string program_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_filter_program_set(efl::eolian::to_c(program_)));
+      }
+
+      void filter_source_set(std::string name_, efl::eo::base eobj_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_filter_source_set(efl::eolian::to_c(name_), efl::eolian::to_c(eobj_)));
+      }
+
+      Evas_Coord max_descent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_max_descent_get());
+            return _tmp_ret;
+      }
+
+      void style_pad_get(int* l_, int* r_, int* t_, int* b_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_text_style_pad_get(l_, r_, t_, b_));
+      }
+
+      Evas_BiDi_Direction direction_get()
+      {
+         Evas_BiDi_Direction _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_direction_get());
+            return _tmp_ret;
+      }
+
+      Evas_Coord ascent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_ascent_get());
+            return _tmp_ret;
+      }
+
+      Evas_Coord horiz_advance_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_horiz_advance_get());
+            return _tmp_ret;
+      }
+
+      Evas_Coord inset_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_inset_get());
+            return _tmp_ret;
+      }
+
+      Evas_Coord max_ascent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_max_ascent_get());
+            return _tmp_ret;
+      }
+
+      Evas_Coord vert_advance_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_vert_advance_get());
+            return _tmp_ret;
+      }
+
+      Evas_Coord descent_get()
+      {
+         Evas_Coord _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_descent_get());
+            return _tmp_ret;
+      }
+
+      int last_up_to_pos(Evas_Coord x_, Evas_Coord y_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_last_up_to_pos(x_, y_));
+            return _tmp_ret;
+      }
+
+      int char_coords_get(Evas_Coord x_, Evas_Coord y_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         int _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_char_coords_get(x_, y_, cx_, cy_, cw_, ch_));
+            return _tmp_ret;
+      }
+
+      bool char_pos_get(int pos_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_text_char_pos_get(pos_, cx_, cy_, cw_, ch_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::text>)
+{
+   return (EVAS_TEXT_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_TEXT_HH
+
diff -Naur a/src/lib/evas/canvas/evas_text.eo.legacy.h b/src/lib/evas/canvas/evas_text.eo.legacy.h
--- a/src/lib/evas/canvas/evas_text.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_text.eo.legacy.h	2014-11-27 00:57:33.500380464 +0200
@@ -0,0 +1,376 @@
+#ifndef _EVAS_TEXT_EO_LEGACY_H_
+#define _EVAS_TEXT_EO_LEGACY_H_
+
+#ifndef _EVAS_TEXT_EO_CLASS_TYPE
+#define _EVAS_TEXT_EO_CLASS_TYPE
+
+typedef Eo Evas_Text;
+
+#endif
+
+#ifndef _EVAS_TEXT_EO_TYPES
+#define _EVAS_TEXT_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Sets the shadow color for the given text object.
+ *
+ * Shadow effects, which are fading colors decorating the text
+ * underneath it, will just be shown if the object is set to one of
+ * the following styles:
+ *
+ * - #EVAS_TEXT_STYLE_SHADOW
+ * - #EVAS_TEXT_STYLE_OUTLINE_SHADOW
+ * - #EVAS_TEXT_STYLE_FAR_SHADOW
+ * - #EVAS_TEXT_STYLE_OUTLINE_SOFT_SHADOW
+ * - #EVAS_TEXT_STYLE_SOFT_SHADOW
+ * - #EVAS_TEXT_STYLE_FAR_SOFT_SHADOW
+ *
+ * One can also change the direction where the shadow grows to, with
+ * evas_object_text_style_set().
+ *
+ * @see evas_object_text_shadow_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_shadow_color_set(Evas_Text *obj, int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the shadow color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_shadow_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_shadow_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * @brief Sets the ellipsis that should be used for the text object.
+ *
+ * This is a value between 0.0 and 1.0 indicating the position of the text
+ * to be shown. 0.0 means the start will be shown and the end trimmed, 1.0
+ * means the beginning will be trimmed and the end will be shown, and any value
+ * in between will cause ellipsis to be added in both end of the text and the
+ * requested part to be shown.
+ * -1.0 means ellipsis is turned off.
+ *
+ * @since 1.8
+ *
+ * @param[in] ellipsis the ellipsis.
+ */
+EAPI void evas_object_text_ellipsis_set(Evas_Text *obj, double ellipsis);
+
+/**
+ *
+ * @brief Gets the ellipsis currently set on the text object.
+ *
+ * @return The ellipsis set on the text object.
+ * @see evas_object_text_ellipsis_set.
+ * @since 1.8
+ *
+ */
+EAPI double evas_object_text_ellipsis_get(const Evas_Text *obj);
+
+/**
+ *
+ * @brief Sets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @since 1.1
+ *
+ * @param[in] delim A null terminated string of delimiters, e.g ",|".
+ */
+EAPI void evas_object_text_bidi_delimiters_set(Evas_Text *obj, const char *delim);
+
+/**
+ *
+ * @brief Gets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @return A null terminated string of delimiters, e.g ",|". If empty, returns NULL.
+ * @since 1.1
+ *
+ */
+EAPI const char *evas_object_text_bidi_delimiters_get(const Evas_Text *obj);
+
+/**
+ *
+ * Sets the outline color for the given text object.
+ *
+ * Outline effects (colored lines around text glyphs) will just be
+ * shown if the object is set to one of the following styles:
+ * - #EVAS_TEXT_STYLE_OUTLINE
+ * - #EVAS_TEXT_STYLE_SOFT_OUTLINE
+ * - #EVAS_TEXT_STYLE_OUTLINE_SHADOW
+ * - #EVAS_TEXT_STYLE_OUTLINE_SOFT_SHADOW
+ *
+ * @see evas_object_text_outline_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_outline_color_set(Evas_Text *obj, int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the outline color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_outline_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_outline_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * Sets the 'glow 2' color for the given text object.
+ *
+ * 'Glow 2' effects, which are glowing colors decorating the text's
+ * (immediate) surroundings, will just be shown if the object is set
+ * to the #EVAS_TEXT_STYLE_GLOW style. See also
+ * evas_object_text_glow_color_set().
+ *
+ * @see evas_object_text_glow2_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_glow2_color_set(Evas_Text *obj, int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the 'glow 2' color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_glow2_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_glow2_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * Sets the style to apply on the given text object.
+ *
+ * Text object styles are one of the values in
+ * #Evas_Text_Style_Type. Some of those values are combinations of
+ * more than one style, and some account for the direction of the
+ * rendering of shadow effects.
+ *
+ * @note One may use the helper macros #EVAS_TEXT_STYLE_BASIC_SET and
+ * #EVAS_TEXT_STYLE_SHADOW_DIRECTION_SET to assemble a style value.
+ *
+ * The following figure illustrates the text styles:
+ *
+ * @image html text-styles.png
+ * @image rtf text-styles.png
+ * @image latex text-styles.eps
+ *
+ * @see evas_object_text_style_get()
+ * @see evas_object_text_shadow_color_set()
+ * @see evas_object_text_outline_color_set()
+ * @see evas_object_text_glow_color_set()
+ * @see evas_object_text_glow2_color_set()
+ *
+ * @param[in] style a style type.
+ */
+EAPI void evas_object_text_style_set(Evas_Text *obj, Evas_Text_Style_Type style);
+
+/**
+ *
+ * Retrieves the style on use on the given text object.
+ *
+ * @return the style type in use.
+ *
+ * @see evas_object_text_style_set() for more details.
+ *
+ */
+EAPI Evas_Text_Style_Type evas_object_text_style_get(const Evas_Text *obj);
+
+/**
+ *
+ * Sets the glow color for the given text object.
+ *
+ * Glow effects, which are glowing colors decorating the text's
+ * surroundings, will just be shown if the object is set to the
+ * #EVAS_TEXT_STYLE_GLOW style.
+ *
+ * @note Glow effects are placed from a short distance of the text
+ * itself, but no touching it. For glowing effects right on the
+ * borders of the glyphs, see 'glow 2' effects
+ * (evas_object_text_glow2_color_set()).
+ *
+ * @see evas_object_text_glow_color_get()
+ *
+ * @param[in] r The red component of the given color.
+ * @param[in] g The green component of the given color.
+ * @param[in] b The blue component of the given color.
+ * @param[in] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_glow_color_set(Evas_Text *obj, int r, int g, int b, int a);
+
+/**
+ *
+ * Retrieves the glow color for the given text object.
+ *
+ * @note Use @c NULL pointers on the color components you're not
+ * interested in: they'll be ignored by the function.
+ *
+ * @see evas_object_text_glow_color_set() for more details.
+ *
+ * @param[out] r The red component of the given color.
+ * @param[out] g The green component of the given color.
+ * @param[out] b The blue component of the given color.
+ * @param[out] a The alpha component of the given color.
+ */
+EAPI void evas_object_text_glow_color_get(const Evas_Text *obj, int *r, int *g, int *b, int *a);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI Evas_Coord evas_object_text_max_descent_get(const Evas_Text *obj);
+
+/**
+ *
+ * Gets the text style pad of a text object.
+ *
+ * @param[out] l The left pad (or @c NULL).
+ * @param[out] r The right pad (or @c NULL).
+ * @param[out] t The top pad (or @c NULL).
+ * @param[out] b The bottom pad (or @c NULL).
+ */
+EAPI void evas_object_text_style_pad_get(const Evas_Text *obj, int *l, int *r, int *t, int *b);
+
+/**
+ *
+ * Retrieves the direction of the text currently being displayed in the
+ * text object.
+ * @return the direction of the text
+ *
+ */
+EAPI Evas_BiDi_Direction evas_object_text_direction_get(const Evas_Text *obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI Evas_Coord evas_object_text_ascent_get(const Evas_Text *obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI Evas_Coord evas_object_text_horiz_advance_get(const Evas_Text *obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI Evas_Coord evas_object_text_inset_get(const Evas_Text *obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI Evas_Coord evas_object_text_max_ascent_get(const Evas_Text *obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI Evas_Coord evas_object_text_vert_advance_get(const Evas_Text *obj);
+
+/**
+ *
+ * No description supplied.
+ *
+ */
+EAPI Evas_Coord evas_object_text_descent_get(const Evas_Text *obj);
+
+/**
+ *
+ * Returns the logical position of the last char in the text up to the pos given. this is NOT the position of the last char because of the possibility of RTL in the text.
+ * 
+ *
+ * @param[in] x in
+ * @param[in] y in
+ */
+EAPI int evas_object_text_last_up_to_pos(const Evas_Text *obj, Evas_Coord x, Evas_Coord y);
+
+/**
+ *
+ * No description supplied.
+ *
+ * @param[in] x in
+ * @param[in] y in
+ * @param[out] cx out
+ * @param[out] cy out
+ * @param[out] cw out
+ * @param[out] ch out
+ */
+EAPI int evas_object_text_char_coords_get(const Evas_Text *obj, Evas_Coord x, Evas_Coord y, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+/**
+ *
+ * Retrieve position and dimension information of a character within a text @c Evas_Object.
+ *
+ * This function is used to obtain the X, Y, width and height of the character
+ * located at @p pos within the @c Evas_Object @p obj. @p obj must be a text object
+ * as created with evas_object_text_add(). Any of the @c Evas_Coord parameters (@p cx,
+ * @p cy, @p cw, @p ch) may be @c NULL in which case no value will be assigned to that
+ * parameter.
+ *
+ * @return @c EINA_FALSE on success, @c EINA_TRUE on error.
+ * 
+ *
+ * @param[in] pos The character position to request co-ordinates for.
+ * @param[out] cx A pointer to an @c Evas_Coord to store the X value in (can be NULL).
+ * @param[out] cy A pointer to an @c Evas_Coord to store the Y value in (can be NULL).
+ * @param[out] cw A pointer to an @c Evas_Coord to store the Width value in (can be NULL).
+ * @param[out] ch A pointer to an @c Evas_Coord to store the Height value in (can be NULL).
+ */
+EAPI Eina_Bool evas_object_text_char_pos_get(const Evas_Text *obj, int pos, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_textblock.eo.c b/src/lib/evas/canvas/evas_textblock.eo.c
--- a/src/lib/evas/canvas/evas_textblock.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textblock.eo.c	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,308 @@
+
+void _evas_textblock_text_markup_set(Eo *obj, Evas_Textblock_Data *pd, const char *text);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_text_markup_set, EO_FUNC_CALL(text), const char *text);
+
+const char * _evas_textblock_text_markup_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_text_markup_get, const char *, 0);
+
+void _evas_textblock_valign_set(Eo *obj, Evas_Textblock_Data *pd, double align);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_valign_set, EO_FUNC_CALL(align), double align);
+
+double _evas_textblock_valign_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_valign_get, double, 0);
+
+void _evas_textblock_bidi_delimiters_set(Eo *obj, Evas_Textblock_Data *pd, const char *delim);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_bidi_delimiters_set, EO_FUNC_CALL(delim), const char *delim);
+
+const char * _evas_textblock_bidi_delimiters_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_bidi_delimiters_get, const char *, 0);
+
+void _evas_textblock_replace_char_set(Eo *obj, Evas_Textblock_Data *pd, const char *ch);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_replace_char_set, EO_FUNC_CALL(ch), const char *ch);
+
+void _evas_textblock_legacy_newline_set(Eo *obj, Evas_Textblock_Data *pd, Eina_Bool mode);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_legacy_newline_set, EO_FUNC_CALL(mode), Eina_Bool mode);
+
+Eina_Bool _evas_textblock_legacy_newline_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_legacy_newline_get, Eina_Bool, 0);
+
+void _evas_textblock_style_set(Eo *obj, Evas_Textblock_Data *pd, const Evas_Textblock_Style *ts);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_style_set, EO_FUNC_CALL(ts), const Evas_Textblock_Style *ts);
+
+const Evas_Textblock_Style * _evas_textblock_style_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_style_get, const Evas_Textblock_Style *, 0);
+
+const Evas_Object_Textblock_Node_Format * _evas_textblock_node_format_first_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_node_format_first_get, const Evas_Object_Textblock_Node_Format *, 0);
+
+void _evas_textblock_size_formatted_get(Eo *obj, Evas_Textblock_Data *pd, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_size_formatted_get, EO_FUNC_CALL(w, h), Evas_Coord *w, Evas_Coord *h);
+
+const Evas_Object_Textblock_Node_Format * _evas_textblock_node_format_last_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_node_format_last_get, const Evas_Object_Textblock_Node_Format *, 0);
+
+Evas_Textblock_Cursor * _evas_textblock_cursor_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_cursor_get, Evas_Textblock_Cursor *, 0);
+
+void _evas_textblock_size_native_get(Eo *obj, Evas_Textblock_Data *pd, Evas_Coord *w, Evas_Coord *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_size_native_get, EO_FUNC_CALL(w, h), Evas_Coord *w, Evas_Coord *h);
+
+void _evas_textblock_style_insets_get(Eo *obj, Evas_Textblock_Data *pd, Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_style_insets_get, EO_FUNC_CALL(l, r, t, b), Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+Eina_Bool _evas_textblock_line_number_geometry_get(Eo *obj, Evas_Textblock_Data *pd, int line, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+EOAPI EO_FUNC_BODYV(evas_obj_textblock_line_number_geometry_get, Eina_Bool, 0, EO_FUNC_CALL(line, cx, cy, cw, ch), int line, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+const char * _evas_textblock_replace_char_get(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_replace_char_get, const char *, 0);
+
+void _evas_textblock_style_user_pop(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_textblock_style_user_pop);
+
+Evas_Textblock_Cursor * _evas_textblock_cursor_new(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_cursor_new, Evas_Textblock_Cursor *, 0);
+
+const Eina_List * _evas_textblock_node_format_list_get(Eo *obj, Evas_Textblock_Data *pd, const char *anchor);
+
+EOAPI EO_FUNC_BODYV(evas_obj_textblock_node_format_list_get, const Eina_List *, 0, EO_FUNC_CALL(anchor), const char *anchor);
+
+const Evas_Textblock_Style * _evas_textblock_style_user_peek(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textblock_style_user_peek, const Evas_Textblock_Style *, 0);
+
+void _evas_textblock_node_format_remove_pair(Eo *obj, Evas_Textblock_Data *pd, Evas_Object_Textblock_Node_Format *n);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_node_format_remove_pair, EO_FUNC_CALL(n), Evas_Object_Textblock_Node_Format *n);
+
+void _evas_textblock_clear(Eo *obj, Evas_Textblock_Data *pd);
+
+EOAPI EO_VOID_FUNC_BODY(evas_obj_textblock_clear);
+
+void _evas_textblock_style_user_push(Eo *obj, Evas_Textblock_Data *pd, Evas_Textblock_Style *ts);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textblock_style_user_push, EO_FUNC_CALL(ts), Evas_Textblock_Style *ts);
+
+void _evas_textblock_eo_base_constructor(Eo *obj, Evas_Textblock_Data *pd);
+
+
+void _evas_textblock_eo_base_destructor(Eo *obj, Evas_Textblock_Data *pd);
+
+
+void _evas_textblock_eo_base_dbg_info_get(Eo *obj, Evas_Textblock_Data *pd, Eo_Dbg_Info *root_node);
+
+
+static Eo_Op_Description _evas_textblock_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_textblock_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_textblock_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_dbg_info_get, _evas_textblock_eo_base_dbg_info_get),
+     EO_OP_FUNC(evas_obj_textblock_text_markup_set, _evas_textblock_text_markup_set, "Sets the tetxblock's text to the markup text."),
+     EO_OP_FUNC(evas_obj_textblock_text_markup_get, _evas_textblock_text_markup_get, "Return the markup of the object."),
+     EO_OP_FUNC(evas_obj_textblock_valign_set, _evas_textblock_valign_set, "@brief Sets the vertical alignment of text within the textblock object"),
+     EO_OP_FUNC(evas_obj_textblock_valign_get, _evas_textblock_valign_get, "@brief Gets the vertical alignment of a textblock"),
+     EO_OP_FUNC(evas_obj_textblock_bidi_delimiters_set, _evas_textblock_bidi_delimiters_set, "@brief Sets the BiDi delimiters used in the textblock."),
+     EO_OP_FUNC(evas_obj_textblock_bidi_delimiters_get, _evas_textblock_bidi_delimiters_get, "@brief Gets the BiDi delimiters used in the textblock."),
+     EO_OP_FUNC(evas_obj_textblock_replace_char_set, _evas_textblock_replace_char_set, "@brief Set the \"replacement character\" to use for the given textblock object."),
+     EO_OP_FUNC(evas_obj_textblock_legacy_newline_set, _evas_textblock_legacy_newline_set, "@brief Sets newline mode. When true, newline character will behave"),
+     EO_OP_FUNC(evas_obj_textblock_legacy_newline_get, _evas_textblock_legacy_newline_get, "@brief Gets newline mode. When true, newline character behaves"),
+     EO_OP_FUNC(evas_obj_textblock_style_set, _evas_textblock_style_set, "Set the objects style to ts."),
+     EO_OP_FUNC(evas_obj_textblock_style_get, _evas_textblock_style_get, "Return the style of an object."),
+     EO_OP_FUNC(evas_obj_textblock_node_format_first_get, _evas_textblock_node_format_first_get, "Returns the first format node."),
+     EO_OP_FUNC(evas_obj_textblock_size_formatted_get, _evas_textblock_size_formatted_get, "Get the formatted width and height. This calculates the actual size after restricting"),
+     EO_OP_FUNC(evas_obj_textblock_node_format_last_get, _evas_textblock_node_format_last_get, "Returns the last format node."),
+     EO_OP_FUNC(evas_obj_textblock_cursor_get, _evas_textblock_cursor_get, "Return the object's main cursor."),
+     EO_OP_FUNC(evas_obj_textblock_size_native_get, _evas_textblock_size_native_get, "Get the native width and height. This calculates the actual size without taking account"),
+     EO_OP_FUNC(evas_obj_textblock_style_insets_get, _evas_textblock_style_insets_get, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_textblock_line_number_geometry_get, _evas_textblock_line_number_geometry_get, "Get the geometry of a line number."),
+     EO_OP_FUNC(evas_obj_textblock_replace_char_get, _evas_textblock_replace_char_get, "@brief Get the \"replacement character\" for given textblock object. Returns"),
+     EO_OP_FUNC(evas_obj_textblock_style_user_pop, _evas_textblock_style_user_pop, "Del the from the top of the user style stack."),
+     EO_OP_FUNC(evas_obj_textblock_cursor_new, _evas_textblock_cursor_new, "Create a new cursor, associate it to the obj and init it to point"),
+     EO_OP_FUNC(evas_obj_textblock_node_format_list_get, _evas_textblock_node_format_list_get, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_textblock_style_user_peek, _evas_textblock_style_user_peek, "Get (don't remove) the style at the top of the user style stack."),
+     EO_OP_FUNC(evas_obj_textblock_node_format_remove_pair, _evas_textblock_node_format_remove_pair, "Remove a format node and its match."),
+     EO_OP_FUNC(evas_obj_textblock_clear, _evas_textblock_clear, "Clear the textblock object."),
+     EO_OP_FUNC(evas_obj_textblock_style_user_push, _evas_textblock_style_user_push, "Push ts to the top of the user style stack."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_textblock_class_desc = {
+     EO_VERSION,
+     "Evas_Textblock",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_textblock_op_desc),
+     NULL,
+     sizeof(Evas_Textblock_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_textblock_class_get, &_evas_textblock_class_desc, EVAS_OBJECT_CLASS, NULL);
+EAPI void
+evas_object_textblock_text_markup_set(Evas_Textblock *obj, const char *text)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_text_markup_set(text));
+}
+
+EAPI const char *
+evas_object_textblock_text_markup_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_text_markup_get());
+}
+
+EAPI void
+evas_object_textblock_valign_set(Evas_Textblock *obj, double align)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_valign_set(align));
+}
+
+EAPI double
+evas_object_textblock_valign_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_valign_get());
+}
+
+EAPI void
+evas_object_textblock_bidi_delimiters_set(Evas_Textblock *obj, const char *delim)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_bidi_delimiters_set(delim));
+}
+
+EAPI const char *
+evas_object_textblock_bidi_delimiters_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_bidi_delimiters_get());
+}
+
+EAPI void
+evas_object_textblock_replace_char_set(Evas_Textblock *obj, const char *ch)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_replace_char_set(ch));
+}
+
+EAPI void
+evas_object_textblock_legacy_newline_set(Evas_Textblock *obj, Eina_Bool mode)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_legacy_newline_set(mode));
+}
+
+EAPI Eina_Bool
+evas_object_textblock_legacy_newline_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_legacy_newline_get());
+}
+
+EAPI void
+evas_object_textblock_style_set(Evas_Textblock *obj, const Evas_Textblock_Style *ts)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_style_set(ts));
+}
+
+EAPI const Evas_Textblock_Style *
+evas_object_textblock_style_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_style_get());
+}
+
+EAPI const Evas_Object_Textblock_Node_Format *
+evas_textblock_node_format_first_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_node_format_first_get());
+}
+
+EAPI void
+evas_object_textblock_size_formatted_get(const Evas_Textblock *obj, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_size_formatted_get(w, h));
+}
+
+EAPI const Evas_Object_Textblock_Node_Format *
+evas_textblock_node_format_last_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_node_format_last_get());
+}
+
+EAPI Evas_Textblock_Cursor *
+evas_object_textblock_cursor_get(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_cursor_get());
+}
+
+EAPI void
+evas_object_textblock_size_native_get(const Evas_Textblock *obj, Evas_Coord *w, Evas_Coord *h)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_size_native_get(w, h));
+}
+
+EAPI void
+evas_object_textblock_style_insets_get(const Evas_Textblock *obj, Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_style_insets_get(l, r, t, b));
+}
+
+EAPI Eina_Bool
+evas_object_textblock_line_number_geometry_get(const Evas_Textblock *obj, int line, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_line_number_geometry_get(line, cx, cy, cw, ch));
+}
+
+EAPI const char *
+evas_object_textblock_replace_char_get(Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_replace_char_get());
+}
+
+EAPI void
+evas_object_textblock_style_user_pop(Evas_Textblock *obj)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_style_user_pop());
+}
+
+EAPI Evas_Textblock_Cursor *
+evas_object_textblock_cursor_new(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_cursor_new());
+}
+
+EAPI const Eina_List *
+evas_textblock_node_format_list_get(const Evas_Textblock *obj, const char *anchor)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_node_format_list_get(anchor));
+}
+
+EAPI const Evas_Textblock_Style *
+evas_object_textblock_style_user_peek(const Evas_Textblock *obj)
+{
+   return eo_do((Evas_Textblock *)obj, evas_obj_textblock_style_user_peek());
+}
+
+EAPI void
+evas_textblock_node_format_remove_pair(Evas_Textblock *obj, Evas_Object_Textblock_Node_Format *n)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_node_format_remove_pair(n));
+}
+
+EAPI void
+evas_object_textblock_style_user_push(Evas_Textblock *obj, Evas_Textblock_Style *ts)
+{
+   eo_do((Evas_Textblock *)obj, evas_obj_textblock_style_user_push(ts));
+}
diff -Naur a/src/lib/evas/canvas/evas_textblock.eo.h b/src/lib/evas/canvas/evas_textblock.eo.h
--- a/src/lib/evas/canvas/evas_textblock.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textblock.eo.h	2014-11-27 00:57:33.517047392 +0200
@@ -0,0 +1,358 @@
+#ifndef _EVAS_TEXTBLOCK_EO_H_
+#define _EVAS_TEXTBLOCK_EO_H_
+
+#ifndef _EVAS_TEXTBLOCK_EO_CLASS_TYPE
+#define _EVAS_TEXTBLOCK_EO_CLASS_TYPE
+
+typedef Eo Evas_Textblock;
+
+#endif
+
+#ifndef _EVAS_TEXTBLOCK_EO_TYPES
+#define _EVAS_TEXTBLOCK_EO_TYPES
+
+
+#endif
+#define EVAS_TEXTBLOCK_CLASS evas_textblock_class_get()
+
+const Eo_Class *evas_textblock_class_get(void) EINA_CONST;
+
+/**
+ *
+ * Sets the tetxblock's text to the markup text.
+ *
+ * @note assumes text does not include the unicode object replacement char (0xFFFC)
+ *
+ * @return Return no value.
+ *
+ * @param[in] text the markup text to use.
+ *
+ */
+EOAPI void  evas_obj_textblock_text_markup_set(const char *text);
+
+/**
+ *
+ * Return the markup of the object.
+ *
+ * @return the markup text of the object.
+ *
+ *
+ */
+EOAPI const char * evas_obj_textblock_text_markup_get(void);
+
+/**
+ *
+ * @brief Sets the vertical alignment of text within the textblock object
+ * as a whole.
+ *
+ * Normally alignment is 0.0 (top of object). Values given should be
+ * between 0.0 and 1.0 (1.0 bottom of object, 0.5 being vertically centered
+ * etc.).
+ *
+ * @since 1.1
+ *
+ * @param[in] align A value between @c 0.0 and @c 1.0.
+ *
+ */
+EOAPI void  evas_obj_textblock_valign_set(double align);
+
+/**
+ *
+ * @brief Gets the vertical alignment of a textblock
+ *
+ * @return The alignment set for the object.
+ * @since 1.1
+ *
+ *
+ */
+EOAPI double  evas_obj_textblock_valign_get(void);
+
+/**
+ *
+ * @brief Sets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @since 1.1
+ *
+ * @param[in] delim A null terminated string of delimiters, e.g ",|".
+ *
+ */
+EOAPI void  evas_obj_textblock_bidi_delimiters_set(const char *delim);
+
+/**
+ *
+ * @brief Gets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @return A null terminated string of delimiters, e.g ",|". If empty, returns
+ * @c NULL.
+ * @since 1.1
+ *
+ *
+ */
+EOAPI const char * evas_obj_textblock_bidi_delimiters_get(void);
+
+/**
+ *
+ * @brief Set the "replacement character" to use for the given textblock object.
+ *
+ * @param[in] ch The charset name.
+ *
+ */
+EOAPI void  evas_obj_textblock_replace_char_set(const char *ch);
+
+/**
+ *
+ * @brief Sets newline mode. When true, newline character will behave
+ * as a paragraph separator.
+ *
+ * @since 1.1
+ *
+ * @param[in] mode @c EINA_TRUE for legacy mode, @c EINA_FALSE otherwise.
+ *
+ */
+EOAPI void  evas_obj_textblock_legacy_newline_set(Eina_Bool mode);
+
+/**
+ *
+ * @brief Gets newline mode. When true, newline character behaves
+ * as a paragraph separator.
+ *
+ * @return @c EINA_TRUE if in legacy mode, @c EINA_FALSE otherwise.
+ * @since 1.1
+ *
+ *
+ */
+EOAPI Eina_Bool  evas_obj_textblock_legacy_newline_get(void);
+
+/**
+ *
+ * Set the objects style to ts.
+ * @return Returns no value.
+ *
+ * @param[in] ts the style to set.
+ *
+ */
+EOAPI void  evas_obj_textblock_style_set(const Evas_Textblock_Style *ts);
+
+/**
+ *
+ * Return the style of an object.
+ * @return the style of the object.
+ *
+ *
+ */
+EOAPI const Evas_Textblock_Style * evas_obj_textblock_style_get(void);
+
+/**
+ *
+ * Returns the first format node.
+ *
+ *
+ */
+EOAPI const Evas_Object_Textblock_Node_Format * evas_obj_textblock_node_format_first_get(void);
+
+/**
+ *
+ * Get the formatted width and height. This calculates the actual size after restricting
+ * the textblock to the current size of the object.
+ * The main difference between this and @ref evas_object_textblock_size_native_get
+ * is that the "native" function does not wrapping into account
+ * it just calculates the real width of the object if it was placed on an
+ * infinite canvas, while this function gives the size after wrapping
+ * according to the size restrictions of the object.
+ *
+ * For example for a textblock containing the text: "You shall not pass!"
+ * with no margins or padding and assuming a monospace font and a size of
+ * 7x10 char widths (for simplicity) has a native size of 19x1
+ * and a formatted size of 5x4.
+ *
+ *
+ * @return Returns no value.
+ * @see evas_object_textblock_size_native_get
+ *
+ * @param[out] w the width of the object.
+ * @param[out] h the height of the object
+ *
+ */
+EOAPI void  evas_obj_textblock_size_formatted_get(Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Returns the last format node.
+ *
+ *
+ */
+EOAPI const Evas_Object_Textblock_Node_Format * evas_obj_textblock_node_format_last_get(void);
+
+/**
+ *
+ * Return the object's main cursor.
+ *
+ * @return The @p obj's main cursor.
+ *
+ *
+ */
+EOAPI Evas_Textblock_Cursor * evas_obj_textblock_cursor_get(void);
+
+/**
+ *
+ * Get the native width and height. This calculates the actual size without taking account
+ * the current size of the object.
+ * The main difference between this and @ref evas_object_textblock_size_formatted_get
+ * is that the "native" function does not take wrapping into account
+ * it just calculates the real width of the object if it was placed on an
+ * infinite canvas, while the "formatted" function gives the size after
+ * wrapping text according to the size restrictions of the object.
+ *
+ * For example for a textblock containing the text: "You shall not pass!"
+ * with no margins or padding and assuming a monospace font and a size of
+ * 7x10 char widths (for simplicity) has a native size of 19x1
+ * and a formatted size of 5x4.
+ *
+ * @return Returns no value.
+ *
+ * @param[out] w the width returned
+ * @param[out] h the height returned
+ *
+ */
+EOAPI void  evas_obj_textblock_size_native_get(Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ * @param[out] l No description supplied.
+ * @param[out] r No description supplied.
+ * @param[out] t No description supplied.
+ * @param[out] b No description supplied.
+ *
+ */
+EOAPI void  evas_obj_textblock_style_insets_get(Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+/**
+ *
+ * Get the geometry of a line number.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE otherwise.
+ * 
+ *
+ * @param[in] line the line number.
+ * @param[out] cx x coord of the line.
+ * @param[out] cy y coord of the line.
+ * @param[out] cw w coord of the line.
+ * @param[out] ch h coord of the line.
+ *
+ */
+EOAPI Eina_Bool  evas_obj_textblock_line_number_geometry_get(int line, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+/**
+ *
+ * @brief Get the "replacement character" for given textblock object. Returns
+ * @c NULL if no replacement character is in use.
+ *
+ * @return Replacement character or @c NULL.
+ * 
+ *
+ *
+ */
+EOAPI const char * evas_obj_textblock_replace_char_get(void);
+
+/**
+ *
+ * Del the from the top of the user style stack.
+ *
+ * @see evas_object_textblock_style_get
+ * @since 1.2
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_textblock_style_user_pop(void);
+
+/**
+ *
+ * Create a new cursor, associate it to the obj and init it to point
+ * to the start of the textblock. Association to the object means the cursor
+ * will be updated when the object will change.
+ *
+ * @note if you need speed and you know what you are doing, it's slightly faster to just allocate the cursor yourself and not associate it. (only people developing the actual object, and not users of the object).
+ *
+ * @return the new cursor.
+ * 
+ *
+ *
+ */
+EOAPI Evas_Textblock_Cursor * evas_obj_textblock_cursor_new(void);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] anchor No description supplied.
+ *
+ */
+EOAPI const Eina_List * evas_obj_textblock_node_format_list_get(const char *anchor);
+
+/**
+ *
+ * Get (don't remove) the style at the top of the user style stack.
+ *
+ * @return the style of the object.
+ * @see evas_object_textblock_style_get
+ * @since 1.2
+ * 
+ *
+ *
+ */
+EOAPI const Evas_Textblock_Style * evas_obj_textblock_style_user_peek(void);
+
+/**
+ *
+ * Remove a format node and its match.
+ * 
+ *
+ * @param[in] n No description supplied.
+ *
+ */
+EOAPI void  evas_obj_textblock_node_format_remove_pair(Evas_Object_Textblock_Node_Format *n);
+
+/**
+ *
+ * Clear the textblock object.
+ * @note Does *NOT* free the Evas object itself.
+ *
+ * @return nothing.
+ * 
+ *
+ *
+ */
+EOAPI void  evas_obj_textblock_clear(void);
+
+/**
+ *
+ * Push ts to the top of the user style stack.
+ *
+ * FIXME: API is solid but currently only supports 1 style in the stack.
+ *
+ * The user style overrides the corresponding elements of the regular style.
+ * This is the proper way to do theme overrides in code.
+ * @return Returns no value.
+ * @see evas_object_textblock_style_set
+ * @since 1.2
+ * 
+ *
+ * @param[in] ts the style to set.
+ *
+ */
+EOAPI void  evas_obj_textblock_style_user_push(Evas_Textblock_Style *ts);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_textblock.eo.hh b/src/lib/evas/canvas/evas_textblock.eo.hh
--- a/src/lib/evas/canvas/evas_textblock.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textblock.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,1200 @@
+#ifndef EFL_GENERATED_EVAS_TEXTBLOCK_HH
+#define EFL_GENERATED_EVAS_TEXTBLOCK_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_textblock.eo.h"
+}
+
+#include "evas_object.eo.hh"
+#include <string>
+
+namespace evas {
+
+struct textblock
+      : evas::object
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit textblock(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit textblock(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   textblock(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : textblock(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   textblock(textblock const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~textblock() {}
+
+   /// @brief Get dbg information from the object.
+   ///
+   /// @param root_node node of the tree
+   ///
+   void dbg_info_get(Eo_Dbg_Info * root_node_) const
+   {
+      eo_do(_eo_ptr(), ::eo_dbg_info_get(root_node_));
+   }
+
+   /// @brief Return the markup of the object.
+   ///
+   /// @return the markup text of the object.
+   ///
+   /// @param text the markup text to use.
+   ///
+   std::string text_markup_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_text_markup_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Sets the tetxblock's text to the markup text.
+   ///
+   /// @note assumes text does not include the unicode object replacement char (0xFFFC)
+   ///
+   /// @return Return no value.
+   ///
+   /// @param text the markup text to use.
+   ///
+   void text_markup_set(std::string text_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_text_markup_set(efl::eolian::to_c(text_)));
+   }
+
+   /// @brief @brief Gets the vertical alignment of a textblock
+   ///
+   /// @return The alignment set for the object.
+   /// @since 1.1
+   ///
+   /// @param align A value between @c 0.0 and @c 1.0.
+   ///
+   double valign_get() const
+   {
+      double _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_valign_get());
+      return _tmp_ret;
+   }
+
+   /// @brief @brief Sets the vertical alignment of text within the textblock object
+   /// as a whole.
+   ///
+   /// Normally alignment is 0.0 (top of object). Values given should be
+   /// between 0.0 and 1.0 (1.0 bottom of object, 0.5 being vertically centered
+   /// etc.).
+   ///
+   /// @since 1.1
+   ///
+   /// @param align A value between @c 0.0 and @c 1.0.
+   ///
+   void valign_set(double align_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_valign_set(align_));
+   }
+
+   /// @brief @brief Gets the BiDi delimiters used in the textblock.
+   ///
+   /// BiDi delimiters are use for in-paragraph separation of bidi segments. This
+   /// is useful for example in recipients fields of e-mail clients where bidi
+   /// oddities can occur when mixing RTL and LTR.
+   ///
+   /// @return A null terminated string of delimiters, e.g ",|". If empty, returns
+   /// @c NULL.
+   /// @since 1.1
+   ///
+   /// @param delim A null terminated string of delimiters, e.g ",|".
+   ///
+   std::string bidi_delimiters_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_bidi_delimiters_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Sets the BiDi delimiters used in the textblock.
+   ///
+   /// BiDi delimiters are use for in-paragraph separation of bidi segments. This
+   /// is useful for example in recipients fields of e-mail clients where bidi
+   /// oddities can occur when mixing RTL and LTR.
+   ///
+   /// @since 1.1
+   ///
+   /// @param delim A null terminated string of delimiters, e.g ",|".
+   ///
+   void bidi_delimiters_set(std::string delim_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_bidi_delimiters_set(efl::eolian::to_c(delim_)));
+   }
+
+   /// @brief @brief Set the "replacement character" to use for the given textblock object.
+   ///
+   /// @param ch The charset name.
+   ///
+   void replace_char_set(std::string ch_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_replace_char_set(efl::eolian::to_c(ch_)));
+   }
+
+   /// @brief @brief Gets newline mode. When true, newline character behaves
+   /// as a paragraph separator.
+   ///
+   /// @return @c EINA_TRUE if in legacy mode, @c EINA_FALSE otherwise.
+   /// @since 1.1
+   ///
+   /// @param mode @c EINA_TRUE for legacy mode, @c EINA_FALSE otherwise.
+   ///
+   bool legacy_newline_get() const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_legacy_newline_get());
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Sets newline mode. When true, newline character will behave
+   /// as a paragraph separator.
+   ///
+   /// @since 1.1
+   ///
+   /// @param mode @c EINA_TRUE for legacy mode, @c EINA_FALSE otherwise.
+   ///
+   void legacy_newline_set(bool mode_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_legacy_newline_set(efl::eolian::to_c(mode_)));
+   }
+
+   /// @brief Return the style of an object.
+   /// @return the style of the object.
+   ///
+   /// @param ts the style to set.
+   ///
+   const Evas_Textblock_Style * style_get() const
+   {
+      const Evas_Textblock_Style * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_style_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Set the objects style to ts.
+   /// @return Returns no value.
+   ///
+   /// @param ts the style to set.
+   ///
+   void style_set(const Evas_Textblock_Style * ts_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_style_set(ts_));
+   }
+
+   /// @brief Returns the first format node.
+   ///
+   /// @param format 
+   ///
+   const Evas_Object_Textblock_Node_Format * node_format_first_get() const
+   {
+      const Evas_Object_Textblock_Node_Format * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_node_format_first_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the formatted width and height. This calculates the actual size after restricting
+   /// the textblock to the current size of the object.
+   /// The main difference between this and @ref evas_object_textblock_size_native_get
+   /// is that the "native" function does not wrapping into account
+   /// it just calculates the real width of the object if it was placed on an
+   /// infinite canvas, while this function gives the size after wrapping
+   /// according to the size restrictions of the object.
+   ///
+   /// For example for a textblock containing the text: "You shall not pass!"
+   /// with no margins or padding and assuming a monospace font and a size of
+   /// 7x10 char widths (for simplicity) has a native size of 19x1
+   /// and a formatted size of 5x4.
+   ///
+   ///
+   /// @return Returns no value.
+   /// @see evas_object_textblock_size_native_get
+   ///
+   /// @param w the width of the object.
+   /// @param h the height of the object
+   ///
+   void size_formatted_get(Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_size_formatted_get(w_, h_));
+   }
+
+   /// @brief Returns the last format node.
+   ///
+   /// @param format 
+   ///
+   const Evas_Object_Textblock_Node_Format * node_format_last_get() const
+   {
+      const Evas_Object_Textblock_Node_Format * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_node_format_last_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Return the object's main cursor.
+   ///
+   /// @return The @p obj's main cursor.
+   ///
+   Evas_Textblock_Cursor * cursor_get() const
+   {
+      Evas_Textblock_Cursor * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_cursor_get());
+      return _tmp_ret;
+   }
+
+   /// @brief Get the native width and height. This calculates the actual size without taking account
+   /// the current size of the object.
+   /// The main difference between this and @ref evas_object_textblock_size_formatted_get
+   /// is that the "native" function does not take wrapping into account
+   /// it just calculates the real width of the object if it was placed on an
+   /// infinite canvas, while the "formatted" function gives the size after
+   /// wrapping text according to the size restrictions of the object.
+   ///
+   /// For example for a textblock containing the text: "You shall not pass!"
+   /// with no margins or padding and assuming a monospace font and a size of
+   /// 7x10 char widths (for simplicity) has a native size of 19x1
+   /// and a formatted size of 5x4.
+   ///
+   /// @return Returns no value.
+   ///
+   /// @param w the width returned
+   /// @param h the height returned
+   ///
+   void size_native_get(Evas_Coord* w_, Evas_Coord* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_size_native_get(w_, h_));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param l 
+   /// @param r 
+   /// @param t 
+   /// @param b 
+   ///
+   void style_insets_get(Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_style_insets_get(l_, r_, t_, b_));
+   }
+
+   /// @brief Get the geometry of a line number.
+   ///
+   /// @return @c EINA_TRUE on success, @c EINA_FALSE otherwise.
+   ///
+   /// @param line the line number.
+   /// @param[out] cx x coord of the line.
+   /// @param[out] cy y coord of the line.
+   /// @param[out] cw w coord of the line.
+   /// @param[out] ch h coord of the line.
+   ///
+   bool line_number_geometry_get(int line_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_) const
+   {
+      Eina_Bool _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_line_number_geometry_get(line_, cx_, cy_, cw_, ch_));
+      return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief @brief Get the "replacement character" for given textblock object. Returns
+   /// @c NULL if no replacement character is in use.
+   ///
+   /// @return Replacement character or @c NULL.
+   ///
+   std::string replace_char_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_replace_char_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Del the from the top of the user style stack.
+   ///
+   /// @see evas_object_textblock_style_get
+   /// @since 1.2
+   ///
+   void style_user_pop() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_style_user_pop());
+   }
+
+   /// @brief Create a new cursor, associate it to the obj and init it to point
+   /// to the start of the textblock. Association to the object means the cursor
+   /// will be updated when the object will change.
+   ///
+   /// @note if you need speed and you know what you are doing, it's slightly faster to just allocate the cursor yourself and not associate it. (only people developing the actual object, and not users of the object).
+   ///
+   /// @return the new cursor.
+   ///
+   Evas_Textblock_Cursor * cursor_new() const
+   {
+      Evas_Textblock_Cursor * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_cursor_new());
+      return _tmp_ret;
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param anchor 
+   ///
+   efl::eina::crange_list< evas::object > node_format_list_get(std::string anchor_) const
+   {
+      const Eina_List * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_node_format_list_get(efl::eolian::to_c(anchor_)));
+      return efl::eolian::to_cxx<efl::eina::crange_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+   }
+
+   /// @brief Get (don't remove) the style at the top of the user style stack.
+   ///
+   /// @return the style of the object.
+   /// @see evas_object_textblock_style_get
+   /// @since 1.2
+   ///
+   const Evas_Textblock_Style * style_user_peek() const
+   {
+      const Evas_Textblock_Style * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textblock_style_user_peek());
+      return _tmp_ret;
+   }
+
+   /// @brief Remove a format node and its match.
+   ///
+   /// @param n 
+   ///
+   void node_format_remove_pair(Evas_Object_Textblock_Node_Format * n_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_node_format_remove_pair(n_));
+   }
+
+   /// @brief Clear the textblock object.
+   /// @note Does *NOT* free the Evas object itself.
+   ///
+   /// @return nothing.
+   ///
+   void clear() const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_clear());
+   }
+
+   /// @brief Push ts to the top of the user style stack.
+   ///
+   /// FIXME: API is solid but currently only supports 1 style in the stack.
+   ///
+   /// The user style overrides the corresponding elements of the regular style.
+   /// This is the proper way to do theme overrides in code.
+   /// @return Returns no value.
+   /// @see evas_object_textblock_style_set
+   /// @since 1.2
+   ///
+   /// @param ts the style to set.
+   ///
+   void style_user_push(Evas_Textblock_Style * ts_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textblock_style_user_push(ts_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_TEXTBLOCK_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_TEXTBLOCK_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_textblock_dbg_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo_Dbg_Info * root_node_)
+{
+   static_cast<T*>(self->this_)->dbg_info_get(root_node_);
+}
+
+template <typename T>
+std::string evas_textblock_text_markup_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->text_markup_get();
+}
+
+template <typename T>
+void evas_textblock_text_markup_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * text_)
+{
+   static_cast<T*>(self->this_)->text_markup_set(efl::eolian::to_cxx<std::string>(text_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+double evas_textblock_valign_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->valign_get();
+}
+
+template <typename T>
+void evas_textblock_valign_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, double align_)
+{
+   static_cast<T*>(self->this_)->valign_set(align_);
+}
+
+template <typename T>
+std::string evas_textblock_bidi_delimiters_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->bidi_delimiters_get();
+}
+
+template <typename T>
+void evas_textblock_bidi_delimiters_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * delim_)
+{
+   static_cast<T*>(self->this_)->bidi_delimiters_set(efl::eolian::to_cxx<std::string>(delim_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+void evas_textblock_replace_char_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * ch_)
+{
+   static_cast<T*>(self->this_)->replace_char_set(efl::eolian::to_cxx<std::string>(ch_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+bool evas_textblock_legacy_newline_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->legacy_newline_get();
+}
+
+template <typename T>
+void evas_textblock_legacy_newline_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eina_Bool mode_)
+{
+   static_cast<T*>(self->this_)->legacy_newline_set(efl::eolian::to_cxx<bool>(mode_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+const Evas_Textblock_Style * evas_textblock_style_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->style_get();
+}
+
+template <typename T>
+void evas_textblock_style_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const Evas_Textblock_Style * ts_)
+{
+   static_cast<T*>(self->this_)->style_set(ts_);
+}
+
+template <typename T>
+const Evas_Object_Textblock_Node_Format * evas_textblock_node_format_first_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->node_format_first_get();
+}
+
+template <typename T>
+void evas_textblock_size_formatted_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->size_formatted_get(w_, h_);
+}
+
+template <typename T>
+const Evas_Object_Textblock_Node_Format * evas_textblock_node_format_last_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->node_format_last_get();
+}
+
+template <typename T>
+Evas_Textblock_Cursor * evas_textblock_cursor_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->cursor_get();
+}
+
+template <typename T>
+void evas_textblock_size_native_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* w_, Evas_Coord* h_)
+{
+   static_cast<T*>(self->this_)->size_native_get(w_, h_);
+}
+
+template <typename T>
+void evas_textblock_style_insets_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_)
+{
+   static_cast<T*>(self->this_)->style_insets_get(l_, r_, t_, b_);
+}
+
+template <typename T>
+bool evas_textblock_line_number_geometry_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int line_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+{
+   return static_cast<T*>(self->this_)->line_number_geometry_get(line_, cx_, cy_, cw_, ch_);
+}
+
+template <typename T>
+std::string evas_textblock_replace_char_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->replace_char_get();
+}
+
+template <typename T>
+void evas_textblock_style_user_pop_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->style_user_pop();
+}
+
+template <typename T>
+Evas_Textblock_Cursor * evas_textblock_cursor_new_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->cursor_new();
+}
+
+template <typename T>
+efl::eina::crange_list< evas::object > evas_textblock_node_format_list_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * anchor_)
+{
+   return static_cast<T*>(self->this_)->node_format_list_get(efl::eolian::to_cxx<std::string>(anchor_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+const Evas_Textblock_Style * evas_textblock_style_user_peek_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->style_user_peek();
+}
+
+template <typename T>
+void evas_textblock_node_format_remove_pair_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Object_Textblock_Node_Format * n_)
+{
+   static_cast<T*>(self->this_)->node_format_remove_pair(n_);
+}
+
+template <typename T>
+void evas_textblock_clear_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   static_cast<T*>(self->this_)->clear();
+}
+
+template <typename T>
+void evas_textblock_style_user_push_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Textblock_Style * ts_)
+{
+   static_cast<T*>(self->this_)->style_user_push(ts_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::textblock >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_dbg_info_get(root_node_));
+      }
+
+      virtual std::string text_markup_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_text_markup_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void text_markup_set(std::string text_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_text_markup_set(efl::eolian::to_c(text_)));
+      }
+
+      virtual double valign_get()
+      {
+         double _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_valign_get());
+            return _tmp_ret;
+      }
+
+      virtual void valign_set(double align_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_valign_set(align_));
+      }
+
+      virtual std::string bidi_delimiters_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_bidi_delimiters_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void bidi_delimiters_set(std::string delim_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_bidi_delimiters_set(efl::eolian::to_c(delim_)));
+      }
+
+      virtual void replace_char_set(std::string ch_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_replace_char_set(efl::eolian::to_c(ch_)));
+      }
+
+      virtual bool legacy_newline_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_legacy_newline_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void legacy_newline_set(bool mode_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_legacy_newline_set(efl::eolian::to_c(mode_)));
+      }
+
+      virtual const Evas_Textblock_Style * style_get()
+      {
+         const Evas_Textblock_Style * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_style_get());
+            return _tmp_ret;
+      }
+
+      virtual void style_set(const Evas_Textblock_Style * ts_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_style_set(ts_));
+      }
+
+      virtual const Evas_Object_Textblock_Node_Format * node_format_first_get()
+      {
+         const Evas_Object_Textblock_Node_Format * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_node_format_first_get());
+            return _tmp_ret;
+      }
+
+      virtual void size_formatted_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_size_formatted_get(w_, h_));
+      }
+
+      virtual const Evas_Object_Textblock_Node_Format * node_format_last_get()
+      {
+         const Evas_Object_Textblock_Node_Format * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_node_format_last_get());
+            return _tmp_ret;
+      }
+
+      virtual Evas_Textblock_Cursor * cursor_get()
+      {
+         Evas_Textblock_Cursor * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_cursor_get());
+            return _tmp_ret;
+      }
+
+      virtual void size_native_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_size_native_get(w_, h_));
+      }
+
+      virtual void style_insets_get(Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_style_insets_get(l_, r_, t_, b_));
+      }
+
+      virtual bool line_number_geometry_get(int line_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_line_number_geometry_get(line_, cx_, cy_, cw_, ch_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual std::string replace_char_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_replace_char_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void style_user_pop()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_style_user_pop());
+      }
+
+      virtual Evas_Textblock_Cursor * cursor_new()
+      {
+         Evas_Textblock_Cursor * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_cursor_new());
+            return _tmp_ret;
+      }
+
+      virtual efl::eina::crange_list< evas::object > node_format_list_get(std::string anchor_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_node_format_list_get(efl::eolian::to_c(anchor_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      virtual const Evas_Textblock_Style * style_user_peek()
+      {
+         const Evas_Textblock_Style * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textblock_style_user_peek());
+            return _tmp_ret;
+      }
+
+      virtual void node_format_remove_pair(Evas_Object_Textblock_Node_Format * n_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_node_format_remove_pair(n_));
+      }
+
+      virtual void clear()
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_clear());
+      }
+
+      virtual void style_user_push(Evas_Textblock_Style * ts_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textblock_style_user_push(ts_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::textblock >
+{
+   static const int value = 27;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::textblock>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_textblock_dbg_info_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_dbg_info_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_textblock_text_markup_get_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_text_markup_get);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_textblock_text_markup_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_text_markup_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_textblock_valign_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_valign_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_textblock_valign_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_valign_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_textblock_bidi_delimiters_get_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_bidi_delimiters_get);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_textblock_bidi_delimiters_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_bidi_delimiters_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_textblock_replace_char_set_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_replace_char_set);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_textblock_legacy_newline_get_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_legacy_newline_get);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_textblock_legacy_newline_set_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_legacy_newline_set);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_textblock_style_get_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_style_get);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_textblock_style_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_style_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_textblock_node_format_first_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_node_format_first_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_textblock_size_formatted_get_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_size_formatted_get);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_textblock_node_format_last_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_node_format_last_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   ops[15].func = reinterpret_cast<void*>(& ::evas_textblock_cursor_get_wrapper<T>);
+   ops[15].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_cursor_get);
+   ops[15].op = EO_OP_OVERRIDE;
+   ops[15].op_type = EO_OP_TYPE_REGULAR;
+   ops[15].doc = NULL;
+
+   ops[16].func = reinterpret_cast<void*>(& ::evas_textblock_size_native_get_wrapper<T>);
+   ops[16].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_size_native_get);
+   ops[16].op = EO_OP_OVERRIDE;
+   ops[16].op_type = EO_OP_TYPE_REGULAR;
+   ops[16].doc = NULL;
+
+   ops[17].func = reinterpret_cast<void*>(& ::evas_textblock_style_insets_get_wrapper<T>);
+   ops[17].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_style_insets_get);
+   ops[17].op = EO_OP_OVERRIDE;
+   ops[17].op_type = EO_OP_TYPE_REGULAR;
+   ops[17].doc = NULL;
+
+   ops[18].func = reinterpret_cast<void*>(& ::evas_textblock_line_number_geometry_get_wrapper<T>);
+   ops[18].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_line_number_geometry_get);
+   ops[18].op = EO_OP_OVERRIDE;
+   ops[18].op_type = EO_OP_TYPE_REGULAR;
+   ops[18].doc = NULL;
+
+   ops[19].func = reinterpret_cast<void*>(& ::evas_textblock_replace_char_get_wrapper<T>);
+   ops[19].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_replace_char_get);
+   ops[19].op = EO_OP_OVERRIDE;
+   ops[19].op_type = EO_OP_TYPE_REGULAR;
+   ops[19].doc = NULL;
+
+   ops[20].func = reinterpret_cast<void*>(& ::evas_textblock_style_user_pop_wrapper<T>);
+   ops[20].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_style_user_pop);
+   ops[20].op = EO_OP_OVERRIDE;
+   ops[20].op_type = EO_OP_TYPE_REGULAR;
+   ops[20].doc = NULL;
+
+   ops[21].func = reinterpret_cast<void*>(& ::evas_textblock_cursor_new_wrapper<T>);
+   ops[21].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_cursor_new);
+   ops[21].op = EO_OP_OVERRIDE;
+   ops[21].op_type = EO_OP_TYPE_REGULAR;
+   ops[21].doc = NULL;
+
+   ops[22].func = reinterpret_cast<void*>(& ::evas_textblock_node_format_list_get_wrapper<T>);
+   ops[22].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_node_format_list_get);
+   ops[22].op = EO_OP_OVERRIDE;
+   ops[22].op_type = EO_OP_TYPE_REGULAR;
+   ops[22].doc = NULL;
+
+   ops[23].func = reinterpret_cast<void*>(& ::evas_textblock_style_user_peek_wrapper<T>);
+   ops[23].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_style_user_peek);
+   ops[23].op = EO_OP_OVERRIDE;
+   ops[23].op_type = EO_OP_TYPE_REGULAR;
+   ops[23].doc = NULL;
+
+   ops[24].func = reinterpret_cast<void*>(& ::evas_textblock_node_format_remove_pair_wrapper<T>);
+   ops[24].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_node_format_remove_pair);
+   ops[24].op = EO_OP_OVERRIDE;
+   ops[24].op_type = EO_OP_TYPE_REGULAR;
+   ops[24].doc = NULL;
+
+   ops[25].func = reinterpret_cast<void*>(& ::evas_textblock_clear_wrapper<T>);
+   ops[25].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_clear);
+   ops[25].op = EO_OP_OVERRIDE;
+   ops[25].op_type = EO_OP_TYPE_REGULAR;
+   ops[25].doc = NULL;
+
+   ops[26].func = reinterpret_cast<void*>(& ::evas_textblock_style_user_push_wrapper<T>);
+   ops[26].api_func = reinterpret_cast<void*>(& ::evas_obj_textblock_style_user_push);
+   ops[26].op = EO_OP_OVERRIDE;
+   ops[26].op_type = EO_OP_TYPE_REGULAR;
+   ops[26].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::textblock >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::textblock, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::textblock >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::textblock, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::textblock>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::textblock() const
+      {
+         return evas::textblock(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_dbg_info_get(root_node_));
+      }
+
+      std::string text_markup_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_text_markup_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void text_markup_set(std::string text_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_text_markup_set(efl::eolian::to_c(text_)));
+      }
+
+      double valign_get()
+      {
+         double _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_valign_get());
+            return _tmp_ret;
+      }
+
+      void valign_set(double align_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_valign_set(align_));
+      }
+
+      std::string bidi_delimiters_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_bidi_delimiters_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void bidi_delimiters_set(std::string delim_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_bidi_delimiters_set(efl::eolian::to_c(delim_)));
+      }
+
+      void replace_char_set(std::string ch_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_replace_char_set(efl::eolian::to_c(ch_)));
+      }
+
+      bool legacy_newline_get()
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_legacy_newline_get());
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void legacy_newline_set(bool mode_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_legacy_newline_set(efl::eolian::to_c(mode_)));
+      }
+
+      const Evas_Textblock_Style * style_get()
+      {
+         const Evas_Textblock_Style * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_style_get());
+            return _tmp_ret;
+      }
+
+      void style_set(const Evas_Textblock_Style * ts_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_style_set(ts_));
+      }
+
+      const Evas_Object_Textblock_Node_Format * node_format_first_get()
+      {
+         const Evas_Object_Textblock_Node_Format * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_node_format_first_get());
+            return _tmp_ret;
+      }
+
+      void size_formatted_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_size_formatted_get(w_, h_));
+      }
+
+      const Evas_Object_Textblock_Node_Format * node_format_last_get()
+      {
+         const Evas_Object_Textblock_Node_Format * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_node_format_last_get());
+            return _tmp_ret;
+      }
+
+      Evas_Textblock_Cursor * cursor_get()
+      {
+         Evas_Textblock_Cursor * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_cursor_get());
+            return _tmp_ret;
+      }
+
+      void size_native_get(Evas_Coord* w_, Evas_Coord* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_size_native_get(w_, h_));
+      }
+
+      void style_insets_get(Evas_Coord* l_, Evas_Coord* r_, Evas_Coord* t_, Evas_Coord* b_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_style_insets_get(l_, r_, t_, b_));
+      }
+
+      bool line_number_geometry_get(int line_, Evas_Coord* cx_, Evas_Coord* cy_, Evas_Coord* cw_, Evas_Coord* ch_)
+      {
+         Eina_Bool _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_line_number_geometry_get(line_, cx_, cy_, cw_, ch_));
+            return efl::eolian::to_cxx<bool>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      std::string replace_char_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_replace_char_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void style_user_pop()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_style_user_pop());
+      }
+
+      Evas_Textblock_Cursor * cursor_new()
+      {
+         Evas_Textblock_Cursor * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_cursor_new());
+            return _tmp_ret;
+      }
+
+      efl::eina::crange_list< evas::object > node_format_list_get(std::string anchor_)
+      {
+         const Eina_List * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_node_format_list_get(efl::eolian::to_c(anchor_)));
+            return efl::eolian::to_cxx<efl::eina::crange_list< evas::object >>(_tmp_ret, std::tuple<std::false_type, std::false_type>());
+      }
+
+      const Evas_Textblock_Style * style_user_peek()
+      {
+         const Evas_Textblock_Style * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textblock_style_user_peek());
+            return _tmp_ret;
+      }
+
+      void node_format_remove_pair(Evas_Object_Textblock_Node_Format * n_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_node_format_remove_pair(n_));
+      }
+
+      void clear()
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_clear());
+      }
+
+      void style_user_push(Evas_Textblock_Style * ts_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textblock_style_user_push(ts_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::textblock>)
+{
+   return (EVAS_TEXTBLOCK_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_TEXTBLOCK_HH
+
diff -Naur a/src/lib/evas/canvas/evas_textblock.eo.legacy.h b/src/lib/evas/canvas/evas_textblock.eo.legacy.h
--- a/src/lib/evas/canvas/evas_textblock.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textblock.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,317 @@
+#ifndef _EVAS_TEXTBLOCK_EO_LEGACY_H_
+#define _EVAS_TEXTBLOCK_EO_LEGACY_H_
+
+#ifndef _EVAS_TEXTBLOCK_EO_CLASS_TYPE
+#define _EVAS_TEXTBLOCK_EO_CLASS_TYPE
+
+typedef Eo Evas_Textblock;
+
+#endif
+
+#ifndef _EVAS_TEXTBLOCK_EO_TYPES
+#define _EVAS_TEXTBLOCK_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * Sets the tetxblock's text to the markup text.
+ *
+ * @note assumes text does not include the unicode object replacement char (0xFFFC)
+ *
+ * @return Return no value.
+ *
+ * @param[in] text the markup text to use.
+ */
+EAPI void evas_object_textblock_text_markup_set(Evas_Textblock *obj, const char *text);
+
+/**
+ *
+ * Return the markup of the object.
+ *
+ * @return the markup text of the object.
+ *
+ */
+EAPI const char *evas_object_textblock_text_markup_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * @brief Sets the vertical alignment of text within the textblock object
+ * as a whole.
+ *
+ * Normally alignment is 0.0 (top of object). Values given should be
+ * between 0.0 and 1.0 (1.0 bottom of object, 0.5 being vertically centered
+ * etc.).
+ *
+ * @since 1.1
+ *
+ * @param[in] align A value between @c 0.0 and @c 1.0.
+ */
+EAPI void evas_object_textblock_valign_set(Evas_Textblock *obj, double align);
+
+/**
+ *
+ * @brief Gets the vertical alignment of a textblock
+ *
+ * @return The alignment set for the object.
+ * @since 1.1
+ *
+ */
+EAPI double evas_object_textblock_valign_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * @brief Sets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @since 1.1
+ *
+ * @param[in] delim A null terminated string of delimiters, e.g ",|".
+ */
+EAPI void evas_object_textblock_bidi_delimiters_set(Evas_Textblock *obj, const char *delim);
+
+/**
+ *
+ * @brief Gets the BiDi delimiters used in the textblock.
+ *
+ * BiDi delimiters are use for in-paragraph separation of bidi segments. This
+ * is useful for example in recipients fields of e-mail clients where bidi
+ * oddities can occur when mixing RTL and LTR.
+ *
+ * @return A null terminated string of delimiters, e.g ",|". If empty, returns
+ * @c NULL.
+ * @since 1.1
+ *
+ */
+EAPI const char *evas_object_textblock_bidi_delimiters_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * @brief Set the "replacement character" to use for the given textblock object.
+ *
+ * @param[in] ch The charset name.
+ */
+EAPI void evas_object_textblock_replace_char_set(Evas_Textblock *obj, const char *ch);
+
+/**
+ *
+ * @brief Sets newline mode. When true, newline character will behave
+ * as a paragraph separator.
+ *
+ * @since 1.1
+ *
+ * @param[in] mode @c EINA_TRUE for legacy mode, @c EINA_FALSE otherwise.
+ */
+EAPI void evas_object_textblock_legacy_newline_set(Evas_Textblock *obj, Eina_Bool mode);
+
+/**
+ *
+ * @brief Gets newline mode. When true, newline character behaves
+ * as a paragraph separator.
+ *
+ * @return @c EINA_TRUE if in legacy mode, @c EINA_FALSE otherwise.
+ * @since 1.1
+ *
+ */
+EAPI Eina_Bool evas_object_textblock_legacy_newline_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * Set the objects style to ts.
+ * @return Returns no value.
+ *
+ * @param[in] ts the style to set.
+ */
+EAPI void evas_object_textblock_style_set(Evas_Textblock *obj, const Evas_Textblock_Style *ts);
+
+/**
+ *
+ * Return the style of an object.
+ * @return the style of the object.
+ *
+ */
+EAPI const Evas_Textblock_Style *evas_object_textblock_style_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * Returns the first format node.
+ *
+ */
+EAPI const Evas_Object_Textblock_Node_Format *evas_textblock_node_format_first_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * Get the formatted width and height. This calculates the actual size after restricting
+ * the textblock to the current size of the object.
+ * The main difference between this and @ref evas_object_textblock_size_native_get
+ * is that the "native" function does not wrapping into account
+ * it just calculates the real width of the object if it was placed on an
+ * infinite canvas, while this function gives the size after wrapping
+ * according to the size restrictions of the object.
+ *
+ * For example for a textblock containing the text: "You shall not pass!"
+ * with no margins or padding and assuming a monospace font and a size of
+ * 7x10 char widths (for simplicity) has a native size of 19x1
+ * and a formatted size of 5x4.
+ *
+ *
+ * @return Returns no value.
+ * @see evas_object_textblock_size_native_get
+ *
+ * @param[out] w the width of the object.
+ * @param[out] h the height of the object
+ */
+EAPI void evas_object_textblock_size_formatted_get(const Evas_Textblock *obj, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * Returns the last format node.
+ *
+ */
+EAPI const Evas_Object_Textblock_Node_Format *evas_textblock_node_format_last_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * Return the object's main cursor.
+ *
+ * @return The @p obj's main cursor.
+ *
+ */
+EAPI Evas_Textblock_Cursor *evas_object_textblock_cursor_get(const Evas_Textblock *obj);
+
+/**
+ *
+ * Get the native width and height. This calculates the actual size without taking account
+ * the current size of the object.
+ * The main difference between this and @ref evas_object_textblock_size_formatted_get
+ * is that the "native" function does not take wrapping into account
+ * it just calculates the real width of the object if it was placed on an
+ * infinite canvas, while the "formatted" function gives the size after
+ * wrapping text according to the size restrictions of the object.
+ *
+ * For example for a textblock containing the text: "You shall not pass!"
+ * with no margins or padding and assuming a monospace font and a size of
+ * 7x10 char widths (for simplicity) has a native size of 19x1
+ * and a formatted size of 5x4.
+ *
+ * @return Returns no value.
+ *
+ * @param[out] w the width returned
+ * @param[out] h the height returned
+ */
+EAPI void evas_object_textblock_size_native_get(const Evas_Textblock *obj, Evas_Coord *w, Evas_Coord *h);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ * @param[out] l No description supplied.
+ * @param[out] r No description supplied.
+ * @param[out] t No description supplied.
+ * @param[out] b No description supplied.
+ */
+EAPI void evas_object_textblock_style_insets_get(const Evas_Textblock *obj, Evas_Coord *l, Evas_Coord *r, Evas_Coord *t, Evas_Coord *b);
+
+/**
+ *
+ * Get the geometry of a line number.
+ *
+ * @return @c EINA_TRUE on success, @c EINA_FALSE otherwise.
+ * 
+ *
+ * @param[in] line the line number.
+ * @param[out] cx x coord of the line.
+ * @param[out] cy y coord of the line.
+ * @param[out] cw w coord of the line.
+ * @param[out] ch h coord of the line.
+ */
+EAPI Eina_Bool evas_object_textblock_line_number_geometry_get(const Evas_Textblock *obj, int line, Evas_Coord *cx, Evas_Coord *cy, Evas_Coord *cw, Evas_Coord *ch);
+
+/**
+ *
+ * @brief Get the "replacement character" for given textblock object. Returns
+ * @c NULL if no replacement character is in use.
+ *
+ * @return Replacement character or @c NULL.
+ * 
+ *
+ */
+EAPI const char *evas_object_textblock_replace_char_get(Evas_Textblock *obj);
+
+/**
+ *
+ * Del the from the top of the user style stack.
+ *
+ * @see evas_object_textblock_style_get
+ * @since 1.2
+ * 
+ *
+ */
+EAPI void evas_object_textblock_style_user_pop(Evas_Textblock *obj);
+
+/**
+ *
+ * Create a new cursor, associate it to the obj and init it to point
+ * to the start of the textblock. Association to the object means the cursor
+ * will be updated when the object will change.
+ *
+ * @note if you need speed and you know what you are doing, it's slightly faster to just allocate the cursor yourself and not associate it. (only people developing the actual object, and not users of the object).
+ *
+ * @return the new cursor.
+ * 
+ *
+ */
+EAPI Evas_Textblock_Cursor *evas_object_textblock_cursor_new(const Evas_Textblock *obj);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ * 
+ *
+ * @param[in] anchor No description supplied.
+ */
+EAPI const Eina_List *evas_textblock_node_format_list_get(const Evas_Textblock *obj, const char *anchor);
+
+/**
+ *
+ * Get (don't remove) the style at the top of the user style stack.
+ *
+ * @return the style of the object.
+ * @see evas_object_textblock_style_get
+ * @since 1.2
+ * 
+ *
+ */
+EAPI const Evas_Textblock_Style *evas_object_textblock_style_user_peek(const Evas_Textblock *obj);
+
+/**
+ *
+ * Remove a format node and its match.
+ * 
+ *
+ * @param[in] n No description supplied.
+ */
+EAPI void evas_textblock_node_format_remove_pair(Evas_Textblock *obj, Evas_Object_Textblock_Node_Format *n);
+
+/**
+ *
+ * Push ts to the top of the user style stack.
+ *
+ * FIXME: API is solid but currently only supports 1 style in the stack.
+ *
+ * The user style overrides the corresponding elements of the regular style.
+ * This is the proper way to do theme overrides in code.
+ * @return Returns no value.
+ * @see evas_object_textblock_style_set
+ * @since 1.2
+ * 
+ *
+ * @param[in] ts the style to set.
+ */
+EAPI void evas_object_textblock_style_user_push(Evas_Textblock *obj, Evas_Textblock_Style *ts);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_textgrid.eo.c b/src/lib/evas/canvas/evas_textgrid.eo.c
--- a/src/lib/evas/canvas/evas_textgrid.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textgrid.eo.c	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,154 @@
+
+void _evas_textgrid_supported_font_styles_set(Eo *obj, Evas_Textgrid_Data *pd, Evas_Textgrid_Font_Style styles);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_supported_font_styles_set, EO_FUNC_CALL(styles), Evas_Textgrid_Font_Style styles);
+
+Evas_Textgrid_Font_Style _evas_textgrid_supported_font_styles_get(Eo *obj, Evas_Textgrid_Data *pd);
+
+EOAPI EO_FUNC_BODY(evas_obj_textgrid_supported_font_styles_get, Evas_Textgrid_Font_Style, 0);
+
+void _evas_textgrid_size_set(Eo *obj, Evas_Textgrid_Data *pd, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_size_set, EO_FUNC_CALL(w, h), int w, int h);
+
+void _evas_textgrid_size_get(Eo *obj, Evas_Textgrid_Data *pd, int *w, int *h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_size_get, EO_FUNC_CALL(w, h), int *w, int *h);
+
+void _evas_textgrid_cell_size_get(Eo *obj, Evas_Textgrid_Data *pd, int *width, int *height);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_cell_size_get, EO_FUNC_CALL(width, height), int *width, int *height);
+
+void _evas_textgrid_update_add(Eo *obj, Evas_Textgrid_Data *pd, int x, int y, int w, int h);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_update_add, EO_FUNC_CALL(x, y, w, h), int x, int y, int w, int h);
+
+void _evas_textgrid_cellrow_set(Eo *obj, Evas_Textgrid_Data *pd, int y, const Evas_Textgrid_Cell *row);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_cellrow_set, EO_FUNC_CALL(y, row), int y, const Evas_Textgrid_Cell *row);
+
+Evas_Textgrid_Cell * _evas_textgrid_cellrow_get(Eo *obj, Evas_Textgrid_Data *pd, int y);
+
+EOAPI EO_FUNC_BODYV(evas_obj_textgrid_cellrow_get, Evas_Textgrid_Cell *, 0, EO_FUNC_CALL(y), int y);
+
+void _evas_textgrid_palette_set(Eo *obj, Evas_Textgrid_Data *pd, Evas_Textgrid_Palette pal, int idx, int r, int g, int b, int a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_palette_set, EO_FUNC_CALL(pal, idx, r, g, b, a), Evas_Textgrid_Palette pal, int idx, int r, int g, int b, int a);
+
+void _evas_textgrid_palette_get(Eo *obj, Evas_Textgrid_Data *pd, Evas_Textgrid_Palette pal, int idx, int *r, int *g, int *b, int *a);
+
+EOAPI EO_VOID_FUNC_BODYV(evas_obj_textgrid_palette_get, EO_FUNC_CALL(pal, idx, r, g, b, a), Evas_Textgrid_Palette pal, int idx, int *r, int *g, int *b, int *a);
+
+void _evas_textgrid_eo_base_constructor(Eo *obj, Evas_Textgrid_Data *pd);
+
+
+void _evas_textgrid_eo_base_destructor(Eo *obj, Evas_Textgrid_Data *pd);
+
+
+void _evas_textgrid_eo_base_dbg_info_get(Eo *obj, Evas_Textgrid_Data *pd, Eo_Dbg_Info *root_node);
+
+
+void _evas_textgrid_efl_text_properties_font_get(Eo *obj, Evas_Textgrid_Data *pd, const char **font, Efl_Font_Size *size);
+
+
+void _evas_textgrid_efl_text_properties_font_set(Eo *obj, Evas_Textgrid_Data *pd, const char *font, Efl_Font_Size size);
+
+
+const char * _evas_textgrid_efl_text_properties_font_source_get(Eo *obj, Evas_Textgrid_Data *pd);
+
+
+void _evas_textgrid_efl_text_properties_font_source_set(Eo *obj, Evas_Textgrid_Data *pd, const char *font_source);
+
+
+static Eo_Op_Description _evas_textgrid_op_desc[] = {
+     EO_OP_FUNC_OVERRIDE(eo_constructor, _evas_textgrid_eo_base_constructor),
+     EO_OP_FUNC_OVERRIDE(eo_destructor, _evas_textgrid_eo_base_destructor),
+     EO_OP_FUNC_OVERRIDE(eo_dbg_info_get, _evas_textgrid_eo_base_dbg_info_get),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_get, _evas_textgrid_efl_text_properties_font_get),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_set, _evas_textgrid_efl_text_properties_font_set),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_source_get, _evas_textgrid_efl_text_properties_font_source_get),
+     EO_OP_FUNC_OVERRIDE(efl_text_properties_font_source_set, _evas_textgrid_efl_text_properties_font_source_set),
+     EO_OP_FUNC(evas_obj_textgrid_supported_font_styles_set, _evas_textgrid_supported_font_styles_set, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_textgrid_supported_font_styles_get, _evas_textgrid_supported_font_styles_get, "No description supplied by the EAPI."),
+     EO_OP_FUNC(evas_obj_textgrid_size_set, _evas_textgrid_size_set, "@brief Set the size of the textgrid object."),
+     EO_OP_FUNC(evas_obj_textgrid_size_get, _evas_textgrid_size_get, "@brief Get the size of the textgrid object."),
+     EO_OP_FUNC(evas_obj_textgrid_cell_size_get, _evas_textgrid_cell_size_get, "@brief Retrieve the size of a cell of the given textgrid object in pixels."),
+     EO_OP_FUNC(evas_obj_textgrid_update_add, _evas_textgrid_update_add, "@brief Indicate for evas that part of a textgrid region (cells) has been updated."),
+     EO_OP_FUNC(evas_obj_textgrid_cellrow_set, _evas_textgrid_cellrow_set, "@brief Set the string at the given row of the given textgrid object."),
+     EO_OP_FUNC(evas_obj_textgrid_cellrow_get, _evas_textgrid_cellrow_get, "@brief Get the string at the given row of the given textgrid object."),
+     EO_OP_FUNC(evas_obj_textgrid_palette_set, _evas_textgrid_palette_set, "@brief The set color to the given palette at the given index of the given textgrid object."),
+     EO_OP_FUNC(evas_obj_textgrid_palette_get, _evas_textgrid_palette_get, "@brief The retrieve color to the given palette at the given index of the given textgrid object."),
+     EO_OP_SENTINEL
+};
+
+static const Eo_Class_Description _evas_textgrid_class_desc = {
+     EO_VERSION,
+     "Evas_Textgrid",
+     EO_CLASS_TYPE_REGULAR,
+     EO_CLASS_DESCRIPTION_OPS(_evas_textgrid_op_desc),
+     NULL,
+     sizeof(Evas_Textgrid_Data),
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_textgrid_class_get, &_evas_textgrid_class_desc, EVAS_OBJECT_CLASS, EFL_TEXT_PROPERTIES_INTERFACE, NULL);
+EAPI void
+evas_object_textgrid_supported_font_styles_set(Evas_Textgrid *obj, Evas_Textgrid_Font_Style styles)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_supported_font_styles_set(styles));
+}
+
+EAPI Evas_Textgrid_Font_Style
+evas_object_textgrid_supported_font_styles_get(const Evas_Textgrid *obj)
+{
+   return eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_supported_font_styles_get());
+}
+
+EAPI void
+evas_object_textgrid_size_set(Evas_Textgrid *obj, int w, int h)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_size_set(w, h));
+}
+
+EAPI void
+evas_object_textgrid_size_get(const Evas_Textgrid *obj, int *w, int *h)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_size_get(w, h));
+}
+
+EAPI void
+evas_object_textgrid_cell_size_get(const Evas_Textgrid *obj, int *width, int *height)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_cell_size_get(width, height));
+}
+
+EAPI void
+evas_object_textgrid_update_add(Evas_Textgrid *obj, int x, int y, int w, int h)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_update_add(x, y, w, h));
+}
+
+EAPI void
+evas_object_textgrid_cellrow_set(Evas_Textgrid *obj, int y, const Evas_Textgrid_Cell *row)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_cellrow_set(y, row));
+}
+
+EAPI Evas_Textgrid_Cell *
+evas_object_textgrid_cellrow_get(const Evas_Textgrid *obj, int y)
+{
+   return eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_cellrow_get(y));
+}
+
+EAPI void
+evas_object_textgrid_palette_set(Evas_Textgrid *obj, Evas_Textgrid_Palette pal, int idx, int r, int g, int b, int a)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_palette_set(pal, idx, r, g, b, a));
+}
+
+EAPI void
+evas_object_textgrid_palette_get(const Evas_Textgrid *obj, Evas_Textgrid_Palette pal, int idx, int *r, int *g, int *b, int *a)
+{
+   eo_do((Evas_Textgrid *)obj, evas_obj_textgrid_palette_get(pal, idx, r, g, b, a));
+}
diff -Naur a/src/lib/evas/canvas/evas_textgrid.eo.h b/src/lib/evas/canvas/evas_textgrid.eo.h
--- a/src/lib/evas/canvas/evas_textgrid.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textgrid.eo.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,229 @@
+#ifndef _EVAS_TEXTGRID_EO_H_
+#define _EVAS_TEXTGRID_EO_H_
+
+#ifndef _EVAS_TEXTGRID_EO_CLASS_TYPE
+#define _EVAS_TEXTGRID_EO_CLASS_TYPE
+
+typedef Eo Evas_Textgrid;
+
+#endif
+
+#ifndef _EVAS_TEXTGRID_EO_TYPES
+#define _EVAS_TEXTGRID_EO_TYPES
+
+
+#endif
+#define EVAS_TEXTGRID_CLASS evas_textgrid_class_get()
+
+const Eo_Class *evas_textgrid_class_get(void) EINA_CONST;
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ * @param[in] styles No description supplied.
+ *
+ */
+EOAPI void  evas_obj_textgrid_supported_font_styles_set(Evas_Textgrid_Font_Style styles);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ *
+ */
+EOAPI Evas_Textgrid_Font_Style  evas_obj_textgrid_supported_font_styles_get(void);
+
+/**
+ *
+ * @brief Set the size of the textgrid object.
+ *
+ * This function sets the number of lines @p h and the number
+ * of columns @p w to the textgrid object @p obj. If
+ * @p w or @p h are less or equal than 0, this
+ * functiond does nothing.
+ *
+ * @since 1.7
+ *
+ * @param[in] w The number of columns (width in cells) of the grid.
+ * @param[in] h The number of rows (height in cells) of the grid.
+ *
+ */
+EOAPI void  evas_obj_textgrid_size_set(int w, int h);
+
+/**
+ *
+ * @brief Get the size of the textgrid object.
+ *
+ * This function retrieves the number of lines in the buffer @p
+ * h and the number of columns in the buffer @p w of
+ * the textgrid object @p obj. @p w or @p h can be
+ * @c NULL. On error, their value is 0.
+ *
+ * @since 1.7
+ *
+ * @param[out] w The number of columns (width in cells) of the grid.
+ * @param[out] h The number of rows (height in cells) of the grid.
+ *
+ */
+EOAPI void  evas_obj_textgrid_size_get(int *w, int *h);
+
+/**
+ *
+ * @brief Retrieve the size of a cell of the given textgrid object in pixels.
+ *
+ * This functions retrieves the width and height, in pixels, of a cell
+ * of the textgrid object @p obj and store them respectively in the
+ * buffers @p width and @p height. Their value depends on the
+ * monospace font used for the textgrid object, as well as the
+ * style. @p width and @p height can be @c NULL. On error, they are
+ * set to 0.
+ *
+ * @see evas_object_textgrid_font_set()
+ * @see evas_object_textgrid_supported_font_styles_set()
+ *
+ * @since 1.7
+ *
+ * @param[out] width A pointer to the location to store the width in pixels of a cell.
+ * @param[out] height A pointer to the location to store the height in
+pixels of a cell.
+ *
+ */
+EOAPI void  evas_obj_textgrid_cell_size_get(int *width, int *height);
+
+/**
+ *
+ * @brief Indicate for evas that part of a textgrid region (cells) has been updated.
+ *
+ * This function declares to evas that a region of cells was updated by
+ * code and needs refreshing. An application should modify cells like this
+ * as an example:
+ *
+ * @code
+ * Evas_Textgrid_Cell *cells;
+ * int i;
+ *
+ * cells = evas_object_textgrid_cellrow_get(obj, row);
+ * for (i = 0; i < width; i++) cells[i].codepoint = 'E';
+ * evas_object_textgrid_cellrow_set(obj, row, cells);
+ * evas_object_textgrid_update_add(obj, 0, row, width, 1);
+ * @endcode
+ *
+ * @see evas_object_textgrid_cellrow_set()
+ * @see evas_object_textgrid_cellrow_get()
+ * @see evas_object_textgrid_size_set()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] x The rect region of cells top-left x (column)
+ * @param[in] y The rect region of cells top-left y (row)
+ * @param[in] w The rect region size in number of cells (columns)
+ * @param[in] h The rect region size in number of cells (rows)
+ *
+ */
+EOAPI void  evas_obj_textgrid_update_add(int x, int y, int w, int h);
+
+/**
+ *
+ * @brief Set the string at the given row of the given textgrid object.
+ *
+ * This function returns cells to the textgrid taken by
+ * evas_object_textgrid_cellrow_get(). The row pointer @p row should be the
+ * same row pointer returned by evas_object_textgrid_cellrow_get() for the
+ * same row @p y.
+ *
+ * @see evas_object_textgrid_cellrow_get()
+ * @see evas_object_textgrid_size_set()
+ * @see evas_object_textgrid_update_add()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] y The row index of the grid.
+ * @param[in] row The string as a sequence of #Evas_Textgrid_Cell.
+ *
+ */
+EOAPI void  evas_obj_textgrid_cellrow_set(int y, const Evas_Textgrid_Cell *row);
+
+/**
+ *
+ * @brief Get the string at the given row of the given textgrid object.
+ *
+ * @return A pointer to the first cell of the given row.
+ *
+ * This function returns a pointer to the first cell of the line @p y
+ * of the textgrid object @p obj. If @p y is not between 0 and the
+ * number of lines of the grid - 1, or on error, this function return @c NULL.
+ *
+ * @see evas_object_textgrid_cellrow_set()
+ * @see evas_object_textgrid_size_set()
+ * @see evas_object_textgrid_update_add()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] y The row index of the grid.
+ *
+ */
+EOAPI Evas_Textgrid_Cell * evas_obj_textgrid_cellrow_get(int y);
+
+/**
+ *
+ * @brief The set color to the given palette at the given index of the given textgrid object.
+ *
+ * This function sets the color for the palette of type @p pal at the
+ * index @p idx of the textgrid object @p obj. The ARGB components are
+ * given by @p r, @p g, @p b and @p a. This color can be used when
+ * setting the #Evas_Textgrid_Cell structure. The components must set
+ * a pre-multiplied color. If pal is #EVAS_TEXTGRID_PALETTE_NONE or
+ * #EVAS_TEXTGRID_PALETTE_LAST, or if @p idx is not between 0 and 255,
+ * or on error, this function does nothing. The color components are
+ * clamped between 0 and 255. If @p idx is greater than the latest set
+ * color, the colors between this last index and @p idx - 1 are set to
+ * black (0, 0, 0, 0).
+ *
+ * @see evas_object_textgrid_palette_get()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] pal The type of the palette to set the color.
+ * @param[in] idx The index of the paletter to which the color is stored.
+ * @param[in] r The red component of the color.
+ * @param[in] g The green component of the color.
+ * @param[in] b The blue component of the color.
+ * @param[in] a The alpha component of the color.
+ *
+ */
+EOAPI void  evas_obj_textgrid_palette_set(Evas_Textgrid_Palette pal, int idx, int r, int g, int b, int a);
+
+/**
+ *
+ * @brief The retrieve color to the given palette at the given index of the given textgrid object.
+ *
+ * This function retrieves the color for the palette of type @p pal at the
+ * index @p idx of the textgrid object @p obj. The ARGB components are
+ * stored in the buffers @p r, @p g, @p b and @p a. If @p idx is not
+ * between 0 and the index of the latest set color, or if @p pal is
+ * #EVAS_TEXTGRID_PALETTE_NONE or #EVAS_TEXTGRID_PALETTE_LAST, the
+ * values of the components are 0. @p r, @p g, @p b and @p a can be
+ * @c NULL.
+ *
+ * @see evas_object_textgrid_palette_set()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] pal The type of the palette to set the color.
+ * @param[in] idx The index of the palette to which the color is stored.
+ * @param[out] r A pointer to the red component of the color.
+ * @param[out] g A pointer to the green component of the color.
+ * @param[out] b A pointer to the blue component of the color.
+ * @param[out] a A pointer to the alpha component of the color.
+ *
+ */
+EOAPI void  evas_obj_textgrid_palette_get(Evas_Textgrid_Palette pal, int idx, int *r, int *g, int *b, int *a);
+
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_textgrid.eo.hh b/src/lib/evas/canvas/evas_textgrid.eo.hh
--- a/src/lib/evas/canvas/evas_textgrid.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textgrid.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,795 @@
+#ifndef EFL_GENERATED_EVAS_TEXTGRID_HH
+#define EFL_GENERATED_EVAS_TEXTGRID_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_textgrid.eo.h"
+}
+
+#include "evas_object.eo.hh"
+#include "efl_text_properties.eo.hh"
+#include <string>
+
+namespace evas {
+
+struct textgrid
+      : evas::object,
+      efl::eo::detail::extension_inheritance<efl::text_properties>::template type< ::evas::textgrid>
+
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit textgrid(Eo* eo)
+      : evas::object(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit textgrid(std::nullptr_t)
+      : evas::object(nullptr)
+   {}
+
+   /// @brief Call the object's constructor.
+   /// Should not be used with #eo_do. Only use it with #eo_do_super.
+   ///
+   textgrid(efl::eo::parent_type _p = (efl::eo::parent = nullptr))
+      : textgrid(_c0(_p))
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   textgrid(textgrid const& other)
+      : evas::object(eo_ref(other._eo_ptr()))
+   {}
+
+   ~textgrid() {}
+
+   /// @brief Get dbg information from the object.
+   ///
+   /// @param root_node node of the tree
+   ///
+   void dbg_info_get(Eo_Dbg_Info * root_node_) const
+   {
+      eo_do(_eo_ptr(), ::eo_dbg_info_get(root_node_));
+   }
+
+   /// @brief Retrieve the font family and size in use on a given text object.
+   ///
+   /// This function allows the font name and size of a text object to be
+   /// queried. Be aware that the font name string is still owned by Evas
+   /// and should @b not have free() called on it by the caller of the
+   /// function.
+   ///
+   /// @see evas_object_text_font_set()
+   ///
+   /// @param font The font family name or filename.
+   /// @param size The font size, in points.
+   ///
+   void font_get(const char ** font_, Efl_Font_Size* size_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_get(font_, size_));
+   }
+
+   /// @brief Set the font family or filename, and size on a given text object.
+   ///
+   /// This function allows the font name and size of a text object to be
+   /// set. The @p font string has to follow fontconfig's convention on
+   /// naming fonts, as it's the underlying library used to query system
+   /// fonts by Evas (see the @c fc-list command's output, on your system,
+   /// to get an idea). Alternatively, one can use a full path to a font file.
+   ///
+   /// @see evas_object_text_font_get()
+   /// @see evas_object_text_font_source_set()
+   ///
+   /// @param font The font family name or filename.
+   /// @param size The font size, in points.
+   ///
+   void font_set(std::string font_, Efl_Font_Size size_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+   }
+
+   /// @brief Get the font file's path which is being used on a given text
+   /// object.
+   ///
+   /// @return The font file's path.
+   ///
+   /// @see evas_object_text_font_get() for more details
+   ///
+   /// @param font_source The font file's path.
+   ///
+   std::string font_source_get() const
+   {
+      const char * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::efl_text_properties_font_source_get());
+      return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+   }
+
+   /// @brief Set the font (source) file to be used on a given text object.
+   ///
+   /// This function allows the font file to be explicitly set for a given
+   /// text object, overriding system lookup, which will first occur in
+   /// the given file's contents.
+   ///
+   /// @see evas_object_text_font_get()
+   ///
+   /// @param font_source The font file's path.
+   ///
+   void font_source_set(std::string font_source_) const
+   {
+      eo_do(_eo_ptr(), ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param styles 
+   ///
+   Evas_Textgrid_Font_Style supported_font_styles_get() const
+   {
+      Evas_Textgrid_Font_Style _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textgrid_supported_font_styles_get());
+      return _tmp_ret;
+   }
+
+   /// @brief No description supplied by the EAPI.
+   ///
+   /// @param styles 
+   ///
+   void supported_font_styles_set(Evas_Textgrid_Font_Style styles_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_supported_font_styles_set(styles_));
+   }
+
+   /// @brief @brief Get the size of the textgrid object.
+   ///
+   /// This function retrieves the number of lines in the buffer @p
+   /// h and the number of columns in the buffer @p w of
+   /// the textgrid object @p obj. @p w or @p h can be
+   /// @c NULL. On error, their value is 0.
+   ///
+   /// @since 1.7
+   ///
+   /// @param w The number of columns (width in cells) of the grid.
+   /// @param h The number of rows (height in cells) of the grid.
+   ///
+   void size_get(int* w_, int* h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_size_get(w_, h_));
+   }
+
+   /// @brief @brief Set the size of the textgrid object.
+   ///
+   /// This function sets the number of lines @p h and the number
+   /// of columns @p w to the textgrid object @p obj. If
+   /// @p w or @p h are less or equal than 0, this
+   /// functiond does nothing.
+   ///
+   /// @since 1.7
+   ///
+   /// @param w The number of columns (width in cells) of the grid.
+   /// @param h The number of rows (height in cells) of the grid.
+   ///
+   void size_set(int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_size_set(w_, h_));
+   }
+
+   /// @brief @brief Retrieve the size of a cell of the given textgrid object in pixels.
+   ///
+   /// This functions retrieves the width and height, in pixels, of a cell
+   /// of the textgrid object @p obj and store them respectively in the
+   /// buffers @p width and @p height. Their value depends on the
+   /// monospace font used for the textgrid object, as well as the
+   /// style. @p width and @p height can be @c NULL. On error, they are
+   /// set to 0.
+   ///
+   /// @see evas_object_textgrid_font_set()
+   /// @see evas_object_textgrid_supported_font_styles_set()
+   ///
+   /// @since 1.7
+   ///
+   /// @param width A pointer to the location to store the width in pixels of a cell.
+   /// @param height A pointer to the location to store the height in
+   /// pixels of a cell.
+   ///
+   void cell_size_get(int* width_, int* height_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_cell_size_get(width_, height_));
+   }
+
+   /// @brief @brief Indicate for evas that part of a textgrid region (cells) has been updated.
+   ///
+   /// This function declares to evas that a region of cells was updated by
+   /// code and needs refreshing. An application should modify cells like this
+   /// as an example:
+   ///
+   /// @code
+   /// Evas_Textgrid_Cell *cells;
+   /// int i;
+   ///
+   /// cells = evas_object_textgrid_cellrow_get(obj, row);
+   /// for (i = 0; i < width; i++) cells[i].codepoint = 'E';
+   /// evas_object_textgrid_cellrow_set(obj, row, cells);
+   /// evas_object_textgrid_update_add(obj, 0, row, width, 1);
+   /// @endcode
+   ///
+   /// @see evas_object_textgrid_cellrow_set()
+   /// @see evas_object_textgrid_cellrow_get()
+   /// @see evas_object_textgrid_size_set()
+   ///
+   /// @since 1.7
+   ///
+   /// @param x The rect region of cells top-left x (column)
+   /// @param y The rect region of cells top-left y (row)
+   /// @param w The rect region size in number of cells (columns)
+   /// @param h The rect region size in number of cells (rows)
+   ///
+   void update_add(int x_, int y_, int w_, int h_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_update_add(x_, y_, w_, h_));
+   }
+
+   /// @brief @brief Set the string at the given row of the given textgrid object.
+   ///
+   /// This function returns cells to the textgrid taken by
+   /// evas_object_textgrid_cellrow_get(). The row pointer @p row should be the
+   /// same row pointer returned by evas_object_textgrid_cellrow_get() for the
+   /// same row @p y.
+   ///
+   /// @see evas_object_textgrid_cellrow_get()
+   /// @see evas_object_textgrid_size_set()
+   /// @see evas_object_textgrid_update_add()
+   ///
+   /// @since 1.7
+   ///
+   /// @param y The row index of the grid.
+   /// @param row The string as a sequence of #Evas_Textgrid_Cell.
+   ///
+   void cellrow_set(int y_, const Evas_Textgrid_Cell * row_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_cellrow_set(y_, row_));
+   }
+
+   /// @brief @brief Get the string at the given row of the given textgrid object.
+   ///
+   /// @return A pointer to the first cell of the given row.
+   ///
+   /// This function returns a pointer to the first cell of the line @p y
+   /// of the textgrid object @p obj. If @p y is not between 0 and the
+   /// number of lines of the grid - 1, or on error, this function return @c NULL.
+   ///
+   /// @see evas_object_textgrid_cellrow_set()
+   /// @see evas_object_textgrid_size_set()
+   /// @see evas_object_textgrid_update_add()
+   ///
+   /// @since 1.7
+   ///
+   /// @param y The row index of the grid.
+   ///
+   Evas_Textgrid_Cell * cellrow_get(int y_) const
+   {
+      Evas_Textgrid_Cell * _tmp_ret;
+      eo_do(_eo_ptr(), _tmp_ret = ::evas_obj_textgrid_cellrow_get(y_));
+      return _tmp_ret;
+   }
+
+   /// @brief @brief The set color to the given palette at the given index of the given textgrid object.
+   ///
+   /// This function sets the color for the palette of type @p pal at the
+   /// index @p idx of the textgrid object @p obj. The ARGB components are
+   /// given by @p r, @p g, @p b and @p a. This color can be used when
+   /// setting the #Evas_Textgrid_Cell structure. The components must set
+   /// a pre-multiplied color. If pal is #EVAS_TEXTGRID_PALETTE_NONE or
+   /// #EVAS_TEXTGRID_PALETTE_LAST, or if @p idx is not between 0 and 255,
+   /// or on error, this function does nothing. The color components are
+   /// clamped between 0 and 255. If @p idx is greater than the latest set
+   /// color, the colors between this last index and @p idx - 1 are set to
+   /// black (0, 0, 0, 0).
+   ///
+   /// @see evas_object_textgrid_palette_get()
+   ///
+   /// @since 1.7
+   ///
+   /// @param pal The type of the palette to set the color.
+   /// @param idx The index of the paletter to which the color is stored.
+   /// @param r The red component of the color.
+   /// @param g The green component of the color.
+   /// @param b The blue component of the color.
+   /// @param a The alpha component of the color.
+   ///
+   void palette_set(Evas_Textgrid_Palette pal_, int idx_, int r_, int g_, int b_, int a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_palette_set(pal_, idx_, r_, g_, b_, a_));
+   }
+
+   /// @brief @brief The retrieve color to the given palette at the given index of the given textgrid object.
+   ///
+   /// This function retrieves the color for the palette of type @p pal at the
+   /// index @p idx of the textgrid object @p obj. The ARGB components are
+   /// stored in the buffers @p r, @p g, @p b and @p a. If @p idx is not
+   /// between 0 and the index of the latest set color, or if @p pal is
+   /// #EVAS_TEXTGRID_PALETTE_NONE or #EVAS_TEXTGRID_PALETTE_LAST, the
+   /// values of the components are 0. @p r, @p g, @p b and @p a can be
+   /// @c NULL.
+   ///
+   /// @see evas_object_textgrid_palette_set()
+   ///
+   /// @since 1.7
+   ///
+   /// @param pal The type of the palette to set the color.
+   /// @param idx The index of the palette to which the color is stored.
+   /// @param[out] r A pointer to the red component of the color.
+   /// @param[out] g A pointer to the green component of the color.
+   /// @param[out] b A pointer to the blue component of the color.
+   /// @param[out] a A pointer to the alpha component of the color.
+   ///
+   void palette_get(Evas_Textgrid_Palette pal_, int idx_, int* r_, int* g_, int* b_, int* a_) const
+   {
+      eo_do(_eo_ptr(), ::evas_obj_textgrid_palette_get(pal_, idx_, r_, g_, b_, a_));
+   }
+
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_TEXTGRID_CLASS);
+   }
+
+private:
+   static Eo* _c0(efl::eo::parent_type _p)
+   {
+      return eo_add_ref(EVAS_TEXTGRID_CLASS, _p._eo_raw, eo_constructor());
+   }
+
+};
+} 
+
+template <typename T>
+void evas_textgrid_dbg_info_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Eo_Dbg_Info * root_node_)
+{
+   static_cast<T*>(self->this_)->dbg_info_get(root_node_);
+}
+
+template <typename T>
+void evas_textgrid_font_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char ** font_, Efl_Font_Size* size_)
+{
+   static_cast<T*>(self->this_)->font_get(font_, size_);
+}
+
+template <typename T>
+void evas_textgrid_font_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * font_, Efl_Font_Size size_)
+{
+   static_cast<T*>(self->this_)->font_set(efl::eolian::to_cxx<std::string>(font_, std::tuple<std::false_type>()), size_);
+}
+
+template <typename T>
+std::string evas_textgrid_font_source_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->font_source_get();
+}
+
+template <typename T>
+void evas_textgrid_font_source_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, const char * font_source_)
+{
+   static_cast<T*>(self->this_)->font_source_set(efl::eolian::to_cxx<std::string>(font_source_, std::tuple<std::false_type>()));
+}
+
+template <typename T>
+Evas_Textgrid_Font_Style evas_textgrid_supported_font_styles_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self)
+{
+   return static_cast<T*>(self->this_)->supported_font_styles_get();
+}
+
+template <typename T>
+void evas_textgrid_supported_font_styles_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Textgrid_Font_Style styles_)
+{
+   static_cast<T*>(self->this_)->supported_font_styles_set(styles_);
+}
+
+template <typename T>
+void evas_textgrid_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* w_, int* h_)
+{
+   static_cast<T*>(self->this_)->size_get(w_, h_);
+}
+
+template <typename T>
+void evas_textgrid_size_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->size_set(w_, h_);
+}
+
+template <typename T>
+void evas_textgrid_cell_size_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int* width_, int* height_)
+{
+   static_cast<T*>(self->this_)->cell_size_get(width_, height_);
+}
+
+template <typename T>
+void evas_textgrid_update_add_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int x_, int y_, int w_, int h_)
+{
+   static_cast<T*>(self->this_)->update_add(x_, y_, w_, h_);
+}
+
+template <typename T>
+void evas_textgrid_cellrow_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int y_, const Evas_Textgrid_Cell * row_)
+{
+   static_cast<T*>(self->this_)->cellrow_set(y_, row_);
+}
+
+template <typename T>
+Evas_Textgrid_Cell * evas_textgrid_cellrow_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, int y_)
+{
+   return static_cast<T*>(self->this_)->cellrow_get(y_);
+}
+
+template <typename T>
+void evas_textgrid_palette_set_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Textgrid_Palette pal_, int idx_, int r_, int g_, int b_, int a_)
+{
+   static_cast<T*>(self->this_)->palette_set(pal_, idx_, r_, g_, b_, a_);
+}
+
+template <typename T>
+void evas_textgrid_palette_get_wrapper(Eo* objid EINA_UNUSED, efl::eo::detail::Inherit_Private_Data* self, Evas_Textgrid_Palette pal_, int idx_, int* r_, int* g_, int* b_, int* a_)
+{
+   static_cast<T*>(self->this_)->palette_get(pal_, idx_, r_, g_, b_, a_);
+}
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::textgrid >
+{
+   template <typename T>
+   struct type
+   {
+      virtual void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::eo_dbg_info_get(root_node_));
+      }
+
+      virtual void font_get(const char ** font_, Efl_Font_Size* size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_get(font_, size_));
+      }
+
+      virtual void font_set(std::string font_, Efl_Font_Size size_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+      }
+
+      virtual std::string font_source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::efl_text_properties_font_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      virtual void font_source_set(std::string font_source_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+      }
+
+      virtual Evas_Textgrid_Font_Style supported_font_styles_get()
+      {
+         Evas_Textgrid_Font_Style _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textgrid_supported_font_styles_get());
+            return _tmp_ret;
+      }
+
+      virtual void supported_font_styles_set(Evas_Textgrid_Font_Style styles_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_supported_font_styles_set(styles_));
+      }
+
+      virtual void size_get(int* w_, int* h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_size_get(w_, h_));
+      }
+
+      virtual void size_set(int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_size_set(w_, h_));
+      }
+
+      virtual void cell_size_get(int* width_, int* height_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_cell_size_get(width_, height_));
+      }
+
+      virtual void update_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_update_add(x_, y_, w_, h_));
+      }
+
+      virtual void cellrow_set(int y_, const Evas_Textgrid_Cell * row_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_cellrow_set(y_, row_));
+      }
+
+      virtual Evas_Textgrid_Cell * cellrow_get(int y_)
+      {
+         Evas_Textgrid_Cell * _tmp_ret = {};
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               _tmp_ret = ::evas_obj_textgrid_cellrow_get(y_));
+            return _tmp_ret;
+      }
+
+      virtual void palette_set(Evas_Textgrid_Palette pal_, int idx_, int r_, int g_, int b_, int a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_palette_set(pal_, idx_, r_, g_, b_, a_));
+      }
+
+      virtual void palette_get(Evas_Textgrid_Palette pal_, int idx_, int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do_super(static_cast<T*>(this)->_eo_ptr(),
+               static_cast<T*>(this)->_eo_class(),
+               ::evas_obj_textgrid_palette_get(pal_, idx_, r_, g_, b_, a_));
+      }
+
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::textgrid >
+{
+   static const int value = 15;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::textgrid>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   ops[0].func = reinterpret_cast<void*>(& ::evas_textgrid_dbg_info_get_wrapper<T>);
+   ops[0].api_func = reinterpret_cast<void*>(& ::eo_dbg_info_get);
+   ops[0].op = EO_OP_OVERRIDE;
+   ops[0].op_type = EO_OP_TYPE_REGULAR;
+   ops[0].doc = NULL;
+
+   ops[1].func = reinterpret_cast<void*>(& ::evas_textgrid_font_get_wrapper<T>);
+   ops[1].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_get);
+   ops[1].op = EO_OP_OVERRIDE;
+   ops[1].op_type = EO_OP_TYPE_REGULAR;
+   ops[1].doc = NULL;
+
+   ops[2].func = reinterpret_cast<void*>(& ::evas_textgrid_font_set_wrapper<T>);
+   ops[2].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_set);
+   ops[2].op = EO_OP_OVERRIDE;
+   ops[2].op_type = EO_OP_TYPE_REGULAR;
+   ops[2].doc = NULL;
+
+   ops[3].func = reinterpret_cast<void*>(& ::evas_textgrid_font_source_get_wrapper<T>);
+   ops[3].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_get);
+   ops[3].op = EO_OP_OVERRIDE;
+   ops[3].op_type = EO_OP_TYPE_REGULAR;
+   ops[3].doc = NULL;
+
+   ops[4].func = reinterpret_cast<void*>(& ::evas_textgrid_font_source_set_wrapper<T>);
+   ops[4].api_func = reinterpret_cast<void*>(& ::efl_text_properties_font_source_set);
+   ops[4].op = EO_OP_OVERRIDE;
+   ops[4].op_type = EO_OP_TYPE_REGULAR;
+   ops[4].doc = NULL;
+
+   ops[5].func = reinterpret_cast<void*>(& ::evas_textgrid_supported_font_styles_get_wrapper<T>);
+   ops[5].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_supported_font_styles_get);
+   ops[5].op = EO_OP_OVERRIDE;
+   ops[5].op_type = EO_OP_TYPE_REGULAR;
+   ops[5].doc = NULL;
+
+   ops[6].func = reinterpret_cast<void*>(& ::evas_textgrid_supported_font_styles_set_wrapper<T>);
+   ops[6].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_supported_font_styles_set);
+   ops[6].op = EO_OP_OVERRIDE;
+   ops[6].op_type = EO_OP_TYPE_REGULAR;
+   ops[6].doc = NULL;
+
+   ops[7].func = reinterpret_cast<void*>(& ::evas_textgrid_size_get_wrapper<T>);
+   ops[7].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_size_get);
+   ops[7].op = EO_OP_OVERRIDE;
+   ops[7].op_type = EO_OP_TYPE_REGULAR;
+   ops[7].doc = NULL;
+
+   ops[8].func = reinterpret_cast<void*>(& ::evas_textgrid_size_set_wrapper<T>);
+   ops[8].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_size_set);
+   ops[8].op = EO_OP_OVERRIDE;
+   ops[8].op_type = EO_OP_TYPE_REGULAR;
+   ops[8].doc = NULL;
+
+   ops[9].func = reinterpret_cast<void*>(& ::evas_textgrid_cell_size_get_wrapper<T>);
+   ops[9].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_cell_size_get);
+   ops[9].op = EO_OP_OVERRIDE;
+   ops[9].op_type = EO_OP_TYPE_REGULAR;
+   ops[9].doc = NULL;
+
+   ops[10].func = reinterpret_cast<void*>(& ::evas_textgrid_update_add_wrapper<T>);
+   ops[10].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_update_add);
+   ops[10].op = EO_OP_OVERRIDE;
+   ops[10].op_type = EO_OP_TYPE_REGULAR;
+   ops[10].doc = NULL;
+
+   ops[11].func = reinterpret_cast<void*>(& ::evas_textgrid_cellrow_set_wrapper<T>);
+   ops[11].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_cellrow_set);
+   ops[11].op = EO_OP_OVERRIDE;
+   ops[11].op_type = EO_OP_TYPE_REGULAR;
+   ops[11].doc = NULL;
+
+   ops[12].func = reinterpret_cast<void*>(& ::evas_textgrid_cellrow_get_wrapper<T>);
+   ops[12].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_cellrow_get);
+   ops[12].op = EO_OP_OVERRIDE;
+   ops[12].op_type = EO_OP_TYPE_REGULAR;
+   ops[12].doc = NULL;
+
+   ops[13].func = reinterpret_cast<void*>(& ::evas_textgrid_palette_set_wrapper<T>);
+   ops[13].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_palette_set);
+   ops[13].op = EO_OP_OVERRIDE;
+   ops[13].op_type = EO_OP_TYPE_REGULAR;
+   ops[13].doc = NULL;
+
+   ops[14].func = reinterpret_cast<void*>(& ::evas_textgrid_palette_get_wrapper<T>);
+   ops[14].api_func = reinterpret_cast<void*>(& ::evas_obj_textgrid_palette_get);
+   ops[14].op = EO_OP_OVERRIDE;
+   ops[14].op_type = EO_OP_TYPE_REGULAR;
+   ops[14].doc = NULL;
+
+   return 0;
+}
+inline void
+call_constructor(tag< evas::textgrid >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::textgrid, ::std::tuple<> > const& args)
+{
+   (void)args;
+   eo_do_super(eo, cls, ::eo_constructor());
+}
+
+inline void
+call_constructor(tag< evas::textgrid >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::textgrid, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::textgrid>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::textgrid() const
+      {
+         return evas::textgrid(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+      void dbg_info_get(Eo_Dbg_Info * root_node_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::eo_dbg_info_get(root_node_));
+      }
+
+      void font_get(const char ** font_, Efl_Font_Size* size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_get(font_, size_));
+      }
+
+      void font_set(std::string font_, Efl_Font_Size size_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_set(efl::eolian::to_c(font_), size_));
+      }
+
+      std::string font_source_get()
+      {
+         const char * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::efl_text_properties_font_source_get());
+            return efl::eolian::to_cxx<std::string>(_tmp_ret, std::tuple<std::false_type>());
+      }
+
+      void font_source_set(std::string font_source_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::efl_text_properties_font_source_set(efl::eolian::to_c(font_source_)));
+      }
+
+      Evas_Textgrid_Font_Style supported_font_styles_get()
+      {
+         Evas_Textgrid_Font_Style _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textgrid_supported_font_styles_get());
+            return _tmp_ret;
+      }
+
+      void supported_font_styles_set(Evas_Textgrid_Font_Style styles_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_supported_font_styles_set(styles_));
+      }
+
+      void size_get(int* w_, int* h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_size_get(w_, h_));
+      }
+
+      void size_set(int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_size_set(w_, h_));
+      }
+
+      void cell_size_get(int* width_, int* height_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_cell_size_get(width_, height_));
+      }
+
+      void update_add(int x_, int y_, int w_, int h_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_update_add(x_, y_, w_, h_));
+      }
+
+      void cellrow_set(int y_, const Evas_Textgrid_Cell * row_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_cellrow_set(y_, row_));
+      }
+
+      Evas_Textgrid_Cell * cellrow_get(int y_)
+      {
+         Evas_Textgrid_Cell * _tmp_ret = {};
+         eo_do(static_cast<U*>(this)->_eo_ptr(), _tmp_ret = ::evas_obj_textgrid_cellrow_get(y_));
+            return _tmp_ret;
+      }
+
+      void palette_set(Evas_Textgrid_Palette pal_, int idx_, int r_, int g_, int b_, int a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_palette_set(pal_, idx_, r_, g_, b_, a_));
+      }
+
+      void palette_get(Evas_Textgrid_Palette pal_, int idx_, int* r_, int* g_, int* b_, int* a_)
+      {
+         eo_do(static_cast<U*>(this)->_eo_ptr(), ::evas_obj_textgrid_palette_get(pal_, idx_, r_, g_, b_, a_));
+      }
+
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::textgrid>)
+{
+   return (EVAS_TEXTGRID_CLASS);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_TEXTGRID_HH
+
diff -Naur a/src/lib/evas/canvas/evas_textgrid.eo.legacy.h b/src/lib/evas/canvas/evas_textgrid.eo.legacy.h
--- a/src/lib/evas/canvas/evas_textgrid.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_textgrid.eo.legacy.h	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,215 @@
+#ifndef _EVAS_TEXTGRID_EO_LEGACY_H_
+#define _EVAS_TEXTGRID_EO_LEGACY_H_
+
+#ifndef _EVAS_TEXTGRID_EO_CLASS_TYPE
+#define _EVAS_TEXTGRID_EO_CLASS_TYPE
+
+typedef Eo Evas_Textgrid;
+
+#endif
+
+#ifndef _EVAS_TEXTGRID_EO_TYPES
+#define _EVAS_TEXTGRID_EO_TYPES
+
+
+#endif
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ * @param[in] styles No description supplied.
+ */
+EAPI void evas_object_textgrid_supported_font_styles_set(Evas_Textgrid *obj, Evas_Textgrid_Font_Style styles);
+
+/**
+ *
+ * No description supplied by the EAPI.
+ *
+ */
+EAPI Evas_Textgrid_Font_Style evas_object_textgrid_supported_font_styles_get(const Evas_Textgrid *obj);
+
+/**
+ *
+ * @brief Set the size of the textgrid object.
+ *
+ * This function sets the number of lines @p h and the number
+ * of columns @p w to the textgrid object @p obj. If
+ * @p w or @p h are less or equal than 0, this
+ * functiond does nothing.
+ *
+ * @since 1.7
+ *
+ * @param[in] w The number of columns (width in cells) of the grid.
+ * @param[in] h The number of rows (height in cells) of the grid.
+ */
+EAPI void evas_object_textgrid_size_set(Evas_Textgrid *obj, int w, int h);
+
+/**
+ *
+ * @brief Get the size of the textgrid object.
+ *
+ * This function retrieves the number of lines in the buffer @p
+ * h and the number of columns in the buffer @p w of
+ * the textgrid object @p obj. @p w or @p h can be
+ * @c NULL. On error, their value is 0.
+ *
+ * @since 1.7
+ *
+ * @param[out] w The number of columns (width in cells) of the grid.
+ * @param[out] h The number of rows (height in cells) of the grid.
+ */
+EAPI void evas_object_textgrid_size_get(const Evas_Textgrid *obj, int *w, int *h);
+
+/**
+ *
+ * @brief Retrieve the size of a cell of the given textgrid object in pixels.
+ *
+ * This functions retrieves the width and height, in pixels, of a cell
+ * of the textgrid object @p obj and store them respectively in the
+ * buffers @p width and @p height. Their value depends on the
+ * monospace font used for the textgrid object, as well as the
+ * style. @p width and @p height can be @c NULL. On error, they are
+ * set to 0.
+ *
+ * @see evas_object_textgrid_font_set()
+ * @see evas_object_textgrid_supported_font_styles_set()
+ *
+ * @since 1.7
+ *
+ * @param[out] width A pointer to the location to store the width in pixels of a cell.
+ * @param[out] height A pointer to the location to store the height in
+pixels of a cell.
+ */
+EAPI void evas_object_textgrid_cell_size_get(const Evas_Textgrid *obj, int *width, int *height);
+
+/**
+ *
+ * @brief Indicate for evas that part of a textgrid region (cells) has been updated.
+ *
+ * This function declares to evas that a region of cells was updated by
+ * code and needs refreshing. An application should modify cells like this
+ * as an example:
+ *
+ * @code
+ * Evas_Textgrid_Cell *cells;
+ * int i;
+ *
+ * cells = evas_object_textgrid_cellrow_get(obj, row);
+ * for (i = 0; i < width; i++) cells[i].codepoint = 'E';
+ * evas_object_textgrid_cellrow_set(obj, row, cells);
+ * evas_object_textgrid_update_add(obj, 0, row, width, 1);
+ * @endcode
+ *
+ * @see evas_object_textgrid_cellrow_set()
+ * @see evas_object_textgrid_cellrow_get()
+ * @see evas_object_textgrid_size_set()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] x The rect region of cells top-left x (column)
+ * @param[in] y The rect region of cells top-left y (row)
+ * @param[in] w The rect region size in number of cells (columns)
+ * @param[in] h The rect region size in number of cells (rows)
+ */
+EAPI void evas_object_textgrid_update_add(Evas_Textgrid *obj, int x, int y, int w, int h);
+
+/**
+ *
+ * @brief Set the string at the given row of the given textgrid object.
+ *
+ * This function returns cells to the textgrid taken by
+ * evas_object_textgrid_cellrow_get(). The row pointer @p row should be the
+ * same row pointer returned by evas_object_textgrid_cellrow_get() for the
+ * same row @p y.
+ *
+ * @see evas_object_textgrid_cellrow_get()
+ * @see evas_object_textgrid_size_set()
+ * @see evas_object_textgrid_update_add()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] y The row index of the grid.
+ * @param[in] row The string as a sequence of #Evas_Textgrid_Cell.
+ */
+EAPI void evas_object_textgrid_cellrow_set(Evas_Textgrid *obj, int y, const Evas_Textgrid_Cell *row);
+
+/**
+ *
+ * @brief Get the string at the given row of the given textgrid object.
+ *
+ * @return A pointer to the first cell of the given row.
+ *
+ * This function returns a pointer to the first cell of the line @p y
+ * of the textgrid object @p obj. If @p y is not between 0 and the
+ * number of lines of the grid - 1, or on error, this function return @c NULL.
+ *
+ * @see evas_object_textgrid_cellrow_set()
+ * @see evas_object_textgrid_size_set()
+ * @see evas_object_textgrid_update_add()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] y The row index of the grid.
+ */
+EAPI Evas_Textgrid_Cell *evas_object_textgrid_cellrow_get(const Evas_Textgrid *obj, int y);
+
+/**
+ *
+ * @brief The set color to the given palette at the given index of the given textgrid object.
+ *
+ * This function sets the color for the palette of type @p pal at the
+ * index @p idx of the textgrid object @p obj. The ARGB components are
+ * given by @p r, @p g, @p b and @p a. This color can be used when
+ * setting the #Evas_Textgrid_Cell structure. The components must set
+ * a pre-multiplied color. If pal is #EVAS_TEXTGRID_PALETTE_NONE or
+ * #EVAS_TEXTGRID_PALETTE_LAST, or if @p idx is not between 0 and 255,
+ * or on error, this function does nothing. The color components are
+ * clamped between 0 and 255. If @p idx is greater than the latest set
+ * color, the colors between this last index and @p idx - 1 are set to
+ * black (0, 0, 0, 0).
+ *
+ * @see evas_object_textgrid_palette_get()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] pal The type of the palette to set the color.
+ * @param[in] idx The index of the paletter to which the color is stored.
+ * @param[in] r The red component of the color.
+ * @param[in] g The green component of the color.
+ * @param[in] b The blue component of the color.
+ * @param[in] a The alpha component of the color.
+ */
+EAPI void evas_object_textgrid_palette_set(Evas_Textgrid *obj, Evas_Textgrid_Palette pal, int idx, int r, int g, int b, int a);
+
+/**
+ *
+ * @brief The retrieve color to the given palette at the given index of the given textgrid object.
+ *
+ * This function retrieves the color for the palette of type @p pal at the
+ * index @p idx of the textgrid object @p obj. The ARGB components are
+ * stored in the buffers @p r, @p g, @p b and @p a. If @p idx is not
+ * between 0 and the index of the latest set color, or if @p pal is
+ * #EVAS_TEXTGRID_PALETTE_NONE or #EVAS_TEXTGRID_PALETTE_LAST, the
+ * values of the components are 0. @p r, @p g, @p b and @p a can be
+ * @c NULL.
+ *
+ * @see evas_object_textgrid_palette_set()
+ *
+ * @since 1.7
+ * 
+ *
+ * @param[in] pal The type of the palette to set the color.
+ * @param[in] idx The index of the palette to which the color is stored.
+ * @param[out] r A pointer to the red component of the color.
+ * @param[out] g A pointer to the green component of the color.
+ * @param[out] b A pointer to the blue component of the color.
+ * @param[out] a A pointer to the alpha component of the color.
+ */
+EAPI void evas_object_textgrid_palette_get(const Evas_Textgrid *obj, Evas_Textgrid_Palette pal, int idx, int *r, int *g, int *b, int *a);
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_zoomable_interface.eo.c b/src/lib/evas/canvas/evas_zoomable_interface.eo.c
--- a/src/lib/evas/canvas/evas_zoomable_interface.eo.c	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_zoomable_interface.eo.c	2014-11-27 00:57:33.497047075 +0200
@@ -0,0 +1,26 @@
+EOAPI const Eo_Event_Description _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START =
+   EO_EVENT_DESCRIPTION("zoom,start", "");
+EOAPI const Eo_Event_Description _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP =
+   EO_EVENT_DESCRIPTION("zoom,stop", "");
+EOAPI const Eo_Event_Description _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED =
+   EO_EVENT_DESCRIPTION("zoom,changed", "");
+
+static const Eo_Event_Description *_evas_zoomable_interface_event_desc[] = {
+     EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START,
+     EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP,
+     EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED,
+     NULL
+};
+
+static const Eo_Class_Description _evas_zoomable_interface_class_desc = {
+     EO_VERSION,
+     "Evas_Zoomable_Interface",
+     EO_CLASS_TYPE_INTERFACE,
+     EO_CLASS_DESCRIPTION_NOOPS(),
+     _evas_zoomable_interface_event_desc,
+     0,
+     NULL,
+     NULL
+};
+
+EO_DEFINE_CLASS(evas_zoomable_interface_interface_get, &_evas_zoomable_interface_class_desc, EVAS_SIGNAL_INTERFACE_INTERFACE, NULL);
\ No newline at end of file
diff -Naur a/src/lib/evas/canvas/evas_zoomable_interface.eo.h b/src/lib/evas/canvas/evas_zoomable_interface.eo.h
--- a/src/lib/evas/canvas/evas_zoomable_interface.eo.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_zoomable_interface.eo.h	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,39 @@
+#ifndef _EVAS_ZOOMABLE_INTERFACE_EO_H_
+#define _EVAS_ZOOMABLE_INTERFACE_EO_H_
+
+#ifndef _EVAS_ZOOMABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_ZOOMABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Zoomable_Interface;
+
+#endif
+
+#ifndef _EVAS_ZOOMABLE_INTERFACE_EO_TYPES
+#define _EVAS_ZOOMABLE_INTERFACE_EO_TYPES
+
+
+#endif
+#define EVAS_ZOOMABLE_INTERFACE_INTERFACE evas_zoomable_interface_interface_get()
+
+const Eo_Class *evas_zoomable_interface_interface_get(void) EINA_CONST;
+
+EOAPI extern const Eo_Event_Description _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START;
+EOAPI extern const Eo_Event_Description _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP;
+EOAPI extern const Eo_Event_Description _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED;
+
+/**
+ * No description
+ */
+#define EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START (&(_EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START))
+
+/**
+ * No description
+ */
+#define EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP (&(_EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP))
+
+/**
+ * No description
+ */
+#define EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED (&(_EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED))
+
+#endif
diff -Naur a/src/lib/evas/canvas/evas_zoomable_interface.eo.hh b/src/lib/evas/canvas/evas_zoomable_interface.eo.hh
--- a/src/lib/evas/canvas/evas_zoomable_interface.eo.hh	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_zoomable_interface.eo.hh	2014-11-27 00:57:33.513714017 +0200
@@ -0,0 +1,258 @@
+#ifndef EFL_GENERATED_EVAS_ZOOMABLE_INTERFACE_HH
+#define EFL_GENERATED_EVAS_ZOOMABLE_INTERFACE_HH
+
+extern "C"
+{
+#include <Efl.h>
+}
+#include <Eo.hh>
+
+#include <eo_cxx_interop.hh>
+
+extern "C"
+{
+#include "evas_zoomable_interface.eo.h"
+}
+
+#include "evas_signal_interface.eo.hh"
+
+namespace evas {
+
+struct zoomable_interface
+      : evas::signal_interface
+{
+   /// @brief Eo Constructor.
+   ///
+   /// Constructs the object from an Eo* pointer stealing its ownership.
+   ///
+   /// @param eo The Eo object pointer.
+   ///
+   explicit zoomable_interface(Eo* eo)
+      : evas::signal_interface(eo)
+   {}
+
+   /// @brief nullptr_t Constructor.
+   ///
+   /// Constructs an empty (null) object.
+   ///
+   explicit zoomable_interface(std::nullptr_t)
+      : evas::signal_interface(nullptr)
+   {}
+
+   /// @brief Copy Constructor.
+   ///
+   zoomable_interface(zoomable_interface const& other)
+      : evas::signal_interface(eo_ref(other._eo_ptr()))
+   {}
+
+   ~zoomable_interface() {}
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_zoom_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START, priority_,
+            &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>,
+         EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START );
+   }
+
+   template <typename T>
+   void
+   callback_zoom_start_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_zoom_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>,
+         EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_zoom_stop_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_zoom_changed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED, priority_,
+            &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, _eo_ptr(), &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>,
+         EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED );
+   }
+
+   template <typename T>
+   void
+   callback_zoom_changed_call(T* info)
+   {
+      eo_do(_eo_ptr(), eo_event_callback_call
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED, info));
+   }
+   static Eo_Class const* _eo_class()
+   {
+      return(EVAS_ZOOMABLE_INTERFACE_INTERFACE);
+   }
+
+private:
+};
+} 
+
+namespace efl { namespace eo { namespace detail {
+
+template<>
+struct operations< evas::zoomable_interface >
+{
+   template <typename T>
+   struct type
+   {
+   };
+};
+
+
+template<>
+struct operation_description_class_size< evas::zoomable_interface >
+{
+   static const int value = 0;
+};
+
+template <typename T>
+int initialize_operation_description(efl::eo::detail::tag<evas::zoomable_interface>
+                                 , Eo_Op_Description* ops)
+{
+   (void)ops;
+   return 0;
+}
+inline void
+call_constructor(tag< evas::zoomable_interface >
+               , Eo* eo, Eo_Class const* cls EINA_UNUSED,
+               args_class<evas::zoomable_interface, ::std::tuple<efl::eo::parent_type> > const& args)
+{
+   eo_do_super(eo, cls, ::eo_constructor());
+   eo_do(eo, ::eo_parent_set(args.get<0>()._eo_raw));
+}
+
+template<>
+struct extension_inheritance< evas::zoomable_interface>
+{
+   template <typename U>
+   struct type
+   {
+      operator evas::zoomable_interface() const
+      {
+         return evas::zoomable_interface(eo_ref(static_cast<U const*>(this)->_eo_ptr()));
+      }
+
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_zoom_start_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START, priority_,
+            &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>,
+         EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START );
+   }
+
+   template <typename T>
+   void
+   callback_zoom_start_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_zoom_stop_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP, priority_,
+            &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>,
+         EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP );
+   }
+
+   template <typename T>
+   void
+   callback_zoom_stop_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP, info));
+   }
+   template <typename F>
+   ::efl::eo::signal_connection
+   callback_zoom_changed_add(F && callback_,
+                        ::efl::eo::callback_priority priority_ =
+                        ::efl::eo::callback_priorities::default_)
+   {
+      typedef typename std::remove_reference<F>::type function_type;
+      ::std::unique_ptr<function_type> f ( new function_type(std::move(callback_)) );
+      eo_do(static_cast<U*>(this)->_eo_ptr(),
+            eo_event_callback_priority_add
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED, priority_,
+            &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>, f.get()));
+      return ::efl::eo::make_signal_connection
+         (f, static_cast<U*>(this)->_eo_ptr(), &efl::eo::_detail::event_callback<evas::zoomable_interface, function_type>,
+         EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED );
+   }
+
+   template <typename T>
+   void
+   callback_zoom_changed_call(T* info)
+   {
+      eo_do(static_cast<U*>(this)->_eo_ptr(), eo_event_callback_call
+            (EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGED, info));
+   }
+   };
+};
+
+inline Eo_Class const* get_eo_class(tag<evas::zoomable_interface>)
+{
+   return (EVAS_ZOOMABLE_INTERFACE_INTERFACE);
+}
+
+} } }
+#endif // EFL_GENERATED_EVAS_ZOOMABLE_INTERFACE_HH
+
diff -Naur a/src/lib/evas/canvas/evas_zoomable_interface.eo.legacy.h b/src/lib/evas/canvas/evas_zoomable_interface.eo.legacy.h
--- a/src/lib/evas/canvas/evas_zoomable_interface.eo.legacy.h	1970-01-01 02:00:00.000000000 +0200
+++ b/src/lib/evas/canvas/evas_zoomable_interface.eo.legacy.h	2014-11-27 00:57:33.493713718 +0200
@@ -0,0 +1,17 @@
+#ifndef _EVAS_ZOOMABLE_INTERFACE_EO_LEGACY_H_
+#define _EVAS_ZOOMABLE_INTERFACE_EO_LEGACY_H_
+
+#ifndef _EVAS_ZOOMABLE_INTERFACE_EO_CLASS_TYPE
+#define _EVAS_ZOOMABLE_INTERFACE_EO_CLASS_TYPE
+
+typedef Eo Evas_Zoomable_Interface;
+
+#endif
+
+#ifndef _EVAS_ZOOMABLE_INTERFACE_EO_TYPES
+#define _EVAS_ZOOMABLE_INTERFACE_EO_TYPES
+
+
+#endif
+
+#endif
